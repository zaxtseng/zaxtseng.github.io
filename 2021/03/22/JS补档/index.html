<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="var,let,const 区别var的作用域是方法作用域,声明之前变量是 undefined.可以重复声明.let的作用域是块级作用域.在声明之前使用会报错,禁止重复声明.const是常量声明方式,声明变量时必须初始化,后面不再修改该常量的值.(声明时必须赋值)const 不是变量的值不能改动,而是变量指向的那个内存地址不能改动. 作用域ES2015 前，ES 只有两种作用域，分别是全局作用域和">
<meta property="og:type" content="article">
<meta property="og:title" content="JS补档">
<meta property="og:url" content="http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/index.html">
<meta property="og:site_name" content="ZAX">
<meta property="og:description" content="var,let,const 区别var的作用域是方法作用域,声明之前变量是 undefined.可以重复声明.let的作用域是块级作用域.在声明之前使用会报错,禁止重复声明.const是常量声明方式,声明变量时必须初始化,后面不再修改该常量的值.(声明时必须赋值)const 不是变量的值不能改动,而是变量指向的那个内存地址不能改动. 作用域ES2015 前，ES 只有两种作用域，分别是全局作用域和">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/473454/1664181323672-63ddb950-9558-4713-a12e-8889f0532fef.png#clientId=u84dfcbb8-1307-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=u3a5e30ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=573&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84467&status=done&style=none&taskId=u91ac1b2a-1524-4384-b47e-76f1a63fd50&title=&width=443">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/473454/1664200975310-09fb6834-6fd6-4750-86cb-09f1a5a63c5a.png#clientId=u0ca97a65-2fdb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=727&id=u04988d1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=727&originWidth=1437&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=422821&status=done&style=none&taskId=u2217fa30-5759-4ec2-8123-b745aacbe77&title=&width=1437">
<meta property="article:published_time" content="2021-03-22T03:31:39.000Z">
<meta property="article:modified_time" content="2022-11-09T06:32:52.033Z">
<meta property="article:author" content="Zax Tseng">
<meta property="article:tag" content="javascript, React, Vue, HTML5">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/473454/1664181323672-63ddb950-9558-4713-a12e-8889f0532fef.png#clientId=u84dfcbb8-1307-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=u3a5e30ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=573&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84467&status=done&style=none&taskId=u91ac1b2a-1524-4384-b47e-76f1a63fd50&title=&width=443">


<link rel="canonical" href="http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/","path":"2021/03/22/JS补档/","title":"JS补档"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JS补档 | ZAX</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZAX</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#var-let-const-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">var,let,const 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.1.</span> <span class="nav-text">作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined-%E5%92%8C-null-%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">undefined 和 null 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E9%97%AD%E5%8C%85"><span class="nav-number">3.1.</span> <span class="nav-text">一般如何产生闭包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.</span> <span class="nav-text">for 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AF-var-%E5%A3%B0%E6%98%8E-for-%E5%BE%AA%E7%8E%AF%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%80%E4%BB%A5-i-%E6%98%AF%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E3%80%82"><span class="nav-number">4.1.</span> <span class="nav-text">如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">4.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E2%80%A6in"><span class="nav-number">4.3.</span> <span class="nav-text">for…in</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E2%80%A6of"><span class="nav-number">4.4.</span> <span class="nav-text">for…of</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">函数柯里化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string-%E5%92%8C-String-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">string 和 String 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-String-%E5%92%8C-String-%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.</span> <span class="nav-text">new String() 和 String()区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.3.</span> <span class="nav-text">switch 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-%E5%92%8C-forEach"><span class="nav-number">5.4.</span> <span class="nav-text">map 和 forEach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%BF%94%E5%9B%9E"><span class="nav-number">5.5.</span> <span class="nav-text">数组返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reduce"><span class="nav-number">5.6.</span> <span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98"><span class="nav-number">5.7.</span> <span class="nav-text">对象类型的指针问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="nav-number">6.1.</span> <span class="nav-text">逻辑非(!)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="nav-number">6.2.</span> <span class="nav-text">双逻辑非(!!)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.3.</span> <span class="nav-text">二进制运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.4.</span> <span class="nav-text">in运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="nav-number">6.5.</span> <span class="nav-text">类型判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof"><span class="nav-number">6.5.1.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof"><span class="nav-number">6.5.2.</span> <span class="nav-text">instanceof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.6.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95"><span class="nav-number">6.6.1.</span> <span class="nav-text">加法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">基本类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="nav-number">8.</span> <span class="nav-text">this 的指向</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84-this"><span class="nav-number">8.1.</span> <span class="nav-text">箭头函数的 this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call-apply-bind"><span class="nav-number">8.2.</span> <span class="nav-text">call,apply,bind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constructor-%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.3.</span> <span class="nav-text">constructor 和原型对象,构造函数,实例对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.3.1.</span> <span class="nav-text">原型对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E-ES6-%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">8.3.2.</span> <span class="nav-text">与 ES6 中继承的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof-1"><span class="nav-number">8.3.3.</span> <span class="nav-text">instanceof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.4.</span> <span class="nav-text">工厂函数和构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">8.4.1.</span> <span class="nav-text">new 的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">8.4.2.</span> <span class="nav-text">new 的细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F-new-Object-Object-create-%E5%8C%BA%E5%88%AB"><span class="nav-number">8.5.</span> <span class="nav-text">对象字面量,new Object(),Object.create()区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-assign"><span class="nav-number">8.6.</span> <span class="nav-text">Object.assign()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">8.7.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">8.8.</span> <span class="nav-text">深拷贝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Event-loop"><span class="nav-number">9.</span> <span class="nav-text">Event loop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">9.1.</span> <span class="nav-text">执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TASK-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">9.2.</span> <span class="nav-text">TASK(微任务和宏任务)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD-async-x2F-await-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">9.3.</span> <span class="nav-text">任务队列中 async&#x2F;await 的运行机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise"><span class="nav-number">10.</span> <span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-number">10.1.</span> <span class="nav-text">状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="nav-number">10.2.</span> <span class="nav-text">链式调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-x2F-await-%E5%92%8C-promise-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">10.3.</span> <span class="nav-text">async&#x2F;await 和 promise 的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#catch"><span class="nav-number">10.4.</span> <span class="nav-text">catch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">10.5.</span> <span class="nav-text">案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-promise-%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87"><span class="nav-number">10.5.1.</span> <span class="nav-text">使用 promise 加载图片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="nav-number">10.6.</span> <span class="nav-text">语法糖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-all"><span class="nav-number">10.7.</span> <span class="nav-text">Promise.all</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zax Tseng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">105</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JS补档 | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JS补档
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-22 11:31:39" itemprop="dateCreated datePublished" datetime="2021-03-22T11:31:39+08:00">2021-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-09 14:32:52" itemprop="dateModified" datetime="2022-11-09T14:32:52+08:00">2022-11-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var,let,const 区别"></a>var,let,const 区别</h1><p><code>var</code>的作用域是方法作用域,声明之前变量是 undefined.可以重复声明.<br><code>let</code>的作用域是块级作用域.在声明之前使用会报错,禁止重复声明.<br><code>const</code>是常量声明方式,声明变量时必须初始化,后面不再修改该常量的值.(声明时必须赋值)<br><code>const</code> 不是变量的值不能改动,而是变量指向的那个内存地址不能改动.</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>ES2015 前，ES 只有两种作用域，分别是全局作用域和函数作用域；在 ES2015 中新增了一个块级作用域.<br>以前块没有独立的作用域，所以在块中定义的变量，块的外面也可以访问，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br></pre></td></tr></table></figure>

<p>这对于代码是非常不利的、不安全的，有了块级作用域，可以通过新的关键字 let 去声明变量，用法跟传统一样，只是 let 声明的变量只能在声明的代码块中使用，外部无法访问的，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// foo is not defined</span></span><br></pre></td></tr></table></figure>

<h1 id="undefined-和-null-区别"><a href="#undefined-和-null-区别" class="headerlink" title="undefined 和 null 区别"></a>undefined 和 null 区别</h1><p>undefined 是未定义的值,是变量最原始的状态<br>null 是人为声明为空的值.希望表示** 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。** 在内存里的表示就是，栈中的变量没有指向堆中的内存对象</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>我的理解: 函数内部包含存在外部作用域的变量,且调用这个函数就形成闭包.<br>单纯有个函数算闭包环境,被调用了,所使用的外部变量也就无法释放了,这才形成闭包.<br>注意闭包的函数是 return 出来的.不 return 也可以产生闭包.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="keyword">return</span> (i += n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> cb = <span class="title function_">main</span>(result);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cb</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cb</span>(<span class="number">3</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="comment">// 形参i存在当前作用域</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    i = i + n;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cb(2)时,先打印10,注意function(n)已经是闭包了,i经过计算变为12,但是没有释放.</span></span><br><span class="line"><span class="comment">// cb(3)时,先打印12, i因为闭包没有释放依旧是12, 再计算后是15.</span></span><br><span class="line"><span class="comment">// result 一直未被修改还是10.</span></span><br></pre></td></tr></table></figure>

<p>位于全局作用域的闭包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      total += i * a;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(total);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tip：这里也形成了闭包。total 被外层引用没有被销毁。</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 6</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>疑问:下面这个算闭包吗,答:不算,把 var 换成 let 就算闭包了.<br>for 循环不是函数，所以 i 是全局作用域中的变量。<br>如果换成 let,其实内部也是闭包的机制，当 onclick 执行是循环早已执行完毕，i 早已销毁，因为闭包的机制我们才能拿到 i 对应的值.也就是说循环的 i 已经完事了,但是块级作用域的 i 还在.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"><span class="comment">//data是数组,数组中存储的是函数,函数中的i其实早已为3,打印出来都是3</span></span><br><span class="line"><span class="comment">//为什么输出3 ？</span></span><br><span class="line"><span class="comment">//因为在执行函数的时候 i 已经完成遍历了,</span></span><br><span class="line"><span class="comment">//data[i]执行后寻找i, 内部没有，向上寻找，这时i 是全局变量, 并且此时的值为3</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 暂时取名 fn</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;; <span class="comment">// i是自由变量，所以这是一个闭包</span></span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"><span class="comment">//在data[0]执行，即fn执行，此时的全局变量 i依旧是 3(但跟fn中的i无关)</span></span><br><span class="line"><span class="comment">//fn内部没有i，向上查找, 找到在for内，匿名函数传进来的i值0，它依旧存在在内存中。</span></span><br><span class="line"><span class="comment">//所以到此不会再向上去到全局作用域中查找。所以此时会打印 0</span></span><br></pre></td></tr></table></figure>

<p>局部变量：在函数中声明，且在函数返回后不会被其他作用域所使用的对象。下面代码中的 local* 都是局部变量。（scopes 是一块堆内存）<br>全局变量 ,在浏览器上为 window ，在 node 里为 global。全局变量会被默认添加到函数作用域链的最底端，也就是上述函数中 [[Scopes]] 中的最后一个，可以看下上面局部变量例子中 Scopes 的最后一个。</p>
<p>var：全局的 var 变量其实仅仅是为 global 对象添加了一条属性。<br>let &#x2F; const：全局的 let&#x2F;const 变量不会修改 window 对象，而是将变量的声明放在了一个特殊的对象下（与 Scope 类似）。<br>被捕获变量就是局部变量的反面：在函数中声明，但在函数返回后仍有未执行作用域（函数或是类）使用到该变量，那么该变量就是被捕获变量。</p>
<h2 id="一般如何产生闭包"><a href="#一般如何产生闭包" class="headerlink" title="一般如何产生闭包"></a>一般如何产生闭包</h2><ul>
<li>返回函数</li>
<li>函数当做参数传递</li>
</ul>
<p>函数科里化是一种闭包.</p>
<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><h2 id="如果是-var-声明-for-循环不是函数，所以-i-是全局作用域中的变量。"><a href="#如果是-var-声明-for-循环不是函数，所以-i-是全局作用域中的变量。" class="headerlink" title="如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。"></a>如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。</h2><p>使用 let 关键字时会产生块级作用域，for 每次循环的大括号都是一个独立的块级作用域，由于后面还要用到 i ,所以这几个块级作用域都不会销毁。<br>elements[0].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 0<br>elements[1].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 1<br>elements[2].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 2<br>elements[3].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> length = element.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  element[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><blockquote>
<p>for &gt; for-of &gt; forEach &gt; map &gt; for-in</p>
</blockquote>
<ul>
<li><code>for</code> 循环当然是最简单的，因为它没有任何额外的函数调用栈和上下文；</li>
<li><code>for...of</code>只要具有 Iterator 接口的数据结构，都可以使用它迭代成员。它直接读取的是键值。</li>
<li><code>forEach</code>，因为它其实比我们想象得要复杂一些，它实际上是 array.forEach(function(currentValue, index, arr), thisValue)它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</li>
<li><code>map()</code> 最慢，因为它的返回值是一个等长的全新的数组，数组创建和赋值产生的性能开销很大。</li>
<li><code>for...in</code>需要穷举对象的所有属性，包括自定义的添加的属性也能遍历到。且 for…in 的 key 是 String 类型，有转换过程，开销比较大。</li>
</ul>
<p>如果你需要将数组按照某种规则映射为另一个数组，就应该用 map。<br>如果你需要进行简单的遍历，用 forEach 或者 for of。<br>如果你需要对迭代器进行遍历，用 for of。<br>如果你需要过滤出符合条件的项，用 filterr。<br>如果你需要先按照规则映射为新数组，再根据条件过滤，那就用一个 map 加一个 filter</p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>是 ES5 版本发布的。以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性。<br>迭代数组时,<code>for...in</code>是下标,<code>for...of</code>是值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line"><span class="keyword">let</span> profile = &#123;<span class="attr">name</span>:<span class="string">&quot;April&quot;</span>,<span class="attr">nickname</span>:<span class="string">&quot;二十七刻&quot;</span>,<span class="attr">country</span>:<span class="string">&quot;China&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> profile)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = profile[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 对象的键值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 对象的键对应的值</span></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 数组下标所对应的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 索引，数组下标</span></span><br><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> str)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = str[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 字符串下标所对应的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 索引 字符串的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>我是 ES6 版本发布的。在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代数组数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 迭代字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 迭代map</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;a&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">2</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs [&quot;a&quot;, 1]</span></span><br><span class="line"><span class="comment">// logs [&quot;b&quot;, 2]</span></span><br><span class="line"><span class="comment">// logs [&quot;c&quot;, 3]</span></span><br><span class="line"><span class="comment">// 迭代map获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代set</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs 1</span></span><br><span class="line"><span class="comment">// logs 2</span></span><br><span class="line"><span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// logs 4</span></span><br><span class="line"><span class="comment">// 迭代 DOM 节点</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.article &gt; p&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> paragraph <span class="keyword">of</span> articleParagraphs) &#123;</span><br><span class="line">    paragraph.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;paragraph&quot;</span>);</span><br><span class="line">    <span class="comment">// 给class名为“article”节点下的 p 标签添加一个名为“paragraph” class属性。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代arguments类数组对象</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(argument);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// logs：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 迭代类型数组</span></span><br><span class="line"><span class="keyword">let</span> typeArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> typeArr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 255</span></span><br></pre></td></tr></table></figure>

<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>高阶函数： 函数可以作为参数传递 &amp;&amp; 函数可以作为返回值输出<br>柯里化(Currying): 把接受多个参数的函数变换成接受一个单一参数（或部分）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>示例:<br>编写一个 add 函数,使得 add(1,2)和 add(1)(2)都可以执行,并返回 3.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要判断参数值的长度</span></span><br><span class="line"><span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span> ? <span class="function"><span class="params">b</span> =&gt;</span> a + b : a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string-和-String-的区别"><a href="#string-和-String-的区别" class="headerlink" title="string 和 String 的区别"></a>string 和 String 的区别</h2><p>String 是包装类,是一个特殊的 object.<br>也就是说当不用 new 的时候，String(…) &#x3D;&#x3D;&#x3D; toString(…)</p>
<h2 id="new-String-和-String-区别"><a href="#new-String-和-String-区别" class="headerlink" title="new String() 和 String()区别"></a>new String() 和 String()区别</h2><p>我们知道 new 关键字的过程涉及到新对象的创建，所以，new String(str)的结果返回的一个新的 String 实例，所以，b 和 b2 保存的是两个对象的引用，他们的引用地址不一样，直接比较的话，逻辑引用类型的比较是一样的，结果就是不相等。</p>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> 条件<span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满足条件1&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 条件<span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满足条件2&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;和上两个条件都不相等&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expression</code>  中是可能变化的量,变化的可能性有三种,条件 1,2,和不满足条件 12 的其他种类.</p>
<p>空数组 push 后,再次调用记得赋值为空.</p>
<h2 id="map-和-forEach"><a href="#map-和-forEach" class="headerlink" title="map 和 forEach"></a>map 和 forEach</h2><p>map 返回处理后的新数组,而不是原数组的处理.原数组是不变的.</p>
<blockquote>
<p>能用 forEach()做到的，map()同样可以。反过来也是如此。<br>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。<br>forEach()允许 callback 更改原始数组的元素。map()返回新的数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;10:00.000&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;11:00.000&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;12:00.000&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> listMap = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">time</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//listMap返回时被处理的时间的字符串数组,原数组list没有变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(listMap); <span class="comment">//[&quot;10:00&quot;, &quot;11:00&quot;, &quot;12:00&quot;]</span></span><br><span class="line"><span class="keyword">let</span> listMap2 = list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span></span><br><span class="line">  item.<span class="property">time</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//forEach不返回新数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(listMap2); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="数组返回"><a href="#数组返回" class="headerlink" title="数组返回"></a>数组返回</h2><p>注意: <code>map</code>,<code>filter</code>,<code>find</code>,<code>findIndex</code>等必须要<code>return</code>才能生效.</p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Max&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Jane&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">groupBy</span>(<span class="params">objectArray, property</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> objectArray.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acc, obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = obj[property];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!acc[key]) &#123;</span><br><span class="line">      acc[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].<span class="title function_">push</span>(obj);</span><br><span class="line">    <span class="comment">// console.log(acc)</span></span><br><span class="line">    <span class="comment">//这里acc[key]是value,也就是value里push</span></span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> groupedPeople = <span class="title function_">groupBy</span>(people, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">// groupedPeople is:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   20: [</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Max&#x27;, age: 20 &#125;,</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Jane&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   21: [&#123; name: &#x27;Alice&#x27;, age: 21 &#125;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象类型的指针问题"><a href="#对象类型的指针问题" class="headerlink" title="对象类型的指针问题"></a>对象类型的指针问题</h2><p>js 中，参数传递只有一种规则:按值传递，基于值的复制。原始类型复制的是值本身，所以这两份数据互不影响；引用类型复制的是引用值，所以形参和实参指向同一个对象，通过一个饮用修改了对象，那么通过另外一个引用访问的对象就是修改后的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  person.<span class="property">age</span> = <span class="number">26</span>;</span><br><span class="line">  person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yck&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">test</span>(p1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// -&gt; ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// -&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>解释:<br><code>p1</code> &#x3D;&gt;指向对象<code>&#123;name:&#39;yck&#39;,age:25&#125;</code>的指针<code>00001</code>.<br><code>test(p1)</code>传指针,<code>person.age = 26</code>修改该对象.此时<code>p1 = &#123;name: &#39;yck&#39;, age:26&#125;</code><br>接下来要给<code>person</code>重新赋值,但是<code>person</code>指向<code>p1</code>的指针被覆盖,重新开辟一块内存,新的指针<code>00002</code>.<br><code>person</code>拥有一个新的地址.<code>person = &#123;name: &#39;yyy&#39;, age: 30&#125;</code>.返回出来.</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非(!)"></a>逻辑非(<code>!</code>)</h2><p>逻辑非的规则:<br>操作数能被转化为<code>true</code>的,都返回<code>false</code>.否则返回<code>true</code>.<br>举例:<br>下面都被转换成<code>false</code>:<br><code>null</code>,<code>NaN</code>,<code>0</code>, <code>&#39;&#39;</code>,<code>undefined</code>.<br>所以遇到<code>!</code>会取反转为<code>true</code>.</p>
<blockquote>
<p>遇到对象会返回<code>false</code>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">!a == <span class="literal">false</span>; <span class="comment">// 字符串取反,就是false, 所以判断结果为true</span></span><br><span class="line">a == <span class="literal">false</span>; <span class="comment">// 使用==转化false为0, &quot;0&quot;和0比较,&quot;0&quot;被转化为0,结果为true</span></span><br><span class="line">a == <span class="number">0</span>; <span class="comment">//跟上一条一样</span></span><br></pre></td></tr></table></figure>

<h2 id="双逻辑非"><a href="#双逻辑非" class="headerlink" title="双逻辑非(!!)"></a>双逻辑非(!!)</h2><p>用于始终返回<code>true</code>或者<code>false</code><br>比如<code>!!undefined</code>返回<code>false</code>,否则直接会返回<code>undefined</code>.</p>
<h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><p><code>&lt;&lt;</code>:左偏移,将数值转换为二进制,然后向左偏移多少位.<br><code>|</code>:按位或.按照二进制转换后,位数有则计算.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//二进制: 0000 0001 =&gt; 左偏移1位 =&gt; 0000 0010 =&gt; 2</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">//二进制: 0000 0010 =&gt; 左偏移2位 =&gt; 0000 1000 =&gt; 8</span></span><br><span class="line"><span class="keyword">let</span> c = a | b;</span><br><span class="line"><span class="comment">//二进制: 0000 0010</span></span><br><span class="line"><span class="comment">//二进制: 0000 1000 =&gt; 0000 1010 =&gt;10</span></span><br></pre></td></tr></table></figure>

<h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a><code>in</code>运算符</h2><p>指定的属性在指定的对象或其原型链中,则<code>in</code>运算符返回 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees; <span class="comment">// 返回false</span></span><br><span class="line"><span class="string">&quot;bay&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// 返回false (必须使用索引号,而不是数组元素的值)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true (length是一个数组属性)</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="property">iterator</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true (数组可迭代，只在ES2015+上有效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置对象</span></span><br><span class="line"><span class="string">&quot;PI&quot;</span> <span class="keyword">in</span> <span class="title class_">Math</span>; <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> mycar = &#123; <span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>, <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>, <span class="attr">year</span>: <span class="number">1998</span> &#125;;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// 返回true</span></span><br><span class="line"><span class="string">&quot;model&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure>

<p>如果只是将一个属性值赋值为<code>undefined</code>,而没有删除,则<code>in</code>运算符仍然会返回 true.</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>原始类型: 除了 null 判断为 object,其他都正常.因为 null 是全零,被判断为 object.<br>引用类型: 除了函数显示<code>function</code>,其他都是<code>object</code>.</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>判断对象类型就可以用 instanceof,它会通过原型链判断.<br>但是原始类型就不行了.</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p><code>a++b</code>返回<code>aNaN</code>.因为<code>++b</code>返回<code>NaN</code>.</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p><code>undefined</code> 表示一个变量自然的、最原始的状态值，而 <code>null</code> 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 <code>undefined</code>，当需要释放一个对象时，直接赋值为 <code>null</code> 即可。<br><code>&#123; &#125;</code>是一个不完全空对象，原型链上有<code>Object</code>，<code>null</code>为原型链顶端，因此<code>Object.prototype.__proto__ === null</code>为 true。</p>
<p>null 是完全空对象，原型链也没有。</p>
<h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>this 的指向与函数声明无关,取决于函数调用.</p>
<ol>
<li>普通函数调用(<code>fn()</code>) -&gt; this 指向 window</li>
<li>对象方法调用(<code>xx.fn()</code>) -&gt; this 指向对象</li>
<li>构造函数调用(<code>new fn()</code>) -&gt; this 指向 new 创建的实例对象</li>
<li>匿名函数中的 this：匿名函数的执行具有全局性，则匿名函数中的 this 指向是 window，而不是调用该匿名函数的对象</li>
</ol>
<p>例如:<br><code>box.onclick = function()&#123;&#125;</code>这就属于对象方法调用,this 也就指向 box.</p>
<h2 id="箭头函数的-this"><a href="#箭头函数的-this" class="headerlink" title="箭头函数的 this"></a>箭头函数的 this</h2><ol>
<li>箭头函数中的 this 是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的；</li>
<li>箭头函数中的 this 指向父级作用域的执行上下文；（技巧：<strong>因为 javascript 中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定 this 的指向，则找到离箭头函数最近的 function，与该 function 平级的执行上下文中的 this 即是箭头函数中的 this</strong>）</li>
<li>箭头函数无法使用 apply、call 和 bind 方法改变 this 指向，因为其 this 值在函数定义的时候就被确定下来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">//此处的this即是箭头函数中的this</span></span><br><span class="line">  <span class="attr">getThis</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getThis</span>()(); <span class="comment">//obj</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">getThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getThis</span>()(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h2><p>不同点:</p>
<ol>
<li>传参不同,call-&gt;多个参数,apply-&gt;数组,bind-&gt;就一个 this</li>
<li>执行机制不同: call,apply 立即执行,bind 不执行.</li>
</ol>
<p><code>call</code>的使用场景:<br><strong>检测数据类型:</strong></p>
<ol>
<li><code>typeof</code>,缺点:无法检测<code>null</code>,<code>array</code></li>
<li>使用<code>Object.prototype.toString.call()</code>.该方法会返回固定类型格式<code>[object type]</code>,其中 type 是类型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>

<p><strong>实现继承:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, uname, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;zhang&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son);</span><br></pre></td></tr></table></figure>

<p><code>apply</code>使用场景:<br><strong>类数组转真数组:</strong></p>
<p>ES5:上下文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line">newArr.<span class="property">push</span>.<span class="title function_">apply</span>(newArr, obj);</span><br></pre></td></tr></table></figure>

<p>ES6: <code>Array.from()</code><br>该方法可以将类数组直接转化为真数组.<br><strong>取数组最大值:</strong><br>ES5:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, arr);</span><br></pre></td></tr></table></figure>

<p>ES6:<code>Math.max(...arr)</code></p>
<p><code>bind</code>不会立即调用函数,而是得到一个修改<code>this</code>后的新函数.(一次修改,终身受用)<br>细节: 如果在 bind 后传递参数,参数也会绑定,但是调用函数所传参数就会失效了.<br><strong>修改不需要立即执行的函数:</strong><br>比如事件处理函数,定时器</p>
<p>如果对一个函数进行多次 bind，那么上下文会是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fn.<span class="title function_">bind</span>().<span class="title function_">bind</span>(a)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>();</span><br><span class="line">  &#125;.<span class="title function_">apply</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>

<p>无论<code>bind</code>多少次,this 永远指向第一次 bind.</p>
<ul>
<li>对于 new 的方式来说，this 被永远绑定在了实例上面，不会被任何方式改变 this</li>
<li>箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。<blockquote>
<p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo()这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p>
</blockquote>
</li>
</ul>
<h2 id="constructor-和原型对象-构造函数-实例对象"><a href="#constructor-和原型对象-构造函数-实例对象" class="headerlink" title="constructor 和原型对象,构造函数,实例对象"></a>constructor 和原型对象,构造函数,实例对象</h2><p><code>prototype</code>属于构造函数,指向原型对象. 作用:解决内存浪费和变量污染.<br><code>constructor</code>属于原型对象,指向构造函数.作用:可以让实例对象知道自己是被谁创建的.<br><code>__proto__</code>属于实例对象,指向原型对象.作用:实例对象访问原型对象的成员.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1664181323672-63ddb950-9558-4713-a12e-8889f0532fef.png#clientId=u84dfcbb8-1307-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=u3a5e30ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=573&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84467&status=done&style=none&taskId=u91ac1b2a-1524-4384-b47e-76f1a63fd50&title=&width=443" alt="image.png"></p>
<blockquote>
<p>如何方便理解三者关系,构造函数是父级,父级的 prototype(老婆)就是原型对象,原型对象的 constructor(老公)就是构造函数,子级实例对象的<strong>proto</strong>(母亲)就是原型对象.</p>
</blockquote>
<p>实例对象是无条件继承原型对象.<br>原型链的作用就是继承.也就说,js 是利用原型链实现面向对象继承的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>构造函数中的方法会导致内存的浪费.<br>两个实例对象虽然都可以调用 eat()方法,但是两个方法堆地址不同.每次调用函数都会在堆内存中生成一块新的空间.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1664200975310-09fb6834-6fd6-4750-86cb-09f1a5a63c5a.png#clientId=u0ca97a65-2fdb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=727&id=u04988d1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=727&originWidth=1437&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=422821&status=done&style=none&taskId=u2217fa30-5759-4ec2-8123-b745aacbe77&title=&width=1437" alt="image.png"><br>解决方法 1: 使用全局变量.即将函数在全局书写,在构造函数内赋值,也即只获取地址.<br>缺点: 导致变量污染.<br>解决方法 2: 使用对象将全局变量函数包裹,但是治标不治本.<br>最终解决方法: 原型对象.</p>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>原型对象是构造函数的默认属性 prototype 所指向的一个空对象.用于解决内存浪费和变量污染的问题.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="与-ES6-中继承的关系"><a href="#与-ES6-中继承的关系" class="headerlink" title="与 ES6 中继承的关系"></a>与 ES6 中继承的关系</h3><p>ES6 中继承的方法属于 ES5 的语法糖.</p>
<h3 id="instanceof-1"><a href="#instanceof-1" class="headerlink" title="instanceof"></a>instanceof</h3><p>用法:检测构造函数的原型在不在实例对象的原型链上.<br>arr 的原型链: arr -&gt;Array.prototype -&gt; Object.prototype -&gt; null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="literal">null</span>; <span class="comment">//typeError,右侧不是一个object</span></span><br></pre></td></tr></table></figure>

<h2 id="工厂函数和构造函数"><a href="#工厂函数和构造函数" class="headerlink" title="工厂函数和构造函数"></a>工厂函数和构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p = &#123;&#125;;</span><br><span class="line">  p.<span class="property">name</span> = name;</span><br><span class="line">  p.<span class="property">age</span> = age;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreatePerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new关键字调用的是构造函数</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h3 id="new-的用途"><a href="#new-的用途" class="headerlink" title="new 的用途"></a>new 的用途</h3><p>首先创建一个空对象,然后将 this 指向这个空对象,然后赋值,最后将这个对象返回出去.</p>
<h3 id="new-的细节"><a href="#new-的细节" class="headerlink" title="new 的细节"></a>new 的细节</h3><ol>
<li>构造函数的首字母大写,为了提醒别人不要忘记 new 关键字</li>
<li>关于构造函数主动写 return.对于值类型,无效,还是返回 new 创建的对象,对于引用类型,会覆盖.</li>
</ol>
<h2 id="对象字面量-new-Object-Object-create-区别"><a href="#对象字面量-new-Object-Object-create-区别" class="headerlink" title="对象字面量,new Object(),Object.create()区别"></a>对象字面量,new Object(),Object.create()区别</h2><p>字面量和 new 关键字创建的对象是 Object 的实例，原型指向 Object.prototype，继承内置对象 Object<br>Object.create(arg, pro)创建的对象的原型取决于 arg，arg 为 null，新对象是空对象，没有原型，不继承任何对象；arg 为指定对象，新对象的原型指向指定对象，继承指定对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> company = &#123;</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yideng = <span class="title class_">Object</span>.<span class="title function_">create</span>(company);</span><br><span class="line"><span class="keyword">delete</span> yideng.<span class="property">address</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yideng.<span class="property">address</span>);</span><br><span class="line"><span class="comment">// 写出执行结果，并解释原因</span></span><br><span class="line"><span class="comment">//beijing</span></span><br><span class="line"><span class="comment">//这里的 yideng 通过 prototype 继承了 company的 address。</span></span><br><span class="line"><span class="comment">//yideng自己并没有address属性。所以delete操作符的作用是无效的。</span></span><br><span class="line"><span class="comment">//yideng.address只是通过原型链去继承company的address</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>语法: <code>Object.assign(target, ...source)</code><br>解释: 将所有可枚举属性的值从一个或多个对象分配到目标对象.最后返回目标对象.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code>只能用于浅拷贝,无法用于深拷贝.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>对于这种就无法拷贝到对象 c.只能使用<code>JSON.parse(JSON.string(obj))</code>.<br>继承属性和不可枚举属性是不能被拷贝的.<br>原始类型会被包装,只有字符串的包装对象才可能有可枚举属性.</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>可以使用扩展运算符实现浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj &#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>通常可以通过 JSON.parse(JSON.stringify(object))来解决。<br>缺点:<br>忽略<code>undefined</code>,<code>Symbol</code>,函数,循环引用对象.</p>
<h1 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h1><p>执行 JS 代码就是往执行栈中放函数.遇到异步代码就挂起,需要执行的时候放到 TASK 中(有多种 task).<br>执行栈空了之后,从 task 中拿出要执行的代码放到执行栈中执行.<br>所以本质上说,异步还是同步行为.</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>先执行同步代码,属于宏任务.<br>执行完后,执行栈空,查询是否有异步代码<br>执行微任务<br>执行微任务后,如有必要,会重新渲染页面<br>开始下一轮 Event loop,执行宏任务中的异步代码,</p>
<h2 id="TASK-微任务和宏任务"><a href="#TASK-微任务和宏任务" class="headerlink" title="TASK(微任务和宏任务)"></a>TASK(微任务和宏任务)</h2><p>在 ES6 中,微任务叫<code>jobs</code>,宏任务叫<code>task</code>.<br>微任务包括: <code>process.nextTick()</code>, <code>Promise</code>,<code>MutationObserver</code>.<br>宏任务包括: <code>script</code>,<code>setTimeout</code>, <code>setInterval</code>,<code>setImmediate</code>,<code>I/O</code>,<code>UI rendering</code>,DOM 事件,DOM 渲染,AJAX 请求.<br>而且微任务并非快于宏任务,因为宏任务包括<code>script</code>,浏览器会先执行一个宏任务,接下来有异步代码才会执行微任务.</p>
<p>微任务和宏任务之间隔了一个 DOM 渲染.<br>执行顺序:<br>微任务 &gt; DOM 渲染 &gt; 宏任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>(); <span class="comment">//2.回到这里,遇到await,让出线程,执行之后的代码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>); <span class="comment">//3. 当同步代码执行完毕,回到这里,</span></span><br><span class="line">  <span class="comment">//将resolve放到微任务队列中,执行后面then中的回调.在两次tick后执行这里的微任务.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>); <span class="comment">//1.立即执行,执行完返回一个Promise</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="任务队列中-async-x2F-await-的运行机制"><a href="#任务队列中-async-x2F-await-的运行机制" class="headerlink" title="任务队列中 async&#x2F;await 的运行机制"></a>任务队列中 async&#x2F;await 的运行机制</h2><ul>
<li>async 定义的是一个 Promise 函数和普通函数一样只要不调用就不会进入事件队列。</li>
<li>async 内部如果没有主动 return Promise，那么 async 会把函数的返回值用 Promise 包装。</li>
<li>await 关键字必须出现在 async 函数中，await 后面不是必须要跟一个异步操作，也可以是一个普通表达式。</li>
<li>遇到 await 关键字，await 右边的语句会被立即执行然后 await 下面的代码进入等待状态，等待 await 得到结果。await 后面如果不是 promise 对象, await 会阻塞后面的代码，先执行 async 外面的同步代码，同步代码执行完，再回到 async 内部，把这个非 promise 的东西，作为 await 表达式的结果。await 后面如果是 promise 对象，await 也会暂停 async 后面的代码，先执行 async 外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</li>
</ul>
<p>await 后面的代码放不放到最后主要看,await 的代码是不是 Promise,如果是,先不放到微任务队中,也就是等同步代码执行完,再放,也就到了微任务队列的最后了,如果不是,可以放到微任务队列中.</p>
<p>try&#x2F;catch 捕获不到异步的异常,只能捕获同步代码.</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 是异步问题同步化解决方案.<br>Promise 本身不是异步,它是个构造函数.<br>Promise 中的函数是同步的.<br>Promise 有一个参数,即<code>excutor</code>执行器,它有两个参数,<code>resolve</code>和<code>reject</code>.<br><code>excutor</code>是同步执行,而<code>then</code>是异步调用的.<br>如果想连续<code>then</code>需要上一个<code>promise</code>中 return 一个新的<code>promise</code>.<br>Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止.</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>promise 内部在<code>resolve</code>之前的代码处于<code>pending</code>状态,之后的是<code>fulfilled</code>.<br>promise 在<code>catch</code>中如果没有抛出错误,则会返回<code>fufilled</code></p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>状态固化后,就不再捕获错误了.比如 resolve()返回后面有报错的内容,但是 catch 就不再捕获了.<br>案例:<br>当 promise 作为参数传递到另一个 promise 中,这个第二个 promise 中的状态就会失效.依赖于第一个 promise.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">resolve</span>(p1)&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>

<p>Promise.all()如果三个内容都失败,只返回第一个失败的信息.如果只有一个出错,也只会返回一个.而且不返回正常的.<br>Promise.race()是谁先完成返回谁,无论是成功还是失败.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">300</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">    &#125; <span class="comment">// &#x27;Error&#x27;</span></span><br><span class="line">    <span class="comment">// 默认return 的是undefined</span></span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="comment">//上一次调用只有失败的状态,而那里默认返回的是undefined,</span></span><br><span class="line">    <span class="comment">//这里在onFulfilled的这里捕获的是上一次失败的默认return的undefined</span></span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;, <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then中throw new Error()的情况</span></span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="comment">// 上面抛出的是error,所以要走onRejectd,也就是第二个函数</span></span><br><span class="line">	<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;,</span><br><span class="line">  <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(reason)&#125; <span class="comment">// &#x27;Error&#x27;</span></span><br><span class="line">  )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="async-x2F-await-和-promise-的关系"><a href="#async-x2F-await-和-promise-的关系" class="headerlink" title="async&#x2F;await 和 promise 的关系"></a>async&#x2F;await 和 promise 的关系</h2><p>await 是等待 promise 的返回,await 做不了 promise 返回状态的工作.<br>await 对应<code>Promise.then</code>成功的情况.<br>await 后如果是函数,则会把函数返回的结果用<code>Promise.then()</code>返回.<br>async 中的<code>Promise.reject()</code>需要使用<code>try/catch</code>进行捕获错误.<br>async 中的函数内部属于同步代码,在遇到 await 之前都可以先执行.</p>
<h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>catch 在 promise 的源码层面就是一个 then,如果 catch 中 return 的有值,可以在 catch 后跟 then.<br>既有 then 中的失败回调,又有 catch 的情况,会走最近的那个.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 输出1,2,3</span></span><br><span class="line"><span class="comment">// catch后没有抛出错,则返回的是resolved状态,可以继续then</span></span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="使用-promise-加载图片"><a href="#使用-promise-加载图片" class="headerlink" title="使用 promise 加载图片"></a>使用 promise 加载图片</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadIMg</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;加载失败&quot;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">src</span> = src;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> url1 =</span><br><span class="line">  <span class="string">&quot;https://i1.hdslb.com/bfs/face/f4d60f852eb1a85696447838c90a94acad31b7ae.jpg@160w_160h_1c_1s.webp&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> url2 =</span><br><span class="line">  <span class="string">&quot;https://i0.hdslb.com/bfs/face/a8ef30d6688d0b532bd20baa160417deae8f386d.jpg@240w_240h_1c_1s.webp&quot;</span>;</span><br><span class="line"><span class="comment">// 连续加载图片</span></span><br><span class="line"><span class="title function_">loadImg</span>(url1)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">img</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(img);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">loadImg</span>(url2);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">img2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(img2);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>Promise.resolve()<br>Promise.reject()</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>如果所有都正确执行,会按顺序返回.有一个失败,就失败.</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/10/React/" rel="prev" title="React">
                  <i class="fa fa-chevron-left"></i> React
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/22/Vue/" rel="next" title="Vue">
                  Vue <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zax Tseng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
