<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="var,let,const 区别var的作用域是方法作用域,声明之前变量是 undefined.可以重复声明.let的作用域是块级作用域.在声明之前使用会报错,禁止重复声明.const是常量声明方式,声明变量时必须初始化,后面不再修改该常量的值.(声明时必须赋值)const 不是变量的值不能改动,而是变量指向的那个内存地址不能改动. 作用域ES2015 前，ES 只有两种作用域，分别是全局作用域和">
<meta property="og:type" content="article">
<meta property="og:title" content="JS补档">
<meta property="og:url" content="http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/index.html">
<meta property="og:site_name" content="ZAX">
<meta property="og:description" content="var,let,const 区别var的作用域是方法作用域,声明之前变量是 undefined.可以重复声明.let的作用域是块级作用域.在声明之前使用会报错,禁止重复声明.const是常量声明方式,声明变量时必须初始化,后面不再修改该常量的值.(声明时必须赋值)const 不是变量的值不能改动,而是变量指向的那个内存地址不能改动. 作用域ES2015 前，ES 只有两种作用域，分别是全局作用域和">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/473454/1664181323672-63ddb950-9558-4713-a12e-8889f0532fef.png#averageHue=%23f7f7f7&clientId=u84dfcbb8-1307-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=u3a5e30ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=573&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84467&status=done&style=none&taskId=u91ac1b2a-1524-4384-b47e-76f1a63fd50&title=&width=443">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/473454/1664200975310-09fb6834-6fd6-4750-86cb-09f1a5a63c5a.png#averageHue=%234d4c44&clientId=u0ca97a65-2fdb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=727&id=u04988d1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=727&originWidth=1437&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=422821&status=done&style=none&taskId=u2217fa30-5759-4ec2-8123-b745aacbe77&title=&width=1437">
<meta property="article:published_time" content="2021-03-22T03:31:39.000Z">
<meta property="article:modified_time" content="2022-11-28T02:40:24.209Z">
<meta property="article:author" content="Zax Tseng">
<meta property="article:tag" content="javascript, React, Vue, HTML5">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/473454/1664181323672-63ddb950-9558-4713-a12e-8889f0532fef.png#averageHue=%23f7f7f7&clientId=u84dfcbb8-1307-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=u3a5e30ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=573&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84467&status=done&style=none&taskId=u91ac1b2a-1524-4384-b47e-76f1a63fd50&title=&width=443">


<link rel="canonical" href="http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/","path":"2021/03/22/JS补档/","title":"JS补档"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JS补档 | ZAX</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZAX</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#var-let-const-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">var,let,const 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.1.</span> <span class="nav-text">作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined-%E5%92%8C-null-%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">undefined 和 null 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E9%97%AD%E5%8C%85"><span class="nav-number">3.1.</span> <span class="nav-text">一般如何产生闭包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.</span> <span class="nav-text">for 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AF-var-%E5%A3%B0%E6%98%8E-for-%E5%BE%AA%E7%8E%AF%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%80%E4%BB%A5-i-%E6%98%AF%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E3%80%82"><span class="nav-number">4.1.</span> <span class="nav-text">如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">4.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E2%80%A6in"><span class="nav-number">4.3.</span> <span class="nav-text">for…in</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E2%80%A6of"><span class="nav-number">4.4.</span> <span class="nav-text">for…of</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">函数柯里化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string-%E5%92%8C-String-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">string 和 String 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-String-%E5%92%8C-String-%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.</span> <span class="nav-text">new String() 和 String()区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.3.</span> <span class="nav-text">switch 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-%E5%92%8C-forEach"><span class="nav-number">5.4.</span> <span class="nav-text">map 和 forEach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%BF%94%E5%9B%9E"><span class="nav-number">5.5.</span> <span class="nav-text">数组返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reduce"><span class="nav-number">5.6.</span> <span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98"><span class="nav-number">5.7.</span> <span class="nav-text">对象类型的指针问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="nav-number">6.1.</span> <span class="nav-text">逻辑非(!)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="nav-number">6.2.</span> <span class="nav-text">双逻辑非(!!)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.3.</span> <span class="nav-text">二进制运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">6.4.</span> <span class="nav-text">in运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="nav-number">6.5.</span> <span class="nav-text">类型判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof"><span class="nav-number">6.5.1.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof"><span class="nav-number">6.5.2.</span> <span class="nav-text">instanceof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.6.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95-%E7%89%B9%E6%AE%8A"><span class="nav-number">6.6.1.</span> <span class="nav-text">加法(特殊)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A4%E4%BA%86%E5%8A%A0%E6%B3%95"><span class="nav-number">6.6.2.</span> <span class="nav-text">除了加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="nav-number">6.6.3.</span> <span class="nav-text">&#x3D;&#x3D;运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">基本类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="nav-number">8.</span> <span class="nav-text">this 的指向</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">8.1.</span> <span class="nav-text">函数调用的优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84-this"><span class="nav-number">8.2.</span> <span class="nav-text">箭头函数的 this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call-apply-bind"><span class="nav-number">8.3.</span> <span class="nav-text">call,apply,bind</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#constructor-%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.</span> <span class="nav-text">constructor 和原型对象,构造函数,实例对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.0.1.</span> <span class="nav-text">原型对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E-ES6-%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">9.0.2.</span> <span class="nav-text">与 ES6 中继承的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof-1"><span class="nav-number">9.0.3.</span> <span class="nav-text">instanceof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.</span> <span class="nav-text">工厂函数和构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">9.1.1.</span> <span class="nav-text">new 的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">9.1.2.</span> <span class="nav-text">new 的细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F-new-Object-Object-create-%E5%8C%BA%E5%88%AB"><span class="nav-number">9.2.</span> <span class="nav-text">对象字面量,new Object(),Object.create()区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-assign"><span class="nav-number">9.3.</span> <span class="nav-text">Object.assign()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">9.4.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">9.5.</span> <span class="nav-text">深拷贝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Event-loop"><span class="nav-number">10.</span> <span class="nav-text">Event loop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84-event-loop"><span class="nav-number">10.1.</span> <span class="nav-text">浏览器的 event loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="nav-number">10.2.</span> <span class="nav-text">异步和同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">10.3.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="nav-number">10.4.</span> <span class="nav-text">执行栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">10.5.</span> <span class="nav-text">执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TASK-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">10.6.</span> <span class="nav-text">TASK(微任务和宏任务)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setInterval"><span class="nav-number">10.7.</span> <span class="nav-text">setInterval</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#requestAnimationFrame"><span class="nav-number">10.8.</span> <span class="nav-text">requestAnimationFrame</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zax Tseng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JS补档 | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JS补档
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-22 11:31:39" itemprop="dateCreated datePublished" datetime="2021-03-22T11:31:39+08:00">2021-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-28 10:40:24" itemprop="dateModified" datetime="2022-11-28T10:40:24+08:00">2022-11-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var,let,const 区别"></a>var,let,const 区别</h1><p><code>var</code>的作用域是方法作用域,声明之前变量是 undefined.可以重复声明.<br><code>let</code>的作用域是块级作用域.在声明之前使用会报错,禁止重复声明.<br><code>const</code>是常量声明方式,声明变量时必须初始化,后面不再修改该常量的值.(声明时必须赋值)<br><code>const</code> 不是变量的值不能改动,而是变量指向的那个内存地址不能改动.</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>ES2015 前，ES 只有两种作用域，分别是全局作用域和函数作用域；在 ES2015 中新增了一个块级作用域.<br>以前块没有独立的作用域，所以在块中定义的变量，块的外面也可以访问，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br></pre></td></tr></table></figure>

<p>这对于代码是非常不利的、不安全的，有了块级作用域，可以通过新的关键字 let 去声明变量，用法跟传统一样，只是 let 声明的变量只能在声明的代码块中使用，外部无法访问的，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// foo is not defined</span></span><br></pre></td></tr></table></figure>

<h1 id="undefined-和-null-区别"><a href="#undefined-和-null-区别" class="headerlink" title="undefined 和 null 区别"></a>undefined 和 null 区别</h1><p>undefined 是未定义的值,是变量最原始的状态<br>null 是人为声明为空的值.希望表示** 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。** 在内存里的表示就是，栈中的变量没有指向堆中的内存对象</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>我的理解: 函数内部包含存在外部作用域的变量,且调用这个函数就形成闭包.<br>单纯有个函数算闭包环境,被调用了,所使用的外部变量也就无法释放了,这才形成闭包.<br>注意闭包的函数是 return 出来的.不 return 也可以产生闭包.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="keyword">return</span> (i += n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> cb = <span class="title function_">main</span>(result);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cb</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cb</span>(<span class="number">3</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="comment">// 形参i存在当前作用域</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    i = i + n;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cb(2)时,先打印10,注意function(n)已经是闭包了,i经过计算变为12,但是没有释放.</span></span><br><span class="line"><span class="comment">// cb(3)时,先打印12, i因为闭包没有释放依旧是12, 再计算后是15.</span></span><br><span class="line"><span class="comment">// result 一直未被修改还是10.</span></span><br></pre></td></tr></table></figure>

<p>位于全局作用域的闭包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      total += i * a;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(total);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tip：这里也形成了闭包。total 被外层引用没有被销毁。</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 6</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>疑问:下面这个算闭包吗,答:不算,把 var 换成 let 就算闭包了.<br>for 循环不是函数，所以 i 是全局作用域中的变量。<br>如果换成 let,其实内部也是闭包的机制，当 onclick 执行是循环早已执行完毕，i 早已销毁，因为闭包的机制我们才能拿到 i 对应的值.也就是说循环的 i 已经完事了,但是块级作用域的 i 还在.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"><span class="comment">//data是数组,数组中存储的是函数,函数中的i其实早已为3,打印出来都是3</span></span><br><span class="line"><span class="comment">//为什么输出3 ？</span></span><br><span class="line"><span class="comment">//因为在执行函数的时候 i 已经完成遍历了,</span></span><br><span class="line"><span class="comment">//data[i]执行后寻找i, 内部没有，向上寻找，这时i 是全局变量, 并且此时的值为3</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 暂时取名 fn</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;; <span class="comment">// i是自由变量，所以这是一个闭包</span></span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"><span class="comment">//在data[0]执行，即fn执行，此时的全局变量 i依旧是 3(但跟fn中的i无关)</span></span><br><span class="line"><span class="comment">//fn内部没有i，向上查找, 找到在for内，匿名函数传进来的i值0，它依旧存在在内存中。</span></span><br><span class="line"><span class="comment">//所以到此不会再向上去到全局作用域中查找。所以此时会打印 0</span></span><br></pre></td></tr></table></figure>

<p>局部变量：在函数中声明，且在函数返回后不会被其他作用域所使用的对象。下面代码中的 local* 都是局部变量。（scopes 是一块堆内存）<br>全局变量 ,在浏览器上为 window ，在 node 里为 global。全局变量会被默认添加到函数作用域链的最底端，也就是上述函数中 [[Scopes]] 中的最后一个，可以看下上面局部变量例子中 Scopes 的最后一个。</p>
<p>var：全局的 var 变量其实仅仅是为 global 对象添加了一条属性。<br>let &#x2F; const：全局的 let&#x2F;const 变量不会修改 window 对象，而是将变量的声明放在了一个特殊的对象下（与 Scope 类似）。<br>被捕获变量就是局部变量的反面：在函数中声明，但在函数返回后仍有未执行作用域（函数或是类）使用到该变量，那么该变量就是被捕获变量。</p>
<h2 id="一般如何产生闭包"><a href="#一般如何产生闭包" class="headerlink" title="一般如何产生闭包"></a>一般如何产生闭包</h2><ul>
<li>返回函数</li>
<li>函数当做参数传递</li>
</ul>
<p>函数科里化是一种闭包.</p>
<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><h2 id="如果是-var-声明-for-循环不是函数，所以-i-是全局作用域中的变量。"><a href="#如果是-var-声明-for-循环不是函数，所以-i-是全局作用域中的变量。" class="headerlink" title="如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。"></a>如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。</h2><p>使用 let 关键字时会产生块级作用域，for 每次循环的大括号都是一个独立的块级作用域，由于后面还要用到 i ,所以这几个块级作用域都不会销毁。<br>elements[0].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 0<br>elements[1].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 1<br>elements[2].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 2<br>elements[3].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> length = element.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  element[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><blockquote>
<p>for &gt; for-of &gt; forEach &gt; map &gt; for-in</p>
</blockquote>
<ul>
<li><code>for</code> 循环当然是最简单的，因为它没有任何额外的函数调用栈和上下文；</li>
<li><code>for...of</code>只要具有 Iterator 接口的数据结构，都可以使用它迭代成员。它直接读取的是键值。</li>
<li><code>forEach</code>，因为它其实比我们想象得要复杂一些，它实际上是 array.forEach(function(currentValue, index, arr), thisValue)它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</li>
<li><code>map()</code> 最慢，因为它的返回值是一个等长的全新的数组，数组创建和赋值产生的性能开销很大。</li>
<li><code>for...in</code>需要穷举对象的所有属性，包括自定义的添加的属性也能遍历到。且 for…in 的 key 是 String 类型，有转换过程，开销比较大。</li>
</ul>
<p>如果你需要将数组按照某种规则映射为另一个数组，就应该用 map。<br>如果你需要进行简单的遍历，用 forEach 或者 for of。<br>如果你需要对迭代器进行遍历，用 for of。<br>如果你需要过滤出符合条件的项，用 filterr。<br>如果你需要先按照规则映射为新数组，再根据条件过滤，那就用一个 map 加一个 filter</p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>是 ES5 版本发布的。以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性。<br>迭代数组时,<code>for...in</code>是下标,<code>for...of</code>是值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line"><span class="keyword">let</span> profile = &#123;<span class="attr">name</span>:<span class="string">&quot;April&quot;</span>,<span class="attr">nickname</span>:<span class="string">&quot;二十七刻&quot;</span>,<span class="attr">country</span>:<span class="string">&quot;China&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> profile)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = profile[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 对象的键值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 对象的键对应的值</span></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 数组下标所对应的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 索引，数组下标</span></span><br><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> str)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = str[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 字符串下标所对应的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 索引 字符串的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>我是 ES6 版本发布的。在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代数组数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 迭代字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 迭代map</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;a&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">2</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs [&quot;a&quot;, 1]</span></span><br><span class="line"><span class="comment">// logs [&quot;b&quot;, 2]</span></span><br><span class="line"><span class="comment">// logs [&quot;c&quot;, 3]</span></span><br><span class="line"><span class="comment">// 迭代map获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代set</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs 1</span></span><br><span class="line"><span class="comment">// logs 2</span></span><br><span class="line"><span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// logs 4</span></span><br><span class="line"><span class="comment">// 迭代 DOM 节点</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.article &gt; p&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> paragraph <span class="keyword">of</span> articleParagraphs) &#123;</span><br><span class="line">    paragraph.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;paragraph&quot;</span>);</span><br><span class="line">    <span class="comment">// 给class名为“article”节点下的 p 标签添加一个名为“paragraph” class属性。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代arguments类数组对象</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(argument);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// logs：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 迭代类型数组</span></span><br><span class="line"><span class="keyword">let</span> typeArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> typeArr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 255</span></span><br></pre></td></tr></table></figure>

<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>高阶函数： 函数可以作为参数传递 &amp;&amp; 函数可以作为返回值输出<br>柯里化(Currying): 把接受多个参数的函数变换成接受一个单一参数（或部分）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>示例:<br>编写一个 add 函数,使得 add(1,2)和 add(1)(2)都可以执行,并返回 3.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要判断参数值的长度</span></span><br><span class="line"><span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span> ? <span class="function"><span class="params">b</span> =&gt;</span> a + b : a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string-和-String-的区别"><a href="#string-和-String-的区别" class="headerlink" title="string 和 String 的区别"></a>string 和 String 的区别</h2><p>String 是包装类,是一个特殊的 object.<br>也就是说当不用 new 的时候，String(…) &#x3D;&#x3D;&#x3D; toString(…)</p>
<h2 id="new-String-和-String-区别"><a href="#new-String-和-String-区别" class="headerlink" title="new String() 和 String()区别"></a>new String() 和 String()区别</h2><p>我们知道 new 关键字的过程涉及到新对象的创建，所以，new String(str)的结果返回的一个新的 String 实例，所以，b 和 b2 保存的是两个对象的引用，他们的引用地址不一样，直接比较的话，逻辑引用类型的比较是一样的，结果就是不相等。</p>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> 条件<span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满足条件1&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 条件<span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满足条件2&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;和上两个条件都不相等&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expression</code>  中是可能变化的量,变化的可能性有三种,条件 1,2,和不满足条件 12 的其他种类.</p>
<p>空数组 push 后,再次调用记得赋值为空.</p>
<h2 id="map-和-forEach"><a href="#map-和-forEach" class="headerlink" title="map 和 forEach"></a>map 和 forEach</h2><p>map 返回处理后的新数组,而不是原数组的处理.原数组是不变的.</p>
<blockquote>
<p>能用 forEach()做到的，map()同样可以。反过来也是如此。<br>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。<br>forEach()允许 callback 更改原始数组的元素。map()返回新的数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;10:00.000&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;11:00.000&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;12:00.000&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> listMap = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">time</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//listMap返回时被处理的时间的字符串数组,原数组list没有变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(listMap); <span class="comment">//[&quot;10:00&quot;, &quot;11:00&quot;, &quot;12:00&quot;]</span></span><br><span class="line"><span class="keyword">let</span> listMap2 = list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span></span><br><span class="line">  item.<span class="property">time</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//forEach不返回新数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(listMap2); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="数组返回"><a href="#数组返回" class="headerlink" title="数组返回"></a>数组返回</h2><p>注意: <code>map</code>,<code>filter</code>,<code>find</code>,<code>findIndex</code>等必须要<code>return</code>才能生效.</p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Max&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Jane&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">groupBy</span>(<span class="params">objectArray, property</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> objectArray.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acc, obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = obj[property];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!acc[key]) &#123;</span><br><span class="line">      acc[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].<span class="title function_">push</span>(obj);</span><br><span class="line">    <span class="comment">// console.log(acc)</span></span><br><span class="line">    <span class="comment">//这里acc[key]是value,也就是value里push</span></span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> groupedPeople = <span class="title function_">groupBy</span>(people, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">// groupedPeople is:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   20: [</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Max&#x27;, age: 20 &#125;,</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Jane&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   21: [&#123; name: &#x27;Alice&#x27;, age: 21 &#125;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象类型的指针问题"><a href="#对象类型的指针问题" class="headerlink" title="对象类型的指针问题"></a>对象类型的指针问题</h2><p>js 中，参数传递只有一种规则:按值传递，基于值的复制。原始类型复制的是值本身，所以这两份数据互不影响；引用类型复制的是引用值，所以形参和实参指向同一个对象，通过一个饮用修改了对象，那么通过另外一个引用访问的对象就是修改后的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  person.<span class="property">age</span> = <span class="number">26</span>;</span><br><span class="line">  person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yck&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">test</span>(p1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// -&gt; ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// -&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>解释:<br><code>p1</code> &#x3D;&gt;指向对象<code>&#123;name:&#39;yck&#39;,age:25&#125;</code>的指针<code>00001</code>.<br><code>test(p1)</code>传指针,<code>person.age = 26</code>修改该对象.此时<code>p1 = &#123;name: &#39;yck&#39;, age:26&#125;</code><br>接下来要给<code>person</code>重新赋值,但是<code>person</code>指向<code>p1</code>的指针被覆盖,重新开辟一块内存,新的指针<code>00002</code>.<br><code>person</code>拥有一个新的地址.<code>person = &#123;name: &#39;yyy&#39;, age: 30&#125;</code>.返回出来.</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非(!)"></a>逻辑非(<code>!</code>)</h2><p>逻辑非的规则:<br>操作数能被转化为<code>true</code>的,都返回<code>false</code>.否则返回<code>true</code>.<br>举例:<br>下面都被转换成<code>false</code>:<br><code>null</code>,<code>NaN</code>,<code>0</code>, <code>&#39;&#39;</code>,<code>undefined</code>.<br>所以遇到<code>!</code>会取反转为<code>true</code>.</p>
<blockquote>
<p>遇到对象会返回<code>false</code>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">!a == <span class="literal">false</span>; <span class="comment">// 字符串取反,就是false, 所以判断结果为true</span></span><br><span class="line">a == <span class="literal">false</span>; <span class="comment">// 使用==转化false为0, &quot;0&quot;和0比较,&quot;0&quot;被转化为0,结果为true</span></span><br><span class="line">a == <span class="number">0</span>; <span class="comment">//跟上一条一样</span></span><br></pre></td></tr></table></figure>

<h2 id="双逻辑非"><a href="#双逻辑非" class="headerlink" title="双逻辑非(!!)"></a>双逻辑非(!!)</h2><p>用于始终返回<code>true</code>或者<code>false</code><br>比如<code>!!undefined</code>返回<code>false</code>,否则直接会返回<code>undefined</code>.</p>
<h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><p><code>&lt;&lt;</code>:左偏移,将数值转换为二进制,然后向左偏移多少位.<br><code>|</code>:按位或.按照二进制转换后,位数有则计算.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//二进制: 0000 0001 =&gt; 左偏移1位 =&gt; 0000 0010 =&gt; 2</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">//二进制: 0000 0010 =&gt; 左偏移2位 =&gt; 0000 1000 =&gt; 8</span></span><br><span class="line"><span class="keyword">let</span> c = a | b;</span><br><span class="line"><span class="comment">//二进制: 0000 0010</span></span><br><span class="line"><span class="comment">//二进制: 0000 1000 =&gt; 0000 1010 =&gt;10</span></span><br></pre></td></tr></table></figure>

<h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a><code>in</code>运算符</h2><p>指定的属性在指定的对象或其原型链中,则<code>in</code>运算符返回 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees; <span class="comment">// 返回false</span></span><br><span class="line"><span class="string">&quot;bay&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// 返回false (必须使用索引号,而不是数组元素的值)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true (length是一个数组属性)</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="property">iterator</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true (数组可迭代，只在ES2015+上有效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置对象</span></span><br><span class="line"><span class="string">&quot;PI&quot;</span> <span class="keyword">in</span> <span class="title class_">Math</span>; <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> mycar = &#123; <span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>, <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>, <span class="attr">year</span>: <span class="number">1998</span> &#125;;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// 返回true</span></span><br><span class="line"><span class="string">&quot;model&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure>

<p>如果只是将一个属性值赋值为<code>undefined</code>,而没有删除,则<code>in</code>运算符仍然会返回 true.</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>值类型用<code>**typeof**</code>,引用类型用<code>**instanceof**</code></p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>运算符返回一个字符串，表示操作数的类型。<br>原始类型: 除了 null 判断为 object,其他都正常.因为 null 是全零,被判断为 object.<br>引用类型: 除了函数显示<code>function</code>,其他都是<code>object</code>.</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>判断对象类型就可以用 instanceof,它会通过原型链判断.<br>但是原始类型就不行了.</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
<th>boolean</th>
<th>Number</th>
<th>String</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>true</td>
<td>1</td>
<td>“true”</td>
</tr>
<tr>
<td>Boolean</td>
<td>false</td>
<td>false</td>
<td>0</td>
<td>“false”</td>
</tr>
<tr>
<td>Number</td>
<td>123</td>
<td>true</td>
<td>123</td>
<td>“123”</td>
</tr>
<tr>
<td>Number</td>
<td>Infinity</td>
<td>true</td>
<td>Infinity</td>
<td>“Infinity”</td>
</tr>
<tr>
<td>Number</td>
<td>0</td>
<td>false</td>
<td>0</td>
<td>“0”</td>
</tr>
<tr>
<td>Number</td>
<td>NaN</td>
<td>false</td>
<td>NaN</td>
<td>“NaN”</td>
</tr>
<tr>
<td>String</td>
<td>“”</td>
<td>false</td>
<td>0</td>
<td>“”</td>
</tr>
<tr>
<td>String</td>
<td>“123”</td>
<td>true</td>
<td>123</td>
<td>“123”</td>
</tr>
<tr>
<td>String</td>
<td>“123abc”</td>
<td>true</td>
<td>NaN</td>
<td>“123abc”</td>
</tr>
<tr>
<td>String</td>
<td>“abc”</td>
<td>true</td>
<td>NaN</td>
<td>“abc”</td>
</tr>
<tr>
<td>Null</td>
<td>null</td>
<td>false</td>
<td>0</td>
<td>“null”</td>
</tr>
<tr>
<td>Undefined</td>
<td>undefined</td>
<td>false</td>
<td>NaN</td>
<td>“undefined”</td>
</tr>
<tr>
<td>Function</td>
<td>function(){}</td>
<td>true</td>
<td>NaN</td>
<td>“function(){}”</td>
</tr>
<tr>
<td>Object</td>
<td>{}</td>
<td>true</td>
<td>NaN</td>
<td>“[object Object]”</td>
</tr>
<tr>
<td>Array</td>
<td>[]</td>
<td>true</td>
<td>0</td>
<td>“”</td>
</tr>
<tr>
<td>Array</td>
<td>[“abc”]</td>
<td>true</td>
<td>NaN</td>
<td>“abc”</td>
</tr>
<tr>
<td>Array</td>
<td>[“123”]</td>
<td>true</td>
<td>123</td>
<td>“123”</td>
</tr>
<tr>
<td>Array</td>
<td>[“123”,”a”]</td>
<td>true</td>
<td>NaN</td>
<td>“123,a”</td>
</tr>
</tbody></table>
<h3 id="加法-特殊"><a href="#加法-特殊" class="headerlink" title="加法(特殊)"></a>加法(特殊)</h3><p>四则运算符合两个规则:</p>
<ol>
<li>运算符一方为字符串,会把另一方转化为字符串.</li>
<li>如果一方不是字符串或数字,就会把它转化为字符串或数字.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&quot;1&quot;</span>; <span class="comment">// &quot;11&quot;</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// &quot;41,2,3&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 ‘11’</li>
<li>对于第二行代码来说，触发特点二，所以将 true 转为数字 1</li>
<li>对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3</li>
</ul>
<p>另外对于加法还需要注意这个表达式 ‘a’ + + ‘b’:</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">`a++b`返回`aNaN`.因为`+'b'`返回`NaN`.</div>
`+ '1'`快速获取number类型.

<h3 id="除了加法"><a href="#除了加法" class="headerlink" title="除了加法"></a>除了加法</h3><p>只要其中一方是数字，那么另一方就会被转为数字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">&quot;3&quot;</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="number">4</span> * []; <span class="comment">// 0</span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="==运算符"></a><code>==</code>运算符</h3><ol>
<li>如果一个操作数是布尔值,在比较之前要转成 number.</li>
<li>如果一个操作数是字符串,另一个是 number,要把字符串转成 number</li>
</ol>
<p>解释<code>[] == ![]</code>为 true.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先转化![] 为false</span></span><br><span class="line"><span class="comment">// 布尔值要先转成number =&gt; false-&gt;0</span></span><br><span class="line"><span class="comment">// [] 就要转成number -&gt; 0</span></span><br><span class="line"><span class="comment">// 0 == 0 //true</span></span><br></pre></td></tr></table></figure>

<p>解释<code>&#123;&#125; == !&#123;&#125;</code>为 false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本和上面相同</span></span><br><span class="line"><span class="comment">// 差异在于&#123;&#125; 转为number是NaN</span></span><br><span class="line"><span class="comment">// NaN == 0 就是false</span></span><br></pre></td></tr></table></figure>

<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p><code>undefined</code> 表示一个变量自然的、最原始的状态值，而 <code>null</code> 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 <code>undefined</code>，当需要释放一个对象时，直接赋值为 <code>null</code> 即可。<br><code>&#123; &#125;</code>是一个不完全空对象，原型链上有<code>Object</code>，<code>null</code>为原型链顶端，因此<code>Object.prototype.__proto__ === null</code>为 true。</p>
<p>null 是完全空对象，原型链也没有。</p>
<h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>this 的指向与函数声明无关,取决于函数调用.</p>
<ol>
<li>普通函数调用(<code>fn()</code>) -&gt; this 指向 window</li>
<li>对象方法调用(<code>xx.fn()</code>) -&gt; this 指向对象</li>
<li>构造函数调用(<code>new fn()</code>) -&gt; this 指向 new 创建的实例对象</li>
<li>匿名函数中的 this：匿名函数的执行具有全局性，则匿名函数中的 this 指向是 window，而不是调用该匿名函数的对象</li>
</ol>
<p>例如:<br><code>box.onclick = function()&#123;&#125;</code>这就属于对象方法调用,this 也就指向 box.</p>
<h2 id="函数调用的优先级"><a href="#函数调用的优先级" class="headerlink" title="函数调用的优先级"></a>函数调用的优先级</h2><p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p>
<h2 id="箭头函数的-this"><a href="#箭头函数的-this" class="headerlink" title="箭头函数的 this"></a>箭头函数的 this</h2><ol>
<li>箭头函数中的 this 是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的；</li>
<li>箭头函数中的 this 指向父级作用域的执行上下文；（技巧：<strong>因为 javascript 中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定 this 的指向，则找到离箭头函数最近的 function，与该 function 平级的执行上下文中的 this 即是箭头函数中的 this</strong>）</li>
<li>箭头函数无法使用 apply、call 和 bind 方法改变 this 指向，因为其 this 值在函数定义的时候就被确定下来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">//此处的this即是箭头函数中的this</span></span><br><span class="line">  <span class="attr">getThis</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getThis</span>()(); <span class="comment">//obj</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">getThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getThis</span>()(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h2><p>不同点:</p>
<ol>
<li>传参不同,call-&gt;多个参数,apply-&gt;数组,bind-&gt;就一个 this</li>
<li>执行机制不同: call,apply 立即执行,bind 不执行.</li>
</ol>
<p><code>call</code>的使用场景:<br><strong>检测数据类型:</strong></p>
<ol>
<li><code>typeof</code>,缺点:无法检测<code>null</code>,<code>array</code></li>
<li>使用<code>Object.prototype.toString.call()</code>.该方法会返回固定类型格式<code>[object type]</code>,其中 type 是类型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>

<p><strong>实现继承:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getValue</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">uname</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, uname, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Son</span>, <span class="comment">// 设置constructor的值是Son,说明原型对象的构造函数是Son</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">	  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;zhang&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son);</span><br></pre></td></tr></table></figure>

<p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数<br><code>apply</code>使用场景:<br><strong>类数组转真数组:</strong></p>
<p>ES5:上下文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line">newArr.<span class="property">push</span>.<span class="title function_">apply</span>(newArr, obj);</span><br></pre></td></tr></table></figure>

<p>ES6: <code>Array.from()</code><br>该方法可以将类数组直接转化为真数组.<br><strong>取数组最大值:</strong><br>ES5:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, arr);</span><br></pre></td></tr></table></figure>

<p>ES6:<code>Math.max(...arr)</code></p>
<p><code>bind</code>不会立即调用函数,而是得到一个修改<code>this</code>后的新函数.(一次修改,终身受用)<br>细节: 如果在 bind 后传递参数,参数也会绑定,但是调用函数所传参数就会失效了.<br><strong>修改不需要立即执行的函数:</strong><br>比如事件处理函数,定时器</p>
<p>如果对一个函数进行多次 bind，那么上下文会是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fn.<span class="title function_">bind</span>().<span class="title function_">bind</span>(a)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>();</span><br><span class="line">  &#125;.<span class="title function_">apply</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>

<p>无论<code>bind</code>多少次,this 永远指向第一次 bind.</p>
<ul>
<li>对于 new 的方式来说，this 被永远绑定在了实例上面，不会被任何方式改变 this</li>
<li>箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。<blockquote>
<p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo()这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p>
</blockquote>
</li>
</ul>
<h1 id="constructor-和原型对象-构造函数-实例对象"><a href="#constructor-和原型对象-构造函数-实例对象" class="headerlink" title="constructor 和原型对象,构造函数,实例对象"></a>constructor 和原型对象,构造函数,实例对象</h1><p><code>prototype</code>属于构造函数,指向原型对象. 作用:解决内存浪费和变量污染.<br><code>constructor</code>属于原型对象,指向构造函数.作用:可以让实例对象知道自己是被谁创建的.<br><code>__proto__</code>属于实例对象,指向原型对象.作用:实例对象访问原型对象的成员.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1664181323672-63ddb950-9558-4713-a12e-8889f0532fef.png#averageHue=%23f7f7f7&clientId=u84dfcbb8-1307-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=u3a5e30ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=573&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84467&status=done&style=none&taskId=u91ac1b2a-1524-4384-b47e-76f1a63fd50&title=&width=443" alt="image.png"></p>
<blockquote>
<p>如何方便理解三者关系,构造函数是父级,父级的 prototype(老婆)就是原型对象,原型对象的 constructor(老公)就是构造函数,子级实例对象的<strong>proto</strong>(母亲)就是原型对象.</p>
</blockquote>
<p>实例对象是无条件继承原型对象.<br>原型链的作用就是继承.也就说,js 是利用原型链实现面向对象继承的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>构造函数中的方法会导致内存的浪费.<br>两个实例对象虽然都可以调用 eat()方法,但是两个方法堆地址不同.每次调用函数都会在堆内存中生成一块新的空间.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1664200975310-09fb6834-6fd6-4750-86cb-09f1a5a63c5a.png#averageHue=%234d4c44&clientId=u0ca97a65-2fdb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=727&id=u04988d1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=727&originWidth=1437&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=422821&status=done&style=none&taskId=u2217fa30-5759-4ec2-8123-b745aacbe77&title=&width=1437" alt="image.png"><br>解决方法 1: 使用全局变量.即将函数在全局书写,在构造函数内赋值,也即只获取地址.<br>缺点: 导致变量污染.<br>解决方法 2: 使用对象将全局变量函数包裹,但是治标不治本.<br>最终解决方法: 原型对象.</p>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>原型对象是构造函数的默认属性 prototype 所指向的一个空对象.用于解决内存浪费和变量污染的问题.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="与-ES6-中继承的关系"><a href="#与-ES6-中继承的关系" class="headerlink" title="与 ES6 中继承的关系"></a>与 ES6 中继承的关系</h3><p>ES6 中继承的方法属于 ES5 的语法糖.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">1</span>);</span><br><span class="line">child.<span class="title function_">getValue</span>(); <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Parent</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。</p>
<h3 id="instanceof-1"><a href="#instanceof-1" class="headerlink" title="instanceof"></a>instanceof</h3><p>用法:检测构造函数的原型在不在实例对象的原型链上.<br>arr 的原型链: arr -&gt;Array.prototype -&gt; Object.prototype -&gt; null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="literal">null</span>; <span class="comment">//typeError,右侧不是一个object</span></span><br></pre></td></tr></table></figure>

<h2 id="工厂函数和构造函数"><a href="#工厂函数和构造函数" class="headerlink" title="工厂函数和构造函数"></a>工厂函数和构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p = &#123;&#125;;</span><br><span class="line">  p.<span class="property">name</span> = name;</span><br><span class="line">  p.<span class="property">age</span> = age;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreatePerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new关键字调用的是构造函数</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h3 id="new-的用途"><a href="#new-的用途" class="headerlink" title="new 的用途"></a>new 的用途</h3><p>首先创建一个空对象,然后将 this 指向这个空对象,然后赋值,最后将这个对象返回出去.</p>
<h3 id="new-的细节"><a href="#new-的细节" class="headerlink" title="new 的细节"></a>new 的细节</h3><ol>
<li>构造函数的首字母大写,为了提醒别人不要忘记 new 关键字</li>
<li>关于构造函数主动写 return.对于值类型,无效,还是返回 new 创建的对象,对于引用类型,会覆盖.</li>
</ol>
<h2 id="对象字面量-new-Object-Object-create-区别"><a href="#对象字面量-new-Object-Object-create-区别" class="headerlink" title="对象字面量,new Object(),Object.create()区别"></a>对象字面量,new Object(),Object.create()区别</h2><p>字面量和 new 关键字创建的对象是 Object 的实例，原型指向 Object.prototype，继承内置对象 Object</p>
<p>Object.create(arg, pro)创建的对象的原型取决于 arg，arg 为 null，新对象是空对象，没有原型，不继承任何对象；arg 为指定对象，新对象的原型指向指定对象，继承指定对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> company = &#123;</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yideng = <span class="title class_">Object</span>.<span class="title function_">create</span>(company);</span><br><span class="line"><span class="keyword">delete</span> yideng.<span class="property">address</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yideng.<span class="property">address</span>);</span><br><span class="line"><span class="comment">// 写出执行结果，并解释原因</span></span><br><span class="line"><span class="comment">//beijing</span></span><br><span class="line"><span class="comment">//这里的 yideng 通过 prototype 继承了 company的 address。</span></span><br><span class="line"><span class="comment">//yideng自己并没有address属性。所以delete操作符的作用是无效的。</span></span><br><span class="line"><span class="comment">//yideng.address只是通过原型链去继承company的address</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>语法: <code>Object.assign(target, ...source)</code><br>解释: 将所有可枚举属性的值从一个或多个对象分配到目标对象.最后返回目标对象.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code>只能用于浅拷贝,无法用于深拷贝.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>对于这种就无法拷贝到对象 c.只能使用<code>JSON.parse(JSON.string(obj))</code>.<br>继承属性和不可枚举属性是不能被拷贝的.<br>原始类型会被包装,只有字符串的包装对象才可能有可枚举属性.</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>可以使用扩展运算符实现浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj &#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>通常可以通过 JSON.parse(JSON.stringify(object))来解决。<br>缺点:<br>忽略<code>undefined</code>,<code>Symbol</code>,函数,循环引用对象.</p>
<h1 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h1><p>执行 JS 代码就是往执行栈中放函数.遇到异步代码就挂起,需要执行的时候放到 TASK 中(有多种 task).<br>执行栈空了之后,从 task 中拿出要执行的代码放到执行栈中执行.</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">所以本质上说,异步还是同步行为.</div>

<h2 id="浏览器的-event-loop"><a href="#浏览器的-event-loop" class="headerlink" title="浏览器的 event loop"></a>浏览器的 event loop</h2><ul>
<li>js 引擎首先从宏任务中取出第一个(一般是 script),</li>
<li>执行完毕后,将微任务中所有的任务取出,按顺序执行</li>
<li>如果在这一步产生新的微任务也要执行</li>
<li>执行完后,会进行 DOM 渲染</li>
<li>进入下一轮 event loop,再取出一个宏任务,,执行完后取出所有的微任务,执行.<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">一次eventloop循环会处理一个宏任务和所有这次循环产生的微任务</div></li>
</ul>
<h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<ul>
<li>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li>
<li>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>
</ul>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>本质上两个名词都是 CPU 工作时间片的描述.</p>
<ul>
<li>进程是 CPU 在<strong>运行指令,加载和保存上下文</strong>所需的时间.放在应用上就代表了一个程序.</li>
<li>线程是进程中更小的单位,描述执行一段指令所需的时间.</li>
</ul>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。<br>当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，<br>当我们使用递归的时候，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ul>
<li>先执行同步代码,属于宏任务.</li>
<li>执行完后,执行栈空,查询是否有异步代码</li>
<li>执行微任务</li>
<li>执行微任务后,如有必要,会重新渲染页面</li>
<li>开始下一轮 Event loop,执行宏任务中的异步代码,</li>
</ul>
<h2 id="TASK-微任务和宏任务"><a href="#TASK-微任务和宏任务" class="headerlink" title="TASK(微任务和宏任务)"></a>TASK(微任务和宏任务)</h2><p>在 ES6 中,微任务叫<code>jobs</code>,宏任务叫<code>task</code>.<br>微任务包括: <code>process.nextTick()</code>, <code>Promise</code>,<code>MutationObserver</code>.<br>宏任务包括: <code>script</code>,<code>setTimeout</code>, <code>setInterval</code>,<code>setImmediate</code>,<code>I/O</code>,<code>UI rendering</code>,DOM 事件,DOM 渲染,AJAX 请求.<br>而且微任务并非快于宏任务,因为宏任务包括<code>script</code>,浏览器会先执行一个宏任务,接下来有异步代码才会执行微任务.</p>
<p>微任务和宏任务之间隔了一个 DOM 渲染.<br>执行顺序:<br>微任务 &gt; DOM 渲染 &gt; 宏任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>(); <span class="comment">//2.回到这里,遇到await,让出线程,执行之后的代码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>); <span class="comment">//3. 当同步代码执行完毕,回到这里,</span></span><br><span class="line">  <span class="comment">//将resolve放到微任务队列中,执行后面then中的回调.在两次tick后执行这里的微任务.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>); <span class="comment">//1.立即执行,执行完返回一个Promise</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt; 代码一执行就开始执行了一个宏任务-宏0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 宏 1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span> * <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 微1-1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 微1-4 =&gt; 这个then中的会等待上一个then执行完成之后得到其状态才会向Queue注册状态对应的回调，假设上一个then中主动抛错且没有捕获，那就注册的是这个then中的第二个回调了。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">bar</span>(); <span class="comment">// =&gt; await(promise的语法糖)，会异步等待获取其返回值</span></span><br><span class="line">  <span class="comment">// =&gt; 后面的代码可以理解为放到异步队列微任务中。 这里可以保留疑问后面会详细说</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>); <span class="comment">// 微1-2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">errorFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// =&gt; 从这后面开始所有的代码可以理解为放到异步队列微任务中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// 微1-3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;async1 success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">errorFunc</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)); <span class="comment">// 微1-5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// run:</span></span><br><span class="line"><span class="comment">// 	执行微1-1: promise1</span></span><br><span class="line"><span class="comment">// 	执行微1-2: async1 end</span></span><br><span class="line"><span class="comment">// 	执行微1-3: error!!!、async1 。</span></span><br><span class="line"><span class="comment">//  当前异步回调执行完毕才Promise.resolve(&#x27;async1 success&#x27;)，</span></span><br><span class="line"><span class="comment">//  然后注册then()中的成功的回调-微1-5</span></span><br><span class="line"><span class="comment">// 	执行微1-4: promise2</span></span><br><span class="line"><span class="comment">//  执行刚刚注册的微1-5: async1 success</span></span><br></pre></td></tr></table></figure>

<p>如果 Promise 中有 setTimeout,那就看 resolve 在不在 setTimeout 里了,如果在,因为后面 then 拿不到 value,无法继续,就得等着,如果不在,那就走 then,回来再走 setTimeout.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 宏2</span></span><br><span class="line">        <span class="title function_">reject</span>();</span><br><span class="line">      &#125;, <span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">      <span class="title function_">resolve</span>() <span class="comment">// TODO 注1</span></span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-2  TODO 注2</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">      &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-4</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-6</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 微1-5 TODO 注3</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注意then后面想执行需要前面的状态是fufilled,否则并不会放入队列</span></span><br><span class="line"><span class="string">``</span><span class="string">`&lt;/div&gt;warning</span></span><br><span class="line"><span class="string">前面说过promise.finally()也是微任务，finally可以理解为不管promise的状态是成功或失败都要执行我。但是我不接受任何结果。因此finally接受不到返回值res为undefined&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 任务队列中async/await的运行机制</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- async定义的是一个Promise函数和普通函数一样只要不调用就不会进入事件队列。</span></span><br><span class="line"><span class="string">- async内部如果没有主动return Promise，那么async会把函数的返回值用Promise包装。</span></span><br><span class="line"><span class="string">- await关键字必须出现在async函数中，await后面不是必须要跟一个异步操作，也可以是一个普通表达式。</span></span><br><span class="line"><span class="string">- 遇到await关键字，await右边的语句会被立即执行然后await下面的代码进入等待状态，等待await得到结果。await后面如果不是 promise 对象, await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果。await后面如果是 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</span></span><br><span class="line"><span class="string">- await后面的代码放不放到最后主要看,await 的代码是不是Promise,如果是,先不放到微任务队中,也就是等同步代码执行完,再放,也就到了微任务队列的最后了,如果不是,可以放到微任务队列中.&lt;/div&gt;warning</span></span><br><span class="line"><span class="string">await的真实意思是 async wait(异步等待的意思)await表达式相当于调用后面返回promise的then方法，异步（等待）获取其返回值。即 await&lt;==&gt;promise.then&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div style=&quot;background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;&quot;&gt;try/catch捕获不到异步的异常,只能捕获同步代码.&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 定时器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## setTimeout</span></span><br><span class="line"><span class="string">setTimeout并不一定准确.</span></span><br><span class="line"><span class="string">其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，我们可以通过代码去修正 setTimeout，从而使定时器相对准确.</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + period</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> currentInterval = interval</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">  <span class="keyword">let</span> h = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>(hdiff / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(s)</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="title class_">Math</span>.<span class="title function_">floor</span>(s)</span><br><span class="line">  <span class="comment">// 得到下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;时：&#x27;</span>+h, <span class="string">&#x27;分：&#x27;</span>+m, <span class="string">&#x27;毫秒：&#x27;</span>+s, <span class="string">&#x27;秒向上取整：&#x27;</span>+sCeil, <span class="string">&#x27;代码执行时间：&#x27;</span>+offset, <span class="string">&#x27;下次循环间隔&#x27;</span>+currentInterval)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(loop, currentInterval)</span><br></pre></td></tr></table></figure>

<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><p>接下来我们来看 setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p>
<p>通常来说不建议使用 setInterval。<br>第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。<br>第二，它存在执行累积的问题.</p>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>通过 <code>requestAnimationFrame</code> 来实现 setInterval.<br>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setInterval</span>(<span class="params">callback, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="property">now</span>;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">let</span> endTime = startTime;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">loop</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    timer = <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(loop);</span><br><span class="line">    endTime = <span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = <span class="title function_">now</span>();</span><br><span class="line">      <span class="title function_">callback</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  timer = <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(loop);</span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">(<span class="params">timer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">3</span>) <span class="title function_">cancelAnimationFrame</span>(timer);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/10/React/" rel="prev" title="React">
                  <i class="fa fa-chevron-left"></i> React
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/22/Vue/" rel="next" title="Vue">
                  Vue <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zax Tseng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
