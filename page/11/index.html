<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="ZAX">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="ZAX">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zax Tseng">
<meta property="article:tag" content="javascript, React, Vue, HTML5">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZAX</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZAX</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zax Tseng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/14/JS%E6%AD%A3%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/14/JS%E6%AD%A3%E5%88%99/" class="post-title-link" itemprop="url">JS正则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-14 15:27:45" itemprop="dateCreated datePublished" datetime="2021-05-14T15:27:45+08:00">2021-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:28" itemprop="dateModified" datetime="2023-05-13T09:03:28+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="两种表达式"><a href="#两种表达式" class="headerlink" title="两种表达式"></a>两种表达式</h2><p>1.对象字面量<br>以斜杠<code>/</code>表示开始和结束.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regx = <span class="regexp">/xyz/</span>;</span><br></pre></td></tr></table></figure>

<p>2.使用<code>RegExp</code>构造函数.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regx = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;xyz&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>两种方法等价,区别在于第一种在引擎编译代码时,新建正则表达式.<br>第二种在运行时新建正则表达式.</p>
<h2 id="第二参数"><a href="#第二参数" class="headerlink" title="第二参数"></a>第二参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regx = <span class="regexp">/xyz/g</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> regx = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h3><p>返回一个布尔值,表示当前模式是否能够匹配参数表达式.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/cat/.<span class="title function_">test</span>(<span class="string">&quot;cats and dogs&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>验证字符串中是否含有<code>cat</code>.<br>如果含有<code>g</code>修饰符,则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="regexp">/z/g</span>;</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;_z_z&quot;</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">test</span>(s); <span class="comment">//true,(从第一个_z前面开始)</span></span><br><span class="line">r.<span class="title function_">test</span>(s); <span class="comment">//true,(从第二个_z前面开始)</span></span><br><span class="line">r.<span class="title function_">test</span>(s); <span class="comment">//false,(从第二个_z后面开始)</span></span><br></pre></td></tr></table></figure>

<p><code>g</code>修饰符表示全局搜索.<br>如果正则是一个空字符串,则会匹配所有的字符串.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">test</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h3><p>返回匹配结果.如果发现匹配,即返回一个数组.成员是匹配成功的子字符串,否则返回<code>null</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;_X_X&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">exec</span>(s); <span class="comment">//[&quot;x&quot;]</span></span><br><span class="line">r2.<span class="title function_">exec</span>(s); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h4 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h4><p>正则如果包含<code>()</code>,则返回的数组包含多个成员.<br>第一个成员是整个匹配成功的结果.第二个成员对应第一个括号,第二个成员对应第二个括号.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;_x_x&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> r = <span class="regexp">/_(x)/</span>;</span><br><span class="line">r.<span class="title function_">exec</span>(s); <span class="comment">//[&quot;_x&quot;, &quot;x&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="Srting-prototype-match"><a href="#Srting-prototype-match" class="headerlink" title="Srting.prototype.match()"></a>Srting.prototype.match()</h2><p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配,返回匹配结果.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;_x_x&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line">s.<span class="title function_">match</span>(r1); <span class="comment">//[&quot;x&quot;&#125;</span></span><br><span class="line">s.<span class="title function_">match</span>(r2); <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>字符串的<code>match</code>方法与正则对象的<code>exec</code>非常类似.<br>匹配成功返回一个数组,匹配失败返回 null.<br>如果正则表达式带有<code>g</code>修饰符,则该方法与<code>exec</code>不同,会一次性返回所有匹配成功的结果.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;abba&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> r = <span class="regexp">/a/g</span>;</span><br><span class="line">s.<span class="title function_">match</span>(r); <span class="comment">//[&quot;a&quot;,&quot;a&quot;]</span></span><br><span class="line">s.<span class="title function_">exec</span>(r); <span class="comment">//[&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h2><p>返回第一个满足匹配结果在整个字符串的位置.如果没有返回<code>-1</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;_x_x&#x27;</span><span class="title function_">search</span>(<span class="regexp">/x/</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h2><p>字符串对象的<code>replace</code>可以替换匹配的值.它接收两个参数,第一个是正则表达式.表示搜索模式.<br>第二个是替换内容.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">replace</span>(search, replacement);</span><br></pre></td></tr></table></figure>

<p>如果不加<code>g</code>,就替换匹配成功的第一个值,否则替换所有值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(a, b); <span class="comment">//&quot;baa&quot;</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/a/</span>, b); <span class="comment">//&quot;baa&quot;</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/a/g</span>, b); <span class="comment">//&quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>repalce</code>消除字符串首尾两端的空格.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;     #id div.class   &quot;</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//#id div.class</span></span><br></pre></td></tr></table></figure>

<p><code>replace</code>第二个参数可以使用美元符号<code>$</code>,用来指代所替换的内容.</p>
<blockquote>
<p>$&amp;：匹配的子字符串。<br>$&#96;：匹配结果前面的文本。<br>$’：匹配结果后面的文本。<br>$n：匹配成功的第 n 组内容，n 是从 1 开始的自然数。<br>$$：指代美元符号$。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;[$`-$&amp;-$&#x27;]&quot;</span>);</span><br><span class="line"><span class="comment">//&quot;a[a-b-c]c&quot;</span></span><br></pre></td></tr></table></figure>

<p>作为 replace 方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。</p>
<h2 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h2><p>该方法接收两个参数,第一个参数是正则表达式,表示分隔规则,第二个参数是返回数组的最大成员数.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非正则分隔</span></span><br><span class="line"><span class="string">&quot;a,  b,c, d&quot;</span>.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;  b&#x27;, &#x27;c&#x27;, &#x27; d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则分隔，去除多余的空格</span></span><br><span class="line"><span class="string">&quot;a,  b,c, d&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/, */</span>);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定返回数组的最大成员</span></span><br><span class="line"><span class="string">&quot;a,  b,c, d&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/, */</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//[ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="string">&quot;aaa*a*&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/a*/</span>);</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;*&#x27;, &#x27;*&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="string">&quot;aaa**a*&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/a*/</span>);</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的分割规则是 0 次或多次的 a，由于正则默认是贪婪匹配，所以例一的第一个分隔符是 aaa，第二个分割符是 a，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是 aaa，第二个分隔符是 0 个 a（即空字符），第三个分隔符是 a，所以将字符串分成四个部分。</p>
<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aaa*a*&quot;</span>.<span class="title function_">split</span>(<span class="regexp">/(a*)/</span>);</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;aaa&#x27;, &#x27;*&#x27;, &#x27;a&#x27;, &#x27;*&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h1 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1><h2 id="点字符"><a href="#点字符" class="headerlink" title="点字符"></a>点字符</h2><p>点字符匹配除回车<code>\r</code>,换行<code>\n</code>,行分隔符<code>\u2028</code>,段分隔符<code>\2029</code>以外的所有字符.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/c.<span class="property">t</span>/;</span><br></pre></td></tr></table></figure>

<p>上面代码中，c.t 匹配 c 和 t 之间包含任意一个字符的情况，只要这三个字符在同一行，比如 cat、c2t、c-t 等等，但是不匹配 coot。</p>
<h2 id="位置字符"><a href="#位置字符" class="headerlink" title="位置字符"></a>位置字符</h2><p>提示字符所处的位置.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^表示字符串的开始位置</span><br><span class="line">$表示字符串的结束位置</span><br></pre></td></tr></table></figure>

<h2 id="选择符"><a href="#选择符" class="headerlink" title="选择符(|)"></a>选择符(|)</h2><p>竖线符号在正则表达式中表示”或关系”</p>
<h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。<br>正则表达式中，需要反斜杠转义的，一共有 12 个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;</code>和<code>\\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的 X 是 A-Z 之中任一个英文字母，用来匹配控制字符。<br><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。<br>\n 匹配换行键。<br>\r 匹配回车键。<br>\t 匹配制表符 tab（U+0009）。<br>\v 匹配垂直制表符（U+000B）。<br>\f 匹配换页符（U+000C）。<br>\0 匹配 null 字符（U+0000）。<br>\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。<br>\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</p>
<h2 id="匹配带千分位的金额-并以正常字符串输出"><a href="#匹配带千分位的金额-并以正常字符串输出" class="headerlink" title="匹配带千分位的金额,并以正常字符串输出"></a>匹配带千分位的金额,并以正常字符串输出</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = s.<span class="title function_">match</span>(<span class="regexp">/\d*(\,\d+)*(\.\d+)?/g</span>)[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="regexp">/\,/gi</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//匹配带千分位的金额,并以正常字符串输出</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/ES6%E8%A1%A5%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/ES6%E8%A1%A5%E6%A1%A3/" class="post-title-link" itemprop="url">ES6补档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-20 16:00:38" itemprop="dateCreated datePublished" datetime="2021-04-20T16:00:38+08:00">2021-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:28" itemprop="dateModified" datetime="2023-05-13T09:03:28+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据结构-Set-和-Map"><a href="#数据结构-Set-和-Map" class="headerlink" title="数据结构 Set 和 Map"></a>数据结构 Set 和 Map</h1><h2 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述:"></a>整体概述:</h2><p><code>Set</code>是一种类似数组的数据结构，区别在于其存储的成员都是不重复的，由此带来了它的一个应用就是：去重。<code>Set</code>通过<code>new</code>关键字实例化，入参可以是数组 or 类数组的对象。</p>
<p>值得注意的是：在<code>Set</code>中，只能存储一个<code>NaN</code>，这说明在 Set 数据结构中，<code>NaN</code>等于<code>NaN</code>。</p>
<p><code>Set</code>实例的方法：<br>操作方法 add()、delete()、has()和 clear()；<br>遍历方法：keys()、values()、entries()和 forEach();扩展运算符…、<br>数组方法 map()、filter()方法也可以用于 Set 结构。<br>由此它可以很方便的实现数组的交、并、差集。</p>
<p><code>WeakSet</code>类似于 Set，主要区别在于 1.成员只能是对象类型； 2.对象都是弱引用（如果其他对象都不再引用该对象，垃圾回收机制会自动回收该对象所占的内存，不可预测何时会发生，故 WeakSet 不可被遍历）</p>
<p>JavaScript 对象 Object 都是键值 K-V 对的集合，但 K 取值只能是字符串和 Symbol，Map 也是 K-V 的集合，然而其 K 可以取任意类型。<br>如果需要键值对的集合，Map 比 Object 更适合。Map 通过 new 关键字实例化。</p>
<p><code>Map</code>实例的方法：set()、get()、has()、delete()和 clear();<br>遍历方法同 Set。</p>
<p><code>Map</code>与其它数据结构的互相转换：Map &lt;—&gt; 数组| Map &lt;—&gt; 对象| Map &lt;—&gt; JSON。</p>
<p><code>WeakMap</code>类似于<code>Map</code>，主要区别在于： 1.只接受对象作为键名； 2.键名所指向的对象不计入垃圾回收机制。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是一个类似数组,但是与数组不同,它具有唯一性.里面的元素都是不重复的,本身是一个构造函数.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SetArr</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="title class_">SetArr</span>.<span class="title function_">add</span>(item));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SetArr</span>);</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line"><span class="number">1</span>: <span class="number">2</span></span><br><span class="line"><span class="number">2</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">size</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">__proto__</span>: <span class="title class_">Set</span></span><br></pre></td></tr></table></figure>

<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><ul>
<li>constructor: 构造函数,就是 Set 函数</li>
<li>size: 返回的是 Set 实例的长度</li>
</ul>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>add(): 往 Set 里添加值,返回 Set 本身</li>
<li>delete(): 删除某个值,返回布尔值判断是否成功</li>
<li>has(value): 判断是否有 value,返回布尔值</li>
<li>clear(): 清除 Set 中所有值,无返回值</li>
</ul>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><ul>
<li>forEach(): 使用回调函数遍历元素</li>
<li>entries(): 返回键值对的遍历器,用于遍历[键名,键值]组成的数组</li>
<li>values(): 返回键值遍历器,用于遍历所有键值</li>
<li>keys(): 返回键名遍历器,用于遍历所有键名<blockquote>
<p>由于 Set 结构是只有键值的结构，所有 keys 方法与 values 方法返回一致。</p>
</blockquote>
</li>
</ul>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h4 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2) [&quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line"><span class="comment">//(2) [&quot;b&quot;, &quot;b&quot;]</span></span><br><span class="line"><span class="comment">//(2) [&quot;c&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="values"><a href="#values" class="headerlink" title="values"></a>values</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a b c</span></span><br></pre></td></tr></table></figure>

<h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a b c</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-set-实现交并差"><a href="#使用-set-实现交并差" class="headerlink" title="使用 set 实现交并差"></a>使用 set 实现交并差</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> b.<span class="title function_">has</span>(item)));</span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> value2 = <span class="keyword">new</span> <span class="title class_">Set</span>([...a], [...b]);</span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="keyword">let</span> value3 = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> !b.<span class="title function_">has</span>(item)));</span><br></pre></td></tr></table></figure>

<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>一个弱的 Set 结构,弱的体现在<code>WeakSet</code>的成员只能是对象.<br><code>WeakSet</code>的对象都是弱引用,即垃圾回收机制不考虑 WeakSet 对该对象的引用.<br><code>WeakSet</code>没有 size 属性,无法遍历.只有实例方法:</p>
<ul>
<li>add(): 向<code>WeakSet</code>添加新成员</li>
<li>delete(): 删除<code>WeakSet</code>的成员</li>
<li>has(): 判断<code>WeakSet</code>是否包含某个元素</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Set 结构是没有键只有值,而 Map 结构是键值的组合.也就可以使用各种数据类型作为键(包括对象).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;alan&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line">map.<span class="title function_">set</span>(obj, <span class="string">&quot;这是一些描述&quot;</span>);</span><br><span class="line">map.<span class="title function_">get</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map);</span><br></pre></td></tr></table></figure>

<h3 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h3><ul>
<li>constructor: Map 构造函数</li>
<li>size: 返回的是 Map 元素的长度</li>
</ul>
<h3 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>set(key, value): 设置 key 所对应的 value 值</li>
<li>get(key): 获取 key 所对应的 value 值,若无则返回 undefined</li>
<li>delete(): 删除某个值,返回布尔值判断是否成功</li>
<li>has(value): 判断是否有 value,返回布尔值</li>
<li>clear(): 清除 Set 中所有值,无返回值</li>
</ul>
<h3 id="遍历方法-1"><a href="#遍历方法-1" class="headerlink" title="遍历方法"></a>遍历方法</h3><ul>
<li>forEach(): 使用回调函数遍历元素</li>
<li>entries(): 返回键值对的遍历器,用于遍历[键名,键值]组成的数组</li>
<li>values(): 返回键值遍历器,用于遍历所有键值</li>
<li>keys(): 返回键名遍历器,用于遍历所有键名</li>
</ul>
<h4 id="keys-1"><a href="#keys-1" class="headerlink" title="keys"></a>keys</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;alan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> person.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br></pre></td></tr></table></figure>

<h4 id="values-1"><a href="#values-1" class="headerlink" title="values"></a>values</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;alan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> person.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alan</span></span><br><span class="line"><span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<h3 id="与其他数据结构转换"><a href="#与其他数据结构转换" class="headerlink" title="与其他数据结构转换"></a>与其他数据结构转换</h3><ul>
<li>Map 转数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;alan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...person);</span><br></pre></td></tr></table></figure>

<ul>
<li>数组转 Map</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;alan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>],</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(arr);</span><br></pre></td></tr></table></figure>

<ul>
<li>Map 转对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;alan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">map</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    obj[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">swap</span>(person);</span><br><span class="line"><span class="comment">//&#123;name: &quot;allan&quot;, age: &quot;20&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象转 Map</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;allen&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;20&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    map.<span class="title function_">set</span>(key, obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">swap</span>(person);</span><br></pre></td></tr></table></figure>

<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap 与 Map 一样可以生成键值对的集合，但是也有不同的地方，主要是有以下的两点：</p>
<ul>
<li>WeakMap 只接受对象作为键名（不包括 null）</li>
<li>ct</li>
</ul>
<p>与 WeakSet 相似，WeakMap 也是没有遍历的操作，也没有 size 属性，没有办法列出所有键名（由于垃圾回收机制的运行），也不能清空。</p>
<h3 id="实例方法-2"><a href="#实例方法-2" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>get():</li>
<li>set():</li>
<li>delete(): 删除 WeakMap 的成员</li>
<li>has(): 判断 WeakMap 是否包含某个元素</li>
</ul>
<h1 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h1><p>将类数组对象转化为数组.<br>第二个参数可以对传入值进行处理.</p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>方式有立即执行函数,AMD,CMD,CommonJS,ES6 模块化.<br>其中最常用的是 CommonJS 和 ES6 模块化</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>CommonJS 即使用<code>require()</code>,<code>module.exports</code>,通常在 Node 中使用.支持动态导入.属于同步导入.</li>
<li>ES6 模块化即使用<code>import</code>,<code>export default</code>.通常用于浏览器,属于异步导入.</li>
<li>CommonJS 在导出时是值拷贝,就算导出的值变了,导入的也不会变.如果想更新,必须重新导入.ES6 模块化采用实时绑定,导出导入都指向同一个地址,所以导入变化导出也会变化.</li>
<li>ES6 模块会编译成<code>require/exports</code>来执行.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 加载模块完毕可以使用</span></span><br><span class="line">  a.<span class="title function_">do</span>();</span><br><span class="line">  b.<span class="title function_">do</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 加载模块</span></span><br><span class="line">  <span class="comment">// 可以把 require 写在函数体的任意地方实现延迟加载</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&quot;./a.js&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">a</span>; <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&quot;./a.js&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">a</span>;</span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span></span><br><span class="line"><span class="comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// module 基本实现</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&quot;xxxx&quot;</span>, <span class="comment">// 我总得知道怎么去找到他吧</span></span><br><span class="line">  <span class="attr">exports</span>: &#123;&#125;, <span class="comment">// exports 就是个空对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span> = <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line"><span class="keyword">var</span> load = <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 导出的东西</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = a;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 然后当我 require 的时候去找到独特的</span></span><br><span class="line"><span class="comment">// id，然后将要使用的东西用立即执行函数包装下，over</span></span><br></pre></td></tr></table></figure>

<p>另外虽然 exports 和 module.exports 用法相似，但是不能对 exports 直接赋值。因为 var exports &#x3D; module.exports 这句代码表明了 exports 和 module.exports 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 exports 赋值就会导致两者不再指向同一个内存地址，修改并不会对 module.exports 起效。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ol>
<li>箭头函数继承而来的 this 指向永远不变.</li>
</ol>
<p>使用<code>call,apply,bind</code>都无法改变箭头函数 this 指向.</p>
<ol start="2">
<li>箭头函数不能作为构造函数使用.因为它没有自己的 this</li>
<li>箭头函数没有自己的<code>arguments</code>对象.</li>
</ol>
<p>在箭头函数中访问 arguments 实际上获得的是外层局部（函数）执行环境中的值.<br>如果想访问箭头函数中的参数,可以使用<code>rest</code>参数.</p>
<ol start="4">
<li>箭头函数没有原型<code>prototype</code></li>
<li>箭头函数不能用作<code>Generator</code>函数，不能使用 yeild 关键字</li>
</ol>
<h1 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h1><p>ES6 的类，完全可以看作构造函数的另一种写法。<br>类的数据类型就是函数，类本身就指向构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Point</span>; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="title class_">Point</span> === <span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>类的所有方法都定义在类的 prototype 属性上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">toValue</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="constructor-关键字"><a href="#constructor-关键字" class="headerlink" title="constructor 关键字"></a>constructor 关键字</h2><p><code>constructor()</code>方法就是构造方法，而<code>this</code>关键字则代表实例对象。<br><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code> </code>constructor()<code>方法，如果没有显式定义，一个空的</code>constructor()&#96;方法会被默认添加。</p>
<h2 id="extends-关键字"><a href="#extends-关键字" class="headerlink" title="extends 关键字"></a>extends 关键字</h2><p>作用:类继承<br>底层原理: 替换原型继承(不会覆盖子构造函数的原型)<br>extends 关键字替换原型的原型:<code>s1.__proto__.__proto__ = Person.prototype</code></p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>用于调用父类的方法.<br>子类中如果想使用<code>constructor</code>,必须使用<code>super</code>关键字调用父类的方法.<br><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用</p>
<blockquote>
<p>在子类的构造函数中，只有调用 super()之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有 super()方法才能让子类实例继承父类。<br>如果子类没有定义 constructor()方法，这个方法会默认添加，并且里面会调用 super()。也就是说，不管有没有显式定义，任何一个子类都有 constructor()方法。</p>
</blockquote>
<h3 id="当做函数"><a href="#当做函数" class="headerlink" title="当做函数"></a>当做函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B 的实例，因此 super()在这里相当于 A.prototype.constructor.call(this)。</p>
</blockquote>
<h3 id="当做对象"><a href="#当做对象" class="headerlink" title="当做对象"></a>当做对象</h3><p><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">p</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">p</span>()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类 B 当中的 super.p()，就是将 super 当作一个对象使用。这时，super 在普通方法之中，指向 A.prototype，所以 super.p()就相当于 A.prototype.p()。</p>
<blockquote>
<p>注意，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// private 私有,仅在类内使用</span></span><br><span class="line">  private <span class="attr">name</span>:string = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">  <span class="comment">// public 公共,内外都可以使用</span></span><br><span class="line">  public <span class="attr">age</span>: number = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// protected 可在类内和继承的子类中调用</span></span><br><span class="line">  protected <span class="attr">sex</span>: string;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Name&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//constructor中的会在new一个实例时调用,接收传入的参数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;dell&#x27;</span>);<span class="comment">//此时调用constructor中的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">getTeacherName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;teacher&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//super关键字表示父类</span></span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getName</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age: number</span>)&#123;</span><br><span class="line">    <span class="comment">//子类中的constructor要想使用,需要调用父类的constructor</span></span><br><span class="line">    <span class="comment">//super()就表示父类的constructor</span></span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&#x27;dell&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="number">123</span>);<span class="comment">//此时调用constructor中的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 子类继承了父类,并且super()传入&#x27;dell&#x27;,则打印dell</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">// 子类继承了父类,虽然传参123,</span></span><br><span class="line"><span class="comment">// 但是子类的构造函数内没有对应的this赋值给age,则继承父类的age,父类的原型对象上age是10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类中的-getter-和-setter"><a href="#类中的-getter-和-setter" class="headerlink" title="类中的 getter 和 setter"></a>类中的 getter 和 setter</h2><p>私有属性无法在外部调用,可以利用<code>getter</code>间接调用私有属性.使用<code>setter</code>间接设置私有属性.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> _name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dell&quot;</span>);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;dell&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static表示挂载在类上,而不是类的实例上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">instance</span>: <span class="title class_">Demo</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> demo1 = <span class="title class_">Demo</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"><span class="keyword">const</span> demo2 = <span class="title class_">Demo</span>.<span class="title function_">getInstance</span>();</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用abstract 关键字抽象类,将公共方法属性抽离出来</span></span><br><span class="line">abstruct <span class="keyword">class</span> <span class="title class_">Geom</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">getType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Geom&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里写abstract的话,子类中必须声明此方法</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">getArea</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Geom</span> &#123;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。<br>Proxy 内置一系列陷阱,用于创建一个对象的代理,从而实现基本操作的拦截和自定义.</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">简单来说, 通过Proxy创建对于原始对象的代理对象,从而在代理对象中使用Reflect达到对JS操作的拦截.</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>
target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;劫持的对象名&#x27;</span>, target)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;劫持的属性名&#x27;</span>, key)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;Tom&quot;</span></span><br></pre></td></tr></table></figure>
上面就是通过Proxy创建了一个代理对象,同时在Proxy内部声明了一个get陷阱.
当我们访问`proxy.name`时实际触发了对应的get陷阱.执行陷阱中的逻辑.
`target`就是劫持的源对象`obj`,
`key`就是劫持的获取的name值,注意getter函数取值时才会触发.
`receiver`表示代理的对象proxy或者继承Proxy的对象.也就是谁调用了函数,就是指的谁.
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key);</span><br><span class="line"><span class="comment">// 这里相当于 return target[key]</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(parent, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 obj 继承与 parent 的代理对象 proxy</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proxy);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">value</span>); <span class="comment">// parent</span></span><br><span class="line"><span class="comment">// 这里因为返回的是源对象的 value,所以是父级的,想要是继承的,需要加上 receiver</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line"><span class="comment">// 这里相当于 return target[key].call(receiver)</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">- <span class="title class_">Proxy</span>中接受的<span class="title class_">Receiver</span>形参表示代理对象本身或者继承自代理对象的对象</span><br><span class="line">- <span class="title class_">Reflect</span>中传递的<span class="title class_">Receiver</span>实参表示修改执行原始操作时的<span class="variable language_">this</span>指向.(实际上就是指向调用者).</span><br><span class="line"></span><br><span class="line">接下来我们通过 <span class="title class_">Proxy</span> 来实现一个数据响应式</span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">let onWatch = (obj, setBind, getLogger) =&gt; &#123;</span></span><br><span class="line"><span class="string">  let handler = &#123;</span></span><br><span class="line"><span class="string">    get(target, property, receiver) &#123;</span></span><br><span class="line"><span class="string">      getLogger(target, property)</span></span><br><span class="line"><span class="string">      return Reflect.get(target, property, receiver)</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    set(target, property, value, receiver) &#123;</span></span><br><span class="line"><span class="string">      setBind(value, property)</span></span><br><span class="line"><span class="string">      return Reflect.set(target, property, value, receiver)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return new Proxy(obj, handler)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let obj = &#123; a: 1 &#125;</span></span><br><span class="line"><span class="string">let p = onWatch(</span></span><br><span class="line"><span class="string">  obj,</span></span><br><span class="line"><span class="string">  (v, property) =&gt; &#123;</span></span><br><span class="line"><span class="string">    console.log(`</span>监听到属性$&#123;property&#125;改变为$&#123;v&#125;<span class="string">`)</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  (target, property) =&gt; &#123;</span></span><br><span class="line"><span class="string">    console.log(`</span><span class="string">&#x27;$&#123;property&#125;&#x27;</span> = $&#123;target[property]&#125;<span class="string">`)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">p.a = 2 // 监听到属性a改变</span></span><br><span class="line"><span class="string">p.a // &#x27;a&#x27; = 2</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在上述代码中，我们通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Reflect</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reflect 提供拦截 JS 操作的方法.并非一个构造函数,不能用 new 进行调用.</span></span><br><span class="line"><span class="string">它的所有方法和属性都是静态的.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line"><span class="comment">// 也就是Reflect将get操作转发给target,获取key的值,相当于target[key]</span></span><br></pre></td></tr></table></figure>

<p>虽然也可以直接使用<code>target[key]</code>,但是 Reflect 可以用 receiver,更强大.</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现功能</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">array[-<span class="number">1</span>]; <span class="comment">// 3，最后一个元素</span></span><br><span class="line">array[-<span class="number">2</span>]; <span class="comment">// 2，从末尾开始向前移动一步</span></span><br><span class="line">array[-<span class="number">3</span>]; <span class="comment">// 1，从末尾开始向前移动两步</span></span><br><span class="line"></span><br><span class="line">array = <span class="keyword">new</span> <span class="title class_">Proxy</span>(array, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// key 是字符串</span></span><br><span class="line">    key = <span class="title class_">Number</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Number</span>(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      key = key + target.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="深层遍历"><a href="#深层遍历" class="headerlink" title="深层遍历"></a>深层遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target.<span class="property">key</span>)</span><br><span class="line">    retrun <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? <span class="keyword">new</span> <span class="title class_">Proxy</span>(res,handler) : res</span><br><span class="line">  &#125;,</span><br><span class="line">	<span class="title function_">set</span>(<span class="params">target, key, val</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 即生成器,它会返回一个迭代器.Generator 最大的特点就是可以控制函数的执行。可以作为异步解决方案.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">12</span>)); <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">13</span>)); <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>Generator 函数需要手动调用<code>next</code>执行,在遇到<code>yield</code>会暂停,返回一个对象,包括执行结果和是否执行完毕.继续调用<code>next</code>会从之前暂停的地方开始,如果传入参数,会覆盖之前的结果.到下一个<code>yield</code>结束.<br>分析上面的代码:</p>
<ul>
<li>第一次执行<code>next</code>,参数是 5,遇到<code>yield</code>暂停,返回值为 5+1 &#x3D;&gt; 6.</li>
<li>第二次执行<code>next</code>,<code>next</code>有参数 12, 覆盖上一次<code>yield</code>处的值,就是<code>y = 2*12</code>,要在这一次的<code>yield</code>处暂停就要 24&#x2F;3,得到 8</li>
<li>最后一次执行<code>next</code>,z 就被赋值为 13,结合第二次 y 是 24,第一次 x 是 5,最后返回 5+13+24&#x3D;42.</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 是异步问题同步化解决方案.<br>Promise 本身不是异步,它是个构造函数.<br>Promise 中的函数是同步的.<br>Promise 有一个参数,即<code>excutor</code>执行器,它有两个参数,<code>resolve</code>和<code>reject</code>.<br><code>excutor</code>是同步执行,而<code>then</code>是异步调用的.<br>如果想连续<code>then</code>需要上一个<code>promise</code>中 return 一个新的<code>promise</code>.<br>Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止.</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>promise 内部在<code>resolve</code>之前的代码处于<code>pending</code>状态,之后的是<code>fulfilled</code>.<br>promise 在<code>catch</code>中如果没有抛出错误,则会返回<code>fufilled</code></p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>状态固化后,就不再捕获错误了.比如 resolve()返回后面有报错的内容,但是 catch 就不再捕获了.<br>案例:<br>当 promise 作为参数传递到另一个 promise 中,这个第二个 promise 中的状态就会失效.依赖于第一个 promise.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">resolve</span>(p1)&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>

<p>Promise.all()如果三个内容都失败,只返回第一个失败的信息.如果只有一个出错,也只会返回一个.而且不返回正常的.<br>Promise.race()是谁先完成返回谁,无论是成功还是失败.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">300</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">    &#125; <span class="comment">// &#x27;Error&#x27;</span></span><br><span class="line">    <span class="comment">// 默认return 的是undefined</span></span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="comment">//上一次调用只有失败的状态,而那里默认返回的是undefined,</span></span><br><span class="line">    <span class="comment">//这里在onFulfilled的这里捕获的是上一次失败的默认return的undefined</span></span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;, <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then中throw new Error()的情况</span></span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="comment">// 上面抛出的是error,所以要走onRejectd,也就是第二个函数</span></span><br><span class="line">	<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;,</span><br><span class="line">  <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(reason)&#125; <span class="comment">// &#x27;Error&#x27;</span></span><br><span class="line">  )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>其实它也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。</p>
<h2 id="如何中断-promise"><a href="#如何中断-promise" class="headerlink" title="如何中断 promise"></a>如何中断 promise</h2><p>插入一个 pending 状态的 promise.</p>
<h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>catch 在 promise 的源码层面就是一个 then,如果 catch 中 return 的有值,可以在 catch 后跟 then.<br>既有 then 中的失败回调,又有 catch 的情况,会走最近的那个.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 输出1,2,3</span></span><br><span class="line"><span class="comment">// catch后没有抛出错,则返回的是resolved状态,可以继续then</span></span><br></pre></td></tr></table></figure>

<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><h3 id="使用-promise-加载图片"><a href="#使用-promise-加载图片" class="headerlink" title="使用 promise 加载图片"></a>使用 promise 加载图片</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadIMg</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;加载失败&quot;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">src</span> = src;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> url1 =</span><br><span class="line">  <span class="string">&quot;https://i1.hdslb.com/bfs/face/f4d60f852eb1a85696447838c90a94acad31b7ae.jpg@160w_160h_1c_1s.webp&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> url2 =</span><br><span class="line">  <span class="string">&quot;https://i0.hdslb.com/bfs/face/a8ef30d6688d0b532bd20baa160417deae8f386d.jpg@240w_240h_1c_1s.webp&quot;</span>;</span><br><span class="line"><span class="comment">// 连续加载图片</span></span><br><span class="line"><span class="title function_">loadImg</span>(url1)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">img</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(img);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">loadImg</span>(url2);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">img2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(img2);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>Promise.resolve()<br>Promise.reject()</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>如果所有都正确执行,会按顺序返回.有一个失败,就失败.</p>
<h1 id="Async-x2F-await"><a href="#Async-x2F-await" class="headerlink" title="Async&#x2F;await"></a>Async&#x2F;await</h1><p>一个函数前加了<code>async</code>,它就会返回 Promise.它的返回值会被<code>Promise.resolve()</code>包裹.</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">await只能配套async使用</div>

<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。<br>如果代码没有依赖性的话，完全可以使用 Promise.all 的方式</p>
<h2 id="async-x2F-await-和-promise-的关系"><a href="#async-x2F-await-和-promise-的关系" class="headerlink" title="async&#x2F;await 和 promise 的关系"></a>async&#x2F;await 和 promise 的关系</h2><p>await 是等待 promise 的返回,await 做不了 promise 返回状态的工作.<br>await 对应<code>Promise.then</code>成功的情况.<br>await 后如果是函数,则会把函数返回的结果用<code>Promise.then()</code>返回.<br>async 中的<code>Promise.reject()</code>需要使用<code>try/catch</code>进行捕获错误.<br>async 中的函数内部属于同步代码,在遇到 await 之前都可以先执行.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">b</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  a = a + (<span class="keyword">await</span> <span class="number">10</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>, a); <span class="comment">// -&gt; &#x27;2&#x27; 10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">b</span>();</span><br><span class="line">a++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>, a); <span class="comment">// -&gt; &#x27;1&#x27; 1</span></span><br><span class="line"><span class="comment">// 先得到&#x27;1&#x27; 1, 后得到&#x27;2&#x27; 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 <code>generator</code> ，<code>generator</code> 会保留堆栈中东西，所以这时候 a &#x3D; 0 被保存了下来</li>
<li>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 <code>Promise.reslove(返回值)</code>，然后会去执行函数外的同步代码</li>
<li>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a &#x3D; 0 + 10</li>
</ul>
<p>上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/18/%E9%9D%A2%E8%AF%95%E5%90%8E%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/18/%E9%9D%A2%E8%AF%95%E5%90%8E%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">面试后总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-18 17:52:39" itemprop="dateCreated datePublished" datetime="2021-04-18T17:52:39+08:00">2021-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:28" itemprop="dateModified" datetime="2023-05-13T09:03:28+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="365-面试"><a href="#365-面试" class="headerlink" title="365 面试"></a>365 面试</h1><ol>
<li>什么是闭包?带来的问题?如何解决?</li>
</ol>
<p>能读取其他函数内部变量的函数.<br>内存泄漏<br>let fn() &#x3D; null</p>
<ol start="2">
<li>JS 的基本类型和引用类型.</li>
</ol>
<p>基本类型: String,number,Boolean,undefined,null,symbol.<br>引用类型: Object.(又可以分为对象,数组,函数,正则)</p>
<ol start="3">
<li>let a &#x3D; {name:123}, let b&#x3D; a, b.name &#x3D; 456,console.log(a.name)?</li>
</ol>
<p>b.age &#x3D; 13.console.log(a.age)?<br>输出 456 和 13.<br>原因: 对象是引用类型,将值保存在堆内存中.对象的值只是将指针指向堆内存中的数据.<br>当堆内存中数据改变,自然指向的值也会改变.</p>
<ol start="4">
<li>let a &#x3D; 123.let b&#x3D;a.b&#x3D;456,console.log(a)?</li>
</ol>
<p>输出 123.</p>
<ol start="5">
<li>innerHTML 和 innerText 的区别?</li>
</ol>
<p>innerHTML 设置或获取元素 html 结构,再写入是会自动构建 DOM.<br>innerText 设置或获取元素内包含的文字内容.</p>
<ol start="6">
<li>创建 DOM 节点的方式?</li>
</ol>
<p>doument.createElement()<br>document.write()<br>document.innerHTML()</p>
<ol start="7">
<li>JS 改变 this 指向的方法.区别</li>
</ol>
<p>bind,apply.call<br>区别: bind 改变 this 指向,返回一个新函数.将函数内部的 this 设置为传入的第一个参数.并不立即执行.<br>call.apply 会调用函数,传入上下文和其参数,并立即执行.在写法上有区别.<br>call 只接受两个参数,一个 this 指向的对象,另一个是数组或者类数组.<br>apply 除了第一个对象外,可以接收多个参数.</p>
<ol start="8">
<li></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&#x27;btn&#x27;</span> type=<span class="string">&#x27;button&#x27;</span> value=<span class="string">&#x27;123&#x27;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> value = <span class="string">&#x27;456&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>) <span class="comment">//打印123</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>new 一个对象经历那些过程?</p>
</li>
<li><p>创建新对象. 2.将新对象的原型绑定到构造函数的原型上. 3.将构造函数的作用域赋值给新对象(因此 this 指向了这个对象). 4.执行构造函数中的代码(为新对象添加属性) 5.返回新对象.</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newFunc</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  o.<span class="property">__proto__</span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(o, name);</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个<code>new</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Con</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>map 和 for 循环的区别</li>
</ol>
<p>map:对传入数组进行处理,返回一个新数组,原数组不做改变.<br>for:遍历数组的方法.</p>
<ol start="11">
<li>Vue 中 created 和 mounted 有什么区别?请求数据在那个生命周期?</li>
</ol>
<p>页面已经创建还未挂载到 DOM 节点上.<br>mounted 属于已经挂载到 DOM 上.<br>初始化数据一般放在 created(),如果需要改变 DOM 放在 mounted()</p>
<h2 id="小明面试题"><a href="#小明面试题" class="headerlink" title="小明面试题"></a>小明面试题</h2><ol>
<li>判断类型的几种方法.</li>
</ol>
<p>instanceof<br>typeof<br>constructor<br>toString(obj 类型直接使用 toSting,而其他类型需要 call&#x3D;&gt;Object.prototype.toString.call(12) &#x2F;&#x2F;[object Number]</p>
<ol start="2">
<li>原生 JS 怎么获取一个元素的宽度.</li>
</ol>
<p>document.getElementById(‘div’).offsetWidth</p>
<ol start="3">
<li>遍历数组和对象的几种方法</li>
</ol>
<p>map,forEach,for,for..in,for…of</p>
<ol start="4">
<li>权限鉴定</li>
<li>vue 中兄弟组件传值</li>
</ol>
<p>定义一个 bus 中介,使用 eventBus,将值传给 bus,再从 bus 中传给兄弟</p>
<ol start="6">
<li>实现一个方法判断入参是否为 JSON</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> str == <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(str).<span class="title function_">toLowerCase</span>() == <span class="string">&quot;[object Object]&quot;</span> &amp;&amp;</span><br><span class="line">  !str.<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>常见的伪数组有那些?怎么转化为真数组</li>
</ol>
<p>无法调用数组的全部方法,但是仍可以用遍历.<br>特点: 按索引方式存储数据,具有 length 属性,没有数组的 push,shift,pop 等方法.<br>常见: function 的 arguments 对象,getELementsByTagName 等 NodeList 对象.<br>转化方法:<br>使用<code>Array.prototype.slice.call()</code><br>使用<code>Array.from()</code><br>使用<code>[].slice.call()</code></p>
<ol start="8">
<li>如何在 node 工程中添加自定义指令和环境变量</li>
</ol>
<p>npm script 编辑<br>开发环境:env_develop<br>生成环境:env_production</p>
<ol start="9">
<li>封装 http 请求以及 restful 的了解</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="keyword">function</span>(<span class="params">...options</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type,</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(resolve,reject)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">	<span class="title function_">reject</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RESTful:</p>
<ol>
<li>使用 HTTP 动词表示增删改查(CRUD)资源， GET：查询，POST：新增，PUT：更新，DELETE：删除</li>
<li>URL 设计.URL 里使用名词而不是动词.名词最好是复数形式.减少层级,除了第一级,其他使用字符串表示.</li>
<li>状态码.状态码必须精确</li>
<li>服务器响应. 不要返回纯文本.应该返回 JSON 对象.</li>
<li>多个 promise 如何处理?保持顺序如何处理</li>
</ol>
<p>Promise.all()<br>Promise.race()<br>async&#x2F;await</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用reduce</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">arr, value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">then</span>(b), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// promise function 1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p1</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(a * <span class="number">5</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// promise function 2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p2</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(a * <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 3  - will be wrapped in a resolved promise by .then()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise function 4</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p4</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(a * <span class="number">4</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseArr = [p1, p2, f3, p4];</span><br><span class="line"><span class="title function_">run</span>(promiseArr, <span class="number">10</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>函数 1 调用函数 2,如果想在函数 2 里终止函数 1,如何操作?</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">b</span>();</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (b = <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>用闭包实现 localStorage</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">configCache</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> _cache = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">getCache</span>(<span class="params">k</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> _cache[k]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">setCache</span>(<span class="params">k, v</span>)&#123;</span><br><span class="line">      _cache[k] = v</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">removeCache</span>(<span class="params">k</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> _cache[k];</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="13">
<li>用 setTimeout 实现 setInterval</li>
</ol>
<p>setTimeout 只执行一次.<br>setinterval 是定时执行多次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">interval</span>(<span class="params">fn, ms</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">set</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(set, ms);</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">setTimeout</span>(set, ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>写一个函数拍平.禁止用 float</li>
</ol>
<p>遍历传入数组,如果某一元素是数组,那就取出,放入原数组.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> each = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">        <span class="title function_">each</span>(item);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">each</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">6</span>, [<span class="number">5</span>, <span class="number">7</span>]], <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flat</span>(a));</span><br><span class="line"><span class="comment">//使用reduce</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(b) ? [...a, ...<span class="title function_">flat</span>(b)] : [...a, b];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">6</span>, [<span class="number">5</span>, <span class="number">7</span>]], <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flat</span>(arr)); <span class="comment">// [1, 2, 3, 6, [5, 7], 4],</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转化字符串toString</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">    .<span class="title function_">toString</span>()</span><br><span class="line">    .<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> +item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">6</span>, [<span class="number">5</span>, <span class="number">7</span>]], <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flat</span>(arr));</span><br></pre></td></tr></table></figure>

<h2 id="小明机选题"><a href="#小明机选题" class="headerlink" title="小明机选题"></a>小明机选题</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/25/Vuex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/25/Vuex/" class="post-title-link" itemprop="url">Vuex</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-25 15:31:43" itemprop="dateCreated datePublished" datetime="2021-03-25T15:31:43+08:00">2021-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:28" itemprop="dateModified" datetime="2023-05-13T09:03:28+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="五大件"><a href="#五大件" class="headerlink" title="五大件"></a>五大件</h2><p>state,actions,mutations,getter,modules</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>state: 主要存放用户数据<br>mutations: set 用户数据(同步形式)<br>actions: 主要是异步操作,通过 <code>commit</code>  触发 mutations 中的操作改变 state<br>getters: change 用户数据(经常性的)<br>modules: 将近似的操作抽离放到一个模块里,防止 store 过于臃肿.</p>
<h2 id="Vuex-中-action-的-commit-的理解"><a href="#Vuex-中-action-的-commit-的理解" class="headerlink" title="Vuex 中 action 的{commit}的理解"></a>Vuex 中 action 的{commit}的理解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//解构赋值</span></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">	<span class="title function_">increment</span>(<span class="params">&#123;commit&#125;</span>)&#123;</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>context 是默认参数,将 <code>&#123;commit&#125;</code>  从 context 中解构出来.<br><code>let &#123; commit &#125; = context</code> <br>那么 <code>commit</code>  就是 <code>context</code>  对象中的一个参数,直接赋值调用即可.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options 上的属性表示附加参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, options</span>) &#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> secure = options.<span class="property">secure</span>,</span><br><span class="line">    path = options.<span class="property">path</span>,</span><br><span class="line">    domain = options.<span class="property">domain</span>,</span><br><span class="line">    expires = options.<span class="property">expires</span>;</span><br><span class="line">  <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以改写为：对options进行解构并赋予默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 options 默认有 <code>&#123; secure, path, domain, expires &#125;</code>  参数,<br>而 <code>options</code>  默认可能空,设置它的默认值为 <code>&#123;&#125;</code> .</p>
<h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><p>state 中的数据不能在组件中赋值,必须使用 mutation 改变.</p>
<h3 id="获取-state"><a href="#获取-state" class="headerlink" title="获取 state"></a>获取 state</h3><ol>
<li>通过属性访问</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;@/store/index.js&quot;</span>; <span class="comment">//需要引入store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">username</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> store.<span class="property">state</span>.<span class="property">username</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 <code>this.$store.state</code>  访问.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">username</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">username</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27; ... computed: mapState(&#123; username: state =&gt;</span><br><span class="line">state.name, age: state =&gt; state.age &#125;) //mapState字符串数组 computed:</span><br><span class="line">mapState([&#x27;username&#x27;,&#x27;age&#x27;]) //当要获取组件自己的data数据时,必须使用常规函数</span><br><span class="line">computed: &#123; ...mapState(&#123; username: function(state)&#123; return this.firstName + &#x27; &#x27;</span><br><span class="line">+ state.username &#125;, age: state =&gt; state.age &#125;) &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>可以执行同步和异步.,通过 <code>commit</code> 触发 mutations 中的操作改变 state</p>
<h2 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h2><ol>
<li>通过 <code>dispatch</code>  分发.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;view&gt;&#123;&#123; count &#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;button @click=&quot;add&quot;&gt;click add&lt;/button&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import store from &quot;@/store/index.js&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return this.$store.state.count;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      store.dispatch(&quot;addCountAction&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><ol start="2">
<li>通过 <code>mapActions</code>  分发.</li>
</ol>
<p>使用 <code>mapActions</code>  辅助函数将组件的 <code>methods</code>  映射为 <code>store.dispatch</code>  调用(需要现在根节点注入 <code>store</code> )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;view&gt;&#123;&#123; count &#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;button @click=&quot;addCount&quot;&gt;click add&lt;/button&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapAction &#125; from &#x27;vuex&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([&#x27;addCountAction&#x27;])</span><br><span class="line">      //将this.addCountAction映射为this.$store.dispatch(&#x27;addCountAction&#x27;)</span><br><span class="line"></span><br><span class="line">      //传入参数</span><br><span class="line">      //将this.addCountAction(amount)映射为this.$store.dispatch(&#x27;addCountAction&#x27;,amount)</span><br><span class="line"></span><br><span class="line">      //传入对象</span><br><span class="line">      ...mapActions(&#123;</span><br><span class="line">        addCount: &#x27;addCountActions&#x27;</span><br><span class="line">        //将this.addCount()映射为this.$store.dispatch(&#x27;addCountAction&#x27;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>组合 Action</li>
</ol>
<p><code>store.dispatch</code>  可以处理被触发 <code>action</code>  的处理函数返回的 <code>Promise</code> ,并且仍返回 <code>Promise</code> .</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在另一个action中</span></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">	<span class="title function_">actionB</span>(<span class="params">&#123; commit, state&#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">			<span class="title function_">commit</span>(<span class="string">&#x27;someMutation&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用async/await</span></span><br><span class="line">  <span class="comment">//假设getData()和getOtherData()返回Promise</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">actionA</span>(<span class="params">&#123;commit, state&#125;</span>)&#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;gotData&#x27;</span>, <span class="keyword">await</span> <span class="title function_">getData</span>())</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">actionB</span>(<span class="params">&#123;commit, state&#125;</span>)&#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">//等待actionA完成</span></span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;gotOtherData&#x27;</span>, <span class="keyword">await</span> <span class="title function_">getOtherData</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个 <code>store.dispatch</code>  在不同模块中可以触发多个 <code>action</code>  函数.在这种情况下,只有当所有触发函数完成后,返回的 Promise 才会执行.</p>
</blockquote>
<p>因为 action 是包含 promise 的,所以在组件中也可以使用 <code>then</code> .</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="variable language_">this</span>.<span class="property">userInfo</span>.<span class="property">username</span>,</span><br><span class="line">  <span class="attr">date</span>: <span class="keyword">new</span> <span class="title function_">dateFormat</span>().<span class="title function_">toString</span>(<span class="string">&quot;date&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">getLogList</span>(payload).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">buildLog</span>());</span><br></pre></td></tr></table></figure>

<h1 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h1><p>getters 是 store 中的计算属性.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">list</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;商品一&quot;</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;商品二&quot;</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;商品三&quot;</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;商品四&quot;</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;商品五&quot;</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>将上面数组筛选出 status 为 true 的对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// vuex中 getters: &#123; activeList(state) &#123; return state.list.filter(v=&gt;v.status) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面中获取的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt; &#123;&#123; $store.getters.activeList&#125;&#125; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//第二种写法 computed()&#123; list()&#123; return this.$store.getters.activeList &#125; &#125; //</span><br><span class="line">第三种 computed:&#123; ...mapGetters([&#x27;aciveList&#x27;]) &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/Vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/22/Vue/" class="post-title-link" itemprop="url">Vue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-22 20:53:06" itemprop="dateCreated datePublished" datetime="2021-03-22T20:53:06+08:00">2021-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:29" itemprop="dateModified" datetime="2023-05-13T09:03:29+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><blockquote>
<p>只有当实例被创建时就已经存在于 data 中的 property 才是响应式的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">&quot;yck&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">observe</span>(data);</span><br><span class="line"><span class="keyword">let</span> name = data.<span class="property">name</span>; <span class="comment">// -&gt; get value</span></span><br><span class="line">data.<span class="property">name</span> = <span class="string">&quot;yyy&quot;</span>; <span class="comment">// -&gt; change value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(obj, key, obj[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  <span class="title function_">observe</span>(val);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get value&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;change value&quot;</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="Vue2-0"><a href="#Vue2-0" class="headerlink" title="Vue2.0"></a>Vue2.0</h3><p>响应式主要是三个部分,Observer 进行数据劫持,Dep 进行依赖收集发生变化触发观察者,Watcher 生成观察者更新视图,将观察者的实例挂载到 Dep 类中,(Dep.target &#x3D; Watcher 的实例).数据变化,调用回调更新视图.</p>
<ul>
<li>首先,利用<code>Object.defineProperty</code>将传入的对象属性添加 getter,setter.</li>
<li>当数据读取时, 在 getter 中进行依赖收集(Dep),也就是把当前对象的 watcher 实例添加到依赖中,</li>
<li>在 setter 中设置依赖通知,在数据变化的时候,依赖通知会通知所有的 watcher 实例执行更新,比如 watch 和 computed 就执行自定义的方法.</li>
</ul>
<h3 id="Vue3-0"><a href="#Vue3-0" class="headerlink" title="Vue3.0"></a>Vue3.0</h3><p>Vue3 最大的变化时是 Observer 响应式中使用了 Proxy.<br>解决的 Vue2 中:</p>
<ol>
<li>对属性的添加,删除的监测(之前使用$set)</li>
<li>对数组基于下标的修改,.length 修改的监测(数组内部变化,之前重写了数组方法)</li>
<li>对 Map,Set 等的支持</li>
</ol>
<h4 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h4><p>Vue3 通过<code>track</code>收集依赖,通过<code>trigger</code>触发更新.本质上通过<code>weakMap</code>, <code>Map</code>,<code>Set</code>实现.</p>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`(<span class="subst">$&#123;monthLine.label&#125;</span>)`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-model=<span class="string">&#x27;value&#x27;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">:value=<span class="string">&#x27;value&#x27;</span></span><br><span class="line">@input=<span class="string">&#x27;fatherM=&gt;this.fatherM = value&#x27;</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">:fatherM=<span class="string">&#x27;fatherM&#x27;</span></span><br><span class="line">:value.<span class="property">sync</span>=<span class="string">&#x27;fatherM=&gt;this.fatherM = value&#x27;</span></span><br></pre></td></tr></table></figure>

<p>给父组件传值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;useMoney&#x27;</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment">//父组件绑定useMoney事件</span></span><br><span class="line">&lt;<span class="title class_">Father</span> @useMoney=<span class="string">&quot;useMoney&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//父级再出发,向上传递</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.$emit(<span class="string">&#x27;useMoney&#x27;</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment">//直接触发父级上的useMoney事件,不用再写触发事件的methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//封装方法</span></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="title function_">extendEvent</span>(<span class="title class_">Vue</span>)</span><br><span class="line"><span class="comment">//event.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">Vue</span>)&#123;</span><br><span class="line">	<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$eventDispatch</span> = <span class="keyword">function</span>(<span class="params">name, value</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> parent = $parent</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(parent)&#123;</span><br><span class="line">			parent.$emit(name, value)</span><br><span class="line">      parent = parent.<span class="property">$parent</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$eventNotice</span> = <span class="keyword">function</span>(<span class="params">name,value</span>)&#123;</span><br><span class="line">  	<span class="keyword">let</span> <span class="title function_">bc</span> = children =&gt; &#123;</span><br><span class="line">      children.<span class="title function_">map</span>(<span class="function"><span class="params">c</span> =&gt;</span>&#123;</span><br><span class="line">				c.$emit(name, value)</span><br><span class="line">        <span class="keyword">if</span>(c.<span class="property">$children</span>)&#123;</span><br><span class="line">					<span class="title function_">bc</span>(C.<span class="property">$children</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bc</span>(<span class="variable language_">this</span>.<span class="property">$children</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听的顺序"><a href="#监听的顺序" class="headerlink" title="监听的顺序"></a>监听的顺序</h3><p>关于<code>$emit</code>和<code>$on</code>的顺序问题,注意是先开启<code>$on</code>进行监听,然后触发<code>$emit</code>.否则触发的时候,<code>$on</code>并没有执行.也就监听不到.<br>比如使用<code>uni.$emit</code>进行触发时,如果跳转到另一个页面,<code>$on</code>是监听不到的,因为已经先触发了<code>emit</code>.<br>正确使用方法: 比如需要回退,那么先打开监听<code>$on</code>,然后在另一页面触发后,回退到该页面,该页面就已经监听到了.</p>
<h2 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h2><p>子组件通过$emit给父组件传值,附带参数. <code>this.$emit(&#39;change&#39;, data)</code> .<br>传递多个参数可以使用函数,<code>this.$emit(&#39;change&#39;, &#123;data0, data1&#125;)</code>父组件在页面接收时不用写接收参数.<code>@change=&#39;change()&#39;</code>  括号里不用写参数.函数里再写.e</p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>在<code>created</code>中进行 DOM 操作一定要放在<code>Vue.nextTick</code>中</li>
<li>在数据变化后要执行某个操作,而这个操作需要使用随数据改变而改变 DOM 结构时,要放在<code>Vue.nextTick()</code>中.</li>
<li>操作数组中的 ref 时,注意 ref 的 VueComponent 节点渲染也是数组,要取数组的第一个,即后面要加<code>[0]</code>.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">`sub<span class="subst">$&#123;index&#125;</span>`</span>][<span class="number">0</span>].<span class="title function_">init</span>());</span><br></pre></td></tr></table></figure>

<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>Vue2 中无法使用<code>Object.defineproperty</code>给数据添加<code>getter/setter</code>属性,但是这个是 Object 的方法,不能操作数组.就要对数组方法重写.即数据劫持.<br>要重写的是改变数组的方法,一共 7 个.<code>push,pop,shift,unshift,sort,splice,reserve</code>.</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>created: DOM 创建但是未挂载,所以这里访问不了 DOM,一般用作调用 api.Vue3 中的 setup 语法题里也获取不到 DOM.<br>mounted: 页面挂载后,这里就可以拿到 DOM 了.</p>
<h2 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h2><p><code>v-</code>指令后面可以跟一个动态参数,用方括号<code>[]</code>包裹.里面是一个 js 表达式的结果.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bind后的动态参数表达响应式的绑定这个值</span></span><br><span class="line">&lt;a v-<span class="attr">bind</span>:[attr] = <span class="string">&quot;url&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="comment">//v-on后面的参数也就是个动态的事件名</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSometing&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>动态参数预期要一个字符串,异常情况下值为<code>null</code>.这个<code>null</code>会被用于移除绑定.<br>空格和引号在方括号里是无效的.可以用计算属性替代这种写法.<br>这里不要用大写,因为会被浏览器强制转换.</p>
<h2 id="动态-class-与-style"><a href="#动态-class-与-style" class="headerlink" title="动态 class 与 style"></a>动态 class 与 style</h2><p><code>v-bind:class</code>接收一个对象以动态切换 class.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v=<span class="attr">bind</span>:<span class="keyword">class</span>=<span class="string">&quot;&#123;active: idActice, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data : &#123;</span><br><span class="line"> <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">hasError</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性所计算的值不用在<code>data</code>中声明.可以说是在<code>computed</code>中声明的一个参数.利用<code>this</code>中的参数去处理之后得到这个值.处理完要<code>return</code>出去.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="动态-class-和计算属性"><a href="#动态-class-和计算属性" class="headerlink" title="动态 class 和计算属性"></a>动态 class 和计算属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"> <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">error</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	<span class="title function_">classObiect</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    	<span class="attr">active</span>: <span class="variable language_">this</span>.<span class="property">isActive</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">error</span>,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="variable language_">this</span>.<span class="property">error</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">error</span>.<span class="property">type</span> === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">	<span class="attr">activeClass</span>: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  <span class="attr">errorClass</span>: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者三元表达式</span></span><br><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="数组语法加对象语法"><a href="#数组语法加对象语法" class="headerlink" title="数组语法加对象语法"></a>数组语法加对象语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">	<span class="attr">activeColor</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=<span class="string">&quot;[activeColor, baseStyle]&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p><code>v-for</code>第一个参数是 value,第二个可以是键名<code>name</code>,第三个可以是索引<code>index</code>.</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>key 的特殊属性用于虚拟 dom 算法中对比新旧 nodes,辨识 VNodes.<br>如果不使用 key,Vue 会就地复用相同类型元素.可能会造成组件没有重新渲染.<br>使用 key,它会基于 key 的变化重新排列元素顺序,并会移除 key 不存在的元素.<br>下列场景适合使用 key:</p>
<ul>
<li>完整触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;span :key=&quot;text&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>当 text 发生改变时，<span> 总是会被替换而不是被修改，因此会触发过渡。</p>
<h3 id="搭配计算属性"><a href="#搭配计算属性" class="headerlink" title="搭配计算属性"></a>搭配计算属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">&quot;n in evenNumbers&quot;</span>&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">	<span class="attr">numbers</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	<span class="title function_">eventNumbers</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">numbers</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">number</span> =&gt;</span> number %<span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多维数组循环使用方法代替计算属性"><a href="#多维数组循环使用方法代替计算属性" class="headerlink" title="多维数组循环使用方法代替计算属性"></a>多维数组循环使用方法代替计算属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-<span class="keyword">for</span><span class="string">&quot;set in sets&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in event(set)&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">	<span class="attr">sets</span>: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">	<span class="title function_">even</span>(<span class="params">numbers</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">number</span> =&gt;</span> number%<span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="v-for-和-v-if-搭配"><a href="#v-for-和-v-if-搭配" class="headerlink" title="v-for 和 v-if 搭配"></a>v-for 和 v-if 搭配</h3><p>不推荐二者在同一个元素使用,而且<code>v-for</code>优先级比<code>v-if</code>高.<br>但是如果想要部分渲染节点,不符合条件的不渲染可以用 v-if.</p>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a><code>v-on</code></h2><p><code>v-on</code>可以传事件名,接参数,也可以访问原始 DOM 事件.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;greet&quot;</span>&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;alert(msg)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;warn(&#x27;msg&#x27;, $event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h2><p>在自定义事件上的 v-model 可以拆分为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-<span class="attr">bind</span>:value=<span class="string">&quot;search&quot;</span> v-<span class="attr">on</span>:input=<span class="string">&quot;search=$event.target.value&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>在组件上的<code>v-model</code>可以拆分为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">	v-<span class="attr">bind</span>:value=<span class="string">&quot;search&quot;</span></span><br><span class="line">	v-<span class="attr">on</span>:input=<span class="string">&quot;search = $event&quot;</span></span><br><span class="line">&gt;&lt;custom-input&gt;</span><br><span class="line"><span class="comment">//组件代码应为</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">			 <span class="attr">v-on:input</span>=<span class="string">&quot;$emit(&#x27;input&#x27;,$event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="computed-VS-methods-VS-watch"><a href="#computed-VS-methods-VS-watch" class="headerlink" title="computed VS methods VS watch"></a>computed VS methods VS watch</h2><p>点击 button,<code>value</code>改变,watch 监听这个<code>value</code>,变化后在 watch 中导致 watchValue 变化.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;computedValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;computedValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;computedValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;methodsValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;methodsValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;methodsValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;watchValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;watchValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;watchValue&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeValue&quot;</span>&gt;</span>change<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">value</span>: <span class="number">1</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">watchValue</span>:<span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">watch</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">value</span>(<span class="params">val</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;watch&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//刚加载并未执行,因为没有发生变化.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//再次点击change,只打印一次</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//如果要加载就执行,可添加immediate,函数就变成handler</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.<span class="property">watchValue</span> = val + <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">computedValue</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;computedValue&#x27;</span>); <span class="comment">//打印1次,有缓存,不变化不重复计算</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      	    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> + <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">methodsValue</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;methodsValue&#x27;</span>); <span class="comment">//打印3次</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> + <span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">changeValue</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">this</span>.<span class="property">value</span> = <span class="number">2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>这里 watch 的一个特点是，最初绑定的时候是不会执行的，要等到 firstName 改变时才执行监听计算。那我们想要一开始就让他最初绑定的时候就执行改怎么办呢？我们需要修改一下我们的 watch 写法，修改过后的 watch 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">firstName</span>: &#123;</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params">newName, oldName</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">fullName</span> = newName + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法</span></span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意到 handler 了吗，我们给 firstName 绑定了一个 handler 方法，之前我们写的 watch 方法其实默认写的就是这个 handler，Vue.js 会去处理这个逻辑，最终编译出来其实就是这个 handler。<br>而 immediate:true 代表如果在 wacth 里声明了 firstName 之后，就会立即先去执行里面的 handler 方法，如果为 false 就跟我们以前的效果一样，不会在绑定的时候就执行。</p>
<h3 id="箭头函数不能在-watch-中写"><a href="#箭头函数不能在-watch-中写" class="headerlink" title="箭头函数不能在 watch 中写"></a>箭头函数不能在 watch 中写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">studentId</span>: <span class="function">(<span class="params">newData, oldData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">disabled</span> = !newData</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="string">&#x27;this&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">studentId</span>: <span class="keyword">function</span> (<span class="params">newData, oldData</span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">disabled</span> = !newData</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="string">&#x27;this&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数会改变 this 的指向，在 Vue 组件中，最好不要随便使用箭头函数。特别是 watch 以及生命周期中。！文档也有相应的提示<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1653556794259-1cb290b7-f13a-45be-95f5-76a1330b3fae.png#averageHue=%23f0ebe1&clientId=ubfda83d1-df90-4&from=paste&height=237&id=u5b90b9ff&originHeight=237&originWidth=680&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=135477&status=done&style=none&taskId=u162fc147-019b-4f39-a07b-a0727fecdec&title=&width=680" alt="image.png"></p>
<h1 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h1><p>计算属性是根据组件数据派生出新数据.使用方式是设置一个函数,返回计算后的结果.具备缓存性质,如果依赖项不变,是不会重新计算的.<br>监听器 watch 可以监听某个响应式数据的变化并执行副作用.使用方式是传递一个函数,并执行副作用.一般用于请求接口.<br>场景上:<br>计算属性一般是在模板中表达式过于复杂就可以写在计算属性中.<br>监听器是在状态变化后做一些额外的 DOM 操作或者异步请求.</p>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>通过<code>component</code>加<code>is</code>属性.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=<span class="string">&quot;currentTabComponent&quot;</span>&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>

<p><code>currentTabComponent</code>可以是已注册组件的名字或一个组件的选项对象.</p>
<h3 id="is的其他用处"><a href="#is的其他用处" class="headerlink" title="is的其他用处"></a><code>is</code>的其他用处</h3><p>比如在<code>table</code>中,加入自定义组件会失效.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//失效</span></span><br><span class="line">&lt;table&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">blog-post-row</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post-row</span>&gt;</span></span></span><br><span class="line">&lt;/table&gt;</span><br><span class="line"><span class="comment">//生效</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">&quot;blog-post-row&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>另外,如果从以下条件使用模板,不存在限制.<br>字符串(例如: <code>template:&quot;...&quot;</code>)<br>单文件组件(<code>.vue</code>)<br><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></p>
<h2 id="非-prop-的-Attribute"><a href="#非-prop-的-Attribute" class="headerlink" title="非 prop 的 Attribute"></a>非 prop 的 Attribute</h2><p>指传向一个组件,但是该组件并没有相应 prop 定义的 attribute.</p>
<h3 id="禁用-Attribute-继承"><a href="#禁用-Attribute-继承" class="headerlink" title="禁用 Attribute 继承"></a>禁用 Attribute 继承</h3><p>如果不希望组件的根元素继承 attribute,可以设置<code>inheritAttrs: false</code>.<br>禁用继承和<code>$attrs</code>可以手动决定这些<code>attribute</code>会被赋予那个元素.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;label&gt;</span><br><span class="line">    &#123;&#123; label &#125;&#125;</span><br><span class="line">    &lt;input</span><br><span class="line">      v-bind=&quot;$attrs&quot;</span><br><span class="line">      v-bind:value=&quot;value&quot;</span><br><span class="line">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export defalut &#123;</span><br><span class="line">   inheritAttrs: false,</span><br><span class="line">   name: &#x27;base-input&#x27;,</span><br><span class="line">   props:[&#x27;label&#x27;,&#x27;value&#x27;],</span><br><span class="line">   data()&#123;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>inheritAttrs: false</code>选项不会影响<code>style</code>和<code>class</code>的绑定.</p>
</blockquote>
<p>这个模式允许使用基础组件的时候更像是使用原始的 HTML 元素,而不会担心哪个元素是真正的根元素.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-input</span><br><span class="line">  label=<span class="string">&quot;Username:&quot;</span></span><br><span class="line">  v-model=<span class="string">&quot;username&quot;</span></span><br><span class="line">  required</span><br><span class="line">  placeholder=<span class="string">&quot;Enter your name&quot;</span></span><br><span class="line">&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>

<h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h3><p>Vue 提供的一个属性,是个对象.包含了作用在这个组件上的所有监听器.<br>在一个组件的根元素上无法监听到原生事件时可以使用.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;label&gt;</span><br><span class="line">    &#123;&#123; label &#125;&#125;</span><br><span class="line">    &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on=&quot;inputListener&quot; /&gt;</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &#x27;base-input&#x27;,</span><br><span class="line">	inheritAttrs:false,</span><br><span class="line">  props: [&#x27;label&#x27;, &#x27;value&#x27;],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListener()&#123;</span><br><span class="line">      var vm = this</span><br><span class="line">      return Object.assign(&#123;&#125;,this.$listeners,</span><br><span class="line">                           &#123;input: function(event)&#123;</span><br><span class="line">															vm.$emit(&#x27;input&#x27;, event.target.value)</span><br><span class="line">      	 &#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a><code>.sync</code>修饰符</h2><p><code>.sync</code>相当于<code>update:myPropsName</code>的模式.<br>比如更新 title</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;update:title&#x27;, newTitle)</span><br><span class="line"></span><br><span class="line">&lt;text-docunment</span><br><span class="line">	v-bind:title=&quot;doc.title&quot;</span><br><span class="line">	v-on:update:title=&quot;doc.title = $event&quot;</span><br><span class="line">&gt;&lt;/text-document&gt;</span><br><span class="line"></span><br><span class="line">&lt;text-document :title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意带有<code>.sync</code>修饰符的<code>v-bind</code>不能和表达式一起使用(例如<code>v-bind:title.sync=&quot;doc.title + &#39;!&#39;&quot;</code>是无效的).取而代之的是只能使用想要绑定的 property 名,类似<code>v-model</code>.</p>
</blockquote>
<p>多个 prop</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-<span class="variable language_">document</span> v-<span class="attr">bind</span>:sync=<span class="string">&quot;doc&quot;</span>&gt;&lt;/text-<span class="variable language_">document</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的;子模板里的所有内容都是在子作用域中编译的.</p>
</blockquote>
<blockquote>
<p>v-slot 只能添加在<code>&lt;template&gt;</code>上</p>
</blockquote>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>如果想在插槽中访问到子组件的数据,就得用作用域插槽.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//把要访问的数据绑定到slot上 //子组件</span><br><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;slot v-bind:user=&quot;user&quot;&gt;</span><br><span class="line">    &#123;&#123;user.lastName&#125;&#125;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">//上面的user数据绑定到了user上.被称为插槽prop //父级作用域中使用v-slot访问</span><br><span class="line">&lt;current-user&gt;</span><br><span class="line">    &lt;template v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">		&#123;&#123;slotProps.user.firstName&#125;&#125;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>

<h4 id="解构插槽-Prop"><a href="#解构插槽-Prop" class="headerlink" title="解构插槽 Prop"></a>解构插槽 Prop</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//上面示例中,父级的slotProps可以解构</span><br><span class="line">&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123;user.firstName&#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br><span class="line"></span><br><span class="line">//多个prop可以重命名</span><br><span class="line">&lt;current-user v-slot=&quot;&#123; user: person &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123;person.firstName&#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br><span class="line"></span><br><span class="line">//设定初始值</span><br><span class="line">&lt;current-user v-slot=&quot;&#123; user = &#123; firstName: &#x27;Tom&#x27; &#125; &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123;user.firstName&#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态插槽"><a href="#动态插槽" class="headerlink" title="动态插槽"></a>动态插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:[slotName]&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure>

<h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件&amp;异步组件"></a>动态组件&amp;异步组件</h2><h3 id="动态组件上使用-keep-alive"><a href="#动态组件上使用-keep-alive" class="headerlink" title="动态组件上使用 keep-alive"></a>动态组件上使用 keep-alive</h3><p>is 动态切换时会重新渲染,如果不需要重新渲染可以用<code>keep-alive</code>缓存下来.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentTabcomponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>就是异步导入,返回 Promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准写法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;template&quot;</span>, <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(&#123; <span class="attr">template</span>: <span class="string">&quot;&lt;div&gt;I am async!&lt;/div&gt;&quot;</span> &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//require语法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;template&quot;</span>, <span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;./my-component&quot;</span>], resolve);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//import写法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;template&quot;</span>, <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./my-component&quot;</span>));</span><br><span class="line"><span class="comment">//局部注册</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&quot;my-component&quot;</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./my-component&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="加载状态"><a href="#加载状态" class="headerlink" title="加载状态"></a>加载状态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">AsyncComponent</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&quot;./MyComponent.vue&quot;</span>),</span><br><span class="line">  <span class="comment">//异步组件加载时所用的组件</span></span><br><span class="line">  <span class="attr">loading</span>: <span class="title class_">LoadingComponent</span>,</span><br><span class="line">  <span class="comment">//加载失败使用的组件</span></span><br><span class="line">  <span class="attr">error</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line">  <span class="comment">//展示加载时组件的延时时间</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">//超时时间</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h2><p>也就是操作其他组件内部或者手动操作 DOM 的情况.</p>
<h3 id="根实例"><a href="#根实例" class="headerlink" title="根实例"></a>根实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$root</span>.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$root</span>.<span class="property">foo</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="父组件实例"><a href="#父组件实例" class="headerlink" title="父组件实例"></a>父组件实例</h3><p><code>this.$parent.xxx</code></p>
<h3 id="子组件实例或子元素"><a href="#子组件实例或子元素" class="headerlink" title="子组件实例或子元素"></a>子组件实例或子元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-input ref=<span class="string">&quot;usernameInput&quot;</span>&gt;&lt;/base-input&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.$refs访问这个实例</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">usernameInput</span></span><br><span class="line"></span><br><span class="line">&lt;input ref=<span class="string">&quot;input&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过其父级组件定义方法:</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">focus</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">input</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>$refs</code>只会在组件渲染完成之后生效.并且不是响应式的.仅作为一个操作子组件的应急方案.所以应该避免在模板或计算属性中访问<code>$refs</code>.</p>
</blockquote>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>如果层级过多,使用<code>$parents</code>不方便.就要使用依赖注入,即<code>provide</code>和<code>inject</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父级组件中声明一个要给子组件的参数,放到provide中</span></span><br><span class="line"><span class="attr">provide</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getMap</span>: <span class="variable language_">this</span>.<span class="property">getMap</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在后代组件中,使用inject接收</span></span><br><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;getMap&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>可以把依赖注入看做一部分”大范围有效的 prop”.</p>
<h2 id="程序化的事件监听器"><a href="#程序化的事件监听器" class="headerlink" title="程序化的事件监听器"></a>程序化的事件监听器</h2><p><code>$on(eventName, eventHandler)</code>侦听一个事件<br><code>$once(eventName, eventHandler)</code>一次性侦听一个事件<br><code>$off(eventName, eventHandler)</code>停止侦听一个事件<br>用法示例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明周期结束前销毁方法</span></span><br><span class="line"><span class="attr">mounted</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> <span class="title class_">Pikaday</span>(&#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">input</span>,</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    picker.<span class="title function_">destroy</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环利用"><a href="#循环利用" class="headerlink" title="循环利用"></a>循环利用</h2><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件是可以在他们自己的模板中调用自身的.不过只能通过<code>name</code>来做这件事.为了避免无限循环,确保递归调用是条件性的(例如使用一个最终会得到<code>false</code>的<code>v-if</code>.</p>
<h3 id="组件之间的循环引用"><a href="#组件之间的循环引用" class="headerlink" title="组件之间的循环引用"></a>组件之间的循环引用</h3><p>当首先组件 A 依赖组件 B,,然后 B 又依赖 A,如此往复.形成了循环.那么需要做一个点,A 需要 B,但不需要先解析 B.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//tree-folder</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">	&lt;tree-folder-contents : children=&quot;folder.children&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">//tree-folder-content</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;child in children&quot;&gt;</span><br><span class="line">      &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt;</span><br><span class="line">      &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">		&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>处理方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在beforeCreate时注册它</span></span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">components</span>.<span class="property">TreeFolderContents</span> = <span class="built_in">require</span>(<span class="string">&#x27;./tree-folder-contents.vue&#x27;</span>).<span class="property">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在本地注册时,使用异步导入,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">components</span>: &#123;</span><br><span class="line">  <span class="title class_">TreeFolderContents</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./tree-folder-contents.vue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><h3 id="递归合并"><a href="#递归合并" class="headerlink" title="递归合并"></a>递归合并</h3><p>当组件和混入对象含有同名选项时,这些选项将以恰当的方式进行”合并”.<br>数据对象在内部会进行递归合并,并在发生冲突时以组件数据优先.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [mixin],</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;goodbye&quot;</span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$data</span>);</span><br><span class="line">    <span class="comment">//=&gt;&#123; message:&quot;goodbye&#x27;, foo: &#x27;abc&#x27;, bar: &#x27;def&#x27; &#125;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同名钩子函数合并为一个数组,混入对象的钩子在组件自身的钩子之前调用.<br>如果<code>created</code>和<code>mixin</code>中有同名方法,两个生命周期都会执行,执行的方法按照页面的方法执行.<br>值为对象的选项,如<code>methods</code>,<code>components</code>和<code>directives</code>,将被合并为同一个对象.两个对象键名冲突时,取组件对象的键值对.</p>
<h3 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myOption = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">myOption</span>;</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(myOption);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">myOption</span>: <span class="string">&quot;hello!&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>一个指令定义对象可以提供以下钩子函数(均为可选):</p>
<ul>
<li><code>bind</code>:只调用一次,指令第一次绑定到元素时调用.在这里可以进行一次性的初始化设置.</li>
<li><code>inserted</code>被绑定元素插入父节点时调用(仅保证父节点存在,但不一定已被插入文档中)</li>
<li><code>update</code>所在组件的 VNode 更新时调用.但是可能发生在其子 VNode 更新之前.指令的值可能发生了改变,也可能没有.</li>
<li><code>componentUpdated</code>指令所在组件的 VNode 及其子 VNode 全部更新后调用.</li>
<li><code>unbind</code>只调用一次,指令与元素解绑时调用.</li>
</ul>
<h3 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h3><ul>
<li><code>el</code>指令所绑定的元素,可以用来直接操作 DOM</li>
<li><code>binding</code>一个对象.包含以下 property:</li>
</ul>
<ol>
<li><code>name</code>指令名,不包含<code>v-</code>前缀.</li>
<li><code>value</code>指令的绑定值.例如<code>v-my-directive=&quot;1+1&quot;</code>中,绑定值为 2.</li>
<li><code>oldValue</code>指令绑定的前一个值.仅在<code>update</code>和<code>componentUpdated</code>钩子中可用.无论值是否改变都可用</li>
<li><code>expression</code>字符串形式的指令表达式.例如<code>v-my-directive=&quot;1+1&quot;</code>中,表达式为<code>&quot;1+1&quot;</code>.</li>
<li><code>arg</code>传给指令的参数.可选.例如<code>v-my-directive:foo</code>中参数为”foo”.</li>
<li><code>modifiers</code>一个包含修饰符的对象.例如<code>v-my-directive.foo.bar</code>,修饰符对象为<code>&#123; foo: true, bar: true &#125;</code></li>
<li><code>vnode</code>Vue 编译生成的虚拟节点.</li>
<li><code>oldVnode</code>上一个虚拟节点,仅在<code>update</code>和<code>componentUpdated</code>钩子可用.<blockquote>
<p>除了<code>el</code>之外,其他参数都应该是只读的,切勿进行修改.如果需要在钩子之间共享数据,建议通过元素的<code>dataset</code>来进行.</p>
</blockquote>
</li>
</ol>
<h3 id="动态指令参数"><a href="#动态指令参数" class="headerlink" title="动态指令参数"></a>动态指令参数</h3><p>用法示例<br>创建一个自定义指令,用来通过固定布局将元素固定在页面上.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;baseexample&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Scroll down the page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin</span>=<span class="string">&quot;200&quot;</span>&gt;</span>Stick me 200px from the top of the page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;pin&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">bind</span>: <span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&quot;fixed&quot;</span>;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">top</span> = binding.<span class="property">value</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#baseexample&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这会把该元素固定到距顶部 200px 位置.如果需要固定在左侧,可以使用动态参数实现.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example&quot;</span>&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Scroll down inside this section<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin:</span>[<span class="attr">direction</span>]=<span class="string">&quot;200&quot;</span>&gt;</span>I am pinned onto<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-demo=<span class="string">&quot;&#123; color:&#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;demo&#x27;</span>,<span class="keyword">function</span>(<span class="params">el, binding</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(binding.<span class="property">value</span>.<span class="property">color</span>)	<span class="comment">//=&gt; &#x27;white&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(binding.<span class="property">value</span>.<span class="property">text</span>) <span class="comment">//=&gt; &#x27;hello!&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="渲染函数-amp-JSX"><a href="#渲染函数-amp-JSX" class="headerlink" title="渲染函数 &amp; JSX"></a>渲染函数 &amp; JSX</h2><p>通过 render 函数去解决重复而冗长的代码.</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/22/JS%E8%A1%A5%E6%A1%A3/" class="post-title-link" itemprop="url">JS补档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-22 11:31:39" itemprop="dateCreated datePublished" datetime="2021-03-22T11:31:39+08:00">2021-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:29" itemprop="dateModified" datetime="2023-05-13T09:03:29+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var,let,const 区别"></a>var,let,const 区别</h1><p><code>var</code>的作用域是方法作用域,声明之前变量是 undefined.可以重复声明.<br><code>let</code>的作用域是块级作用域.在声明之前使用会报错,禁止重复声明.<br><code>const</code>是常量声明方式,声明变量时必须初始化,后面不再修改该常量的值.(声明时必须赋值)<br><code>const</code> 不是变量的值不能改动,而是变量指向的那个内存地址不能改动.</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>ES2015 前，ES 只有两种作用域，分别是全局作用域和函数作用域；在 ES2015 中新增了一个块级作用域.<br>以前块没有独立的作用域，所以在块中定义的变量，块的外面也可以访问，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br></pre></td></tr></table></figure>

<p>这对于代码是非常不利的、不安全的，有了块级作用域，可以通过新的关键字 let 去声明变量，用法跟传统一样，只是 let 声明的变量只能在声明的代码块中使用，外部无法访问的，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// foo is not defined</span></span><br></pre></td></tr></table></figure>

<h1 id="undefined-和-null-区别"><a href="#undefined-和-null-区别" class="headerlink" title="undefined 和 null 区别"></a>undefined 和 null 区别</h1><p>undefined 是未定义的值,是变量最原始的状态<br>null 是人为声明为空的值.希望表示** 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。** 在内存里的表示就是，栈中的变量没有指向堆中的内存对象</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>我的理解: 函数内部包含存在外部作用域的变量,且调用这个函数就形成闭包.<br>外部调用函数内部的变量<br>单纯有个函数算闭包环境,被调用了,所使用的外部变量也就无法释放了,这才形成闭包.<br>注意闭包的函数是 return 出来的.不 return 也可以产生闭包.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="keyword">return</span> (i += n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> cb = <span class="title function_">main</span>(result);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cb</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cb</span>(<span class="number">3</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="comment">// 形参i存在当前作用域</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    i = i + n;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cb(2)时,先打印10,注意function(n)已经是闭包了,i经过计算变为12,但是没有释放.</span></span><br><span class="line"><span class="comment">// cb(3)时,先打印12, i因为闭包没有释放依旧是12, 再计算后是15.</span></span><br><span class="line"><span class="comment">// result 一直未被修改还是10.</span></span><br></pre></td></tr></table></figure>

<p>位于全局作用域的闭包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      total += i * a;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(total);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tip：这里也形成了闭包。total 被外层引用没有被销毁。</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 6</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>疑问:下面这个算闭包吗,答:不算,把 var 换成 let 就算闭包了.<br>for 循环不是函数，所以 i 是全局作用域中的变量。<br>如果换成 let,其实内部也是闭包的机制，当 onclick 执行是循环早已执行完毕，i 早已销毁，因为闭包的机制我们才能拿到 i 对应的值.也就是说循环的 i 已经完事了,但是块级作用域的 i 还在.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"><span class="comment">//data是数组,数组中存储的是函数,函数中的i其实早已为3,打印出来都是3</span></span><br><span class="line"><span class="comment">//为什么输出3 ？</span></span><br><span class="line"><span class="comment">//因为在执行函数的时候 i 已经完成遍历了,</span></span><br><span class="line"><span class="comment">//data[i]执行后寻找i, 内部没有，向上寻找，这时i 是全局变量, 并且此时的值为3</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 暂时取名 fn</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;; <span class="comment">// i是自由变量，所以这是一个闭包</span></span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"><span class="comment">//在data[0]执行，即fn执行，此时的全局变量 i依旧是 3(但跟fn中的i无关)</span></span><br><span class="line"><span class="comment">//fn内部没有i，向上查找, 找到在for内，匿名函数传进来的i值0，它依旧存在在内存中。</span></span><br><span class="line"><span class="comment">//所以到此不会再向上去到全局作用域中查找。所以此时会打印 0</span></span><br></pre></td></tr></table></figure>

<p>局部变量：在函数中声明，且在函数返回后不会被其他作用域所使用的对象。下面代码中的 local* 都是局部变量。（scopes 是一块堆内存）<br>全局变量 ,在浏览器上为 window ，在 node 里为 global。全局变量会被默认添加到函数作用域链的最底端，也就是上述函数中 [[Scopes]] 中的最后一个，可以看下上面局部变量例子中 Scopes 的最后一个。</p>
<p>var：全局的 var 变量其实仅仅是为 global 对象添加了一条属性。<br>let &#x2F; const：全局的 let&#x2F;const 变量不会修改 window 对象，而是将变量的声明放在了一个特殊的对象下（与 Scope 类似）。<br>被捕获变量就是局部变量的反面：在函数中声明，但在函数返回后仍有未执行作用域（函数或是类）使用到该变量，那么该变量就是被捕获变量。</p>
<h2 id="一般如何产生闭包"><a href="#一般如何产生闭包" class="headerlink" title="一般如何产生闭包"></a>一般如何产生闭包</h2><ul>
<li>返回函数</li>
<li>函数当做参数传递</li>
</ul>
<p>函数科里化是一种闭包.</p>
<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><h2 id="如果是-var-声明-for-循环不是函数，所以-i-是全局作用域中的变量。"><a href="#如果是-var-声明-for-循环不是函数，所以-i-是全局作用域中的变量。" class="headerlink" title="如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。"></a>如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。</h2><p>使用 let 关键字时会产生块级作用域，for 每次循环的大括号都是一个独立的块级作用域，由于后面还要用到 i ,所以这几个块级作用域都不会销毁。<br>elements[0].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 0<br>elements[1].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 1<br>elements[2].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 2<br>elements[3].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> length = element.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  element[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 循环是同步代码,先执行,事件绑定函数是异步代码.后执行.此时 for 执行完毕,i 是最后一个值.</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><blockquote>
<p>for &gt; for-of &gt; forEach &gt; map &gt; for-in</p>
</blockquote>
<ul>
<li><code>for</code> 循环当然是最简单的，因为它没有任何额外的函数调用栈和上下文；</li>
<li><code>for...of</code>只要具有 Iterator 接口的数据结构，都可以使用它迭代成员。它直接读取的是键值。</li>
<li><code>forEach</code>，因为它其实比我们想象得要复杂一些，它实际上是 array.forEach(function(currentValue, index, arr), thisValue)它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</li>
<li><code>map()</code> 最慢，因为它的返回值是一个等长的全新的数组，数组创建和赋值产生的性能开销很大。</li>
<li><code>for...in</code>需要穷举对象的所有属性，包括自定义的添加的属性也能遍历到。且 for…in 的 key 是 String 类型，有转换过程，开销比较大。</li>
</ul>
<p>如果你需要将数组按照某种规则映射为另一个数组，就应该用 map。<br>如果你需要进行简单的遍历，用 forEach 或者 for of。<br>如果你需要对迭代器进行遍历，用 for of。<br>如果你需要过滤出符合条件的项，用 filterr。<br>如果你需要先按照规则映射为新数组，再根据条件过滤，那就用一个 map 加一个 filter</p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>是 ES5 版本发布的。以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性。<br>迭代数组时,<code>for...in</code>是下标,<code>for...of</code>是值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line"><span class="keyword">let</span> profile = &#123;<span class="attr">name</span>:<span class="string">&quot;April&quot;</span>,<span class="attr">nickname</span>:<span class="string">&quot;二十七刻&quot;</span>,<span class="attr">country</span>:<span class="string">&quot;China&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> profile)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = profile[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 对象的键值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 对象的键对应的值</span></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 数组下标所对应的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 索引，数组下标</span></span><br><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> str)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = str[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 字符串下标所对应的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 索引 字符串的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>我是 ES6 版本发布的。在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代数组数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 迭代字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 迭代map</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;a&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">2</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs [&quot;a&quot;, 1]</span></span><br><span class="line"><span class="comment">// logs [&quot;b&quot;, 2]</span></span><br><span class="line"><span class="comment">// logs [&quot;c&quot;, 3]</span></span><br><span class="line"><span class="comment">// 迭代map获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代set</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs 1</span></span><br><span class="line"><span class="comment">// logs 2</span></span><br><span class="line"><span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// logs 4</span></span><br><span class="line"><span class="comment">// 迭代 DOM 节点</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.article &gt; p&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> paragraph <span class="keyword">of</span> articleParagraphs) &#123;</span><br><span class="line">    paragraph.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;paragraph&quot;</span>);</span><br><span class="line">    <span class="comment">// 给class名为“article”节点下的 p 标签添加一个名为“paragraph” class属性。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代arguments类数组对象</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(argument);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// logs：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 迭代类型数组</span></span><br><span class="line"><span class="keyword">let</span> typeArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> typeArr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 255</span></span><br></pre></td></tr></table></figure>

<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>高阶函数： 函数可以作为参数传递 &amp;&amp; 函数可以作为返回值输出<br>柯里化(Currying): 把接受多个参数的函数变换成接受一个单一参数（或部分）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>示例:<br>编写一个 add 函数,使得 add(1,2)和 add(1)(2)都可以执行,并返回 3.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要判断参数值的长度</span></span><br><span class="line"><span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span> ? <span class="function"><span class="params">b</span> =&gt;</span> a + b : a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string-和-String-的区别"><a href="#string-和-String-的区别" class="headerlink" title="string 和 String 的区别"></a>string 和 String 的区别</h2><p>String 是包装类,是一个特殊的 object.<br>也就是说当不用 new 的时候，String(…) &#x3D;&#x3D;&#x3D; toString(…)</p>
<h2 id="new-String-和-String-区别"><a href="#new-String-和-String-区别" class="headerlink" title="new String() 和 String()区别"></a>new String() 和 String()区别</h2><p>我们知道 new 关键字的过程涉及到新对象的创建，所以，new String(str)的结果返回的一个新的 String 实例，所以，b 和 b2 保存的是两个对象的引用，他们的引用地址不一样，直接比较的话，逻辑引用类型的比较是一样的，结果就是不相等。</p>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>注意： 如果没写 break，下面的语句也会执行，不管是否符合条件。<br>default 是条件都不满足才执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> 条件<span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满足条件1&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果这里没写break，下面条件2的语句也会执行，不管是否符合条件2</span></span><br><span class="line">  <span class="keyword">case</span> 条件<span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满足条件2&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;和上两个条件都不相等&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expression</code>  中是可能变化的量,变化的可能性有三种,条件 1,2,和不满足条件 12 的其他种类.</p>
<p>空数组 push 后,再次调用记得赋值为空.</p>
<h2 id="map-和-forEach"><a href="#map-和-forEach" class="headerlink" title="map 和 forEach"></a>map 和 forEach</h2><p>map 返回处理后的新数组,而不是原数组的处理.原数组是不变的.</p>
<blockquote>
<p>能用 forEach()做到的，map()同样可以。反过来也是如此。<br>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。<br>forEach()允许 callback 更改原始数组的元素。map()返回新的数组。</p>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>forEach 执行后返回 undefined<br>map 执行后返回新数组</p>
<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>只能遍历数组并参数都一样<br>不改变原函数（引用类型除外）<br>无法中断循环；return 只是结束本次循环，进入下一次循环<br>break 或 continue 都将会报错</p>
<p>forEach 和 map 可以通过<code>return false</code>跳出本次循环，但是不能中断整个循环。<br>break 和 continue 也会报错。想要中断，可以使用<code>thorow new Error</code>。<br>for&#x2F;for…of： break 跳出本次循环；continue 结束本次循环执行下一次循环，没有 return。<br>for…in：会忽略 break || continue。没有 return。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;10:00.000&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;11:00.000&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;12:00.000&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> listMap = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">time</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//listMap返回时被处理的时间的字符串数组,原数组list没有变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(listMap); <span class="comment">//[&quot;10:00&quot;, &quot;11:00&quot;, &quot;12:00&quot;]</span></span><br><span class="line"><span class="keyword">let</span> listMap2 = list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span></span><br><span class="line">  item.<span class="property">time</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//forEach不返回新数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(listMap2); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="数组返回"><a href="#数组返回" class="headerlink" title="数组返回"></a>数组返回</h2><p>注意: <code>map</code>,<code>filter</code>,<code>find</code>,<code>findIndex</code>等必须要<code>return</code>才能生效.</p>
<h2 id="类数组转数组方法"><a href="#类数组转数组方法" class="headerlink" title="类数组转数组方法"></a>类数组转数组方法</h2><ol>
<li><code>Array.prototype.slice.call(obj)</code> &#x2F;&#x2F; 因为 slice 返回一个新数组,原数组不变。</li>
<li><code>Array.from</code></li>
<li>扩展运算符</li>
</ol>
<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h2><p>该方法对一个类数组或可迭代对象创建一个浅拷贝的数组实例。<br>方法接收 3 个参数，<br>第一个是类数组或可迭代对象，<br>第二个参数是个回调，新数组的每个元素都会执行该回调，<br>第三个参数是执行第二个回调函数的 this 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>); <span class="comment">// [2,4,6]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">5</span> &#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i); <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Max&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Jane&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">groupBy</span>(<span class="params">objectArray, property</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> objectArray.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acc, obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = obj[property];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!acc[key]) &#123;</span><br><span class="line">      acc[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].<span class="title function_">push</span>(obj);</span><br><span class="line">    <span class="comment">// console.log(acc)</span></span><br><span class="line">    <span class="comment">//这里acc[key]是value,也就是value里push</span></span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> groupedPeople = <span class="title function_">groupBy</span>(people, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">// groupedPeople is:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   20: [</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Max&#x27;, age: 20 &#125;,</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Jane&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   21: [&#123; name: &#x27;Alice&#x27;, age: 21 &#125;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="reduce-的理解"><a href="#reduce-的理解" class="headerlink" title="reduce 的理解"></a>reduce 的理解</h2><p>reduce 接收由数组调用，接收一个函数，和一个可选参数，初始值。如果没有初始值，默认初始值是函数的第一个参数。函数有 3 个参数，分别是累加器 acc，当前值 cur，当前值的索引 index。</p>
<p>reduce 有几种常用的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// return 就是下一次累加的结果</span></span><br><span class="line">  <span class="keyword">return</span> acc + cur;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 流程就是第一次0+1</span></span><br><span class="line"><span class="comment">// 第二次 1 + 2</span></span><br><span class="line"><span class="comment">// 第三次 3 + 3</span></span><br><span class="line"><span class="comment">// 最终结果6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多维数组转化一维数组（数组扁平化）</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]],</span><br><span class="line">]; <span class="comment">// =&gt; [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flat</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断cur是不是数组,如果不是数组，就把它拼接到空数组里</span></span><br><span class="line">    <span class="comment">// concat是可以连接数组或值的</span></span><br><span class="line">    <span class="comment">// 进入递归的数组，最后返回的也是一个一维数组</span></span><br><span class="line">    <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flat</span>(cur) : cur);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计数组中值的个数</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>]; <span class="comment">// =&gt; &#123;a: 2, b: 1, c: 2&#125;</span></span><br><span class="line"><span class="comment">// 上面说明最终要返回一个对象</span></span><br><span class="line"></span><br><span class="line">arr3.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果对象中没有这个值，那就把它放进去，赋值一次</span></span><br><span class="line">  <span class="keyword">if</span> (!prev[cur]) &#123;</span><br><span class="line">    prev[cur] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经出现了，次数+1</span></span><br><span class="line">    prev[cur]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把这个对象返回出去</span></span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="对象类型的指针问题"><a href="#对象类型的指针问题" class="headerlink" title="对象类型的指针问题"></a>对象类型的指针问题</h2><p>js 中，参数传递只有一种规则:按值传递，基于值的复制。原始类型复制的是值本身，所以这两份数据互不影响；引用类型复制的是引用值，所以形参和实参指向同一个对象，通过一个饮用修改了对象，那么通过另外一个引用访问的对象就是修改后的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  person.<span class="property">age</span> = <span class="number">26</span>;</span><br><span class="line">  person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yck&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">test</span>(p1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// -&gt; ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// -&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>解释:<br><code>p1</code> &#x3D;&gt;指向对象<code>&#123;name:&#39;yck&#39;,age:25&#125;</code>的指针<code>00001</code>.<br><code>test(p1)</code>传指针,<code>person.age = 26</code>修改该对象.此时<code>p1 = &#123;name: &#39;yck&#39;, age:26&#125;</code><br>接下来要给<code>person</code>重新赋值,但是<code>person</code>指向<code>p1</code>的指针被覆盖,重新开辟一块内存,新的指针<code>00002</code>.<br><code>person</code>拥有一个新的地址.<code>person = &#123;name: &#39;yyy&#39;, age: 30&#125;</code>.返回出来.</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非(!)"></a>逻辑非(<code>!</code>)</h2><p>逻辑非的规则:<br>操作数能被转化为<code>true</code>的,都返回<code>false</code>.否则返回<code>true</code>.<br>举例:<br>下面都被转换成<code>false</code>:<br><code>null</code>,<code>NaN</code>,<code>0</code>, <code>&#39;&#39;</code>,<code>undefined</code>.<br>所以遇到<code>!</code>会取反转为<code>true</code>.</p>
<blockquote>
<p>遇到对象会返回<code>false</code>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">!a == <span class="literal">false</span>; <span class="comment">// 字符串取反,就是false, 所以判断结果为true</span></span><br><span class="line">a == <span class="literal">false</span>; <span class="comment">// 使用==转化false为0, &quot;0&quot;和0比较,&quot;0&quot;被转化为0,结果为true</span></span><br><span class="line">a == <span class="number">0</span>; <span class="comment">//跟上一条一样</span></span><br></pre></td></tr></table></figure>

<h2 id="双逻辑非"><a href="#双逻辑非" class="headerlink" title="双逻辑非(!!)"></a>双逻辑非(!!)</h2><p>用于始终返回<code>true</code>或者<code>false</code><br>比如<code>!!undefined</code>返回<code>false</code>,否则直接会返回<code>undefined</code>.</p>
<h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符(??)"></a>空值合并运算符(<code>??</code>)</h3><p>当左侧为<code>null</code>或<code>undefined</code>，返回右侧。<br>与<code>||</code>的区别，当左侧是<code>&#39;&#39;</code>或者<code>0</code>，是可以取左侧的值的。</p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="(,)逗号运算符"></a><code>(,)</code>逗号运算符</h2><p>逗号表达式的值是成员表达式最右侧的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a, b, c;</span><br><span class="line"></span><br><span class="line">(a = b = <span class="number">3</span>), (c = <span class="number">4</span>); <span class="comment">// 值 4 返回到控制台</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3 (left-most)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x, y, z;</span><br><span class="line"></span><br><span class="line">x = ((y = <span class="number">5</span>), (z = <span class="number">6</span>)); <span class="comment">// 值 6 返回到控制台</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 6 (right-most)</span></span><br></pre></td></tr></table></figure>

<h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><p><code>&lt;&lt;</code>:左偏移,将数值转换为二进制,然后向左偏移多少位.<br><code>|</code>:按位或.按照二进制转换后,位数有则计算.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//二进制: 0000 0001 =&gt; 左偏移1位 =&gt; 0000 0010 =&gt; 2</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">//二进制: 0000 0010 =&gt; 左偏移2位 =&gt; 0000 1000 =&gt; 8</span></span><br><span class="line"><span class="keyword">let</span> c = a | b;</span><br><span class="line"><span class="comment">//二进制: 0000 0010</span></span><br><span class="line"><span class="comment">//二进制: 0000 1000 =&gt; 0000 1010 =&gt;10</span></span><br></pre></td></tr></table></figure>

<h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a><code>in</code>运算符</h2><p>指定的属性在指定的对象或其原型链中,则<code>in</code>运算符返回 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees; <span class="comment">// 返回false</span></span><br><span class="line"><span class="string">&quot;bay&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// 返回false (必须使用索引号,而不是数组元素的值)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true (length是一个数组属性)</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="property">iterator</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true (数组可迭代，只在ES2015+上有效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置对象</span></span><br><span class="line"><span class="string">&quot;PI&quot;</span> <span class="keyword">in</span> <span class="title class_">Math</span>; <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> mycar = &#123; <span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>, <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>, <span class="attr">year</span>: <span class="number">1998</span> &#125;;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// 返回true</span></span><br><span class="line"><span class="string">&quot;model&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure>

<p>如果只是将一个属性值赋值为<code>undefined</code>,而没有删除,则<code>in</code>运算符仍然会返回 true.</p>
<h2 id="判断对象上是否有某个属性"><a href="#判断对象上是否有某个属性" class="headerlink" title="判断对象上是否有某个属性"></a>判断对象上是否有某个属性</h2><p>方法有： for…in，Object.keys，in 操作符， hasownProperty。<br>for…in：可以遍历包括原型链上的属性<br>Object.keys: 遍历所有可枚举属性，不包括原型链<br>in 操作符： 可以检查原型链<br>hasOwnProperty：无法检查原型链.(返回布尔值，判断对象中是否有该值）</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>值类型用<code>**typeof**</code>,引用类型用<code>**instanceof**</code></p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>运算符返回一个字符串，表示操作数的类型。<br>原始类型: 除了 null 判断为 object,其他都正常.因为 null 是全零,被判断为 object.<br>引用类型: 除了函数显示<code>function</code>,其他都是<code>object</code>.</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>判断对象类型就可以用 instanceof,它会通过原型链判断.<br>但是原始类型就不行了.</p>
<h2 id="判断是否是数组"><a href="#判断是否是数组" class="headerlink" title="判断是否是数组"></a>判断是否是数组</h2><ol>
<li>Array.isArray()</li>
<li>Object.prototype.toString.call(arr)</li>
<li>instanceof</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
<th>boolean</th>
<th>Number</th>
<th>String</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>true</td>
<td>1</td>
<td>“true”</td>
</tr>
<tr>
<td>Boolean</td>
<td>false</td>
<td>false</td>
<td>0</td>
<td>“false”</td>
</tr>
<tr>
<td>Number</td>
<td>123</td>
<td>true</td>
<td>123</td>
<td>“123”</td>
</tr>
<tr>
<td>Number</td>
<td>Infinity</td>
<td>true</td>
<td>Infinity</td>
<td>“Infinity”</td>
</tr>
<tr>
<td>Number</td>
<td>0</td>
<td>false</td>
<td>0</td>
<td>“0”</td>
</tr>
<tr>
<td>Number</td>
<td>NaN</td>
<td>false</td>
<td>NaN</td>
<td>“NaN”</td>
</tr>
<tr>
<td>String</td>
<td>“”</td>
<td>false</td>
<td>0</td>
<td>“”</td>
</tr>
<tr>
<td>String</td>
<td>“123”</td>
<td>true</td>
<td>123</td>
<td>“123”</td>
</tr>
<tr>
<td>String</td>
<td>“123abc”</td>
<td>true</td>
<td>NaN</td>
<td>“123abc”</td>
</tr>
<tr>
<td>String</td>
<td>“abc”</td>
<td>true</td>
<td>NaN</td>
<td>“abc”</td>
</tr>
<tr>
<td>Null</td>
<td>null</td>
<td>false</td>
<td>0</td>
<td>“null”</td>
</tr>
<tr>
<td>Undefined</td>
<td>undefined</td>
<td>false</td>
<td>NaN</td>
<td>“undefined”</td>
</tr>
<tr>
<td>Function</td>
<td>function(){}</td>
<td>true</td>
<td>NaN</td>
<td>“function(){}”</td>
</tr>
<tr>
<td>Object</td>
<td>{}</td>
<td>true</td>
<td>NaN</td>
<td>“[object Object]”</td>
</tr>
<tr>
<td>Array</td>
<td>[]</td>
<td>true</td>
<td>0</td>
<td>“”</td>
</tr>
<tr>
<td>Array</td>
<td>[“abc”]</td>
<td>true</td>
<td>NaN</td>
<td>“abc”</td>
</tr>
<tr>
<td>Array</td>
<td>[“123”]</td>
<td>true</td>
<td>123</td>
<td>“123”</td>
</tr>
<tr>
<td>Array</td>
<td>[“123”,”a”]</td>
<td>true</td>
<td>NaN</td>
<td>“123,a”</td>
</tr>
</tbody></table>
<h3 id="加法-特殊"><a href="#加法-特殊" class="headerlink" title="加法(特殊)"></a>加法(特殊)</h3><p>四则运算符合两个规则:</p>
<ol>
<li>运算符一方为字符串,会把另一方转化为字符串.</li>
<li>如果一方不是字符串或数字,就会把它转化为字符串或数字.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&quot;1&quot;</span>; <span class="comment">// &quot;11&quot;</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// &quot;41,2,3&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 ‘11’</li>
<li>对于第二行代码来说，触发特点二，所以将 true 转为数字 1</li>
<li>对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3</li>
</ul>
<p>另外对于加法还需要注意这个表达式 ‘a’ + + ‘b’:</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">`a++b`返回`aNaN`.因为`+'b'`返回`NaN`.</div>
`+ '1'`快速获取number类型.

<h3 id="除了加法"><a href="#除了加法" class="headerlink" title="除了加法"></a>除了加法</h3><p>只要其中一方是数字，那么另一方就会被转为数字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">&quot;3&quot;</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="number">4</span> * []; <span class="comment">// 0</span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="==运算符"></a><code>==</code>运算符</h3><ol>
<li>如果一个操作数是布尔值,在比较之前要转成 number.</li>
<li>如果一个操作数是字符串,另一个是 number,要把字符串转成 number</li>
</ol>
<p>解释<code>[] == ![]</code>为 true.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先转化![] 为false</span></span><br><span class="line"><span class="comment">// 布尔值要先转成number =&gt; false-&gt;0</span></span><br><span class="line"><span class="comment">// [] 就要转成number -&gt; 0</span></span><br><span class="line"><span class="comment">// 0 == 0 //true</span></span><br></pre></td></tr></table></figure>

<p>解释<code>&#123;&#125; == !&#123;&#125;</code>为 false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本和上面相同</span></span><br><span class="line"><span class="comment">// 差异在于&#123;&#125; 转为number是NaN</span></span><br><span class="line"><span class="comment">// NaN == 0 就是false</span></span><br></pre></td></tr></table></figure>

<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p><code>undefined</code> 表示一个变量自然的、最原始的状态值，而 <code>null</code> 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 <code>undefined</code>，当需要释放一个对象时，直接赋值为 <code>null</code> 即可。<br><code>&#123; &#125;</code>是一个不完全空对象，原型链上有<code>Object</code>，<code>null</code>为原型链顶端，因此<code>Object.prototype.__proto__ === null</code>为 true。</p>
<p>null 是完全空对象，原型链也没有。</p>
<h1 id="0-1-0-2-x3D-0-3"><a href="#0-1-0-2-x3D-0-3" class="headerlink" title="0.1+0.2 !&#x3D; 0.3"></a>0.1+0.2 !&#x3D; 0.3</h1><p>因为 JS 采用 IEEE 754 双精度版本（64 位），并且只要采用 IEEE 754 的语言都有该问题。<br>0.1 在二进制中是无限循环的一些数字，其实不只是 0.1，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。</p>
<p>那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 0.1 不再是 0.1 了，而是变成了 0.100000000000000002.</p>
<p>那么可能你又会有一个疑问，既然 0.1 不是 0.1，那为什么 console.log(0.1) 却是正确的呢？</p>
<p>因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值.</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).<span class="title function_">toFixed</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>this 的指向与函数声明无关,取决于函数调用.</p>
<ol>
<li>普通函数调用(<code>fn()</code>) -&gt; this 指向 window</li>
<li>对象方法调用(<code>xx.fn()</code>) -&gt; this 指向对象</li>
<li>构造函数调用(<code>new fn()</code>) -&gt; this 指向 new 创建的实例对象</li>
<li>匿名函数中的 this：匿名函数的执行具有全局性，则匿名函数中的 this 指向是 window，而不是调用该匿名函数的对象</li>
</ol>
<p>例如:<br><code>box.onclick = function()&#123;&#125;</code>这就属于对象方法调用,this 也就指向 box.</p>
<h2 id="函数调用的优先级"><a href="#函数调用的优先级" class="headerlink" title="函数调用的优先级"></a>函数调用的优先级</h2><p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p>
<h2 id="箭头函数的-this"><a href="#箭头函数的-this" class="headerlink" title="箭头函数的 this"></a>箭头函数的 this</h2><ol>
<li>箭头函数中的 this 是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的；</li>
<li>箭头函数中的 this 指向父级作用域的执行上下文；（技巧：<strong>因为 javascript 中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定 this 的指向，则找到离箭头函数最近的 function，与该 function 平级的执行上下文中的 this 即是箭头函数中的 this</strong>）</li>
<li>箭头函数无法使用 apply、call 和 bind 方法改变 this 指向，因为其 this 值在函数定义的时候就被确定下来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">//此处的this即是箭头函数中的this</span></span><br><span class="line">  <span class="attr">getThis</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getThis</span>()(); <span class="comment">//obj</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">getThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getThis</span>()(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h2><p>笨方法记不同：call&#x3D;&gt;list, apply&#x3D;&gt;arr.<br>不同点:</p>
<ol>
<li>传参不同,call-&gt;多个参数,<strong>apply</strong>-&gt;数组,bind-&gt;就一个 this</li>
<li>执行机制不同: call,apply 立即执行,bind 不执行.</li>
</ol>
<p><code>call</code>的使用场景:<br><strong>检测数据类型:</strong></p>
<ol>
<li><code>typeof</code>,缺点:无法检测<code>null</code>,<code>array</code></li>
<li>使用<code>Object.prototype.toString.call()</code>.该方法会返回固定类型格式<code>[object type]</code>,其中 type 是类型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>

<p><strong>实现继承:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getValue</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">uname</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, uname, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Son</span>, <span class="comment">// 设置constructor的值是Son,说明原型对象的构造函数是Son</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">	  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;zhang&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son);</span><br></pre></td></tr></table></figure>

<p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数<br><code>apply</code>使用场景:<br><strong>类数组转真数组:</strong></p>
<p>ES5:上下文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line">newArr.<span class="property">push</span>.<span class="title function_">apply</span>(newArr, obj);</span><br></pre></td></tr></table></figure>

<p>ES6: <code>Array.from()</code><br>该方法可以将类数组直接转化为真数组.<br><strong>取数组最大值:</strong><br>ES5:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, arr);</span><br></pre></td></tr></table></figure>

<p>ES6:<code>Math.max(...arr)</code></p>
<p><code>bind</code>不会立即调用函数,而是得到一个修改<code>this</code>后的新函数.(一次修改,终身受用)<br>细节: 如果在 bind 后传递参数,参数也会绑定,但是调用函数所传参数就会失效了.<br><strong>修改不需要立即执行的函数:</strong><br>比如事件处理函数,定时器</p>
<p>如果对一个函数进行多次 bind，那么上下文会是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fn.<span class="title function_">bind</span>().<span class="title function_">bind</span>(a)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>();</span><br><span class="line">  &#125;.<span class="title function_">apply</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>

<p>无论<code>bind</code>多少次,this 永远指向第一次 bind.</p>
<ul>
<li>对于 new 的方式来说，this 被永远绑定在了实例上面，不会被任何方式改变 this</li>
<li>箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。<blockquote>
<p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo()这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p>
</blockquote>
</li>
</ul>
<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><p>每个实例对象都有一个私有属性<code>__proto__</code>，指向构造函数的原型对象<code>prototype</code>。<br>该原型对象也有自己的原型对象，层层向上直到一个对象的原型对象为 null。这构成了原型链。<br>null 没有原型，是原型链的最后一环。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>当访问一个对象的属性时，不只从该对象上寻找，还从原型链上查找，直到找到或者到达原型链的末端。</p>
<h1 id="constructor-和原型对象-构造函数-实例对象"><a href="#constructor-和原型对象-构造函数-实例对象" class="headerlink" title="constructor 和原型对象,构造函数,实例对象"></a>constructor 和原型对象,构造函数,实例对象</h1><p><code>prototype</code>属于构造函数,指向原型对象. 作用:解决内存浪费和变量污染.<br><code>constructor</code>属于原型对象,指向构造函数.作用:可以让实例对象知道自己是被谁创建的.<br><code>__proto__</code>属于实例对象,指向原型对象.作用:实例对象访问原型对象的成员.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1664181323672-63ddb950-9558-4713-a12e-8889f0532fef.png#averageHue=%23f7f7f7&clientId=u84dfcbb8-1307-4&from=paste&height=347&id=u3a5e30ca&originHeight=449&originWidth=573&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84467&status=done&style=none&taskId=u91ac1b2a-1524-4384-b47e-76f1a63fd50&title=&width=443" alt="image.png"></p>
<blockquote>
<p>如何方便理解三者关系,构造函数是父级,父级的 prototype(老婆)就是原型对象,原型对象的 constructor(老公)就是构造函数,子级实例对象的<strong>proto</strong>(母亲)就是原型对象.</p>
</blockquote>
<p>实例对象是无条件继承原型对象.<br>原型链的作用就是继承.也就说,js 是利用原型链实现面向对象继承的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>构造函数中的方法会导致内存的浪费.<br>两个实例对象虽然都可以调用 eat()方法,但是两个方法堆地址不同.每次调用函数都会在堆内存中生成一块新的空间.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1664200975310-09fb6834-6fd6-4750-86cb-09f1a5a63c5a.png#averageHue=%234d4c44&clientId=u0ca97a65-2fdb-4&from=paste&height=727&id=u04988d1f&originHeight=727&originWidth=1437&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=422821&status=done&style=none&taskId=u2217fa30-5759-4ec2-8123-b745aacbe77&title=&width=1437" alt="image.png"><br>解决方法 1: 使用全局变量.即将函数在全局书写,在构造函数内赋值,也即只获取地址.<br>缺点: 导致变量污染.<br>解决方法 2: 使用对象将全局变量函数包裹,但是治标不治本.<br>最终解决方法: 原型对象.</p>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>原型对象是构造函数的默认属性 prototype 所指向的一个空对象.用于解决内存浪费和变量污染的问题.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="与-ES6-中继承的关系"><a href="#与-ES6-中继承的关系" class="headerlink" title="与 ES6 中继承的关系"></a>与 ES6 中继承的关系</h3><p>ES6 中继承的方法属于 ES5 的语法糖.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">1</span>);</span><br><span class="line">child.<span class="title function_">getValue</span>(); <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Parent</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。</p>
<h3 id="instanceof-1"><a href="#instanceof-1" class="headerlink" title="instanceof"></a>instanceof</h3><p>用法:检测构造函数的原型在不在实例对象的原型链上.<br>arr 的原型链: arr -&gt;Array.prototype -&gt; Object.prototype -&gt; null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="literal">null</span>; <span class="comment">//typeError,右侧不是一个object</span></span><br></pre></td></tr></table></figure>

<h2 id="工厂函数和构造函数"><a href="#工厂函数和构造函数" class="headerlink" title="工厂函数和构造函数"></a>工厂函数和构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p = &#123;&#125;;</span><br><span class="line">  p.<span class="property">name</span> = name;</span><br><span class="line">  p.<span class="property">age</span> = age;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreatePerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new关键字调用的是构造函数</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h3 id="new-的用途"><a href="#new-的用途" class="headerlink" title="new 的用途"></a>new 的用途</h3><ol>
<li>创建空对象.方法很多种,对象字面量<code>const obj = &#123;&#125;</code>,或者<code>Object.create()</code></li>
<li>将空对象的原型指向构造函数的原型. <code>obj.__proto__ = constructor.prototype</code></li>
<li>将空对象作为构造函数的上下文(改变 this 指向).<code>const res = constructor.apply(obj, args)</code></li>
<li>对构造函数的返回值进行处理判断<code>return res instanceof Object ?  res : obj</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模仿new关键词实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; constructor 构造函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">...any</span>&#125; argument 任意参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">_new</span> = (<span class="params">constructor, ...argument</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;; <span class="comment">//创建一个空的简单对象</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">//设置原型</span></span><br><span class="line">  <span class="comment">//新创建的对象作为this的上下文传递给构造函数</span></span><br><span class="line">  <span class="keyword">const</span> res = constructor.<span class="title function_">apply</span>(obj, argument);</span><br><span class="line">  <span class="comment">//如果该函数没有返回对象，则返回this(这个this指constructor执行时内部的this))。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&quot;object&quot;</span> ? res : obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, sex</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Ben&quot;</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> peopleOther = <span class="title function_">_new</span>(<span class="title class_">Person</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;woman&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;people&quot;</span>, people); <span class="comment">// people Person &#123; name: &#x27;Ben&#x27;, sex: &#x27;man&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;peopleOther&quot;</span>, peopleOther); <span class="comment">// peopleOther Person &#123; name: &#x27;Alice&#x27;, sex: &#x27;woman&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;people.__proto__&quot;</span>, people.<span class="property">__proto__</span>); <span class="comment">//people.__proto__ Person &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;peopleOther.__proto__&quot;</span>, peopleOther.<span class="property">__proto__</span>); <span class="comment">//peopleOther.__proto__ Person &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="new-的细节"><a href="#new-的细节" class="headerlink" title="new 的细节"></a>new 的细节</h3><ol>
<li>构造函数的首字母大写,为了提醒别人不要忘记 new 关键字</li>
<li>关于构造函数主动写 return.对于值类型,无效,还是返回 new 创建的对象,对于引用类型,会覆盖.</li>
<li>new 的 this 问题。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>); <span class="comment">// Hello, my name is</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>);</span></span><br><span class="line"><span class="string">  &#125;,1000)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const user = new User();</span></span><br></pre></td></tr></table></figure>

<h2 id="对象字面量-new-Object-Object-create-区别"><a href="#对象字面量-new-Object-Object-create-区别" class="headerlink" title="对象字面量,new Object(),Object.create()区别"></a>对象字面量,new Object(),Object.create()区别</h2><p>字面量和 new 关键字创建的对象是 Object 的实例，原型指向 Object.prototype，继承内置对象 Object</p>
<p>Object.create(arg, pro)创建的对象的原型取决于 arg，arg 为 null，新对象是空对象，没有原型，不继承任何对象；arg 为指定对象，新对象的原型指向指定对象，继承指定对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> company = &#123;</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yideng = <span class="title class_">Object</span>.<span class="title function_">create</span>(company);</span><br><span class="line"><span class="keyword">delete</span> yideng.<span class="property">address</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yideng.<span class="property">address</span>);</span><br><span class="line"><span class="comment">// 写出执行结果，并解释原因</span></span><br><span class="line"><span class="comment">//beijing</span></span><br><span class="line"><span class="comment">//这里的 yideng 通过 prototype 继承了 company的 address。</span></span><br><span class="line"><span class="comment">//yideng自己并没有address属性。所以delete操作符的作用是无效的。</span></span><br><span class="line"><span class="comment">//yideng.address只是通过原型链去继承company的address</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>语法: <code>Object.assign(target, ...source)</code><br>解释: 将所有可枚举属性的值从一个或多个对象分配到目标对象.最后返回目标对象.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code>只能用于浅拷贝,无法用于深拷贝.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>对于这种就无法拷贝到对象 c.只能使用<code>JSON.parse(JSON.string(obj))</code>.<br>继承属性和不可枚举属性是不能被拷贝的.<br>原始类型会被包装,只有字符串的包装对象才可能有可枚举属性.</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>可以使用扩展运算符实现浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj &#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>通常可以通过 JSON.parse(JSON.stringify(object))来解决。<br>缺点:<br>忽略<code>undefined</code>,<code>Symbol</code>,函数,循环引用对象.</p>
<h1 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h1><p>执行 JS 代码就是往执行栈中放函数.遇到异步代码就挂起,需要执行的时候放到 TASK 中(有多种 task).<br>执行栈空了之后,从 task 中拿出要执行的代码放到执行栈中执行.</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">所以本质上说,异步还是同步行为.</div>

<h2 id="浏览器的-event-loop"><a href="#浏览器的-event-loop" class="headerlink" title="浏览器的 event loop"></a>浏览器的 event loop</h2><ul>
<li>js 引擎首先从宏任务中取出第一个(一般是 script),</li>
<li>执行完毕后,将微任务中所有的任务取出,按顺序执行</li>
<li>如果在这一步产生新的微任务也要执行</li>
<li>执行完后,会进行 DOM 渲染</li>
<li>进入下一轮 event loop,再取出一个宏任务,,执行完后取出所有的微任务,执行.<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">一次eventloop循环会处理一个宏任务和所有这次循环产生的微任务</div></li>
</ul>
<h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<ul>
<li>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li>
<li>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>
</ul>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>本质上两个名词都是 CPU 工作时间片的描述.</p>
<ul>
<li>进程是 CPU 在<strong>运行指令,加载和保存上下文</strong>所需的时间.放在应用上就代表了一个程序.</li>
<li>线程是进程中更小的单位,描述执行一段指令所需的时间.</li>
</ul>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。<br>当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，<br>当我们使用递归的时候，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ul>
<li>先执行同步代码,属于宏任务.</li>
<li>执行完后,执行栈空,查询是否有异步代码</li>
<li>执行微任务</li>
<li>执行微任务后,如有必要,会重新渲染页面</li>
<li>开始下一轮 Event loop,执行宏任务中的异步代码,</li>
</ul>
<h2 id="TASK-微任务和宏任务"><a href="#TASK-微任务和宏任务" class="headerlink" title="TASK(微任务和宏任务)"></a>TASK(微任务和宏任务)</h2><p>在 ES6 中,微任务叫<code>jobs</code>,宏任务叫<code>task</code>.<br>微任务包括: <code>process.nextTick()</code>, <code>Promise</code>,<code>MutationObserver</code>.<br>宏任务包括: <code>script</code>,<code>setTimeout</code>, <code>setInterval</code>,<code>setImmediate</code>,<code>I/O</code>,<code>UI rendering</code>,DOM 事件,DOM 渲染,AJAX 请求.<br>而且微任务并非快于宏任务,因为宏任务包括<code>script</code>,浏览器会先执行一个宏任务,接下来有异步代码才会执行微任务.</p>
<p>微任务和宏任务之间隔了一个 DOM 渲染.<br>执行顺序:<br>微任务 &gt; DOM 渲染 &gt; 宏任务</p>
<h3 id="关于-promise"><a href="#关于-promise" class="headerlink" title="关于 promise"></a>关于 promise</h3><p>promise 内部是同步代码,then()才是异步代码,遇到 then 就放到微任务队列中.<br>疑惑:<br>多个 then,嵌套 then 的顺序?<br>先将第一个 then 加入到微任务队列中,后面的拿不到状态,因为前面还是 pending,所以还无法放入队列.<br>等到前一个执行完毕,才加入队列.<br>then 中如果又 return 一个 promise,则前一个 promise 的其他 then 就挂到新的 promise 下.如果新的 promise 没有 return,那就要看有没有<code>resolve()</code>,有<code>resolve()</code>就继续走一个 then,因为<code>resolve</code>表示上一个 promise 状态 fulfilled 了,可以继续.而 then 中或者 await 中的 promise 就看有没有 return 了,如果是<code>return Promise</code>那么就直接跳出这个包裹函数了,包裹函数后面的异步就放在最后才执行.<br>setTimeout 中含有 promise 的顺序?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>(); <span class="comment">//2.回到这里,遇到await,让出线程,执行之后的代码,所以下面的也不放到微任务队列</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>); <span class="comment">//3. 当同步代码执行完毕,回到这里,</span></span><br><span class="line">  <span class="comment">//将resolve放到微任务队列中,执行后面then中的回调.在两次tick后执行这里的微任务.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>); <span class="comment">//1.立即执行,执行完返回一个Promise</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt; 代码一执行就开始执行了一个宏任务-宏0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 宏 1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span> * <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 微1-1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 微1-4 =&gt;</span></span><br><span class="line">    <span class="comment">// 这个then中的会等待上一个then执行完成之后得到其状态才会向Queue注册状态对应的回调，</span></span><br><span class="line">    <span class="comment">//假设上一个then中主动抛错且没有捕获，那就注册的是这个then中的第二个回调了。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">bar</span>(); <span class="comment">// =&gt; await(promise的语法糖)，会异步等待获取其返回值</span></span><br><span class="line">  <span class="comment">// =&gt; 后面的代码可以理解为放到异步队列微任务中。 这里可以保留疑问后面会详细说</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>); <span class="comment">// 微1-2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">errorFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// =&gt; 从这后面开始所有的代码可以理解为放到异步队列微任务中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// 微1-3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;async1 success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">errorFunc</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)); <span class="comment">// 微1-5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// run:</span></span><br><span class="line"><span class="comment">// 	执行微1-1: promise1</span></span><br><span class="line"><span class="comment">// 	执行微1-2: async1 end</span></span><br><span class="line"><span class="comment">// 	执行微1-3: error!!!、async1 。</span></span><br><span class="line"><span class="comment">//  当前异步回调执行完毕才Promise.resolve(&#x27;async1 success&#x27;)，</span></span><br><span class="line"><span class="comment">//  然后注册then()中的成功的回调-微1-5</span></span><br><span class="line"><span class="comment">// 	执行微1-4: promise2</span></span><br><span class="line"><span class="comment">//  执行刚刚注册的微1-5: async1 success</span></span><br></pre></td></tr></table></figure>

<p>如果 Promise 中有 setTimeout,那就看 resolve 在不在 setTimeout 里了,如果在,因为后面 then 拿不到 value,无法继续,就得等着,如果不在,那就走 then,回来再走 setTimeout.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 宏2</span></span><br><span class="line">        <span class="title function_">reject</span>();</span><br><span class="line">      &#125;, <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">      <span class="title function_">resolve</span>() <span class="comment">// TODO 注1</span></span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-2  TODO 注2</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">      &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-4</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-6</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 微1-5 TODO 注3</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微1-3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注意then后面想执行需要前面的状态是fufilled,否则并不会放入队列</span></span><br><span class="line"><span class="comment">//主要是关于resolve()后进队列的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-1进队列,</span></span><br><span class="line"><span class="comment">// 1-1内部的promise 是同步代码,</span></span><br><span class="line"><span class="comment">// 1-2进队列,同时1-1的返回值是resolve(undivided)</span></span><br><span class="line"><span class="comment">// 当有返回值时,1-3进队列</span></span><br><span class="line"><span class="comment">// 清空微任务,1-2执行,1-4进队列,同时1-2的resolve(undivided),1-5进队列,</span></span><br><span class="line"><span class="comment">// 执行微任务,1-3执行,1-4执行,1-6进队列,1-5执行.</span></span><br><span class="line"><span class="comment">// 最后1-6进执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我觉得大概就是这样，then执行一定要记住then在resolve之后才会把then回调放到微任务队列去</span></span><br><span class="line"><span class="string">``</span><span class="string">`&lt;/div&gt;warning</span></span><br><span class="line"><span class="string">前面说过promise.finally()也是微任务，finally可以理解为不管promise的状态是成功或失败都要执行我。但是我不接受任何结果。因此finally接受不到返回值res为undefined&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 任务队列中async/await的运行机制</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- async定义的是一个Promise函数和普通函数一样只要不调用就不会进入事件队列。</span></span><br><span class="line"><span class="string">- async内部如果没有主动return Promise，那么async会把函数的返回值用Promise包装。</span></span><br><span class="line"><span class="string">- await关键字必须出现在async函数中，await后面不是必须要跟一个异步操作，也可以是一个普通表达式。</span></span><br><span class="line"><span class="string">- 遇到await关键字，await右边的语句会被立即执行然后await下面的代码进入等待状态，等待await得到结果。await后面如果不是 promise 对象, await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果。await后面如果是 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</span></span><br><span class="line"><span class="string">- await后面的代码放不放到最后主要看,await 的代码是不是Promise,如果是,先不放到微任务队中,也就是等同步代码执行完,再放,也就到了微任务队列的最后了,如果不是,可以放到微任务队列中.</span></span><br><span class="line"><span class="string">- `</span><span class="keyword">await</span> <span class="title function_">bar</span>()<span class="string">` =&gt; `</span><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">bar</span>())<span class="string">`, 后面的代码相当于`</span><span class="title class_">Promise</span>.<span class="title function_">then</span>(...)<span class="string">`</span></span><br><span class="line"><span class="string">- `</span><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span><span class="string">`如果promise没有返回值,是不执行后面内容.&lt;/div&gt;warning</span></span><br><span class="line"><span class="string">await的真实意思是 async wait(异步等待的意思)await表达式相当于调用后面返回promise的then方法，异步（等待）获取其返回值。即 await&lt;==&gt;promise.then&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div style=&quot;background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;&quot;&gt;try/catch捕获不到异步的异常,只能捕获同步代码.&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 定时器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## setTimeout</span></span><br><span class="line"><span class="string">setTimeout并不一定准确.</span></span><br><span class="line"><span class="string">其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，我们可以通过代码去修正 setTimeout，从而使定时器相对准确.</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + period</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> currentInterval = interval</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">  <span class="keyword">let</span> h = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>(hdiff / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(s)</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="title class_">Math</span>.<span class="title function_">floor</span>(s)</span><br><span class="line">  <span class="comment">// 得到下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;时：&#x27;</span>+h, <span class="string">&#x27;分：&#x27;</span>+m, <span class="string">&#x27;毫秒：&#x27;</span>+s, <span class="string">&#x27;秒向上取整：&#x27;</span>+sCeil, <span class="string">&#x27;代码执行时间：&#x27;</span>+offset, <span class="string">&#x27;下次循环间隔&#x27;</span>+currentInterval)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(loop, currentInterval)</span><br></pre></td></tr></table></figure>

<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><p>接下来我们来看 setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p>
<p>通常来说不建议使用 setInterval。<br>第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。<br>第二，它存在执行累积的问题.</p>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>通过 <code>requestAnimationFrame</code> 来实现 setInterval.<br>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setInterval</span>(<span class="params">callback, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="property">now</span>;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">let</span> endTime = startTime;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">loop</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    timer = <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(loop);</span><br><span class="line">    endTime = <span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = <span class="title function_">now</span>();</span><br><span class="line">      <span class="title function_">callback</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  timer = <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(loop);</span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">(<span class="params">timer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">3</span>) <span class="title function_">cancelAnimationFrame</span>(timer);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h2 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h2><p>存活时间短,采用 Scavenge GC 算法.<br>分为两部分空间,From 和 To,总是有一个空闲.<br>新分配的对象 &#x3D;&gt; From 空间,放满为止. &#x3D;&gt; 启动 GC,检查 From 空间,<br>存活的,复制到 To 空间, 失活的,清除. &#x3D;&gt; From 和 To 空间互换.</p>
<h2 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h2><ul>
<li>经历过一次 GC 的对象进入老生代空间</li>
<li>To 空间的对象占比大小超过 25% &#x3D;&gt;老生代空间</li>
</ul>
<p>老生代采用标记-清除, 标记-紧缩算法.</p>
<h1 id="JS-异步"><a href="#JS-异步" class="headerlink" title="JS 异步"></a>JS 异步</h1><p>我们都知道 JavaScript 是单线程的，如果 JS 都是同步代码执行意味着什么呢？这样可能会造成阻塞，如果当前我们有一段代码需要执行时，如果使用同步的方式，那么就会阻塞后面的代码执行；而如果使用异步则不会阻塞，我们不需要等待异步代码执行的返回结果，可以继续执行该异步任务之后的代码逻辑。因此在 JS 编程中，会大量使用异步来进行编程</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>所谓的同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值之后，就可以执行其他代码了。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>所谓异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul>
<li>回调函数</li>
<li>Promise</li>
<li>Generator</li>
<li>async&#x2F;await</li>
</ul>
<p>还有事件监听,发布订阅模式是异步操作.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/10/React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/10/React/" class="post-title-link" itemprop="url">React</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-10 09:11:13" itemprop="dateCreated datePublished" datetime="2021-03-10T09:11:13+08:00">2021-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:29" itemprop="dateModified" datetime="2023-05-13T09:03:29+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>react 页面是由各个 react 组件构成的.</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h2><p>各个组件之间传值,向外部传值用 <code>this.props....</code> <br>向内部传值用 <code>this.state...</code> <br>在内部保存值用 <code>this.setState</code></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类有三个要素.<br>声明的参数<br>constructor 构造函数<br>调用的函数.</p>
<h3 id="React-类"><a href="#React-类" class="headerlink" title="React 类"></a>React 类</h3><p>一般调用的是 <code>render()</code>  函数,将内部的 <code>JSX</code>  语法构建到虚拟 DOM 中.从而渲染到页面上.<br>在定义子类的构造函数时,都要调用 <code>super()</code>  方法.<br>因此,所有含有构造函数的 React 组件,必须以 <code>super(props)</code>  开头.</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>子组件通过一个绑定的参数接受来自父组件的 props.父组件把值写在 state 中.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> state = &#123;</span><br><span class="line">   lastName = <span class="string">&quot;Tom&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#123;this.state.lastName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      //name=&#123;this.state.lastName&#125;作为一个整体传递给子组件,作为props</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>父组件的数据: &#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>通过回调函数,父组件提供回调函数,子组件调用,将要传递的数据通过参数传递.<br>父组件拿到数据进行更新 state.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">	state = &#123;</span><br><span class="line">    <span class="attr">parentName</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明回调</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getChildMsg</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;来自子组件&quot;</span>,data)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    	<span class="attr">parentName</span>: data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件接受: &#123;this.state.parentName&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">getMsg</span>=<span class="string">&#123;this.getChildMsg&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;子组件的信息&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//触发父组件的回调,并将参数传递</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">getMsg</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleCick&#125;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>父级的方法传递到子级的底层时,进行调用的时候,最好有所关联<br>filter 方法并没有更新当前的数组而是创建了一个新数组，它会过滤掉不符合条件的数据项，符合条件的数据项就会组成新的数组。<br><code>filter</code> 是 JavaScript 中删除数组元素的首选方法。<br>现在我们需要将<code>removeUser</code>传递给组件，并且在每一个列表行上渲染一个按钮，点击这个按钮调用这个方法。我们通过属性的方式将<code>removeUser</code>方法传递给 Table 组件。<br>TableBody 中，在调用<code>removeItem()</code>时，将数据对应的索引号<code>(index)</code>作为参数传递给了<code>removeItem()</code>方法，这样过滤方法就知道该删除哪个数据项了。创建一个按钮，并在<code>onClick</code>中调用<code>removeItem()</code>.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [users, setUsers] = <span class="title function_">useState</span>([&#123; <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span> &#125;]);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">removeUser</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setUsers</span>(users.<span class="title function_">filter</span>(<span class="function">(<span class="params">use, i</span>) =&gt;</span> index !== i));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Table</span> <span class="attr">items</span>=<span class="string">&#123;users&#125;</span> <span class="attr">removeItem</span>=<span class="string">&#123;removeUsers&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Table</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; items, removeUsers &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TableHeader</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TableBody</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;</span> <span class="attr">removeItem</span>=<span class="string">&#123;removeItem&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TableBody</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; items, removeUsers &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> rows = items.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;items.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;items.job&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> removeUSer(index)&#125;&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span>&#123;rows&#125;<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>组件传值的时候不要直接把传递过来的函数放到组件上,建议另写一个函数调用的时候带上这个<code>props</code>传递的函数.<br>下面的<code>handleSubmit</code>是从<code>props</code>拿到的,但是又封装一个函数才进行调用.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Form</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> initalData = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> [formData, setFormData] = <span class="title function_">useState</span>(initalData);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, value &#125; = e.<span class="property">target</span>;</span><br><span class="line">    <span class="title function_">setFormData</span>(&#123;</span><br><span class="line">      ...formData,</span><br><span class="line">      [name]: value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">submitForm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    props.<span class="title function_">handleSubmit</span>(formData);</span><br><span class="line">    <span class="title function_">setFormData</span>(initalData);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">name</span>=<span class="string">&quot;name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;formData.name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">name</span>=<span class="string">&quot;age&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;formData.age&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onSubmit</span>=<span class="string">&#123;submitForm&#125;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="兄弟通信"><a href="#兄弟通信" class="headerlink" title="兄弟通信"></a>兄弟通信</h3><h4 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h4><blockquote>
<p>当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，需要把子组件的  state  数据提升至其共同的父组件当中保存。之后父组件可以通过  props  将状态数据传递到子组件当中。这样应用当中所有组件的状态数据就能够更方便地同步共享了。</p>
</blockquote>
<ul>
<li>将共享状态提升到最近的公共父组件,由公共父组件管理状态</li>
<li>思想: 状态提升</li>
<li>公共父组件职责: 提供共享状态,提供操作共享状态的方法</li>
<li>要通讯的子组件只需要通过<code>props</code>接收或者操作状态的方法</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">//共享状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//共享方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onIncrement</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      	<span class="tag">&lt;<span class="name">Child1</span> <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child2</span> <span class="attr">onIncrement</span>=<span class="string">&#123;this.onIncrement&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child1</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>计数器: &#123;props.count&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child2</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span>props.onIncrement()&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><blockquote>
<p>因为 DOM 元素   是一个内置组件，因此其 onClick 属性在 React 中有特殊的含义。而对于用户自定义的组件来说，命名就可以由用户自己来定义了。我们给 Square 的 onClick 和 Board 的 handleClick 赋予任意的名称，代码依旧有效。在 React 中，有一个命名规范，通常会将代表事件的监听 prop 命名为 on[Event]，将处理事件的监听方法命名为 handle[Event] 这样的格式。</p>
</blockquote>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><p>将 class 组件修改为函数式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Square extends React.Component &#123;</span></span><br><span class="line"><span class="comment">//     render() &#123;</span></span><br><span class="line"><span class="comment">//       return (</span></span><br><span class="line"><span class="comment">//         &lt;button</span></span><br><span class="line"><span class="comment">//           className=&quot;square&quot;</span></span><br><span class="line"><span class="comment">//           onClick=&#123;()=&gt; this.props.onClick()&#125;&gt;</span></span><br><span class="line"><span class="comment">//           &#123;this.props.value&#125;</span></span><br><span class="line"><span class="comment">//         &lt;/button&gt;</span></span><br><span class="line"><span class="comment">//       );</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Square</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.value&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<br><code>onClick=&#123;()=&gt;this.props.onClick()&#125;</code> <br>修改为<br><code>onClick=&#123;props.onClick&#125;</code> <br>两侧括号消失</p>
</blockquote>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><ul>
<li>可以给组件传任意类型的值</li>
<li><code>props</code>是只读的对象,只能读取属性的值,无法修改</li>
<li>使用类组件时,如果写了构造函数,应该将<code>props</code>传递给<code>super()</code>,否则无法在构造函数中获取<code>props</code></li>
</ul>
<h3 id="props-深入"><a href="#props-深入" class="headerlink" title="props 深入"></a>props 深入</h3><h4 id="children-属性"><a href="#children-属性" class="headerlink" title="children 属性"></a>children 属性</h4><p>表示组件标签的子节点.当组件标签有子节点时,props 就会有该属性.<br>children 和普通的 props 属性一样,值可以是任意值.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;Test /&gt;</span></span><br><span class="line">  &lt;/<span class="title class_">App</span>&gt;,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="props-校验"><a href="#props-校验" class="headerlink" title="props 校验"></a>props 校验</h4><p>安装包<code>prop-types</code>,引入包,<br>使用<code>组件名.propTypes=&#123;&#125;</code>来给组件的 props 添加校验规则.<br>校验规则通过<code>PropTypes</code>对象来指定</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.colors&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">App</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="comment">//约定colors属性为array类型</span></span><br><span class="line">  <span class="comment">//如果类型不对,则报错</span></span><br><span class="line">  <span class="attr">colors</span>: <span class="title class_">PropTypes</span>.<span class="property">array</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="约束规则"><a href="#约束规则" class="headerlink" title="约束规则"></a>约束规则</h4><ol>
<li>常见类型: array, bool, func, number, object, string</li>
<li>React 元素类型: element</li>
<li>必填项: isRequired</li>
<li>特定结构的对象: <code>shape(&#123;&#125;)</code></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见类型</span></span><br><span class="line"><span class="attr">optionalFunc</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>,</span><br><span class="line"><span class="comment">//必选</span></span><br><span class="line"><span class="attr">requiredFunc</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line"><span class="comment">//特定结构对象</span></span><br><span class="line"><span class="attr">optionalObjectwithShape</span>: <span class="title class_">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="title class_">Proptypes</span>.<span class="property">string</span>,</span><br><span class="line">  <span class="attr">fontSize</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="props-默认值"><a href="#props-默认值" class="headerlink" title="props 默认值"></a>props 默认值</h4><p><code>组件.defaultProps</code>: 给组件传入默认值,在未传入 props 时生效.</p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>不要直接修改 state,使用 <code>this.setState()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">comment</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">comment</span>: <span class="string">&quot;hello&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>构造函数是唯一可以给 <code>this.state</code>  赋值的地方.</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>setSate 接收一个函数,而函数的参数就是当前 state 的值.变化后记得将新的 state 返回出去.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">count</span>) =&gt;</span> count + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="state-的更新可能异步"><a href="#state-的更新可能异步" class="headerlink" title="state 的更新可能异步"></a>state 的更新可能异步</h3><p><code>this.props</code>  和 <code>this.state</code>  可能会异步更新,不要依赖他们的值更新下一个状态.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">increment</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>正确解决方法:</p>
<p>让 <code>setState</code>  接收一个函数而不是一个对象.<br>这个函数用上一个 <code>state</code>  作为参数,将此次更新被应用时的 <code>props</code>  作为第二个参数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">		<span class="attr">count</span>: state.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">		&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="state-的更新可能会被吞并"><a href="#state-的更新可能会被吞并" class="headerlink" title="state 的更新可能会被吞并"></a>state 的更新可能会被吞并</h3><p>当调用 <code>setState</code>  时, <code>React</code>  会把提供的对象合并到当前的 state 中.<br>这个不太懂.</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>跨组件通信,也就是不同层级的组件访问相同的数据,比如当前的登录用户,主题,语言.</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用<code>React.createContext</code>创建<code>Provider</code>和<code>Consumer</code>两个组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br></pre></td></tr></table></figure>

<p>使用<code>Provider</code>作为父节点.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>value</code>属性表示要传递的数据.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> value=<span class="string">&quot;red&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>调用<code>Consumer</code>组件进行接收.Consumer 内部需要一个函数作为子元素.<br>即 data 接收的就是 value 的值.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Consumer</span>&gt;&#123;<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>data参数表示接收到的数据--&#123;data&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&lt;/<span class="title class_">Consumer</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="关于-Provider-渲染"><a href="#关于-Provider-渲染" class="headerlink" title="关于 Provider 渲染"></a>关于 Provider 渲染</h3><p>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。从 Provider 到其内部 consumer 组件（包括 .contextType 和 useContext）的传播不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件跳过更新的情况下也能更新。</p>
<h3 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h3><p>挂载在 class 上的 contextType 属性可以赋值为 context 对象,此属性可以让我们通过<code>this.context</code>来获取 Context 的值.可以在任何生命周期中访问.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">    <span class="comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">    <span class="comment">/* 基于 MyContext 组件的值进行渲染 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">contextType</span> = <span class="title class_">MyContext</span>;</span><br></pre></td></tr></table></figure>

<h3 id="额外的"><a href="#额外的" class="headerlink" title="额外的"></a>额外的</h3><p>如果想避免层层传递某些属性,也可以使用组件组合()</p>
<h2 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h2><p>任何的  state  总是所属于特定的组件，而且从该  state  派生的任何数据或  UI  只能影响树中“低于”它们的组件。<br>如果把一个以组件构成的树想象成一个  props  的数据瀑布的话，那么每一个组件的  state  就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>不能通过返回 <code>false</code>  阻止事件默认行为,必须显示的使用 <code>preventDefault</code> .</p>
<h3 id="this-的绑定"><a href="#this-的绑定" class="headerlink" title="this 的绑定"></a>this 的绑定</h3><p>将 this 绑定到构造函数上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toggle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !state.<span class="property">isToggleOn</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.isToggleOn ? &quot;ON&quot; : &quot;OFF&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDom</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>不想 <code>bind</code>  的解决方法.</p>
<ol>
<li>使用箭头函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toggle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">	...</span><br><span class="line">  handleClick = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span>&#123;</span><br><span class="line">			<span class="attr">isToggleOn</span>: !state.<span class="property">isToggleOn</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 render 中使用箭头函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> &#123;this.handleClick()&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    	Clcik me</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><p>若 id 是要删除的哪一行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span><span class="variable language_">this</span>.<span class="title function_">deleteRow</span>(id, e)&#125;&gt;<span class="title class_">Delete</span> <span class="title class_">Row</span>&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.deleteRow.bind(this,</span> <span class="attr">id</span>)&#125;&gt;</span>Delete Row<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="关于-Click-中的箭头函数问题"><a href="#关于-Click-中的箭头函数问题" class="headerlink" title="关于 Click 中的箭头函数问题"></a>关于 Click 中的箭头函数问题</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onClick=&#123;这里是一个函数或函数引用&#125;</span><br><span class="line">onClick=&#123;<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">handleClick</span>(i)&#125;，这里面就是一个匿名函数，</span><br><span class="line"><span class="comment">//点击事件发生时，会执行这个匿名函数，匿名函数再调用handleClick函数(传参i)；</span></span><br><span class="line"><span class="comment">//其次才是this绑定的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果直接写函数执行,是错误的,因为会在页面渲染时立即执行,而不是点击才执行</span></span><br><span class="line">onClick=&#123;<span class="title function_">handleClick</span>()&#125; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>所以,如果要传递参数时,才需要使用箭头函数,或者绑定 this.</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserGreeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GuestGreeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoginIn = props.<span class="property">isLoginIn</span>;</span><br><span class="line">  <span class="keyword">if</span> (isLoginIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">isLoginIn</span>=<span class="string">&#123;false&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementBId</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="列表和-Key"><a href="#列表和-Key" class="headerlink" title="列表和 Key"></a>列表和 Key</h2><p>一个元素的  key  最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的  id  来作为元素的  key.当元素没有确定  id  的时候，万不得已你可以使用元素索引  index  作为  key.<br>和<code>Vue</code>不同,<code>key</code>写在返回式中.</p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>使用 <code>map()</code> 进行遍历时,记得 <code>return</code> .</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">numbers.<span class="title function_">map</span>(<span class="function"><span class="params">number</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">numbers.<span class="title function_">map</span>(<span class="function"><span class="params">number</span> =&gt;</span>&#123;<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure>

<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>暂时空置</p>
<h2 id="状态提升-1"><a href="#状态提升-1" class="headerlink" title="状态提升"></a>状态提升</h2><p>在  React  应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state  都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个  state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步  state。</p>
<h3 id="component-composition-这种透传数据的模式"><a href="#component-composition-这种透传数据的模式" class="headerlink" title="component composition 这种透传数据的模式"></a>component composition 这种透传数据的模式</h3><p>引用官网的一句话</p>
<blockquote>
<p>Context 主要应用场景在于<em>很多</em>不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p>
<p><strong>如果你只是想避免层层传递一些属性，</strong><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html"><strong>组件组合（component composition）</strong></a><strong>有时候是一个比 context 更好的解决方案。</strong><br><strong>我们把我们需要用到数据的那个组件直接丢到数据来源的 props 身上</strong> ，然后消费数据，把消费完的组件，也就是要被渲染到页面的内容，通过 <code>props</code> 传回来。这就是 <code>component compositon</code> ，简单粗暴，我们在原来的地方，直接渲染这个组件即可<br>例如：我们在 <code>Page</code> 组件中需要传递个 <code>Auth</code> 组件 <code>user</code> 信息，它们之间有很多的深层嵌套<br>我们可以这么做 （官网例子）</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里真正需要user和avatarSize的其实只有Link组件</span></span><br><span class="line">&lt;<span class="title class_">Page</span> user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">  <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line">    <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line">    <span class="comment">// ... 渲染出 ...</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里就是把上面的Link组件提出来,把组件通过props传递下去</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.<span class="property">user</span>;</span><br><span class="line">  <span class="keyword">const</span> userLink = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;props.avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">userLink</span>=<span class="string">&#123;userLink&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在，我们有这样的组件：</span></span><br><span class="line">&lt;<span class="title class_">Page</span> user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...Page的子组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">userLink</span>=<span class="string">&#123;...&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// ... 渲染出 ...PageLayout的子组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">userLink</span>=<span class="string">&#123;...&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&#123;props.<span class="property">userLink</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们只用传递 <code>userLink</code> 即可，</p>
<h2 id="组合-VS-继承"><a href="#组合-VS-继承" class="headerlink" title="组合 VS 继承"></a>组合 VS 继承</h2><h3 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h3><p>有些组件无法提前知晓它们子组件的具体内容。在  Sidebar（侧边栏）和  Dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。<br>我们建议这些组件使用一个特殊的  children prop  来将他们的子组件传递到渲染结果中.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FancyBorder</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&quot;<span class="attr">FancyBorder</span> <span class="attr">FancyBorder-</span>&quot; + <span class="attr">props.color</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSX 标签中的所有内容都会作为一个 <code>children</code>prop 传递给 FancyBorder 组件。因为 FancyBorder 将 <code>&#123;props.children&#125;</code>  渲染在一个</p>
<p>少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 <code>children</code> ，而是自行约定：将所需内容传入 <code>props</code> ，并使用相应的 <code>prop</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Contacts</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Contacts&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Chat</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Chat&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SplitPane</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-left&quot;</span>&gt;</span>&#123;props.left&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-right&quot;</span>&gt;</span>&#123;props.right&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SplitPane</span> <span class="attr">left</span>=<span class="string">&#123;</span>&lt;<span class="attr">Contacts</span> /&gt;</span>&#125; right=&#123;<span class="tag">&lt;<span class="name">Chat</span> /&gt;</span>&#125; /&gt;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="特例关系"><a href="#特例关系" class="headerlink" title="特例关系"></a>特例关系</h3><p>暂无</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="创建时"><a href="#创建时" class="headerlink" title="创建时"></a>创建时</h3><p><code>constructor</code>&#x3D;&gt;<code>render()</code>&#x3D;&gt;<code>componentDidMount</code></p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>constructor</td>
<td>创建组件</td>
<td>1.初始化 state</td>
</tr>
<tr>
<td>2.为事件处理程序绑定 this</td>
<td></td>
<td></td>
</tr>
<tr>
<td>render</td>
<td>每次渲染都会触发</td>
<td>渲染 UI(注意不能调用 setState)</td>
</tr>
<tr>
<td>componentDIdMount</td>
<td>组件挂载(完成 DOM 渲染后)</td>
<td>1.发送网络请求</td>
</tr>
<tr>
<td>2.DOM 操作</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="更新时"><a href="#更新时" class="headerlink" title="更新时"></a>更新时</h3><p>执行时机: 1.<code>setState</code>2.<code>forceUpdate()</code>3.组件接收新的 props<br>执行顺序: <code>render()</code> &#x3D;&gt; <code>componentDidUpdate</code></p>
<table>
<thead>
<tr>
<th>钩子函数</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>render</td>
<td>每次组件渲染都会触发</td>
<td>渲染 UI,与挂载阶段是同一个 render</td>
</tr>
<tr>
<td>componentDidUpdate</td>
<td>组件更新(完成 DOM 渲染后)</td>
<td>1.发送网络请求</td>
</tr>
</tbody></table>
<p>2.DOM 操作<br>注意如果要 setState 必须放在 if 条件中 |</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果要在componentDidUpdate中setState,需要加if</span></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">	<span class="comment">//比较更新前后的props是否相同,决定是否重新渲染</span></span><br><span class="line">  <span class="keyword">if</span>(prevProps.<span class="property">count</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="卸载时"><a href="#卸载时" class="headerlink" title="卸载时"></a>卸载时</h3><table>
<thead>
<tr>
<th>钩子函数</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>componentWillUnmount</td>
<td>组件卸载</td>
<td>执行清理工作(如卸载定时器)</td>
</tr>
</tbody></table>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">timeId</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器执行&quot;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerId</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>shouldComponentUpdate</code></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h2><p>要复用什么? 1.<code>state</code>2.操作<code>state</code>的方法(组件状态逻辑)<br>方式: 1.<code>render props</code>模式 2.<code>HOC</code>高阶组件 3. 自定义 hooks</p>
<h3 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h3><p>思路: 将复用的 state 和操作 state 的方法封装到一个组件<br>问题 1: 如何拿到该组件中复用的 state?<br>方法: 在使用组件时,添加一个值为函数的 prop,通过函数参数来获取(需要组件内部实现)<br>问题 2: 如何渲染任意 UI?<br>方法: 使用该函数的返回值作为要渲染的内容.(需要组件内部实现)</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</div>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Mouse</span> render=&#123;<span class="function">(<span class="params">mouse</span>) =&gt;</span> &#123;&#125;&#125; /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;(mouse)</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标当前位置:&#123;mouse.x&#125;,&#123;mouse.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">) &#125;/&gt;</span></span><br></pre></td></tr></table></figure>
具体步骤:

<ol>
<li>创建 Mouse 组件,在组件中提供复用的状态逻辑代码</li>
<li>将要复用的状态作为<code>props.render(state)</code>方法的参数,暴露到组件外部</li>
<li>使用<code>props.render()</code>的返回值作为要渲染的内容</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        x = <span class="number">0</span>,</span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">x</span>: e.<span class="property">clientX</span>,</span><br><span class="line">            <span class="attr">y</span>: clientY</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 这里是关键</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">render</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Mouse render=&#123;(mouse) =&gt; &#123;</span><br><span class="line">                    return (</span><br><span class="line">                        &lt;p&gt;鼠标位置: &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">                    )</span><br><span class="line">                &#125;&#125; /&gt;</span><br><span class="line">            &lt;Mouse render=&#123;(mouse) =&gt; &#123;</span><br><span class="line">									return (</span><br><span class="line">                    &lt;img src=&#123;img&#125; alt=&quot;cat&quot; style=&#123;&#123;</span><br><span class="line">                      	postion: &#x27;absolute&#x27;,</span><br><span class="line">                        top: mouse.y,</span><br><span class="line">                        left: mouse.x</span><br><span class="line">                      &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-children-替代-render"><a href="#使用-children-替代-render" class="headerlink" title="使用 children 替代 render"></a>使用 children 替代 render</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Mouse</span>&gt;</span><br><span class="line">  &#123; &#123;(x,y)&#125; =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标的位置: &#123;x&#125;,&#123;y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> &#125;</span><br><span class="line">&lt;/<span class="title class_">Mouse</span>&gt;</span><br><span class="line"><span class="comment">// 组件内部,见上面</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">children</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ol>
<li>使用 propTypes 进行校验</li>
<li>将事件绑定解除</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Mouse</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">children</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HOC-高阶组件"><a href="#HOC-高阶组件" class="headerlink" title="HOC 高阶组件"></a>HOC 高阶组件</h2><p>目的: 实现逻辑复用<br>方法: 采用包装(装饰)模式<br>思路: 实际上是一个函数,接收要包装的组件,返回增强后的组件<br>方法: 内部创建一个类组件,在类组件内提供复用的状态逻辑代码,通过 prop 将复用的状态传递给被包装的组件.<br>使用场景: 比如暗黑模式.将组件进行包裹.</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>创建一个函数,名称约定以<code>with</code>开头.</li>
<li>指定函数参数,参数以首字母大写开头</li>
<li>在函数内部创建一个类组件,提供复用的状态逻辑代码</li>
<li>在该组件,渲染参数组件,同时将状态通过 prop 传递给参数组件</li>
<li>调用该高阶组件,传入要增强的组件,通过返回值拿到增强后的组件,并将其渲染到页面上</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">//声明高阶组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withMouse</span>(<span class="params">wrappedComponent</span>) &#123;</span><br><span class="line">  <span class="comment">//创建类组件</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">      <span class="comment">//在这里提供提供复用的代码和state</span></span><br><span class="line">        state = &#123;</span><br><span class="line">            x = <span class="number">0</span>,</span><br><span class="line">            y = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">x</span>: e.<span class="property">clientX</span>,</span><br><span class="line">                <span class="attr">y</span>: clientY</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">//将内部的state放到包裹的组件上</span></span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">wrappedComponent</span> &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//返回出这个类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Mouse</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Position</span> = props =&gt; &#123;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标位置: &#123;props.x&#125;, &#123;props.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Cat</span> =(<span class="params">props</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">postion:</span> &#x27;<span class="attr">absolute</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">top:</span> <span class="attr">props.y</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">left:</span> <span class="attr">props.x</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &#125;&#125; /&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用高阶组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MousePosition</span> = <span class="title function_">withMouse</span>(<span class="title class_">Position</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MouseCat</span> = <span class="title function_">withMouse</span>(<span class="title class_">Cat</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>高阶组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">MousePosition</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">           			<span class="tag">&lt;<span class="name">MouseCat</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置-display-Name"><a href="#设置-display-Name" class="headerlink" title="设置 display Name"></a>设置 display Name</h3><p>原因: 默认情况,React 使用组件名作为 displayName,则会出现两个名字相同的情况<br>方法: 设置 displayName,便以区分.注意名字首字母大写.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withMouse</span>(<span class="params">wrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在高阶组件内设置displayName,注意首字母大写</span></span><br><span class="line">  <span class="title class_">Mouse</span>.<span class="property">displayName</span> = <span class="string">`WithMouse<span class="subst">$&#123;getDisplayName(wrappedComponent)&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mouse</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置获取名称方法,注意首字母大写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDisplayName</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span>.<span class="property">displayName</span> || <span class="title class_">WrappedComponent</span>.<span class="property">name</span> || <span class="string">&quot;Component&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传递-props"><a href="#传递-props" class="headerlink" title="传递 props"></a>传递 props</h3><p>将 props 和 state 一起放在返回的组件上</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">wrappedComponent</span> &#123;<span class="attr">...state</span>&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="DOM-元素"><a href="#DOM-元素" class="headerlink" title="DOM 元素"></a>DOM 元素</h2><p>渲染文章时防止 XSS 攻击,使用特殊的写法<code>dangerouslySetInnerHTML=&#123;&#123;__html:'文章内容'&#125;&#125;</code></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Content</span>&gt;</span><br><span class="line">  &#123;contentData &amp;&amp;</span><br><span class="line">    contentData.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span> <span class="attr">__html:</span> <span class="attr">item</span> &#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    ))&#125;</span><br><span class="line">&lt;/<span class="title class_">Content</span>&gt;</span><br></pre></td></tr></table></figure>

<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><ul>
<li>jsx 上写的事件没有绑定在真实 DOM 上,而是通过事件代理的方式绑定在 document 上.</li>
<li>冒泡到 document 上的也不是原生事件,而是合成事件.如果不想冒泡,需要使用<code>event.preventDefault</code>,不能使用<code>event.stopPropagation</code>.</li>
<li>合成事件是有个专门的事件池来管理它们的创建和销毁.当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/09/Taro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/09/Taro/" class="post-title-link" itemprop="url">Taro</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-09 14:12:04" itemprop="dateCreated datePublished" datetime="2021-03-09T14:12:04+08:00">2021-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:29" itemprop="dateModified" datetime="2023-05-13T09:03:29+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="新项目启动"><a href="#新项目启动" class="headerlink" title="新项目启动"></a>新项目启动</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局安装taro</span></span><br><span class="line">npm i -g @tarojs/cli</span><br><span class="line"><span class="comment">// 项目初始化</span></span><br><span class="line">taro init appName</span><br></pre></td></tr></table></figure>

<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><p>需要下载微信小程序开发工具，使用工具打开 taro 项目根目录。</p>
<h2 id="老项目更新依赖"><a href="#老项目更新依赖" class="headerlink" title="老项目更新依赖"></a>老项目更新依赖</h2><p>老项目在新 taro 框架,需要更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taro update project</span><br></pre></td></tr></table></figure>

<p>Taro3 和老版本引入有差别</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Taro</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Taro3新版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Taro</span> <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="挂载-App-js"><a href="#挂载-App-js" class="headerlink" title="挂载 App.js"></a>挂载 App.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老版本app.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Taro</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Index</span> <span class="keyword">from</span> <span class="string">&quot;./pages/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./app.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">//config写到app的类里.</span></span><br><span class="line">  <span class="comment">//新版写到单独的app.config.js文件里</span></span><br><span class="line">  config = &#123;</span><br><span class="line">    <span class="attr">pages</span>: [</span><br><span class="line">      <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pages/nodes/nodes&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pages/hot/hot&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pages/node_detail/node_detail&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pages/thread_detail/thread_detail&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">tabBar</span>: &#123;</span><br><span class="line">      <span class="attr">list</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">iconPath</span>: <span class="string">&quot;resource/latest.png&quot;</span>,</span><br><span class="line">          <span class="attr">selectedIconPath</span>: <span class="string">&quot;resource/lastest_on.png&quot;</span>,</span><br><span class="line">          <span class="attr">pagePath</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">          <span class="attr">text</span>: <span class="string">&quot;最新&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">iconPath</span>: <span class="string">&quot;resource/hotest.png&quot;</span>,</span><br><span class="line">          <span class="attr">selectedIconPath</span>: <span class="string">&quot;resource/hotest_on.png&quot;</span>,</span><br><span class="line">          <span class="attr">pagePath</span>: <span class="string">&quot;pages/hot/hot&quot;</span>,</span><br><span class="line">          <span class="attr">text</span>: <span class="string">&quot;热门&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">iconPath</span>: <span class="string">&quot;resource/node.png&quot;</span>,</span><br><span class="line">          <span class="attr">selectedIconPath</span>: <span class="string">&quot;resource/node_on.png&quot;</span>,</span><br><span class="line">          <span class="attr">pagePath</span>: <span class="string">&quot;pages/nodes/nodes&quot;</span>,</span><br><span class="line">          <span class="attr">text</span>: <span class="string">&quot;节点&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&quot;#000&quot;</span>,</span><br><span class="line">      <span class="attr">selectedColor</span>: <span class="string">&quot;#56abe4&quot;</span>,</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">      <span class="attr">borderStyle</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">window</span>: &#123;</span><br><span class="line">      <span class="attr">backgroundTextStyle</span>: <span class="string">&quot;light&quot;</span>,</span><br><span class="line">      <span class="attr">navigationBarBackgroundColor</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">      <span class="attr">navigationBarTitleText</span>: <span class="string">&quot;V2EX&quot;</span>,</span><br><span class="line">      <span class="attr">navigationBarTextStyle</span>: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//return的是首页.</span></span><br><span class="line">  <span class="comment">//新版本return的是this.prop.children</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line">      <span class="comment">//  return this.props.children</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//老版本使用Taro.render挂载到app节点上</span></span><br><span class="line"><span class="comment">//新版本直接export default App</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Taro</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>));</span><br><span class="line"><span class="comment">//export default App</span></span><br></pre></td></tr></table></figure>

<h3 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h3><p><code>taro-UI</code>  的样式可以按需引入.</p>
<p>研究多 tab 页报错问题，路径地址写错了</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>小程序的跳转<code>Taro.navigateTo</code>.<br>H5 的跳转是从<code>@tarojs/router</code>中引入<code>navigateTo</code>.</p>
<h2 id="路由声明"><a href="#路由声明" class="headerlink" title="路由声明"></a>路由声明</h2><p>路由在 <code>@tarojs/taro</code>  中的 <code>getCurrentInstance().router 中获取.</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  current = <span class="title function_">getCurrentInstance</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// getCurrentInstance().router 和 this.$router 和属性一样</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">router</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router &#125; = <span class="title function_">getCurrentInstance</span>();</span><br><span class="line">  <span class="comment">// getCurrentInstance().router 和 useRouter 返回的内容也一样</span></span><br><span class="line">  <span class="comment">// const router = useRouter()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由参数获取"><a href="#路由参数获取" class="headerlink" title="路由参数获取"></a>路由参数获取</h2><p>原生小程序路由一般在 <code>onLoad</code>  中获取传过来的参数.<br><code>Taro</code>  推荐在 <code>ComponentDidShow</code>  中获取.(也可以在 <code>onLoad</code>  中)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js 项目入口文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  componentDidShow (options <span class="comment">/* 这里有你想要的路由信息 */</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>小程序 &#x3D;&gt; class 类 &#x3D;&gt; 函数式 hook<br>onLoad &#x3D;&gt; onLoad<br>onReady &#x3D;&gt; onReady &#x3D;&gt; useReady<br>onLanch &#x3D;&gt; onLanch<br>onShow &#x3D;&gt; conponentDidShow &#x3D;&gt; useDidShow<br>onHide &#x3D;&gt;componentDidHide &#x3D;&gt; useDidHide</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h4 id="onPullDownRefresh"><a href="#onPullDownRefresh" class="headerlink" title="onPullDownRefresh()"></a>onPullDownRefresh()</h4><p>监听用户下拉动作。</p>
<p>需要在全局配置的  window  选项中或页面配置中设置  enablePullDownRefresh: true。<br>可以通过  Taro.startPullDownRefresh  触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。<br>当处理完数据刷新后，Taro.stopPullDownRefresh  可以停止当前页面的下拉刷新.</p>
<h4 id="onReachBottom"><a href="#onReachBottom" class="headerlink" title="onReachBottom()"></a>onReachBottom()</h4><p>监听用户上拉触底事件。</p>
<p>可以在全局配置的  window  选项中或页面配置中设置触发距离  onReachBottomDistance。<br>在触发距离内滑动期间，本事件只会被触发一次</p>
<blockquote>
<p>H5  暂时没有同步实现，可以通过给  window  绑定  scroll  事件来进行模拟</p>
</blockquote>
<h4 id="onPageScroll"><a href="#onPageScroll" class="headerlink" title="onPageScroll()"></a>onPageScroll()</h4><p>监听用户滑动页面事件.</p>
<blockquote>
<p>H5  暂时没有同步实现，可以通过给  window  绑定  scroll  事件来进行模拟</p>
</blockquote>
<h3 id="基本事件"><a href="#基本事件" class="headerlink" title="基本事件"></a>基本事件</h3><p>在  Taro  中事件遵从小驼峰式（camelCase）命名规范，所有内置事件名以  on  开头。</p>
<p>在事件回调函数中，第一个参数是事件本身，回调中调用  stopPropagation  可以阻止冒泡。</p>
<blockquote>
<p>只有小程序的  bindtap  对应  Taro  的  onClick<br>其余小程序事件名把  bind  换成  on  即是  Taro  事件名</p>
</blockquote>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>安装 redux 及其中间件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add redux react-redux redux-thunk redux-logger</span><br><span class="line"><span class="comment"># 或者使用 npm</span></span><br><span class="line">$ npm install --save redux react-redux redux-thunk redux-logger</span><br></pre></td></tr></table></figure>

<p>随后可以在项目  src  目录下新增一个  store  目录，在目录下增加  index.js  文件用来配置  store，按自己喜好设置  redux  的中间件，例如下面例子中使用  redux-thunk  和  redux-logger  这两个中间件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&quot;../reducers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable language_">window</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span></span><br><span class="line">    ? <span class="variable language_">window</span>.<span class="title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;</span><br><span class="line">        <span class="comment">// Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize...</span></span><br><span class="line">      &#125;)</span><br><span class="line">    : compose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [thunkMiddleware];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;development&quot;</span> &amp;&amp;</span><br><span class="line">  process.<span class="property">env</span>.<span class="property">TARO_ENV</span> !== <span class="string">&quot;quickapp&quot;</span></span><br><span class="line">) &#123;</span><br><span class="line">  middlewares.<span class="title function_">push</span>(<span class="built_in">require</span>(<span class="string">&quot;redux-logger&quot;</span>).<span class="title function_">createLogger</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = <span class="title function_">composeEnhancers</span>(</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(...middlewares)</span><br><span class="line">  <span class="comment">// other store enhancers if any</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">configStore</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer, enhancer);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在项目入口文件  app.js  中使用  redux  中提供的  Provider  组件将前面写好的  store  接入应用中.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们要使用 Redux</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> configStore <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./app.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configStore</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 可以使用所有的 React 组件方法</span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onLaunch</span></span><br><span class="line">  <span class="title function_">onLaunch</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onShow</span></span><br><span class="line">  <span class="title function_">componentDidShow</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onHide</span></span><br><span class="line">  <span class="title function_">componentDidHide</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在入口组件不会渲染任何内容，但我们可以在这里做类似于状态管理的事情</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        /* this.props.children 是将要被渲染的页面 */</span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>然后就可以开始使用了。如  redux  推荐的那样，可以增加</p>
<ul>
<li>constants  目录，用来放置所有的  action type  常量</li>
<li>actions  目录，用来放置所有的  actions</li>
<li>reducers  目录，用来放置所有的  reducers</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/Koa2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/Koa2/" class="post-title-link" itemprop="url">Koa2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-28 09:57:58" itemprop="dateCreated datePublished" datetime="2021-02-28T09:57:58+08:00">2021-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:29" itemprop="dateModified" datetime="2023-05-13T09:03:29+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Koa 本质上是调用一系列的中间件，来处理对应的请求，并决定是否传递到下一个中间件去处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa --save</span><br></pre></td></tr></table></figure>

<p>所以，接口的本质，就是判断不同的请求链接，干不同的事情，返回相应的结果。那么我们得需要一个路由中间件来处理分发请求。<br>使用 <code>koa-router</code>  处理路由.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa-router --save</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址跳转</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;这是主页&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/user&quot;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;这是user页&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这里koa不会去处理数据,需要使用中间件body-parse</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/post&quot;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;async&quot;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">sleep</span> = <span class="keyword">async</span> (<span class="params">ms</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">      &#125;, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  ctz.<span class="property">body</span> = <span class="string">`这是异步网页`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>()).<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use(ctx =&gt; &#123;</span></span><br><span class="line"><span class="comment">// 	ctx.body = `您的网址为:$&#123;ctx.request.url&#125;`</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>安装 <code>body-parse</code> .</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa-bodyparser --save</span><br></pre></td></tr></table></figure>

<h2 id="业务分离"><a href="#业务分离" class="headerlink" title="业务分离"></a>业务分离</h2><p>改造后目录结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-koa2 - node_modules - controller;</span><br><span class="line">user.<span class="property">js</span> - index.<span class="property">js</span> - router.<span class="property">js</span> - package.<span class="property">json</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&quot;./router&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;koa-bodparser&quot;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>()).<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/26/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/26/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-26 11:26:53" itemprop="dateCreated datePublished" datetime="2021-02-26T11:26:53+08:00">2021-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-13 09:03:29" itemprop="dateModified" datetime="2023-05-13T09:03:29+08:00">2023-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>拉取镜像<br><code>docker pull image</code> <br>根据镜像创建使用该镜像的容器<br><code>docker run -di --name mycentos centos:7</code></p>
<h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><p>当前运行的容器<br><code>docker ps</code></p>
<h2 id="Dockerflie"><a href="#Dockerflie" class="headerlink" title="Dockerflie"></a>Dockerflie</h2><p><code>docker image build</code>  会读取 dockerfile,并将应用容器化.<br>Dockerfile  由一行行命令语句组成，并支持以  #  开头的注释行.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># <span class="title class_">Test</span> web-app to use <span class="keyword">with</span> <span class="title class_">Pluralsight</span> courses and <span class="title class_">Docker</span> <span class="title class_">Deep</span> <span class="title class_">Dive</span> book</span><br><span class="line"># <span class="title class_">Linux</span> x64</span><br><span class="line"><span class="variable constant_">FROM</span> alpine</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">LABEL</span> maintainer=<span class="string">&quot;nigelpoulton@hotmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="title class_">Install</span> <span class="title class_">Node</span> and <span class="variable constant_">NPM</span></span><br><span class="line"><span class="variable constant_">RUN</span> apk add --update nodejs nodejs-npm</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Copy</span> app to /src</span><br><span class="line"><span class="variable constant_">COPY</span> . /src</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">WORKDIR</span> /src</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Install</span> dependencies</span><br><span class="line"><span class="variable constant_">RUN</span>  npm install</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">ENTRYPOINT</span> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;./app.js&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>使用  -t  参数为镜像打标签，使用  -f  参数指定  Dockerfile  的路径和名称，使用  -f  参数可以指定位于任意路径下的任意名称的  Dockerfile。</p>
<p>构建上下文是指应用文件存放的位置，可能是本地  Docker  主机上的一个目录或一个远程的  Git  库。</p>
<p>Dockerfile  中的  FROM  指令用于指定要构建的镜像的基础镜像。它通常是  Dockerfile  中的第一条指令。</p>
<p>Dockerfile  中的  RUN  指令用于在镜像中执行命令，这会创建新的镜像层。每个  RUN  指令创建一个新的镜像层。</p>
<p>Dockerfile  中的  COPY  指令用于将文件作为一个新的层添加到镜像中。通常使用  COPY  指令将应用代码赋值到镜像中。</p>
<p>Dockerfile  中的  EXPOSE  指令用于记录应用所使用的网络端口。</p>
<p>Dockerfile  中的  ENTRYPOINT  指令用于指定镜像以容器方式启动后默认运行的程序。</p>
<p>其他的  Dockerfile  指令还有  LABEL、ENV、ONBUILD、HEALTHCHECK、CMD  等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zax Tseng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
