<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="ZAX">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="ZAX">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zax Tseng">
<meta property="article:tag" content="javascript, React, Vue, HTML5">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZAX</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZAX</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zax Tseng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/JS%E8%A1%A5%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/22/JS%E8%A1%A5%E6%A1%A3/" class="post-title-link" itemprop="url">JS补档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-22 11:31:39" itemprop="dateCreated datePublished" datetime="2021-03-22T11:31:39+08:00">2021-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:55" itemprop="dateModified" datetime="2022-11-01T18:08:55+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="var-let-const-区别"><a href="#var-let-const-区别" class="headerlink" title="var,let,const 区别"></a>var,let,const 区别</h1><p><code>var</code>的作用域是方法作用域,声明之前变量是 undefined.可以重复声明.<br><code>let</code>的作用域是块级作用域.在声明之前使用会报错,禁止重复声明.<br><code>const</code>是常量声明方式,声明变量时必须初始化,后面不再修改该常量的值.(声明时必须赋值)<br><code>const</code> 不是变量的值不能改动,而是变量指向的那个内存地址不能改动.</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>ES2015 前，ES 只有两种作用域，分别是全局作用域和函数作用域；在 ES2015 中新增了一个块级作用域.<br>以前块没有独立的作用域，所以在块中定义的变量，块的外面也可以访问，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br></pre></td></tr></table></figure>

<p>这对于代码是非常不利的、不安全的，有了块级作用域，可以通过新的关键字 let 去声明变量，用法跟传统一样，只是 let 声明的变量只能在声明的代码块中使用，外部无法访问的，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// foo is not defined</span></span><br></pre></td></tr></table></figure>

<h1 id="undefined-和-null-区别"><a href="#undefined-和-null-区别" class="headerlink" title="undefined 和 null 区别"></a>undefined 和 null 区别</h1><p>undefined 是未定义的值,是变量最原始的状态<br>null 是人为声明为空的值.希望表示** 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。** 在内存里的表示就是，栈中的变量没有指向堆中的内存对象</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>我的理解: 函数内部包含存在外部作用域的变量,且调用这个函数就形成闭包.<br>单纯有个函数算闭包环境,被调用了,所使用的外部变量也就无法释放了,这才形成闭包.<br>注意闭包的函数是 return 出来的.不 return 也可以产生闭包.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="keyword">return</span> (i += n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> cb = <span class="title function_">main</span>(result);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cb</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cb</span>(<span class="number">3</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="comment">// 形参i存在当前作用域</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="comment">// 相当于</span></span><br><span class="line">    i = i + n;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cb(2)时,先打印10,注意function(n)已经是闭包了,i经过计算变为12,但是没有释放.</span></span><br><span class="line"><span class="comment">// cb(3)时,先打印12, i因为闭包没有释放依旧是12, 再计算后是15.</span></span><br><span class="line"><span class="comment">// result 一直未被修改还是10.</span></span><br></pre></td></tr></table></figure>

<p>位于全局作用域的闭包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      total += i * a;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(total);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tip：这里也形成了闭包。total 被外层引用没有被销毁。</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line">result[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">result[<span class="number">1</span>](); <span class="comment">// 6</span></span><br><span class="line">result[<span class="number">2</span>](); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>疑问:下面这个算闭包吗,答:不算,把 var 换成 let 就算闭包了.<br>for 循环不是函数，所以 i 是全局作用域中的变量。<br>如果换成 let,其实内部也是闭包的机制，当 onclick 执行是循环早已执行完毕，i 早已销毁，因为闭包的机制我们才能拿到 i 对应的值.也就是说循环的 i 已经完事了,但是块级作用域的 i 还在.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"><span class="comment">//data是数组,数组中存储的是函数,函数中的i其实早已为3,打印出来都是3</span></span><br><span class="line"><span class="comment">//为什么输出3 ？</span></span><br><span class="line"><span class="comment">//因为在执行函数的时候 i 已经完成遍历了,</span></span><br><span class="line"><span class="comment">//data[i]执行后寻找i, 内部没有，向上寻找，这时i 是全局变量, 并且此时的值为3</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 暂时取名 fn</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;; <span class="comment">// i是自由变量，所以这是一个闭包</span></span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"><span class="comment">//在data[0]执行，即fn执行，此时的全局变量 i依旧是 3(但跟fn中的i无关)</span></span><br><span class="line"><span class="comment">//fn内部没有i，向上查找, 找到在for内，匿名函数传进来的i值0，它依旧存在在内存中。</span></span><br><span class="line"><span class="comment">//所以到此不会再向上去到全局作用域中查找。所以此时会打印 0</span></span><br></pre></td></tr></table></figure>

<p>局部变量：在函数中声明，且在函数返回后不会被其他作用域所使用的对象。下面代码中的 local* 都是局部变量。（scopes 是一块堆内存）<br>全局变量 ,在浏览器上为 window ，在 node 里为 global。全局变量会被默认添加到函数作用域链的最底端，也就是上述函数中 [[Scopes]] 中的最后一个，可以看下上面局部变量例子中 Scopes 的最后一个。</p>
<p>var：全局的 var 变量其实仅仅是为 global 对象添加了一条属性。<br>let &#x2F; const：全局的 let&#x2F;const 变量不会修改 window 对象，而是将变量的声明放在了一个特殊的对象下（与 Scope 类似）。<br>被捕获变量就是局部变量的反面：在函数中声明，但在函数返回后仍有未执行作用域（函数或是类）使用到该变量，那么该变量就是被捕获变量。</p>
<h2 id="一般如何产生闭包"><a href="#一般如何产生闭包" class="headerlink" title="一般如何产生闭包"></a>一般如何产生闭包</h2><ul>
<li>返回函数</li>
<li>函数当做参数传递</li>
</ul>
<p>函数科里化是一种闭包.</p>
<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><h2 id="如果是-var-声明-for-循环不是函数，所以-i-是全局作用域中的变量。"><a href="#如果是-var-声明-for-循环不是函数，所以-i-是全局作用域中的变量。" class="headerlink" title="如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。"></a>如果是 var 声明,for 循环不是函数，所以 i 是全局作用域中的变量。</h2><p>使用 let 关键字时会产生块级作用域，for 每次循环的大括号都是一个独立的块级作用域，由于后面还要用到 i ,所以这几个块级作用域都不会销毁。<br>elements[0].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 0<br>elements[1].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 1<br>elements[2].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 2<br>elements[3].onclick &#x3D; function() { alert(i); } &#x2F;&#x2F; 在此块级作用域中，i &#x3D; 3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> length = element.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  element[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><blockquote>
<p>for &gt; for-of &gt; forEach &gt; map &gt; for-in</p>
</blockquote>
<ul>
<li><code>for</code> 循环当然是最简单的，因为它没有任何额外的函数调用栈和上下文；</li>
<li><code>for...of</code>只要具有 Iterator 接口的数据结构，都可以使用它迭代成员。它直接读取的是键值。</li>
<li><code>forEach</code>，因为它其实比我们想象得要复杂一些，它实际上是 array.forEach(function(currentValue, index, arr), thisValue)它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</li>
<li><code>map()</code> 最慢，因为它的返回值是一个等长的全新的数组，数组创建和赋值产生的性能开销很大。</li>
<li><code>for...in</code>需要穷举对象的所有属性，包括自定义的添加的属性也能遍历到。且 for…in 的 key 是 String 类型，有转换过程，开销比较大。</li>
</ul>
<p>如果你需要将数组按照某种规则映射为另一个数组，就应该用 map。<br>如果你需要进行简单的遍历，用 forEach 或者 for of。<br>如果你需要对迭代器进行遍历，用 for of。<br>如果你需要过滤出符合条件的项，用 filterr。<br>如果你需要先按照规则映射为新数组，再根据条件过滤，那就用一个 map 加一个 filter</p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>是 ES5 版本发布的。以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性。<br>迭代数组时,<code>for...in</code>是下标,<code>for...of</code>是值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line"><span class="keyword">let</span> profile = &#123;<span class="attr">name</span>:<span class="string">&quot;April&quot;</span>,<span class="attr">nickname</span>:<span class="string">&quot;二十七刻&quot;</span>,<span class="attr">country</span>:<span class="string">&quot;China&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> profile)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = profile[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 对象的键值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 对象的键对应的值</span></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 数组下标所对应的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 索引，数组下标</span></span><br><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> str)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = str[i];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 字符串下标所对应的元素</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 索引 字符串的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>我是 ES6 版本发布的。在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代数组数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 迭代字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// logs &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// 迭代map</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;a&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">2</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs [&quot;a&quot;, 1]</span></span><br><span class="line"><span class="comment">// logs [&quot;b&quot;, 2]</span></span><br><span class="line"><span class="comment">// logs [&quot;c&quot;, 3]</span></span><br><span class="line"><span class="comment">// 迭代map获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代set</span></span><br><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs 1</span></span><br><span class="line"><span class="comment">// logs 2</span></span><br><span class="line"><span class="comment">// logs 3</span></span><br><span class="line"><span class="comment">// logs 4</span></span><br><span class="line"><span class="comment">// 迭代 DOM 节点</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.article &gt; p&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> paragraph <span class="keyword">of</span> articleParagraphs) &#123;</span><br><span class="line">    paragraph.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;paragraph&quot;</span>);</span><br><span class="line">    <span class="comment">// 给class名为“article”节点下的 p 标签添加一个名为“paragraph” class属性。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代arguments类数组对象</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(argument);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// logs：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 迭代类型数组</span></span><br><span class="line"><span class="keyword">let</span> typeArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> typeArr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// logs：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 255</span></span><br></pre></td></tr></table></figure>

<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>高阶函数： 函数可以作为参数传递 &amp;&amp; 函数可以作为返回值输出<br>柯里化(Currying): 把接受多个参数的函数变换成接受一个单一参数（或部分）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>示例:<br>编写一个 add 函数,使得 add(1,2)和 add(1)(2)都可以执行,并返回 3.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要判断参数值的长度</span></span><br><span class="line"><span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span> ? <span class="function"><span class="params">b</span> =&gt;</span> a + b : a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string-和-String-的区别"><a href="#string-和-String-的区别" class="headerlink" title="string 和 String 的区别"></a>string 和 String 的区别</h2><p>String 是包装类,是一个特殊的 object.<br>也就是说当不用 new 的时候，String(…) &#x3D;&#x3D;&#x3D; toString(…)</p>
<h2 id="new-String-和-String-区别"><a href="#new-String-和-String-区别" class="headerlink" title="new String() 和 String()区别"></a>new String() 和 String()区别</h2><p>我们知道 new 关键字的过程涉及到新对象的创建，所以，new String(str)的结果返回的一个新的 String 实例，所以，b 和 b2 保存的是两个对象的引用，他们的引用地址不一样，直接比较的话，逻辑引用类型的比较是一样的，结果就是不相等。</p>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> 条件<span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满足条件1&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 条件<span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;满足条件2&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;和上两个条件都不相等&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expression</code>  中是可能变化的量,变化的可能性有三种,条件 1,2,和不满足条件 12 的其他种类.</p>
<p>空数组 push 后,再次调用记得赋值为空.</p>
<h2 id="map-和-forEach"><a href="#map-和-forEach" class="headerlink" title="map 和 forEach"></a>map 和 forEach</h2><p>map 返回处理后的新数组,而不是原数组的处理.原数组是不变的.</p>
<blockquote>
<p>能用 forEach()做到的，map()同样可以。反过来也是如此。<br>map()会分配内存空间存储新数组并返回，forEach()不会返回数据。<br>forEach()允许 callback 更改原始数组的元素。map()返回新的数组。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;10:00.000&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;11:00.000&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">time</span>: <span class="string">&quot;12:00.000&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> listMap = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">time</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//listMap返回时被处理的时间的字符串数组,原数组list没有变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(listMap); <span class="comment">//[&quot;10:00&quot;, &quot;11:00&quot;, &quot;12:00&quot;]</span></span><br><span class="line"><span class="keyword">let</span> listMap2 = list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span></span><br><span class="line">  item.<span class="property">time</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//forEach不返回新数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(listMap2); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="数组返回"><a href="#数组返回" class="headerlink" title="数组返回"></a>数组返回</h2><p>注意: <code>map</code>,<code>filter</code>,<code>find</code>,<code>findIndex</code>等必须要<code>return</code>才能生效.</p>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Max&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Jane&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">groupBy</span>(<span class="params">objectArray, property</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> objectArray.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acc, obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = obj[property];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!acc[key]) &#123;</span><br><span class="line">      acc[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].<span class="title function_">push</span>(obj);</span><br><span class="line">    <span class="comment">// console.log(acc)</span></span><br><span class="line">    <span class="comment">//这里acc[key]是value,也就是value里push</span></span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> groupedPeople = <span class="title function_">groupBy</span>(people, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">// groupedPeople is:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   20: [</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Max&#x27;, age: 20 &#125;,</span></span><br><span class="line"><span class="comment">//     &#123; name: &#x27;Jane&#x27;, age: 20 &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   21: [&#123; name: &#x27;Alice&#x27;, age: 21 &#125;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象类型的指针问题"><a href="#对象类型的指针问题" class="headerlink" title="对象类型的指针问题"></a>对象类型的指针问题</h2><p>js 中，参数传递只有一种规则:按值传递，基于值的复制。原始类型复制的是值本身，所以这两份数据互不影响；引用类型复制的是引用值，所以形参和实参指向同一个对象，通过一个饮用修改了对象，那么通过另外一个引用访问的对象就是修改后的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  person.<span class="property">age</span> = <span class="number">26</span>;</span><br><span class="line">  person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yyy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yck&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">test</span>(p1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// -&gt; ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// -&gt; ?</span></span><br></pre></td></tr></table></figure>

<p>解释:<br><code>p1</code> &#x3D;&gt;指向对象<code>&#123;name:&#39;yck&#39;,age:25&#125;</code>的指针<code>00001</code>.<br><code>test(p1)</code>传指针,<code>person.age = 26</code>修改该对象.此时<code>p1 = &#123;name: &#39;yck&#39;, age:26&#125;</code><br>接下来要给<code>person</code>重新赋值,但是<code>person</code>指向<code>p1</code>的指针被覆盖,重新开辟一块内存,新的指针<code>00002</code>.<br><code>person</code>拥有一个新的地址.<code>person = &#123;name: &#39;yyy&#39;, age: 30&#125;</code>.返回出来.</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非(!)"></a>逻辑非(<code>!</code>)</h2><p>逻辑非的规则:<br>操作数能被转化为<code>true</code>的,都返回<code>false</code>.否则返回<code>true</code>.<br>举例:<br>下面都被转换成<code>false</code>:<br><code>null</code>,<code>NaN</code>,<code>0</code>, <code>&#39;&#39;</code>,<code>undefined</code>.<br>所以遇到<code>!</code>会取反转为<code>true</code>.</p>
<blockquote>
<p>遇到对象会返回<code>false</code>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">!a == <span class="literal">false</span>; <span class="comment">// 字符串取反,就是false, 所以判断结果为true</span></span><br><span class="line">a == <span class="literal">false</span>; <span class="comment">// 使用==转化false为0, &quot;0&quot;和0比较,&quot;0&quot;被转化为0,结果为true</span></span><br><span class="line">a == <span class="number">0</span>; <span class="comment">//跟上一条一样</span></span><br></pre></td></tr></table></figure>

<h2 id="双逻辑非"><a href="#双逻辑非" class="headerlink" title="双逻辑非(!!)"></a>双逻辑非(!!)</h2><p>用于始终返回<code>true</code>或者<code>false</code><br>比如<code>!!undefined</code>返回<code>false</code>,否则直接会返回<code>undefined</code>.</p>
<h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><p><code>&lt;&lt;</code>:左偏移,将数值转换为二进制,然后向左偏移多少位.<br><code>|</code>:按位或.按照二进制转换后,位数有则计算.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//二进制: 0000 0001 =&gt; 左偏移1位 =&gt; 0000 0010 =&gt; 2</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">//二进制: 0000 0010 =&gt; 左偏移2位 =&gt; 0000 1000 =&gt; 8</span></span><br><span class="line"><span class="keyword">let</span> c = a | b;</span><br><span class="line"><span class="comment">//二进制: 0000 0010</span></span><br><span class="line"><span class="comment">//二进制: 0000 1000 =&gt; 0000 1010 =&gt;10</span></span><br></pre></td></tr></table></figure>

<h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a><code>in</code>运算符</h2><p>指定的属性在指定的对象或其原型链中,则<code>in</code>运算符返回 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;redwood&quot;</span>, <span class="string">&quot;bay&quot;</span>, <span class="string">&quot;cedar&quot;</span>, <span class="string">&quot;oak&quot;</span>, <span class="string">&quot;maple&quot;</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees; <span class="comment">// 返回false</span></span><br><span class="line"><span class="string">&quot;bay&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// 返回false (必须使用索引号,而不是数组元素的值)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;length&quot;</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true (length是一个数组属性)</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="property">iterator</span> <span class="keyword">in</span> trees; <span class="comment">// 返回true (数组可迭代，只在ES2015+上有效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置对象</span></span><br><span class="line"><span class="string">&quot;PI&quot;</span> <span class="keyword">in</span> <span class="title class_">Math</span>; <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> mycar = &#123; <span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>, <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>, <span class="attr">year</span>: <span class="number">1998</span> &#125;;</span><br><span class="line"><span class="string">&quot;make&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// 返回true</span></span><br><span class="line"><span class="string">&quot;model&quot;</span> <span class="keyword">in</span> mycar; <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure>

<p>如果只是将一个属性值赋值为<code>undefined</code>,而没有删除,则<code>in</code>运算符仍然会返回 true.</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>原始类型: 除了 null 判断为 object,其他都正常.因为 null 是全零,被判断为 object.<br>引用类型: 除了函数显示<code>function</code>,其他都是<code>object</code>.</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>判断对象类型就可以用 instanceof,它会通过原型链判断.<br>但是原始类型就不行了.</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p><code>a++b</code>返回<code>aNaN</code>.因为<code>++b</code>返回<code>NaN</code>.</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p><code>undefined</code> 表示一个变量自然的、最原始的状态值，而 <code>null</code> 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 <code>undefined</code>，当需要释放一个对象时，直接赋值为 <code>null</code> 即可。<br><code>&#123; &#125;</code>是一个不完全空对象，原型链上有<code>Object</code>，<code>null</code>为原型链顶端，因此<code>Object.prototype.__proto__ === null</code>为 true。</p>
<p>null 是完全空对象，原型链也没有。</p>
<h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>this 的指向与函数声明无关,取决于函数调用.</p>
<ol>
<li>普通函数调用(<code>fn()</code>) -&gt; this 指向 window</li>
<li>对象方法调用(<code>xx.fn()</code>) -&gt; this 指向对象</li>
<li>构造函数调用(<code>new fn()</code>) -&gt; this 指向 new 创建的实例对象</li>
<li>匿名函数中的 this：匿名函数的执行具有全局性，则匿名函数中的 this 指向是 window，而不是调用该匿名函数的对象</li>
</ol>
<p>例如:<br><code>box.onclick = function()&#123;&#125;</code>这就属于对象方法调用,this 也就指向 box.</p>
<h2 id="箭头函数的-this"><a href="#箭头函数的-this" class="headerlink" title="箭头函数的 this"></a>箭头函数的 this</h2><ol>
<li>箭头函数中的 this 是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的；</li>
<li>箭头函数中的 this 指向父级作用域的执行上下文；（技巧：<strong>因为 javascript 中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定 this 的指向，则找到离箭头函数最近的 function，与该 function 平级的执行上下文中的 this 即是箭头函数中的 this</strong>）</li>
<li>箭头函数无法使用 apply、call 和 bind 方法改变 this 指向，因为其 this 值在函数定义的时候就被确定下来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">//此处的this即是箭头函数中的this</span></span><br><span class="line">  <span class="attr">getThis</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getThis</span>()(); <span class="comment">//obj</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">getThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">getThis</span>()(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h2><p>不同点:</p>
<ol>
<li>传参不同,call-&gt;多个参数,apply-&gt;数组,bind-&gt;就一个 this</li>
<li>执行机制不同: call,apply 立即执行,bind 不执行.</li>
</ol>
<p><code>call</code>的使用场景:<br><strong>检测数据类型:</strong></p>
<ol>
<li><code>typeof</code>,缺点:无法检测<code>null</code>,<code>array</code></li>
<li>使用<code>Object.prototype.toString.call()</code>.该方法会返回固定类型格式<code>[object type]</code>,其中 type 是类型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>

<p><strong>实现继承:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">uname</span> = uname;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">uname, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, uname, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;zhang&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son);</span><br></pre></td></tr></table></figure>

<p><code>apply</code>使用场景:<br><strong>类数组转真数组:</strong></p>
<p>ES5:上下文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line">newArr.<span class="property">push</span>.<span class="title function_">apply</span>(newArr, obj);</span><br></pre></td></tr></table></figure>

<p>ES6: <code>Array.from()</code><br>该方法可以将类数组直接转化为真数组.<br><strong>取数组最大值:</strong><br>ES5:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, arr);</span><br></pre></td></tr></table></figure>

<p>ES6:<code>Math.max(...arr)</code></p>
<p><code>bind</code>不会立即调用函数,而是得到一个修改<code>this</code>后的新函数.(一次修改,终身受用)<br>细节: 如果在 bind 后传递参数,参数也会绑定,但是调用函数所传参数就会失效了.<br><strong>修改不需要立即执行的函数:</strong><br>比如事件处理函数,定时器</p>
<p>如果对一个函数进行多次 bind，那么上下文会是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fn.<span class="title function_">bind</span>().<span class="title function_">bind</span>(a)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>();</span><br><span class="line">  &#125;.<span class="title function_">apply</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>

<p>无论<code>bind</code>多少次,this 永远指向第一次 bind.</p>
<ul>
<li>对于 new 的方式来说，this 被永远绑定在了实例上面，不会被任何方式改变 this</li>
<li>箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。<blockquote>
<p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo()这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p>
</blockquote>
</li>
</ul>
<h2 id="constructor-和原型对象-构造函数-实例对象"><a href="#constructor-和原型对象-构造函数-实例对象" class="headerlink" title="constructor 和原型对象,构造函数,实例对象"></a>constructor 和原型对象,构造函数,实例对象</h2><p><code>prototype</code>属于构造函数,指向原型对象. 作用:解决内存浪费和变量污染.<br><code>constructor</code>属于原型对象,指向构造函数.作用:可以让实例对象知道自己是被谁创建的.<br><code>__proto__</code>属于实例对象,指向原型对象.作用:实例对象访问原型对象的成员.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1664181323672-63ddb950-9558-4713-a12e-8889f0532fef.png#clientId=u84dfcbb8-1307-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=347&id=u3a5e30ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=573&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84467&status=done&style=none&taskId=u91ac1b2a-1524-4384-b47e-76f1a63fd50&title=&width=443" alt="image.png"></p>
<blockquote>
<p>如何方便理解三者关系,构造函数是父级,父级的 prototype(老婆)就是原型对象,原型对象的 constructor(老公)就是构造函数,子级实例对象的<strong>proto</strong>(母亲)就是原型对象.</p>
</blockquote>
<p>实例对象是无条件继承原型对象.<br>原型链的作用就是继承.也就说,js 是利用原型链实现面向对象继承的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>构造函数中的方法会导致内存的浪费.<br>两个实例对象虽然都可以调用 eat()方法,但是两个方法堆地址不同.每次调用函数都会在堆内存中生成一块新的空间.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/473454/1664200975310-09fb6834-6fd6-4750-86cb-09f1a5a63c5a.png#clientId=u0ca97a65-2fdb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=727&id=u04988d1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=727&originWidth=1437&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=422821&status=done&style=none&taskId=u2217fa30-5759-4ec2-8123-b745aacbe77&title=&width=1437" alt="image.png"><br>解决方法 1: 使用全局变量.即将函数在全局书写,在构造函数内赋值,也即只获取地址.<br>缺点: 导致变量污染.<br>解决方法 2: 使用对象将全局变量函数包裹,但是治标不治本.<br>最终解决方法: 原型对象.</p>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>原型对象是构造函数的默认属性 prototype 所指向的一个空对象.用于解决内存浪费和变量污染的问题.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="与-ES6-中继承的关系"><a href="#与-ES6-中继承的关系" class="headerlink" title="与 ES6 中继承的关系"></a>与 ES6 中继承的关系</h3><p>ES6 中继承的方法属于 ES5 的语法糖.</p>
<h3 id="instanceof-1"><a href="#instanceof-1" class="headerlink" title="instanceof"></a>instanceof</h3><p>用法:检测构造函数的原型在不在实例对象的原型链上.<br>arr 的原型链: arr -&gt;Array.prototype -&gt; Object.prototype -&gt; null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">//true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="literal">null</span>; <span class="comment">//typeError,右侧不是一个object</span></span><br></pre></td></tr></table></figure>

<h2 id="工厂函数和构造函数"><a href="#工厂函数和构造函数" class="headerlink" title="工厂函数和构造函数"></a>工厂函数和构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p = &#123;&#125;;</span><br><span class="line">  p.<span class="property">name</span> = name;</span><br><span class="line">  p.<span class="property">age</span> = age;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreatePerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new关键字调用的是构造函数</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">CreatePerson</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h3 id="new-的用途"><a href="#new-的用途" class="headerlink" title="new 的用途"></a>new 的用途</h3><p>首先创建一个空对象,然后将 this 指向这个空对象,然后赋值,最后将这个对象返回出去.</p>
<h3 id="new-的细节"><a href="#new-的细节" class="headerlink" title="new 的细节"></a>new 的细节</h3><ol>
<li>构造函数的首字母大写,为了提醒别人不要忘记 new 关键字</li>
<li>关于构造函数主动写 return.对于值类型,无效,还是返回 new 创建的对象,对于引用类型,会覆盖.</li>
</ol>
<h2 id="对象字面量-new-Object-Object-create-区别"><a href="#对象字面量-new-Object-Object-create-区别" class="headerlink" title="对象字面量,new Object(),Object.create()区别"></a>对象字面量,new Object(),Object.create()区别</h2><p>字面量和 new 关键字创建的对象是 Object 的实例，原型指向 Object.prototype，继承内置对象 Object<br>Object.create(arg, pro)创建的对象的原型取决于 arg，arg 为 null，新对象是空对象，没有原型，不继承任何对象；arg 为指定对象，新对象的原型指向指定对象，继承指定对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> company = &#123;</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;beijing&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> yideng = <span class="title class_">Object</span>.<span class="title function_">create</span>(company);</span><br><span class="line"><span class="keyword">delete</span> yideng.<span class="property">address</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yideng.<span class="property">address</span>);</span><br><span class="line"><span class="comment">// 写出执行结果，并解释原因</span></span><br><span class="line"><span class="comment">//beijing</span></span><br><span class="line"><span class="comment">//这里的 yideng 通过 prototype 继承了 company的 address。</span></span><br><span class="line"><span class="comment">//yideng自己并没有address属性。所以delete操作符的作用是无效的。</span></span><br><span class="line"><span class="comment">//yideng.address只是通过原型链去继承company的address</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>语法: <code>Object.assign(target, ...source)</code><br>解释: 将所有可枚举属性的值从一个或多个对象分配到目标对象.最后返回目标对象.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code>只能用于浅拷贝,无法用于深拷贝.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>对于这种就无法拷贝到对象 c.只能使用<code>JSON.parse(JSON.string(obj))</code>.<br>继承属性和不可枚举属性是不能被拷贝的.<br>原始类型会被包装,只有字符串的包装对象才可能有可枚举属性.</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>可以使用扩展运算符实现浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj &#125;;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>通常可以通过 JSON.parse(JSON.stringify(object))来解决。<br>缺点:<br>忽略<code>undefined</code>,<code>Symbol</code>,函数,循环引用对象.</p>
<h1 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h1><p>执行 JS 代码就是往执行栈中放函数.遇到异步代码就挂起,需要执行的时候放到 TASK 中(有多种 task).<br>执行栈空了之后,从 task 中拿出要执行的代码放到执行栈中执行.<br>所以本质上说,异步还是同步行为.</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>先执行同步代码,属于宏任务.<br>执行完后,执行栈空,查询是否有异步代码<br>执行微任务<br>执行微任务后,如有必要,会重新渲染页面<br>开始下一轮 Event loop,执行宏任务中的异步代码,</p>
<h2 id="TASK-微任务和宏任务"><a href="#TASK-微任务和宏任务" class="headerlink" title="TASK(微任务和宏任务)"></a>TASK(微任务和宏任务)</h2><p>在 ES6 中,微任务叫<code>jobs</code>,宏任务叫<code>task</code>.<br>微任务包括: <code>process.nextTick()</code>, <code>Promise</code>,<code>MutationObserver</code>.<br>宏任务包括: <code>script</code>,<code>setTimeout</code>, <code>setInterval</code>,<code>setImmediate</code>,<code>I/O</code>,<code>UI rendering</code>,DOM 事件,DOM 渲染,AJAX 请求.<br>而且微任务并非快于宏任务,因为宏任务包括<code>script</code>,浏览器会先执行一个宏任务,接下来有异步代码才会执行微任务.</p>
<p>微任务和宏任务之间隔了一个 DOM 渲染.<br>执行顺序:<br>微任务 &gt; DOM 渲染 &gt; 宏任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>(); <span class="comment">//2.回到这里,遇到await,让出线程,执行之后的代码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>); <span class="comment">//3. 当同步代码执行完毕,回到这里,</span></span><br><span class="line">  <span class="comment">//将resolve放到微任务队列中,执行后面then中的回调.在两次tick后执行这里的微任务.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2 end&quot;</span>); <span class="comment">//1.立即执行,执行完返回一个Promise</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="任务队列中-async-x2F-await-的运行机制"><a href="#任务队列中-async-x2F-await-的运行机制" class="headerlink" title="任务队列中 async&#x2F;await 的运行机制"></a>任务队列中 async&#x2F;await 的运行机制</h2><ul>
<li>async 定义的是一个 Promise 函数和普通函数一样只要不调用就不会进入事件队列。</li>
<li>async 内部如果没有主动 return Promise，那么 async 会把函数的返回值用 Promise 包装。</li>
<li>await 关键字必须出现在 async 函数中，await 后面不是必须要跟一个异步操作，也可以是一个普通表达式。</li>
<li>遇到 await 关键字，await 右边的语句会被立即执行然后 await 下面的代码进入等待状态，等待 await 得到结果。await 后面如果不是 promise 对象, await 会阻塞后面的代码，先执行 async 外面的同步代码，同步代码执行完，再回到 async 内部，把这个非 promise 的东西，作为 await 表达式的结果。await 后面如果是 promise 对象，await 也会暂停 async 后面的代码，先执行 async 外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</li>
</ul>
<p>await 后面的代码放不放到最后主要看,await 的代码是不是 Promise,如果是,先不放到微任务队中,也就是等同步代码执行完,再放,也就到了微任务队列的最后了,如果不是,可以放到微任务队列中.</p>
<p>try&#x2F;catch 捕获不到异步的异常,只能捕获同步代码.</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 是异步问题同步化解决方案.<br>Promise 本身不是异步,它是个构造函数.<br>Promise 中的函数是同步的.<br>Promise 有一个参数,即<code>excutor</code>执行器,它有两个参数,<code>resolve</code>和<code>reject</code>.<br><code>excutor</code>是同步执行,而<code>then</code>是异步调用的.<br>如果想连续<code>then</code>需要上一个<code>promise</code>中 return 一个新的<code>promise</code>.<br>Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止.</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>promise 内部在<code>resolve</code>之前的代码处于<code>pending</code>状态,之后的是<code>fulfilled</code>.<br>promise 在<code>catch</code>中如果没有抛出错误,则会返回<code>fufilled</code></p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>状态固化后,就不再捕获错误了.比如 resolve()返回后面有报错的内容,但是 catch 就不再捕获了.<br>案例:<br>当 promise 作为参数传递到另一个 promise 中,这个第二个 promise 中的状态就会失效.依赖于第一个 promise.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">resolve</span>(p1)&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>

<p>Promise.all()如果三个内容都失败,只返回第一个失败的信息.如果只有一个出错,也只会返回一个.而且不返回正常的.<br>Promise.race()是谁先完成返回谁,无论是成功还是失败.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">300</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">    &#125; <span class="comment">// &#x27;Error&#x27;</span></span><br><span class="line">    <span class="comment">// 默认return 的是undefined</span></span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="comment">//上一次调用只有失败的状态,而那里默认返回的是undefined,</span></span><br><span class="line">    <span class="comment">//这里在onFulfilled的这里捕获的是上一次失败的默认return的undefined</span></span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;, <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then中throw new Error()的情况</span></span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="comment">// 上面抛出的是error,所以要走onRejectd,也就是第二个函数</span></span><br><span class="line">	<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;,</span><br><span class="line">  <span class="function">(<span class="params">reason</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(reason)&#125; <span class="comment">// &#x27;Error&#x27;</span></span><br><span class="line">  )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="async-x2F-await-和-promise-的关系"><a href="#async-x2F-await-和-promise-的关系" class="headerlink" title="async&#x2F;await 和 promise 的关系"></a>async&#x2F;await 和 promise 的关系</h2><p>await 是等待 promise 的返回,await 做不了 promise 返回状态的工作.<br>await 对应<code>Promise.then</code>成功的情况.<br>await 后如果是函数,则会把函数返回的结果用<code>Promise.then()</code>返回.<br>async 中的<code>Promise.reject()</code>需要使用<code>try/catch</code>进行捕获错误.<br>async 中的函数内部属于同步代码,在遇到 await 之前都可以先执行.</p>
<h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>catch 在 promise 的源码层面就是一个 then,如果 catch 中 return 的有值,可以在 catch 后跟 then.<br>既有 then 中的失败回调,又有 catch 的情况,会走最近的那个.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 输出1,2,3</span></span><br><span class="line"><span class="comment">// catch后没有抛出错,则返回的是resolved状态,可以继续then</span></span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="使用-promise-加载图片"><a href="#使用-promise-加载图片" class="headerlink" title="使用 promise 加载图片"></a>使用 promise 加载图片</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadIMg</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;加载失败&quot;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">src</span> = src;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> url1 =</span><br><span class="line">  <span class="string">&quot;https://i1.hdslb.com/bfs/face/f4d60f852eb1a85696447838c90a94acad31b7ae.jpg@160w_160h_1c_1s.webp&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> url2 =</span><br><span class="line">  <span class="string">&quot;https://i0.hdslb.com/bfs/face/a8ef30d6688d0b532bd20baa160417deae8f386d.jpg@240w_240h_1c_1s.webp&quot;</span>;</span><br><span class="line"><span class="comment">// 连续加载图片</span></span><br><span class="line"><span class="title function_">loadImg</span>(url1)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">img</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(img);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">loadImg</span>(url2);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">img2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(img2);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>Promise.resolve()<br>Promise.reject()</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>如果所有都正确执行,会按顺序返回.有一个失败,就失败.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/10/React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/10/React/" class="post-title-link" itemprop="url">React</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-10 09:11:13" itemprop="dateCreated datePublished" datetime="2021-03-10T09:11:13+08:00">2021-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:55" itemprop="dateModified" datetime="2022-11-01T18:08:55+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>react 页面是由各个 react 组件构成的.</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h2><p>各个组件之间传值,向外部传值用 <code>this.props....</code> <br>向内部传值用 <code>this.state...</code> <br>在内部保存值用 <code>this.setState</code></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类有三个要素.<br>声明的参数<br>constructor 构造函数<br>调用的函数.</p>
<h3 id="React-类"><a href="#React-类" class="headerlink" title="React 类"></a>React 类</h3><p>一般调用的是 <code>render()</code>  函数,将内部的 <code>JSX</code>  语法构建到虚拟 DOM 中.从而渲染到页面上.<br>在定义子类的构造函数时,都要调用 <code>super()</code>  方法.<br>因此,所有含有构造函数的 React 组件,必须以 <code>super(props)</code>  开头.</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>子组件通过一个绑定的参数接受来自父组件的 props.父组件把值写在 state 中.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> state = &#123;</span><br><span class="line">   lastName = <span class="string">&quot;Tom&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#123;this.state.lastName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      //name=&#123;this.state.lastName&#125;作为一个整体传递给子组件,作为props</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>父组件的数据: &#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>通过回调函数,父组件提供回调函数,子组件调用,将要传递的数据通过参数传递.<br>父组件拿到数据进行更新 state.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">	state = &#123;</span><br><span class="line">    <span class="attr">parentName</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//声明回调</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getChildMsg</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;来自子组件&quot;</span>,data)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    	<span class="attr">parentName</span>: data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件接受: &#123;this.state.parentName&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> <span class="attr">getMsg</span>=<span class="string">&#123;this.getChildMsg&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;子组件的信息&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//触发父组件的回调,并将参数传递</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">getMsg</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleCick&#125;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>父级的方法传递到子级的底层时,进行调用的时候,最好有所关联<br>filter 方法并没有更新当前的数组而是创建了一个新数组，它会过滤掉不符合条件的数据项，符合条件的数据项就会组成新的数组。<br><code>filter</code> 是 JavaScript 中删除数组元素的首选方法。<br>现在我们需要将<code>removeUser</code>传递给组件，并且在每一个列表行上渲染一个按钮，点击这个按钮调用这个方法。我们通过属性的方式将<code>removeUser</code>方法传递给 Table 组件。<br>TableBody 中，在调用<code>removeItem()</code>时，将数据对应的索引号<code>(index)</code>作为参数传递给了<code>removeItem()</code>方法，这样过滤方法就知道该删除哪个数据项了。创建一个按钮，并在<code>onClick</code>中调用<code>removeItem()</code>.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [users, setUsers] = <span class="title function_">useState</span>([&#123; <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span> &#125;]);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">removeUser</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setUsers</span>(users.<span class="title function_">filter</span>(<span class="function">(<span class="params">use, i</span>) =&gt;</span> index !== i));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Table</span> <span class="attr">items</span>=<span class="string">&#123;users&#125;</span> <span class="attr">removeItem</span>=<span class="string">&#123;removeUsers&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Table</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; items, removeUsers &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TableHeader</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TableBody</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;</span> <span class="attr">removeItem</span>=<span class="string">&#123;removeItem&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TableBody</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; items, removeUsers &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> rows = items.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;items.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;items.job&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> removeUSer(index)&#125;&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span>&#123;rows&#125;<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>组件传值的时候不要直接把传递过来的函数放到组件上,建议另写一个函数调用的时候带上这个<code>props</code>传递的函数.<br>下面的<code>handleSubmit</code>是从<code>props</code>拿到的,但是又封装一个函数才进行调用.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Form</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> initalData = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> [formData, setFormData] = <span class="title function_">useState</span>(initalData);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, value &#125; = e.<span class="property">target</span>;</span><br><span class="line">    <span class="title function_">setFormData</span>(&#123;</span><br><span class="line">      ...formData,</span><br><span class="line">      [name]: value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">submitForm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    props.<span class="title function_">handleSubmit</span>(formData);</span><br><span class="line">    <span class="title function_">setFormData</span>(initalData);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">name</span>=<span class="string">&quot;name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;formData.name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">name</span>=<span class="string">&quot;age&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;formData.age&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onSubmit</span>=<span class="string">&#123;submitForm&#125;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="兄弟通信"><a href="#兄弟通信" class="headerlink" title="兄弟通信"></a>兄弟通信</h3><h4 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h4><blockquote>
<p>当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，需要把子组件的  state  数据提升至其共同的父组件当中保存。之后父组件可以通过  props  将状态数据传递到子组件当中。这样应用当中所有组件的状态数据就能够更方便地同步共享了。</p>
</blockquote>
<ul>
<li>将共享状态提升到最近的公共父组件,由公共父组件管理状态</li>
<li>思想: 状态提升</li>
<li>公共父组件职责: 提供共享状态,提供操作共享状态的方法</li>
<li>要通讯的子组件只需要通过<code>props</code>接收或者操作状态的方法</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">//共享状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//共享方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onIncrement</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      	<span class="tag">&lt;<span class="name">Child1</span> <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child2</span> <span class="attr">onIncrement</span>=<span class="string">&#123;this.onIncrement&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child1</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>计数器: &#123;props.count&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child2</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span>props.onIncrement()&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><blockquote>
<p>因为 DOM 元素   是一个内置组件，因此其 onClick 属性在 React 中有特殊的含义。而对于用户自定义的组件来说，命名就可以由用户自己来定义了。我们给 Square 的 onClick 和 Board 的 handleClick 赋予任意的名称，代码依旧有效。在 React 中，有一个命名规范，通常会将代表事件的监听 prop 命名为 on[Event]，将处理事件的监听方法命名为 handle[Event] 这样的格式。</p>
</blockquote>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><p>将 class 组件修改为函数式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Square extends React.Component &#123;</span></span><br><span class="line"><span class="comment">//     render() &#123;</span></span><br><span class="line"><span class="comment">//       return (</span></span><br><span class="line"><span class="comment">//         &lt;button</span></span><br><span class="line"><span class="comment">//           className=&quot;square&quot;</span></span><br><span class="line"><span class="comment">//           onClick=&#123;()=&gt; this.props.onClick()&#125;&gt;</span></span><br><span class="line"><span class="comment">//           &#123;this.props.value&#125;</span></span><br><span class="line"><span class="comment">//         &lt;/button&gt;</span></span><br><span class="line"><span class="comment">//       );</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Square</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.value&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<br><code>onClick=&#123;()=&gt;this.props.onClick()&#125;</code> <br>修改为<br><code>onClick=&#123;props.onClick&#125;</code> <br>两侧括号消失</p>
</blockquote>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><ul>
<li>可以给组件传任意类型的值</li>
<li><code>props</code>是只读的对象,只能读取属性的值,无法修改</li>
<li>使用类组件时,如果写了构造函数,应该将<code>props</code>传递给<code>super()</code>,否则无法在构造函数中获取<code>props</code></li>
</ul>
<h3 id="props-深入"><a href="#props-深入" class="headerlink" title="props 深入"></a>props 深入</h3><h4 id="children-属性"><a href="#children-属性" class="headerlink" title="children 属性"></a>children 属性</h4><p>表示组件标签的子节点.当组件标签有子节点时,props 就会有该属性.<br>children 和普通的 props 属性一样,值可以是任意值.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;Test /&gt;</span></span><br><span class="line">  &lt;/<span class="title class_">App</span>&gt;,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="props-校验"><a href="#props-校验" class="headerlink" title="props 校验"></a>props 校验</h4><p>安装包<code>prop-types</code>,引入包,<br>使用<code>组件名.propTypes=&#123;&#125;</code>来给组件的 props 添加校验规则.<br>校验规则通过<code>PropTypes</code>对象来指定</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.colors&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">App</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="comment">//约定colors属性为array类型</span></span><br><span class="line">  <span class="comment">//如果类型不对,则报错</span></span><br><span class="line">  <span class="attr">colors</span>: <span class="title class_">PropTypes</span>.<span class="property">array</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="约束规则"><a href="#约束规则" class="headerlink" title="约束规则"></a>约束规则</h4><ol>
<li>常见类型: array, bool, func, number, object, string</li>
<li>React 元素类型: element</li>
<li>必填项: isRequired</li>
<li>特定结构的对象: <code>shape(&#123;&#125;)</code></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见类型</span></span><br><span class="line"><span class="attr">optionalFunc</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>,</span><br><span class="line"><span class="comment">//必选</span></span><br><span class="line"><span class="attr">requiredFunc</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line"><span class="comment">//特定结构对象</span></span><br><span class="line"><span class="attr">optionalObjectwithShape</span>: <span class="title class_">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="title class_">Proptypes</span>.<span class="property">string</span>,</span><br><span class="line">  <span class="attr">fontSize</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="props-默认值"><a href="#props-默认值" class="headerlink" title="props 默认值"></a>props 默认值</h4><p><code>组件.defaultProps</code>: 给组件传入默认值,在未传入 props 时生效.</p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>不要直接修改 state,使用 <code>this.setState()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">comment</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">comment</span>: <span class="string">&quot;hello&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>构造函数是唯一可以给 <code>this.state</code>  赋值的地方.</p>
<h3 id="state-的更新可能异步"><a href="#state-的更新可能异步" class="headerlink" title="state 的更新可能异步"></a>state 的更新可能异步</h3><p><code>this.props</code>  和 <code>this.state</code>  可能会异步更新,不要依赖他们的值更新下一个状态.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">increment</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>正确解决方法:</p>
<p>让 <code>setState</code>  接收一个函数而不是一个对象.<br>这个函数用上一个 <code>state</code>  作为参数,将此次更新被应用时的 <code>props</code>  作为第二个参数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">		<span class="attr">count</span>: state.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">		&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="state-的更新可能会被吞并"><a href="#state-的更新可能会被吞并" class="headerlink" title="state 的更新可能会被吞并"></a>state 的更新可能会被吞并</h3><p>当调用 <code>setState</code>  时, <code>React</code>  会把提供的对象合并到当前的 state 中.<br>这个不太懂.</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>跨组件通信</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用<code>React.createContext</code>创建<code>Provider</code>和<code>Consumer</code>两个组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br></pre></td></tr></table></figure>

<p>使用<code>Provider</code>作为父节点.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>value</code>属性表示要传递的数据.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> value=<span class="string">&quot;red&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>调用<code>Consumer</code>组件进行接收.<br>即 data 接收的就是 value 的值.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Consumer</span>&gt;&#123;<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>data参数表示接收到的数据--&#123;data&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&lt;/<span class="title class_">Consumer</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h2><p>任何的  state  总是所属于特定的组件，而且从该  state  派生的任何数据或  UI  只能影响树中“低于”它们的组件。<br>如果把一个以组件构成的树想象成一个  props  的数据瀑布的话，那么每一个组件的  state  就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>不能通过返回 <code>false</code>  阻止事件默认行为,必须显示的使用 <code>preventDefault</code> .</p>
<h3 id="this-的绑定"><a href="#this-的绑定" class="headerlink" title="this 的绑定"></a>this 的绑定</h3><p>将 this 绑定到构造函数上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toggle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !state.<span class="property">isToggleOn</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.isToggleOn ? &quot;ON&quot; : &quot;OFF&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDom</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>不想 <code>bind</code>  的解决方法.</p>
<ol>
<li>使用箭头函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toggle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">	...</span><br><span class="line">  handleClick = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span>&#123;</span><br><span class="line">			<span class="attr">isToggleOn</span>: !state.<span class="property">isToggleOn</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 render 中使用箭头函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> &#123;this.handleClick()&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    	Clcik me</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h3><p>若 id 是要删除的哪一行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span><span class="variable language_">this</span>.<span class="title function_">deleteRow</span>(id, e)&#125;&gt;<span class="title class_">Delete</span> <span class="title class_">Row</span>&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.deleteRow.bind(this,</span> <span class="attr">id</span>)&#125;&gt;</span>Delete Row<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="关于-Click-中的箭头函数问题"><a href="#关于-Click-中的箭头函数问题" class="headerlink" title="关于 Click 中的箭头函数问题"></a>关于 Click 中的箭头函数问题</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onClick=&#123;这里是一个函数或函数引用&#125;</span><br><span class="line">onClick=&#123;<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">handleClick</span>(i)&#125;，这里面就是一个匿名函数，</span><br><span class="line"><span class="comment">//点击事件发生时，会执行这个匿名函数，匿名函数再调用handleClick函数(传参i)；</span></span><br><span class="line"><span class="comment">//其次才是this绑定的问题</span></span><br></pre></td></tr></table></figure>

<p>所以,如果要传递参数时,才需要使用箭头函数,或者绑定 this.</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserGreeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GuestGreeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoginIn = props.<span class="property">isLoginIn</span>;</span><br><span class="line">  <span class="keyword">if</span> (isLoginIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">isLoginIn</span>=<span class="string">&#123;false&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementBId</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="列表和-Key"><a href="#列表和-Key" class="headerlink" title="列表和 Key"></a>列表和 Key</h2><p>一个元素的  key  最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的  id  来作为元素的  key.当元素没有确定  id  的时候，万不得已你可以使用元素索引  index  作为  key.<br>和<code>Vue</code>不同,<code>key</code>写在返回式中.</p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>使用 <code>map()</code> 进行遍历时,记得 <code>return</code> .</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">numbers.<span class="title function_">map</span>(<span class="function"><span class="params">number</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">numbers.<span class="title function_">map</span>(<span class="function"><span class="params">number</span> =&gt;</span>&#123;<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure>

<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>暂时空置</p>
<h2 id="状态提升-1"><a href="#状态提升-1" class="headerlink" title="状态提升"></a>状态提升</h2><p>在  React  应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state  都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个  state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步  state。</p>
<h2 id="组合-VS-继承"><a href="#组合-VS-继承" class="headerlink" title="组合 VS 继承"></a>组合 VS 继承</h2><h3 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h3><p>有些组件无法提前知晓它们子组件的具体内容。在  Sidebar（侧边栏）和  Dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。<br>我们建议这些组件使用一个特殊的  children prop  来将他们的子组件传递到渲染结果中.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FancyBorder</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&quot;<span class="attr">FancyBorder</span> <span class="attr">FancyBorder-</span>&quot; + <span class="attr">props.color</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSX 标签中的所有内容都会作为一个 <code>children</code>prop 传递给 FancyBorder 组件。因为 FancyBorder 将 <code>&#123;props.children&#125;</code>  渲染在一个</p>
<p>少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 <code>children</code> ，而是自行约定：将所需内容传入 <code>props</code> ，并使用相应的 <code>prop</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Contacts</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Contacts&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Chat</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Chat&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SplitPane</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-left&quot;</span>&gt;</span>&#123;props.left&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-right&quot;</span>&gt;</span>&#123;props.right&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SplitPane</span> <span class="attr">left</span>=<span class="string">&#123;</span>&lt;<span class="attr">Contacts</span> /&gt;</span>&#125; right=&#123;<span class="tag">&lt;<span class="name">Chat</span> /&gt;</span>&#125; /&gt;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="特例关系"><a href="#特例关系" class="headerlink" title="特例关系"></a>特例关系</h3><p>暂无</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="创建时"><a href="#创建时" class="headerlink" title="创建时"></a>创建时</h3><p><code>constructor</code>&#x3D;&gt;<code>render()</code>&#x3D;&gt;<code>componentDidMount</code></p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>constructor</td>
<td>创建组件</td>
<td>1.初始化 state</td>
</tr>
<tr>
<td>2.为事件处理程序绑定 this</td>
<td></td>
<td></td>
</tr>
<tr>
<td>render</td>
<td>每次渲染都会触发</td>
<td>渲染 UI(注意不能调用 setState)</td>
</tr>
<tr>
<td>componentDIdMount</td>
<td>组件挂载(完成 DOM 渲染后)</td>
<td>1.发送网络请求</td>
</tr>
<tr>
<td>2.DOM 操作</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="更新时"><a href="#更新时" class="headerlink" title="更新时"></a>更新时</h3><p>执行时机: 1.<code>setState</code>2.<code>forceUpdate()</code>3.组件接收新的 props<br>执行顺序: <code>render()</code> &#x3D;&gt; <code>componentDidUpdate</code></p>
<table>
<thead>
<tr>
<th>钩子函数</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>render</td>
<td>每次组件渲染都会触发</td>
<td>渲染 UI,与挂载阶段是同一个 render</td>
</tr>
<tr>
<td>componentDidUpdate</td>
<td>组件更新(完成 DOM 渲染后)</td>
<td>1.发送网络请求</td>
</tr>
</tbody></table>
<p>2.DOM 操作<br>注意如果要 setState 必须放在 if 条件中 |</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果要在componentDidUpdate中setState,需要加if</span></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">	<span class="comment">//比较更新前后的props是否相同,决定是否重新渲染</span></span><br><span class="line">  <span class="keyword">if</span>(prevProps.<span class="property">count</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">count</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="卸载时"><a href="#卸载时" class="headerlink" title="卸载时"></a>卸载时</h3><table>
<thead>
<tr>
<th>钩子函数</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>componentWillUnmount</td>
<td>组件卸载</td>
<td>执行清理工作(如卸载定时器)</td>
</tr>
</tbody></table>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">timeId</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器执行&quot;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerId</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>shouldComponentUpdate</code></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h2><p>要复用什么? 1.<code>state</code>2.操作<code>state</code>的方法(组件状态逻辑)<br>方式: 1.<code>render props</code>模式 2.<code>HOC</code>高阶组件</p>
<h3 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h3><p>思路: 将复用的 state 和操作 state 的方法封装到一个组件<br>问题 1: 如何拿到该组件中复用的 state?<br>方法: 在使用组件时,添加一个值为函数的 prop,通过函数参数来获取(需要组件内部实现)<br>问题 2: 如何渲染任意 UI?<br>方法: 使用该函数的返回值作为要渲染的内容.(需要组件内部实现)</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Mouse</span> render=&#123;<span class="function">(<span class="params">mouse</span>) =&gt;</span> &#123;&#125;&#125; /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;(mouse)</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标当前位置:&#123;mouse.x&#125;,&#123;mouse.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">) &#125;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体步骤:</p>
<ol>
<li>创建 Mouse 组件,在组件中提供复用的状态逻辑代码</li>
<li>将要复用的状态作为<code>props.render(state)</code>方法的参数,暴露到组件外部</li>
<li>使用<code>props.render()</code>的返回值作为要渲染的内容</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        x = <span class="number">0</span>,</span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">x</span>: e.<span class="property">clientX</span>,</span><br><span class="line">            <span class="attr">y</span>: clientY</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">render</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Mouse render=&#123;(mouse) =&gt; &#123;</span><br><span class="line">                    return (</span><br><span class="line">                        &lt;p&gt;鼠标位置: &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">                    )</span><br><span class="line">                &#125;&#125; /&gt;</span><br><span class="line">            &lt;Mouse render=&#123;(mouse) =&gt; &#123;</span><br><span class="line">									return (</span><br><span class="line">                    &lt;img src=&#123;img&#125; alt=&quot;cat&quot; style=&#123;&#123;</span><br><span class="line">                      	postion: &#x27;absolute&#x27;,</span><br><span class="line">                        top: mouse.y,</span><br><span class="line">                        left: mouse.x</span><br><span class="line">                      &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-children-替代-render"><a href="#使用-children-替代-render" class="headerlink" title="使用 children 替代 render"></a>使用 children 替代 render</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Mouse</span>&gt;</span><br><span class="line">  &#123; &#123;(x,y)&#125; =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标的位置: &#123;x&#125;,&#123;y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> &#125;</span><br><span class="line">&lt;/<span class="title class_">Mouse</span>&gt;</span><br><span class="line"><span class="comment">//组件内部</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">children</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br></pre></td></tr></table></figure>

<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ol>
<li>使用 propTypes 进行校验</li>
<li>将事件绑定解除</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Mouse</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">children</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HOC-高阶组件"><a href="#HOC-高阶组件" class="headerlink" title="HOC 高阶组件"></a>HOC 高阶组件</h2><p>目的: 实现逻辑复用<br>方法: 采用包装(装饰)模式<br>思路: 实际上是一个函数,接收要包装的组件,返回增强后的组件<br>方法: 内部创建一个类组件,在类组件内提供复用的状态逻辑代码,通过 prop 将复用的状态传递给被包装的组件.</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>创建一个函数,名称约定以<code>with</code>开头.</li>
<li>指定函数参数,参数以首字母大写开头</li>
<li>在函数内部创建一个类组件,提供复用的状态逻辑代码</li>
<li>在该组件,渲染参数组件,同时将状态通过 prop 传递给参数组件</li>
<li>调用该高阶组件,传入要增强的组件,通过返回值拿到增强后的组件,并将其渲染到页面上</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">//声明高阶组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withMouse</span>(<span class="params">wrappedComponent</span>) &#123;</span><br><span class="line">  <span class="comment">//创建类组件</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">      <span class="comment">//在这里提供提供复用的代码和state</span></span><br><span class="line">        state = &#123;</span><br><span class="line">            x = <span class="number">0</span>,</span><br><span class="line">            y = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">x</span>: e.<span class="property">clientX</span>,</span><br><span class="line">                <span class="attr">y</span>: clientY</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">//将内部的state放到包裹的组件上</span></span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">wrappedComponent</span> &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//返回出这个类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Mouse</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Position</span> = props =&gt; &#123;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标位置: &#123;props.x&#125;, &#123;props.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Cat</span> =(<span class="params">props</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">postion:</span> &#x27;<span class="attr">absolute</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">top:</span> <span class="attr">props.y</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">left:</span> <span class="attr">props.x</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &#125;&#125; /&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用高阶组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MousePosition</span> = <span class="title function_">withMouse</span>(<span class="title class_">Position</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MouseCat</span> = <span class="title function_">withMouse</span>(<span class="title class_">Cat</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>高阶组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">MousePosition</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">           			<span class="tag">&lt;<span class="name">MouseCat</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置-display-Name"><a href="#设置-display-Name" class="headerlink" title="设置 display Name"></a>设置 display Name</h3><p>原因: 默认情况,React 使用组件名作为 displayName,则会出现两个名字相同的情况<br>方法: 设置 displayName,便以区分.注意名字首字母大写.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withMouse</span>(<span class="params">wrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在高阶组件内设置displayName,注意首字母大写</span></span><br><span class="line">  <span class="title class_">Mouse</span>.<span class="property">displayName</span> = <span class="string">`WithMouse<span class="subst">$&#123;getDisplayName(wrappedComponent)&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mouse</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置获取名称方法,注意首字母大写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDisplayName</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span>.<span class="property">displayName</span> || <span class="title class_">WrappedComponent</span>.<span class="property">name</span> || <span class="string">&quot;Component&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传递-props"><a href="#传递-props" class="headerlink" title="传递 props"></a>传递 props</h3><p>将 props 和 state 一起放在返回的组件上</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">wrappedComponent</span> &#123;<span class="attr">...state</span>&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/09/Taro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/09/Taro/" class="post-title-link" itemprop="url">Taro</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-09 14:12:04" itemprop="dateCreated datePublished" datetime="2021-03-09T14:12:04+08:00">2021-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:56" itemprop="dateModified" datetime="2022-11-01T18:08:56+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="老项目更新依赖"><a href="#老项目更新依赖" class="headerlink" title="老项目更新依赖"></a>老项目更新依赖</h2><p>老项目在新 taro 框架,需要更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taro update project</span><br></pre></td></tr></table></figure>

<p>Taro3 和老版本引入有差别</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Taro</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Taro3新版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Taro</span> <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="挂载-App-js"><a href="#挂载-App-js" class="headerlink" title="挂载 App.js"></a>挂载 App.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老版本app.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Taro</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Index</span> <span class="keyword">from</span> <span class="string">&quot;./pages/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./app.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">//config写到app的类里.</span></span><br><span class="line">  <span class="comment">//新版写到单独的app.config.js文件里</span></span><br><span class="line">  config = &#123;</span><br><span class="line">    <span class="attr">pages</span>: [</span><br><span class="line">      <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pages/nodes/nodes&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pages/hot/hot&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pages/node_detail/node_detail&quot;</span>,</span><br><span class="line">      <span class="string">&quot;pages/thread_detail/thread_detail&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">tabBar</span>: &#123;</span><br><span class="line">      <span class="attr">list</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">iconPath</span>: <span class="string">&quot;resource/latest.png&quot;</span>,</span><br><span class="line">          <span class="attr">selectedIconPath</span>: <span class="string">&quot;resource/lastest_on.png&quot;</span>,</span><br><span class="line">          <span class="attr">pagePath</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">          <span class="attr">text</span>: <span class="string">&quot;最新&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">iconPath</span>: <span class="string">&quot;resource/hotest.png&quot;</span>,</span><br><span class="line">          <span class="attr">selectedIconPath</span>: <span class="string">&quot;resource/hotest_on.png&quot;</span>,</span><br><span class="line">          <span class="attr">pagePath</span>: <span class="string">&quot;pages/hot/hot&quot;</span>,</span><br><span class="line">          <span class="attr">text</span>: <span class="string">&quot;热门&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">iconPath</span>: <span class="string">&quot;resource/node.png&quot;</span>,</span><br><span class="line">          <span class="attr">selectedIconPath</span>: <span class="string">&quot;resource/node_on.png&quot;</span>,</span><br><span class="line">          <span class="attr">pagePath</span>: <span class="string">&quot;pages/nodes/nodes&quot;</span>,</span><br><span class="line">          <span class="attr">text</span>: <span class="string">&quot;节点&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&quot;#000&quot;</span>,</span><br><span class="line">      <span class="attr">selectedColor</span>: <span class="string">&quot;#56abe4&quot;</span>,</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">      <span class="attr">borderStyle</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">window</span>: &#123;</span><br><span class="line">      <span class="attr">backgroundTextStyle</span>: <span class="string">&quot;light&quot;</span>,</span><br><span class="line">      <span class="attr">navigationBarBackgroundColor</span>: <span class="string">&quot;#fff&quot;</span>,</span><br><span class="line">      <span class="attr">navigationBarTitleText</span>: <span class="string">&quot;V2EX&quot;</span>,</span><br><span class="line">      <span class="attr">navigationBarTextStyle</span>: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//return的是首页.</span></span><br><span class="line">  <span class="comment">//新版本return的是this.prop.children</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line">      <span class="comment">//  return this.props.children</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//老版本使用Taro.render挂载到app节点上</span></span><br><span class="line"><span class="comment">//新版本直接export default App</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Taro</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>));</span><br><span class="line"><span class="comment">//export default App</span></span><br></pre></td></tr></table></figure>

<h3 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h3><p><code>taro-UI</code>  的样式可以按需引入.</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="路由声明"><a href="#路由声明" class="headerlink" title="路由声明"></a>路由声明</h2><p>路由在 <code>@tarojs/taro</code>  中的 <code>getCurrentInstance().router 中获取.</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  current = <span class="title function_">getCurrentInstance</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// getCurrentInstance().router 和 this.$router 和属性一样</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">router</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&quot;@tarojs/taro&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router &#125; = <span class="title function_">getCurrentInstance</span>();</span><br><span class="line">  <span class="comment">// getCurrentInstance().router 和 useRouter 返回的内容也一样</span></span><br><span class="line">  <span class="comment">// const router = useRouter()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由参数获取"><a href="#路由参数获取" class="headerlink" title="路由参数获取"></a>路由参数获取</h2><p>原生小程序路由一般在 <code>onLoad</code>  中获取传过来的参数.<br><code>Taro</code>  推荐在 <code>ComponentDidShow</code>  中获取.(也可以在 <code>onLoad</code>  中)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js 项目入口文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  componentDidShow (options <span class="comment">/* 这里有你想要的路由信息 */</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>小程序 &#x3D;&gt; class 类 &#x3D;&gt; 函数式 hook<br>onLoad &#x3D;&gt; onLoad<br>onReady &#x3D;&gt; onReady &#x3D;&gt; useReady<br>onLanch &#x3D;&gt; onLanch<br>onShow &#x3D;&gt; conponentDidShow &#x3D;&gt; useDidShow<br>onHide &#x3D;&gt;componentDidHide &#x3D;&gt; useDidHide</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h4 id="onPullDownRefresh"><a href="#onPullDownRefresh" class="headerlink" title="onPullDownRefresh()"></a>onPullDownRefresh()</h4><p>监听用户下拉动作。</p>
<p>需要在全局配置的  window  选项中或页面配置中设置  enablePullDownRefresh: true。<br>可以通过  Taro.startPullDownRefresh  触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。<br>当处理完数据刷新后，Taro.stopPullDownRefresh  可以停止当前页面的下拉刷新.</p>
<h4 id="onReachBottom"><a href="#onReachBottom" class="headerlink" title="onReachBottom()"></a>onReachBottom()</h4><p>监听用户上拉触底事件。</p>
<p>可以在全局配置的  window  选项中或页面配置中设置触发距离  onReachBottomDistance。<br>在触发距离内滑动期间，本事件只会被触发一次</p>
<blockquote>
<p>H5  暂时没有同步实现，可以通过给  window  绑定  scroll  事件来进行模拟</p>
</blockquote>
<h4 id="onPageScroll"><a href="#onPageScroll" class="headerlink" title="onPageScroll()"></a>onPageScroll()</h4><p>监听用户滑动页面事件.</p>
<blockquote>
<p>H5  暂时没有同步实现，可以通过给  window  绑定  scroll  事件来进行模拟</p>
</blockquote>
<h3 id="基本事件"><a href="#基本事件" class="headerlink" title="基本事件"></a>基本事件</h3><p>在  Taro  中事件遵从小驼峰式（camelCase）命名规范，所有内置事件名以  on  开头。</p>
<p>在事件回调函数中，第一个参数是事件本身，回调中调用  stopPropagation  可以阻止冒泡。</p>
<blockquote>
<p>只有小程序的  bindtap  对应  Taro  的  onClick<br>其余小程序事件名把  bind  换成  on  即是  Taro  事件名</p>
</blockquote>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>安装 redux 及其中间件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add redux react-redux redux-thunk redux-logger</span><br><span class="line"><span class="comment"># 或者使用 npm</span></span><br><span class="line">$ npm install --save redux react-redux redux-thunk redux-logger</span><br></pre></td></tr></table></figure>

<p>随后可以在项目  src  目录下新增一个  store  目录，在目录下增加  index.js  文件用来配置  store，按自己喜好设置  redux  的中间件，例如下面例子中使用  redux-thunk  和  redux-logger  这两个中间件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&quot;../reducers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable language_">window</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span></span><br><span class="line">    ? <span class="variable language_">window</span>.<span class="title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;</span><br><span class="line">        <span class="comment">// Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize...</span></span><br><span class="line">      &#125;)</span><br><span class="line">    : compose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [thunkMiddleware];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;development&quot;</span> &amp;&amp;</span><br><span class="line">  process.<span class="property">env</span>.<span class="property">TARO_ENV</span> !== <span class="string">&quot;quickapp&quot;</span></span><br><span class="line">) &#123;</span><br><span class="line">  middlewares.<span class="title function_">push</span>(<span class="built_in">require</span>(<span class="string">&quot;redux-logger&quot;</span>).<span class="title function_">createLogger</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = <span class="title function_">composeEnhancers</span>(</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(...middlewares)</span><br><span class="line">  <span class="comment">// other store enhancers if any</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">configStore</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer, enhancer);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在项目入口文件  app.js  中使用  redux  中提供的  Provider  组件将前面写好的  store  接入应用中.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们要使用 Redux</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> configStore <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./app.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">configStore</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 可以使用所有的 React 组件方法</span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onLaunch</span></span><br><span class="line">  <span class="title function_">onLaunch</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onShow</span></span><br><span class="line">  <span class="title function_">componentDidShow</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onHide</span></span><br><span class="line">  <span class="title function_">componentDidHide</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在入口组件不会渲染任何内容，但我们可以在这里做类似于状态管理的事情</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        /* this.props.children 是将要被渲染的页面 */</span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>然后就可以开始使用了。如  redux  推荐的那样，可以增加</p>
<ul>
<li>constants  目录，用来放置所有的  action type  常量</li>
<li>actions  目录，用来放置所有的  actions</li>
<li>reducers  目录，用来放置所有的  reducers</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/28/Koa2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/Koa2/" class="post-title-link" itemprop="url">Koa2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-28 09:57:58" itemprop="dateCreated datePublished" datetime="2021-02-28T09:57:58+08:00">2021-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:56" itemprop="dateModified" datetime="2022-11-01T18:08:56+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Koa 本质上是调用一系列的中间件，来处理对应的请求，并决定是否传递到下一个中间件去处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa --save</span><br></pre></td></tr></table></figure>

<p>所以，接口的本质，就是判断不同的请求链接，干不同的事情，返回相应的结果。那么我们得需要一个路由中间件来处理分发请求。<br>使用 <code>koa-router</code>  处理路由.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa-router --save</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址跳转</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;这是主页&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/user&quot;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;这是user页&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这里koa不会去处理数据,需要使用中间件body-parse</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/post&quot;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;async&quot;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">sleep</span> = <span class="keyword">async</span> (<span class="params">ms</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">      &#125;, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  ctz.<span class="property">body</span> = <span class="string">`这是异步网页`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>()).<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use(ctx =&gt; &#123;</span></span><br><span class="line"><span class="comment">// 	ctx.body = `您的网址为:$&#123;ctx.request.url&#125;`</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>安装 <code>body-parse</code> .</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa-bodyparser --save</span><br></pre></td></tr></table></figure>

<h2 id="业务分离"><a href="#业务分离" class="headerlink" title="业务分离"></a>业务分离</h2><p>改造后目录结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-koa2 - node_modules - controller;</span><br><span class="line">user.<span class="property">js</span> - index.<span class="property">js</span> - router.<span class="property">js</span> - package.<span class="property">json</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&quot;./router&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;koa-bodparser&quot;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>()).<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/26/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/26/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-26 11:26:53" itemprop="dateCreated datePublished" datetime="2021-02-26T11:26:53+08:00">2021-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:56" itemprop="dateModified" datetime="2022-11-01T18:08:56+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>拉取镜像<br><code>docker pull image</code> <br>根据镜像创建使用该镜像的容器<br><code>docker run -di --name mycentos centos:7</code></p>
<h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><p>当前运行的容器<br><code>docker ps</code></p>
<h2 id="Dockerflie"><a href="#Dockerflie" class="headerlink" title="Dockerflie"></a>Dockerflie</h2><p><code>docker image build</code>  会读取 dockerfile,并将应用容器化.<br>Dockerfile  由一行行命令语句组成，并支持以  #  开头的注释行.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># <span class="title class_">Test</span> web-app to use <span class="keyword">with</span> <span class="title class_">Pluralsight</span> courses and <span class="title class_">Docker</span> <span class="title class_">Deep</span> <span class="title class_">Dive</span> book</span><br><span class="line"># <span class="title class_">Linux</span> x64</span><br><span class="line"><span class="variable constant_">FROM</span> alpine</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">LABEL</span> maintainer=<span class="string">&quot;nigelpoulton@hotmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="title class_">Install</span> <span class="title class_">Node</span> and <span class="variable constant_">NPM</span></span><br><span class="line"><span class="variable constant_">RUN</span> apk add --update nodejs nodejs-npm</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Copy</span> app to /src</span><br><span class="line"><span class="variable constant_">COPY</span> . /src</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">WORKDIR</span> /src</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Install</span> dependencies</span><br><span class="line"><span class="variable constant_">RUN</span>  npm install</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">ENTRYPOINT</span> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;./app.js&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>使用  -t  参数为镜像打标签，使用  -f  参数指定  Dockerfile  的路径和名称，使用  -f  参数可以指定位于任意路径下的任意名称的  Dockerfile。</p>
<p>构建上下文是指应用文件存放的位置，可能是本地  Docker  主机上的一个目录或一个远程的  Git  库。</p>
<p>Dockerfile  中的  FROM  指令用于指定要构建的镜像的基础镜像。它通常是  Dockerfile  中的第一条指令。</p>
<p>Dockerfile  中的  RUN  指令用于在镜像中执行命令，这会创建新的镜像层。每个  RUN  指令创建一个新的镜像层。</p>
<p>Dockerfile  中的  COPY  指令用于将文件作为一个新的层添加到镜像中。通常使用  COPY  指令将应用代码赋值到镜像中。</p>
<p>Dockerfile  中的  EXPOSE  指令用于记录应用所使用的网络端口。</p>
<p>Dockerfile  中的  ENTRYPOINT  指令用于指定镜像以容器方式启动后默认运行的程序。</p>
<p>其他的  Dockerfile  指令还有  LABEL、ENV、ONBUILD、HEALTHCHECK、CMD  等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/TypeScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/23/TypeScript/" class="post-title-link" itemprop="url">TypeScript</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-23 15:29:47" itemprop="dateCreated datePublished" datetime="2021-02-23T15:29:47+08:00">2021-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:56" itemprop="dateModified" datetime="2022-11-01T18:08:56+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="初次使用"><a href="#初次使用" class="headerlink" title="初次使用"></a>初次使用</h2><p>安装 ts</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br><span class="line">//查看版本</span><br><span class="line">tsc -v</span><br><span class="line"></span><br><span class="line">//使用tsc编译文件,但是每次都要运行</span><br><span class="line">//监听模式可以实时编译</span><br><span class="line">tsc -w</span><br></pre></td></tr></table></figure>

<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组有两种定义方法.</p>
<ol>
<li>在元素类型后接 <code>[]</code> .表示由此类型元素组成的一个数组.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用数组泛型.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组,各元素的类型不必相同.(可以理解为混合数组).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [string, number];</span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; <span class="comment">//正确</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>]; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>当访问一个越界的元素，会使用联合类型替代：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&quot;world&quot;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<h4 id="在-react-中使用"><a href="#在-react-中使用" class="headerlink" title="在 react 中使用"></a>在 react 中使用</h4><p>便于重命名</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useHappy</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [isHappy,makeTomHappy,makeUnHappy]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">SomeComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [tomIsHappy,makeTomHappy,makeTomUnHappy] = <span class="title function_">useHappy</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>enum</code>  是对 JS 标准数据类型的一种补充.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="comment">//有一种数据类型是Color,这种类型有三种参数</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span></span><br><span class="line"><span class="comment">//设定c是Color类型中的Green</span></span><br></pre></td></tr></table></figure>

<p>默认情况下,从 <code>0</code>  开始为元素符号. 可以手动赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//2,初始值设定为1,那么其余成员会从1开始增长</span></span><br></pre></td></tr></table></figure>

<p>然后可以由枚举值获得它的名字.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>[<span class="number">2</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//显示&quot;Green&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>用于暂时不清楚类型的指定类型.<br>当只知道一部分数据类型时, <code>any</code>  类型也是有用的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: any = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p><code>void</code>  类型表示与 <code>any</code>  类型相反.它表示没有任何类型,<br>当一个函数没有返回值时,通常其返回值类型是 <code>void</code> .<br>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>TypeScript 里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和  <code>void</code>相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把  <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<blockquote>
<p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。 这能避免 <em>很多</em>常见的问题。 也许在某处你想传入一个 <code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。<br>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p>
</blockquote>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p><code>never</code>  类型表示那些永不存在的类型.例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是  <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<blockquote>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使  <code>any</code>也不可以赋值给<code>never</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: string</span>): never &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><code>object</code>  表示非原始类型.也就是除 <code>number</code> , <code>string</code> , <code>boolean</code> , <code>symbol</code> , <code>null</code> , <code>undefined</code>  之外的类型.<br>用来表示对象类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="keyword">void</span>;</span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">//ok</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>); <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言类似于类型转换,不进行特殊的数据检查和解构.<br>没有运行时的影响,只在编译阶段起作用.<br><code>Typescript</code>  假设已进行了必须的检查.</p>
<h3 id="类型断言的形式"><a href="#类型断言的形式" class="headerlink" title="类型断言的形式"></a>类型断言的形式</h3><ol>
<li>尖括号</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: any = <span class="string">&quot;this is a string&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: number = (&lt;string&gt;someString).<span class="property">length</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>as</code>  语法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: any = <span class="string">&quot;this is a stirng&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: number = (someValue <span class="keyword">as</span> string).<span class="property">length</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们传给<code>setTimeout</code>的每一个函数表达式实际上都引用了相同作用域里的同一个<code>i</code></p>
</blockquote>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><p>接口的作用就是为类型命名和三方代码定义契约.</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带可选属性的接口在可选属性名字定义的后面加 <code>?</code>  符号.</p>
<p>好处一: 对可能存在的属性进行预定义.<br>好处二: 可以捕获引用了不存在属性时的错误.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params">config: SquareConfig</span>): &#123; <span class="attr">color</span>: string, <span class="attr">area</span>: number &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>, <span class="attr">area</span>: <span class="number">100</span> &#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">color</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">color</span> = config.<span class="property">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">width</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">area</span> = config.<span class="property">width</span> * config.<span class="property">width</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">color</span>: <span class="string">&quot;black&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">string</span>;</span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建时修改其值.<br>可以在属性名前加 <code>readonly</code>  指定只读属性.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Point</span> &#123;</span><br><span class="line">  readonly <span class="attr">x</span>: number;</span><br><span class="line">  readonly <span class="attr">y</span>: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过赋值一个对象字面量来构造 <code>Point</code> .赋值后, <code>x</code>  和 <code>y</code>  不能再被改变.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.<span class="property">x</span> = <span class="number">5</span>; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code>  类型,与 <code>Array&lt;T&gt;</code>  相似.<br>只是把所有可变方法去掉了.可以确保数组创建后再也不会被修改.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;number&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">//error</span></span><br><span class="line">ro.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">//error</span></span><br><span class="line">a = ro; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>把 <code>ReadonlyArray</code>  赋值到一个普通数组也不行.<br>但是可以用类型断言重写.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> number[]</span><br></pre></td></tr></table></figure>

<p><code>readonly</code>  和 <code>const</code></p>
<blockquote>
<p>最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。  做为变量使用的话用  const，若做为属性则使用 readonly。</p>
</blockquote>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>如可选属性上的例子,如果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;); <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>额外的属性检查会报错.</p>
<h4 id="绕过属性检查"><a href="#绕过属性检查" class="headerlink" title="绕过属性检查"></a>绕过属性检查</h4><ol>
<li>使用类型断言</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">opacity</span>: <span class="number">0.5</span>&#125;) <span class="keyword">as</span> <span class="title class_">SquareConfig</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加字符串索引签名</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">  [<span class="attr">propName</span>: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将这个对象赋值给另一个变量</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">SquareOptions</span> = &#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createsquare</span>(squareOptions);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为  squareOptions 不会经过额外属性检查，所以编译器不会报错。</p>
</blockquote>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>给接口定义一个调用签名就可以使用接口表示函数类型.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: string, <span class="attr">substring</span>: string): boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展示创建一个函数类型的变量,并将同一类型的函数赋值给这个变量.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span> (<span class="params">source: string, subString: string</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.<span class="title function_">search</span>(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。  比如，我们使用下面的代码重写上面的例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span> (<span class="params">src: string, sub: string</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>指能够”通过索引得到”的类型.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span>;</span><br><span class="line">myAray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStr</span>: string = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>上面例子,定义了 <code>StringArray</code>  接口,具有索引签名.<br>这个索引签名表示当用 <code>number</code>  去索引 <code>StringArray</code>  时会得到 <code>String</code>  类型的返回值.</p>
<blockquote>
<p>TypeScript 支持两种索引签名：字符串和数字。  可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。  这是因为当使用  number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。  也就是说用  100（一个 number）去索引等同于使用”100”（一个 string）去索引，因此两者需要保持一致。</p>
</blockquote>
<p>可以将索引签名设置为只读,这样就防止了给索引赋值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">ReadonlyStringArray</span> &#123;</span><br><span class="line">	readonly [<span class="attr">index</span>: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">ReadonlyStringArray</span> = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>]</span><br><span class="line">mArray[<span class="number">2</span>] = <span class="string">&quot;Marry&quot;</span> <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你不能设置 myArray[2]，因为索引签名是只读的。</p>
</blockquote>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><blockquote>
<p>与 C#或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> implements <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: number, m: number</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在接口中描述一个方法,在类里实现,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">  <span class="title function_">setTime</span>(<span class="attr">d</span>: <span class="title class_">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> implements <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">	<span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">	<span class="title function_">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">currentTime</span> = d;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">h: number, m: number</span>)&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口描述了类的公共部分，而不是公共和私有两部分。  它不会帮你检查类是否具有某些私有成员。</p>
</blockquote>
<h4 id="类静态部分与实例部分的区别-没看懂"><a href="#类静态部分与实例部分的区别-没看懂" class="headerlink" title="类静态部分与实例部分的区别(没看懂)"></a>类静态部分与实例部分的区别(没看懂)</h4><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。  你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：<br>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor 存在于类的静态部分，所以不在检查的范围内。<br>因此，我们应该直接操作类的静态部分。  看下面的例子，我们定义了两个接口， ClockConstructor 为构造函数所用和 ClockInterface 为实例方法所用。  为了方便我们定义一个构造函数  createClock，它用传入的类型创建实例。(没看懂)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> (<span class="attr">hour</span>: number, <span class="attr">minute</span>: number): <span class="title class_">ClockInterface</span>;</span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="title function_">tick</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createClock</span>(<span class="params">ctor: ClockConstructor, hour: number, minute: number</span>): <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DigitalClock</span> implements <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: number, m: number</span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beep beep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnalogClock</span> implements <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: number, m: number</span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;tick tock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = <span class="title function_">createClock</span>(<span class="title class_">DigitalClock</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = <span class="title function_">createClock</span>(<span class="title class_">AnalogClock</span>, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></table></figure>

<p>因为 createClock 的第一个参数是 ClockConstructor 类型，在 createClock(AnalogClock, 7, 32)里，会检查 AnalogClock 是否符合构造函数签名。</p>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样,接口也可以继承.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Shape</span> &#123;</span><br><span class="line">	<span class="attr">color</span>: string;</span><br><span class="line">&#125;</span><br><span class="line">interface <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> <span class="attr">sideLength</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = &lt;<span class="title class_">Square</span>&gt;&#123;&#125;</span><br><span class="line">square.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.<span class="property">sideLength</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">PenStroke</span> &#123;</span><br><span class="line">    <span class="attr">penWidth</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>, <span class="title class_">PenStroke</span> &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;<span class="title class_">Square</span>&gt;&#123;&#125;;</span><br><span class="line">square.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.<span class="property">sideLength</span> = <span class="number">10</span>;</span><br><span class="line">square.<span class="property">penWidth</span> = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Counter</span> &#123;</span><br><span class="line">    (<span class="attr">start</span>: number): string;</span><br><span class="line">    <span class="attr">interval</span>: number;</span><br><span class="line">    <span class="title function_">reset</span>(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCounter</span>(<span class="params"></span>): <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;<span class="title class_">Counter</span>&gt;<span class="keyword">function</span> (<span class="params">start: number</span>) &#123; &#125;;</span><br><span class="line">    counter.<span class="property">interval</span> = <span class="number">123</span>;</span><br><span class="line">    counter.<span class="property">reset</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">getCounter</span>();</span><br><span class="line"><span class="title function_">c</span>(<span class="number">10</span>);</span><br><span class="line">c.<span class="title function_">reset</span>();</span><br><span class="line">c.<span class="property">interval</span> = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">    private <span class="attr">state</span>: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">SelectableControl</span> <span class="keyword">extends</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> implements <span class="title class_">SelectableControl</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> implements <span class="title class_">SelectableControl</span> &#123;</span><br><span class="line">    <span class="title function_">select</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Location</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的例子里，SelectableControl 包含了 Control 的所有成员，包括私有成员 state。  因为  state 是私有成员，所以只能够是 Control 的子类们才能实现 SelectableControl 接口。  因为只有  Control 的子类才能够拥有一个声明于 Control 的私有成员 state，这对私有成员的兼容性是必需的。<br>在 Control 类内部，是允许通过 SelectableControl 的实例来访问私有成员 state 的。  实际上， SelectableControl 接口和拥有 select 方法的 Control 类是一样的。 Button 和 TextBox 类是 SelectableControl 的子类（因为它们都继承自 Control 并有 select 方法），但 Image 和 Location 类并不是这样的</p>
</blockquote>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: string;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类的关键字"><a href="#类的关键字" class="headerlink" title="类的关键字"></a>类的关键字</h3><ul>
<li>public</li>
<li>private 类的外部不可用，继承也不行</li>
<li>protected 类的外部不可用，继承可以</li>
<li>public readOnly xxx 只读属性</li>
<li>static funcXXX 静态方法，不需要 new 就可以调用</li>
<li>abstract funcXXX 抽象类，所有子类都必须要实现 funcXXX</li>
</ul>
<p>类有 3 个成员: <code>greeting</code>  内部参数, <code>constructor</code>  构造函数, <code>greet()</code>  方法</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>使用继承来扩展类.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters: number = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal moved <span class="subst">$&#123;distanceInMeters&#125;</span>m`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">类;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br><span class="line">dog.<span class="title function_">move</span>(<span class="number">10</span>);</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br></pre></td></tr></table></figure>

<p>类从基类中继承了属性和方法.<br>其中, <code>Dog</code>  是个派生类,它派生自 <code>Animal</code>  基类,通过 <code>extends</code>  关键字.<br>派生类通常被称为子类, 基类为超类.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Slitering...&quot;</span>)</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">40</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Galloping...&quot;</span>);</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&#x27;Python&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Horse</span>(<span class="string">&#x27;Palo&#x27;</span>);</span><br><span class="line">sam.<span class="title function_">move</span>();</span><br><span class="line">tom.<span class="title function_">move</span>(<span class="number">34</span>);</span><br></pre></td></tr></table></figure>

<p>派生类 <code>Snake</code>  包含一个 <code>super()</code> ,它会执行基类的构造函数.<br>在构造函数里访问 <code>this</code>  的属性之前,一定要调用 <code>super</code> .</p>
<blockquote>
<p>Snake 类和  Horse 类都创建了  move 方法，它们重写了从  Animal 继承来的  move 方法，使得  move 方法根据不同的类而具有不同的功能。  注意，即使  tom 被声明为  Animal 类型，但因为它的值是  Horse，调用  tom.move(34)时，它会调用  Horse 里重写的方法</p>
</blockquote>
<h3 id="公有-私有与受保护的修饰符"><a href="#公有-私有与受保护的修饰符" class="headerlink" title="公有,私有与受保护的修饰符"></a>公有,私有与受保护的修饰符</h3><h4 id="默认为-public"><a href="#默认为-public" class="headerlink" title="默认为 public"></a>默认为 <code>public</code></h4><p>Ts 中.成员默认为 <code>public</code> ,</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>当成员被标记为 <code>private</code> ,就不能在声明它的外部访问.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Cat&quot;</span>).<span class="property">name</span> <span class="comment">//error, name是私有的.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rhio</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&quot;Rhio&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">cosntructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Goat&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> rhio = <span class="keyword">new</span> <span class="title class_">Rhio</span>();</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">animal = rhio;</span><br><span class="line">animal = employee; <span class="comment">//error,Animal和Employee不兼容.</span></span><br></pre></td></tr></table></figure>

<p><code>Rhio</code>  继承了 <code>Animal</code> ,它们共享了私有定义 <code>private name: string</code> ,因此兼容.<br><code>Emploee</code>  虽然也有私有定义 <code>name</code> ,但是和 <code>Animal</code>  定义的并不相同.</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a><code>protected</code></h4><p>protected 修饰符与  private 修饰符的行为很相似，但有一点不同， protected 成员在派生类中仍然可以访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">department</span> = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getElevatorPitch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Howard&quot;</span>, <span class="string">&quot;Sales&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(howard.<span class="title function_">getElevatorPitch</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(howard.<span class="property">name</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>注意，我们不能在  Person 类外使用  name，但是我们仍然可以通过  Employee 类的实例方法访问，因为  Employee 是由  Person 派生而来的。</p>
<p>构造函数也可以被标记成  protected。  这意味着这个类不能在包含它的类外被实例化，但是能被继承</p>
<h4 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h4><p>你可以使用  readonly 关键字将属性设置为只读的。  只读属性必须在声明时或构造函数里被初始化。</p>
<h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。<br>在构造函数里使用 <code>readonly name:string</code>  参数来创建和初始化 <code>name</code>  成员.<br>对于 <code>private</code>  和 <code>protected</code>  也一样.</p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>TS 支持通过 <code>getters/setters</code>  来截取对对象成员的访问.<br>将下面的例子改写为使用 <code>get</code>  和 <code>set</code> .</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&quot;secret passcode&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_fullName</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&quot;secret passcode&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> empolyee = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&quot;Bob Smith&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(employee.<span class="property">fullName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限.</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类一般不会被实例化.不同接口,抽象类可以包含成员的细节.<br><code>abstract</code>  用于定义抽象类和在抽象类内部定义抽象方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">public name: string</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printName</span>(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;department name: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	abstract <span class="title function_">printMeeting</span>(): <span class="keyword">void</span>; <span class="comment">//必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。  抽象方法的语法与接口方法相似。  两者都是定义方法签名但不包含方法体。  然而，抽象方法必须包含  abstract 关键字并且可以包含访问修饰符。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">printName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Department name: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">printMeeting</span>(): <span class="built_in">void</span>; <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&quot;Accounting and Auditing&quot;</span>); <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The Accounting Department meets each Monday at 10am.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">generateReports</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Generating accounting reports...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">department</span>: <span class="title class_">Department</span>; <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">Department</span>(); <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">AccountingDepartment</span>(); <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.<span class="title function_">printName</span>();</span><br><span class="line">department.<span class="title function_">printMeeting</span>();</span><br><span class="line">department.<span class="title function_">generateReports</span>(); <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>

<h3 id="把类当做接口用"><a href="#把类当做接口用" class="headerlink" title="把类当做接口用"></a>把类当做接口用</h3><p>类定义会创建两个东西：类的实例类型和一个构造函数。  因为类可以创建出类型，所以你能够在允许使用接口的地方使用类</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3</span>d <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">point3d</span>: <span class="title class_">Point3</span>d = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>使用<code>instance</code>关键字.<br>将<code>constructor</code>私有化.<br>在类的内部去 new 一个实例,在外部无法 new 该实例.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DellAnalyzer</span> <span class="keyword">implements</span> <span class="title class_">IAnalyzer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">instance</span>: <span class="title class_">DellAnalyzer</span></span><br><span class="line">  <span class="comment">// 使用该函数提供对外的方法入口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">DellAnalyzer</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">            <span class="title class_">DellAnalyzer</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">DellAnalyzer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">DellAnalyzer</span>.<span class="property">instance</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改成单例模式,私有化constructor,外部无法调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="类的装饰器"><a href="#类的装饰器" class="headerlink" title="类的装饰器"></a>类的装饰器</h3><p>装饰器本身是一个函数,通过<code>@</code>符号使用.<br>接收的参数是一个构造函数.<br>执行时机在类创建时立即执行.<br>多个装饰器,执行顺序是反着的,先写的后执行.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testDecorator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用泛型规范入参为构造函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> &lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt;(<span class="attr">constructor</span>: T) &#123;</span><br><span class="line">    <span class="comment">// 扩展constructor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> constructor &#123;</span><br><span class="line">      name = <span class="string">&quot;lee&quot;</span>;</span><br><span class="line">      <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Test</span> = <span class="title function_">testDecorator</span>()(</span><br><span class="line">  <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: stirng</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;dell&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">getName</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类中方法的装饰器"><a href="#类中方法的装饰器" class="headerlink" title="类中方法的装饰器"></a>类中方法的装饰器</h3><p>普通方法,target 对应的是类的<code>prototype</code><br>静态方法,target 对应的是类的构造函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNameDecorator</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  key: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  descriptor: PropertypeDecorator</span></span><br><span class="line"><span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@getNameDecorator</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;dell&quot;</span>);</span><br><span class="line">consoele.<span class="title function_">log</span>(test.<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure>

<h3 id="类中访问器的装饰器"><a href="#类中访问器的装饰器" class="headerlink" title="类中访问器的装饰器"></a>类中访问器的装饰器</h3><p><code>get</code>和<code>set</code>不能同时使用装饰器.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">visitDecorator</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  key: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  descriptor: PropertyDecorator</span></span><br><span class="line"><span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@visitDecorator</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;dell&quot;</span>);</span><br><span class="line">test.<span class="property">name</span> = <span class="string">&quot;dell lee&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类中属性的装饰器"><a href="#类中属性的装饰器" class="headerlink" title="类中属性的装饰器"></a>类中属性的装饰器</h3><p>和方法的装饰器的区别是没有第三个参数,但是可以自己添加</p>
<blockquote>
<p>装饰器的修改是修改 prototype 上的,即修改并不是实例上的,而是原型上的.</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nameDecorator</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">descriptor</span>: <span class="title class_">PropertyDecorator</span> = &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="meta">@nameDecorator</span></span><br><span class="line">  name = <span class="string">&quot;dell&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">test.<span class="property">name</span> = <span class="string">&quot;dell lee&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">name</span>); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h3 id="类中参数的装饰器"><a href="#类中参数的装饰器" class="headerlink" title="类中参数的装饰器"></a>类中参数的装饰器</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">paramDecorator</span>(<span class="params">target: <span class="built_in">any</span>, method: <span class="built_in">string</span>, paramIndex: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target, method, paramIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="title function_">getInfo</span>(<span class="params"><span class="meta">@paramDecorator</span> name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">test.<span class="title function_">getInfo</span>(<span class="string">&quot;Dell&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>将报错捕获统一使用装饰器</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式返回一个装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">catchError</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, discriptor: propertyDecorator</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = discriptor.<span class="property">value</span>;</span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="meta">@catchError</span>(<span class="string">&quot;userInfo.name不存在&quot;</span>)</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> userInfo.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@catchError</span>(<span class="string">&quot;userInfo.age不存在&quot;</span>)</span><br><span class="line">  <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> userInfo.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">test.<span class="title function_">getName</span>();</span><br><span class="line">test.<span class="title function_">getAge</span>();</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数类型包括两部分: 参数类型和返回值类型.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只要参数类型匹配,就认为他是有效的函数类型,不在乎参数名是否正确.</p>
<p>在函数和返回值类型之前使用( <code>=&gt;</code> )符号.</p>
<p>返回值类型是函数类型的必要成分,如果函数没有返回任何值.也必须指定返回值类型为 <code>void</code> .</p>
<h4 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h4><p>如果在赋值语句一边指定类型,另一边没有指定.TS 会自定识别处类型:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myAdd has the full function type</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The parameters `x` and `y` have the type number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这叫’按上下文归类’,是类型推论的一种.</p>
<h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><blockquote>
<p>TypeScript 里的每个函数参数都是必须的。  这不是指不能传递  null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。  编译器还会假设只有这些参数会被传递进函数。  简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span>;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>); <span class="comment">//error, 少参数</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&quot;Bob&quot;</span>,</span><br></pre></td></tr></table></figure>

<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>若要同时操作多个参数,可以使用<code>arguments</code>来访问所有传入的参数.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employeeName = <span class="title function_">buildName</span>(<span class="string">&quot;Jose&quot;</span>, <span class="string">&quot;Sam&quot;</span> ,<span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;Mack&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在箭头函数中指定<code>this</code>参数.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">  <span class="attr">suit</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">card</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Deck</span> &#123;</span><br><span class="line">  <span class="attr">suits</span>: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="attr">cards</span>: <span class="built_in">number</span>[];</span><br><span class="line">  <span class="title function_">createCardPicker</span>(<span class="attr">this</span>: <span class="title class_">Deck</span>): <span class="function">() =&gt;</span> <span class="title class_">Card</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">deck</span>: <span class="title class_">Deck</span> = &#123;</span><br><span class="line">  <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">  <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">  <span class="attr">createCardPicker</span>: <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: Deck</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.<span class="title function_">createCardPicker</span>();</span><br><span class="line"><span class="keyword">let</span> pickedCard = <span class="title function_">cardPicker</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard.<span class="property">suit</span>);</span><br></pre></td></tr></table></figure>

<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>为同一个函数提供多个函数类型定义来进行函数重载.<br>编译器会根据这个列表去处理函数的调用.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: &#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): &#123; <span class="attr">suit</span>: <span class="built_in">string</span>; <span class="attr">card</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="comment">// Check to see if we&#x27;re working with an object/array</span></span><br><span class="line">  <span class="comment">// if so, they gave us the deck and we&#x27;ll pick the card</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * x.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> pickedCard;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&quot;diamonds&quot;</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&quot;spades&quot;</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&quot;hearts&quot;</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[<span class="title function_">pickCard</span>(myDeck)];</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard1.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard1.<span class="property">suit</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = <span class="title function_">pickCard</span>(<span class="number">15</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;card: &quot;</span> + pickedCard2.<span class="property">card</span> + <span class="string">&quot; of &quot;</span> + pickedCard2.<span class="property">suit</span>);</span><br></pre></td></tr></table></figure>

<p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>
<p>注意，function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard 会产生错误。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>使用<code>&lt;&gt;</code>来指定泛型的类型,保证传入的参数和输出的参数是一致的.<br>更普遍的泛型是不写,让编译器自己通过类型推断确定类型,如果编译器无法推断,就需要写泛型了.<br>泛型是声明的时候随便定义,使用的时候进行真正定义.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> join&lt;T, P&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: P) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明的时候并不知道具体参数是什么类型</span></span><br><span class="line"><span class="comment">// 但是使用时, 通过在这里声明就限定了参数的类型</span></span><br><span class="line">join&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">// 当然也可以不写,这样会自己推断出</span></span><br><span class="line"><span class="title function_">join</span>(<span class="number">1</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h3><p>通过指定 arg 的参数类型是 T 的数组,返回的元素类型也是 T 的数组,存在长度,不会报错.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T&gt;(<span class="attr">arg</span>: T[]): T[] &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类似于泛型接口,泛型类使用<code>&lt;&gt;</code>括起泛型类型,跟在类名后面.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="attr">zeroValue</span>: T;</span><br><span class="line">	<span class="attr">add</span>: <span class="function">(<span class="params">x:T, y:T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;number&gt;()</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> data: T[]</span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getItem</span>(<span class="attr">index</span>: <span class="built_in">number</span>): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用时指定泛型是number</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">DataManger</span>&lt;<span class="built_in">number</span>&gt;([<span class="string">&quot;1&quot;</span>]);</span><br><span class="line">data.<span class="title function_">getItem</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>此时 GenericNumber 类只能使用 number 类型.<br>类有两部分:静态部分和实例部分.泛型类指的是实例部分的类型,所以类的静态属性不能使用这个泛型类型.</p>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>通过<code>extends</code>关键字约束条件.<br>定义一个接口来描述约束条件,创建一个包含<code>.length</code>属性的接口.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  retrun arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><p>作用:使用枚举定义一些带名字的常量.</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Up初始化为1,其余成员从1开始增长</span></span><br><span class="line"><span class="comment">//如果不设置初始值,那么up为0,总之,各个值都是不同的</span></span><br></pre></td></tr></table></figure>

<p>用法: 通过枚举的属性来访问枚举的成员,和枚举的名字来访问枚举类型:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Response</span> &#123;</span><br><span class="line">  <span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Yes</span> = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">respond</span>(<span class="params">recipient: string, message: Response</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">respond</span>(<span class="string">&#x27;Princess Caroline&#x27;</span>, <span class="title class_">Response</span>.<span class="property">Yes</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不带初始化器的枚举或者被放在第一的位置,或者被放在使用了数字常量或其他常量初始化了的枚举后面.</p>
</blockquote>
<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>在一个字符串枚举中,每个成员都必须用字符串字面量,或另外一个字符串枚举成员进行初始化.</p>
<h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><p>枚举可以混合字符串和数字成员.但不建议这样做.</p>
<h4 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h4><p>每个枚举成员都带有一个值,他可以是常量或计算出来的.当满足如下条件时,枚举成员被当做是常量:</p>
<ol>
<li>它是枚举的第一个成员且没有初始化器,这种情况下它被赋予值 0:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123; x &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>它不带有初始化器且它之前的枚举成员是一个数字常量.这种情况下,当前枚举成员的值为它上一个枚举成员的值加 1.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">  A =<span class="number">1</span>, B, C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>枚举成员使用常量枚举表达式初始化.常数枚举表达式是 TS 表达式的子集.它可以在编译阶段求值.当一个表达式满足下面条件之一时,它就是一个常量枚举表达式:</li>
</ol>
<ul>
<li>一个枚举表达式字面量</li>
<li>一个对之前定义的常量枚举成员的引用</li>
<li>带括号的常量枚举表达式</li>
<li>一元运算符<code>+</code>,<code>-</code>,<code>~</code>其中之一应用在常量枚举表达式</li>
<li>常量枚举表达式作为二次运算符<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>,<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>&gt;&gt;&gt;</code>,<code>&amp;</code>,<code>|</code>,<code>^</code>的操作对象,若常熟枚举表达式求值后为<code>NaN</code>或<code>Infinity</code>,则会在编译阶段报错.</li>
</ul>
<p>所有其他情况的枚举成员被当做是需要计算得出的值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">FileAccess</span> &#123;</span><br><span class="line">  <span class="title class_">None</span>,</span><br><span class="line">  <span class="title class_">Read</span>  = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Write</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">ReadWrite</span> = <span class="title class_">Read</span> | <span class="title class_">Write</span>,</span><br><span class="line">  G = <span class="string">&#x27;123&#x27;</span>.<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><p>字面量枚举成员是指不带有初始值的常量枚举成员,或者值被初始化为</p>
<ul>
<li>任何字符串字面量</li>
<li>任何数字字面量</li>
<li>应用了一元<code>-</code>符号的数字字面量</li>
</ul>
<p>当所有枚举成员都拥有字面量枚举值时,他就带有了一种特殊的语义.<br>首先,枚举成员成为了类型.<br>枚举类型本身变成了每个枚举成员的联合.</p>
<h3 id="运行时枚举"><a href="#运行时枚举" class="headerlink" title="运行时枚举"></a>运行时枚举</h3><p>枚举是在运行时真正存在的对象.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">  X,Y,Z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Enum</span> &#123;</span><br><span class="line">  A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Enum</span>.<span class="property">A</span></span><br><span class="line"><span class="keyword">let</span> nameOfA = <span class="title class_">Enum</span>[a] <span class="comment">//&quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a>const 枚举</h3><p>为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问.<br>可以使用 const 枚举,常量枚举通过在枚举上使用<code>const 修饰符来定义.</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enum <span class="title class_">Enum</span> &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量枚举只能使用常量枚举表达式,并且不同于常规枚举,它们在编译阶段会被删除,常量枚举成员在使用的地方会被内联进来.原因是常量枚举不允许包含计算成员.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enum <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>]</span><br></pre></td></tr></table></figure>

<p>生产的代码为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h3><p>描述已经存在的枚举类型的形状.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare enum <span class="title class_">Enum</span> &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B,</span><br><span class="line">  C =<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><p>TS 的类型推论可能按照相反的方向进行.叫做按上下文归类.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmousedown</span> = <span class="keyword">function</span> (<span class="params">mouseEvent</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(mouseEvnet.<span class="property">button</span>); <span class="comment">//error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子会得到一个类型错误.TS 类型检查器使用<code>Window.onmousedown</code>函数的类型来推断右边函数表达式的类型.如果函数表达式不是在上下文类型的位置,<code>mouseEvent</code>参数的类型需要指定为<code>any</code>,这样也不会报错.</p>
<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>结构化类型系统的基本规则是,如果<code>x</code>想兼容<code>y</code>,那么<code>y</code>至少具有与<code>x</code>相同的属性.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Named</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="title class_">Named</span>;</span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">location</span>: <span class="string">&quot;Seattle&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//类型推断y的类型是&#123;name: string, location: string&#125;</span></span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里检查 y 是否可以赋值给 x,编译器检查 x 中的每个属性,看是否能在 y 中也找到对应属性.注意,y 有个额外参数,但不会引起错误.只有目标类型(这里是 Named)的成员会被一一检查是否兼容.</p>
</blockquote>
<h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">x</span> = (<span class="params">a: number</span>) =&gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">y</span> = (<span class="params">a: number, s: string</span>) =&gt; <span class="number">0</span>;</span><br><span class="line">y = x; <span class="comment">//ok</span></span><br><span class="line">x = y; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p>看 x 是否可以赋值给 y 首先看参数列表.<br>x 的每个参数必须在 y 里找到对应类型的参数.注意的是参数的名字相同与否无所谓,只看类型.<br>x 的每个参数都可以在 y 中找到对应的参数,所以运行赋值.<br>第二个赋值错误,因为 y 有个必须的第二个参数,但是 x 没有,所以不允许赋值.</p>
<h3 id="枚举-2"><a href="#枚举-2" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型与数字类型兼容,并且数字类型与枚举类型兼容.不同枚举类型之间是不兼容.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="title class_">Status</span> &#123; <span class="title class_">Ready</span>, <span class="title class_">Waiting</span>&#125;</span><br><span class="line">enum <span class="title class_">Color</span> &#123; <span class="title class_">Red</span>, <span class="title class_">Blue</span>,<span class="title class_">Green</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status = <span class="title class_">Status</span>.<span class="property">Ready</span></span><br><span class="line">status = <span class="title class_">Color</span>.<span class="property">Green</span> <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><p>类与对象字面量和接口差不多,但有一点不同: 类有静态部分和实例部分的类型.<br>比较两个类类型的对象时,只有实例的成员会被比较.静态成员和构造函数不在比较的范围内.</p>
<h3 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h3><p>因为 TS 是结构性的类型系统,类型参数只影响使用其作为类型一部分的结果类型.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Empty</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="attr">x</span>: <span class="title class_">Empty</span>&lt;number&gt;;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">y</span>: <span class="title class_">Empty</span>&lt;string&gt;;</span><br><span class="line">  x = y; <span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<p>其中,x 和 y 是兼容的,因为他们的结构使用类型参数时并没有什么不同.</p>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>即多个类型合并成一个类型.<br>适合场景: 混入或者其他不适合典型面向对象模型的地方.<br>下面的例子没看懂</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> extend&lt;T, U&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U): T &amp; U &#123;</span><br><span class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    for (let id in first) &#123;</span><br><span class="line">        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    for (let id in second) &#123;</span><br><span class="line">        if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(public name: string) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Loggable &#123;</span><br><span class="line">    log(): void;</span><br><span class="line">&#125;</span><br><span class="line">class ConsoleLogger implements Loggable &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());</span><br><span class="line">var n = jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>表示一个值可以是几种类型之一.我们用竖线(<code>|</code>)分隔每个类型.<br>可以访问联合类型的所有类型里的共有成员.</p>
<h3 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面代码会报错</span></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>();</span><br><span class="line"><span class="comment">//每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.<span class="property">swim</span>) &#123;</span><br><span class="line">  pet.<span class="title function_">swim</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.<span class="property">fly</span>) &#123;</span><br><span class="line">  pet.<span class="title function_">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用类型断言解决:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>()</span><br><span class="line"><span class="keyword">if</span>((&lt;<span class="title class_">Fish</span>&gt;pet).<span class="property">swim</span>)&#123;</span><br><span class="line">  (&lt;<span class="title class_">Fish</span>&gt;pet).<span class="title function_">swim</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  (&lt;<span class="title class_">Bird</span>&gt;pet).<span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><h3 id="全局库声明文件"><a href="#全局库声明文件" class="headerlink" title="全局库声明文件"></a>全局库声明文件</h3><p>通过<code>declare</code>关键字进行声明文件可以在全局访问,而一般将该文件定义在<code>types/*.d.ts</code>中方便管理.<br>而<code>interface</code>和<code>type</code>不需要<code>declare</code>也可以在全局访问.<br>一般的<code>declare</code>声明不能重复声明,即使重复也只显示第一个.而<code>interface</code>重复声明会发生合并.<br><code>declare</code>使用<code>export</code>替换效果是一样的.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery.d.ts</span></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">$</span>: <span class="function">(<span class="params">param: () =&gt; <span class="built_in">void</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// 定义全局函数</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JQueryInstance</span> &#123;</span><br><span class="line">  <span class="attr">html</span>: <span class="function">(<span class="params">html: <span class="built_in">string</span></span>) =&gt;</span> <span class="title class_">JqueryInstance</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载(也就是重复声明)</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">$</span>(<span class="params">readyFunc: () =&gt; <span class="built_in">void</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">$</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title class_">JqueryInstance</span>;</span><br><span class="line"><span class="comment">// 使用interface定义</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JQuery</span> &#123;</span><br><span class="line">  (<span class="attr">readyFunc</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">  (<span class="attr">selector</span>: <span class="built_in">string</span>): <span class="title class_">JqueryInstance</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">$</span>: <span class="title class_">JQuery</span>;</span><br></pre></td></tr></table></figure>

<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">n</span>: <span class="built_in">number</span> = <span class="number">123</span>; <span class="comment">//可以全局访问</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">making</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">numbeOfMaking</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以将这些变量放在namespace的作用域内,</span></span><br><span class="line"><span class="comment">// 通过myLib.making()进行访问.</span></span><br><span class="line"><span class="comment">// 内部不用再写declare,另外内部也可以嵌套namespace</span></span><br></pre></td></tr></table></figure>

<h3 id="模块化库声明文件"><a href="#模块化库声明文件" class="headerlink" title="模块化库声明文件"></a>模块化库声明文件</h3><p>模块化声明时文件放置到<code>types/*</code>,声明该模块同名的文件夹.<br>注意修改<code>tsconfig.json</code>文件中的配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/*&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型帮助类型"><a href="#泛型帮助类型" class="headerlink" title="泛型帮助类型"></a>泛型帮助类型</h2><h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><p>通过类型推论进行类型保护,即类型收窄.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">  <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">  <span class="title function_">fly</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Pet</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pets.<span class="title function_">forEach</span>(<span class="function">(<span class="params">pet</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isFish</span>(pet)) &#123;</span><br><span class="line">    pet.<span class="title function_">swim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.<span class="title function_">fly</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a>in 操作符</h3><p>同样用于类型收窄(类型保护)</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pets.<span class="title function_">forEach</span>(<span class="function">(<span class="params">pet</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> pet) &#123;</span><br><span class="line">    pet.<span class="title function_">swim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.<span class="title function_">fly</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p><code>typeof variable === &#39;类型名称&#39;</code>表达式明确告知 TypeScript 变量 variable 的类型，<br>起到类型保护的作用.</p>
<h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><p><code>variable instanceof Type</code>告知 TypeScript 变量 variable 的类型为 Type，起到类型保护的作用：<br>使用<code>instanceof</code>注意只能使用<code>class</code>,不能使用<code>interface</code>.否则无法调用<code>instanceof</code>.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="title function_">swim</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fish is swiming&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="title function_">fly</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bird is flying&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">pet: Fish | Bird</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pet <span class="keyword">instanceof</span> <span class="title class_">Fish</span>) &#123;</span><br><span class="line">    pet.<span class="title function_">swim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.<span class="title function_">fly</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p><code>T extends U ? X : Y;</code><br>若 T 能赋值给 U,则类型是 X,否则是 Y.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Words</span> = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> W&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Words</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">WA</span> = W&lt;<span class="string">&quot;a&quot;</span>&gt;; <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">WD</span> = W&lt;<span class="string">&quot;d&quot;</span>&gt;; <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><p>表示在 extends 条件语句中待推断的类型变量.i</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Union</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer U&gt; ? U : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果泛型参数 T 满足约束条件 Array,那就返回这个类型变量 U.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ParamType</span>&lt;T&gt; = T <span class="keyword">extends</span> (<span class="attr">param</span>: infer P) =&gt; <span class="built_in">any</span> ? P : T;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="function">(<span class="params">dog: IDog</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Param</span> = <span class="title class_">ParamType</span>&lt;<span class="title class_">Func</span>&gt;; <span class="comment">//IDog</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TypeSring</span> = <span class="title class_">ParamType</span>&lt;stirng&gt;; <span class="comment">//string</span></span><br></pre></td></tr></table></figure>

<h3 id="keyof-索引类型"><a href="#keyof-索引类型" class="headerlink" title="keyof(索引类型)"></a>keyof(索引类型)</h3><p>用来取得一个对象接口的所有 key 值.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K1</span> = keyof <span class="title class_">IPerson</span>; <span class="comment">//&#x27;name&#x27; | &#x27;age&#x27; | &#x27;sex&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K2</span> = keyof <span class="title class_">IPerson</span>[]; <span class="comment">//&#x27;length&#x27;|&#x27;push&#x27;|&#x27;pop&#x27;...</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K3</span> = <span class="keyword">typeof</span> &#123; [<span class="attr">x</span>:<span class="built_in">string</span>]: <span class="title class_">Person</span> &#125;; <span class="comment">//string | number`</span></span><br></pre></td></tr></table></figure>

<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>在 JS 中,typeof 判断数据类型.<br>在 TS 中,获取一个变量的声明类型,如果不存在,获取该变量的推论类型.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  sex?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">jack</span>: <span class="title class_">IPerson</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>, <span class="attr">age</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Jack</span> = <span class="keyword">typeof</span> jack; <span class="comment">// -&gt; IPerson</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F = <span class="keyword">typeof</span> foo; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br><span class="line"><span class="comment">//Jack 这个类型别名实际上就是 jack 的类型 IPerson，</span></span><br><span class="line"><span class="comment">//而 F 的类型就是 TS 自己推导出来的 foo 的类型 (x: number) =&gt; number[]。</span></span><br></pre></td></tr></table></figure>

<h2 id="内置帮助类型"><a href="#内置帮助类型" class="headerlink" title="内置帮助类型"></a>内置帮助类型</h2><h3 id="Partial-映射类型"><a href="#Partial-映射类型" class="headerlink" title="Partial(映射类型)"></a>Partial<T>(映射类型)</h3><p>让 T 中所有属性都是可选的.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，我们希望类型中的所有属性都不是必需的，只有在某些条件下才存在，我们就可以使用 Partial 来将已声明的类型中的所有属性标识为可选的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">pirce</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialDog</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Dog</span>&gt;;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialDog</span> = &#123;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  pirce?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<T></h3><p>与<code>Partial</code>正好相反,所有属性都是必选的.</p>
<h3 id="Readonly-映射类型"><a href="#Readonly-映射类型" class="headerlink" title="Readonly(映射类型)"></a>Readonly<T>(映射类型)</h3><p>所有属性设为只读</p>
<h3 id="Record-lt-K-T-gt"><a href="#Record-lt-K-T-gt" class="headerlink" title="Record&lt;K,T&gt;"></a>Record&lt;K,T&gt;</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with a set of properties K of type T</span></span><br><span class="line"><span class="comment"> * 构造一个具有一组属性K(类型T)的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造一个具有一组属性 K(类型 T)的类型.<br>K 对应 key,T 对应对象的 value.返回是一个声明好的对象.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> petsGroup = <span class="string">&quot;dog&quot;</span> | <span class="string">&quot;cat&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPetInfo</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IPets</span> = <span class="title class_">Record</span>&lt;petsGroup, <span class="title class_">IPetInfo</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">animalsInfo</span>: <span class="title class_">IPets</span> = &#123;</span><br><span class="line">  <span class="attr">dog</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">cat</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;xiaobai&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Pick-lt-T-K-gt"><a href="#Pick-lt-T-K-gt" class="headerlink" title="Pick&lt;T,K&gt;"></a>Pick&lt;T,K&gt;</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * From T, pick a set of properties whose keys are in the union K</span></span><br><span class="line"><span class="comment"> * 从T中，选择一组键在并集K中的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从源码可以看到 K 必须是 T 的 key，然后用 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值.<br>相当于从 T 里挑选 K(可能是多个)出来作为属性.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PickDog</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">IDog</span>, <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span> | <span class="string">&quot;height&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PickDog</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">dog</span>: <span class="title class_">PickDog</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wangcai&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">70</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Exclude-lt-T-U-gt"><a href="#Exclude-lt-T-U-gt" class="headerlink" title="Exclude&lt;T,U&gt;"></a>Exclude&lt;T,U&gt;</h3><p>排除 T 中的 U.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude from T those types that are assignable to U</span></span><br><span class="line"><span class="comment"> * 从T中排除那些可分配给U的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<p>与 Pick 相反，Pick 用于拣选出我们需要关心的属性，而 Exclude 用于排除掉我们不需要关心的属性.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> keys = keyof <span class="title class_">IDog</span>; <span class="comment">// -&gt; &quot;name&quot; | &quot;age&quot; | &quot;height&quot; | &quot;weight&quot; | &quot;sex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExcludeDog</span> = <span class="title class_">Exclude</span>&lt;keys, <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExcludeDog</span> = <span class="string">&quot;height&quot;</span> | <span class="string">&quot;weight&quot;</span> | <span class="string">&quot;sex&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Extract-lt-T-U-gt"><a href="#Extract-lt-T-U-gt" class="headerlink" title="Extract&lt;T,U&gt;"></a>Extract&lt;T,U&gt;</h3><p>相当于取交集</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extract from T those types that are assignable to U</span></span><br><span class="line"><span class="comment"> * 从T中提取可分配给U的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Omit-lt-T-K-gt"><a href="#Omit-lt-T-K-gt" class="headerlink" title="Omit&lt;T,K&gt;"></a>Omit&lt;T,K&gt;</h3><p>类似于<code>Exclude</code>,但是更方便.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with the properties of T except for those in type K.</span></span><br><span class="line"><span class="comment"> * 构造一个除类型K之外的T属性的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude null and undefined from T</span></span><br><span class="line"><span class="comment"> * 从T中排除null和undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>返回类型为 T 的函数的参数类型所组成的数组.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the parameters of a function type in a tuple</span></span><br><span class="line"><span class="comment"> * 在元组中获取构造函数类型的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: infer P</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? P</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Parameters</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;; <span class="comment">// [string]</span></span><br></pre></td></tr></table></figure>

<h3 id="ConstructorParamters"><a href="#ConstructorParamters" class="headerlink" title="ConstructorParamters"></a>ConstructorParamters</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the parameters of a constructor function type in a tuple</span></span><br><span class="line"><span class="comment"> * 在元组中获取构造函数类型的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructorParameters</span>&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the return type of a function type</span></span><br><span class="line"><span class="comment"> * 获取函数类型的返回类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<h3 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the return type of a constructor function type</span></span><br><span class="line"><span class="comment"> * 获取构造函数类型的返回类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">InstanceType</span>&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<h3 id="ThisType"><a href="#ThisType" class="headerlink" title="ThisType"></a>ThisType</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marker for contextual &#x27;this&#x27; type</span></span><br><span class="line"><span class="comment"> * 上下文“this”类型的标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ThisType</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">ThisType</span>&lt;<span class="title class_">Person</span>&gt; = &#123;</span><br><span class="line">  <span class="title function_">mimi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>; <span class="comment">// string</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的话，就可以指定 obj 里的所有方法里的上下文对象改成 Person 这个类型了</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有ThisType情况下</span></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  <span class="title function_">wang</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>); <span class="comment">// error，在dog中只有wang一个函数，不存在a</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用ThisType</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: &#123; <span class="attr">wang</span>: <span class="built_in">any</span> &#125; &amp; <span class="title class_">ThisType</span>&lt;&#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;&gt; = &#123;</span><br><span class="line">  <span class="title function_">wang</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">wang</span>); <span class="comment">// error，因为没有在ThisType中定义</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>); <span class="comment">// ok</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">dog.<span class="property">wang</span>; <span class="comment">// ok 正常调用</span></span><br><span class="line">dog.<span class="property">age</span>; <span class="comment">// error，在外面的话，就跟ThisType没有关系了,这里就是没有定义age了</span></span><br></pre></td></tr></table></figure>

<p>ThisType 的作用是：提示其下所定义的函数，在函数 body 中，其调用者的类型是什么。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在命名空间中,将想要暴露出去的代码使用<code>export</code>暴露出去,即可在外部调用.</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;reference path=&quot;...&#x27; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>表示引入文件,只能存在于最前端,在后面会被认为是注释.</p>
<h2 id="书写建议"><a href="#书写建议" class="headerlink" title="书写建议"></a>书写建议</h2><ol>
<li>避免 enum 枚举</li>
<li>避免命名空间 namespace</li>
<li>避免装饰器，尽量等到这个语法标准化完成。如果你需要一个库用装饰器，要考虑它的标准化状态。</li>
<li>尽量用 <code>#somePrivateField</code>而不是<code>private somePrivateField</code>.</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/node%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/22/node%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">node爬虫入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-22 09:04:31" itemprop="dateCreated datePublished" datetime="2021-02-22T09:04:31+08:00">2021-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:56" itemprop="dateModified" datetime="2022-11-01T18:08:56+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="node-基础"><a href="#node-基础" class="headerlink" title="node 基础"></a>node 基础</h3><p>require 模块结束时,需要用<code>;</code>结尾.否则报错.</p>
<h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h1><h2 id="请求模块"><a href="#请求模块" class="headerlink" title="请求模块"></a>请求模块</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/request">npm 地址</a><br>虽然 request 模块是几乎学习 node 接触的第一个模块,但是目前已经被弃用了.所以推荐使用 superagent.</p>
<h3 id="superagent"><a href="#superagent" class="headerlink" title="superagent"></a>superagent</h3><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/superagent">npm 地址</a><br>简单的调用,简单的写法,配套的插件.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">&quot;superagent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback</span></span><br><span class="line">superagent</span><br><span class="line">  .<span class="title function_">post</span>(<span class="string">&quot;/api/pet&quot;</span>)</span><br><span class="line">  .<span class="title function_">send</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Manny&quot;</span>, <span class="attr">species</span>: <span class="string">&quot;cat&quot;</span> &#125;) <span class="comment">// sends a JSON post body</span></span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&quot;X-API-Key&quot;</span>, <span class="string">&quot;foobar&quot;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&quot;accept&quot;</span>, <span class="string">&quot;json&quot;</span>)</span><br><span class="line">  .<span class="title function_">end</span>(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Calling the end function will send the request</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise with then/catch</span></span><br><span class="line">superagent.<span class="title function_">post</span>(<span class="string">&quot;/api/pet&quot;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>).<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise with async/await</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> superagent.<span class="title function_">post</span>(<span class="string">&quot;/api/pet&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="解析模块"><a href="#解析模块" class="headerlink" title="解析模块"></a>解析模块</h2><h3 id="cheerio"><a href="#cheerio" class="headerlink" title="cheerio"></a>cheerio</h3><p>cheerio 是 node 中的 jQuery,可方便的控制 dom 节点.获取相应参数.<br>语法使用 jquery 语法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = cheerio.<span class="title function_">load</span>(body);</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a>Puppeteer</h3><p>Puppeteer 俗称无头浏览器,实际是一个没有显示界面的 Chrome 浏览器.故能在浏览器上操作的也可以通过 Puppeteer 操作.<br>缺点是比常规爬虫慢.</p>
<h4 id="cheerio-和-Puppeteer-的区别"><a href="#cheerio-和-Puppeteer-的区别" class="headerlink" title="cheerio 和 Puppeteer 的区别"></a>cheerio 和 Puppeteer 的区别</h4><p>cherrico 本质上只是一个使用类似 jquery 的语法操作 HTML 文档的库，使用 cherrico 爬取数据，只是请求到静态的 HTML 文档，如果网页内部的数据是通过 ajax 动态获取的，那么便爬取不到的相应的数据。<br>而 Puppeteer 能够模拟一个浏览器的运行环境，能够请求网站信息，并运行网站内部的逻辑。然后再通过 WS 协议动态的获取页面内部的数据，并能够进行任何模拟的操作(点击、滑动、hover 等),并且支持跳转页面，多页面管理。<br>甚至能注入 node 上的脚本到浏览器内部环境运行，总之，你能对一个网页做的操作它都能做，你不能做的它也能做。</p>
<h2 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h2><h3 id="iconv-lite"><a href="#iconv-lite" class="headerlink" title="iconv-lite"></a>iconv-lite</h3><p>转码模块,如果中文乱码.可使用该模块进行转码，中文显示正常后开始解析源码，获取需要的 URL.</p>
<h3 id="superagent-charset"><a href="#superagent-charset" class="headerlink" title="superagent-charset"></a>superagent-charset</h3><p>如果不想那么麻烦,直接使用,省的再安装模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&quot;superagent&quot;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;superagent-charset&quot;</span>)(request);</span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">  .<span class="title function_">get</span>(<span class="string">&quot;http://www.xxx.com/&quot;</span>)</span><br><span class="line">  .<span class="title function_">charset</span>(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line">  .<span class="title function_">end</span>(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Tesseract"><a href="#Tesseract" class="headerlink" title="Tesseract"></a>Tesseract</h3><p>OCR 识别模块,可用于识别验证码图片.</p>
<h3 id="gm"><a href="#gm" class="headerlink" title="gm"></a>gm</h3><p>gm 是 Node.js 对 GraphicsMagick 和 ImageMagick 封装。GraphicsMagick 和 ImageMagick 是老牌的图片处理工具.用于对验证码图片的噪点处理.</p>
<h2 id="配合"><a href="#配合" class="headerlink" title="配合"></a>配合</h2><p>Puppeteer 用于抓取网页中的图片，Tesseract 做图像识别，gm 实现图片去噪点，三个工具各司其职，分工明确。</p>
<h2 id="node-爬虫框架"><a href="#node-爬虫框架" class="headerlink" title="node 爬虫框架"></a>node 爬虫框架</h2><h3 id="ppspider"><a href="#ppspider" class="headerlink" title="ppspider"></a>ppspider</h3><p><a target="_blank" rel="noopener" href="https://github.com/xiyuan-fengyu/ppspider.git">github 地址</a></p>
<h2 id="操作思想"><a href="#操作思想" class="headerlink" title="操作思想"></a>操作思想</h2><p>爬虫主要在于两个字,’爬’和’取’.<br>‘爬’在于发起请求,获取数据.<br>‘取’在于解析数据.</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>node 多会进行 IO 操作,所以需要经常使用错误处理.<br>常用的比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">superagent.<span class="title function_">get</span>(url).<span class="title function_">end</span>(<span class="keyword">function</span> (<span class="params">err, res</span>) &#123;</span><br><span class="line">  <span class="comment">// 抛错拦截</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">throw</span> <span class="title class_">Error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等待 code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>try&#x2F;catch 操作注意异步处理.</p>
<blockquote>
<p>《深入浅出 Nodejs》书中描述” 尝试对异步方法进行 try&#x2F;catch 操作只能捕获当次事件循环内的异常，对 callback 执行时抛出的异常将无能为力 “。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903742966349832">可参考此文</a></p>
</blockquote>
<h1 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h1><ol>
<li>通过 UA 机制识别爬虫。</li>
</ol>
<p>UA 的全称是 UserAgent，它是请求浏览器的身份标志，许多网站使用它来作为鉴别爬虫的标志，假如访问请求的头部中没有带 UA 那么就会被判定为爬虫，但由于这种要针对这种反爬虫机制非常容易，即随机 UA，因此这种反爬机制使用的很少。</p>
<ol start="2">
<li>通过访问频率鉴别爬虫。</li>
</ol>
<p>爬虫为了更好地保证效率，通常会在很短的时间内多次访问目标网站，因此能够通过单个 IP 访问的频率来判断是否为爬虫。并且，这种反爬方式比较难以被反反爬机制反制，只能通过更换代理 IP 来保证效率。</p>
<ol start="3">
<li>通过 Cookie 和验证码识别爬虫。</li>
</ol>
<p>Cookie 是指会员制的账号密码登陆验证，这就可以通过限制单账号抓取频率来限制爬虫抓取，而验证码完全是随机的，爬虫脚本无法正确鉴别，同样能够限制爬虫程序。</p>
<h2 id="反反爬虫"><a href="#反反爬虫" class="headerlink" title="反反爬虫"></a>反反爬虫</h2><p>爬虫过于频繁就会触发封 ip,弹验证码等反爬虫的行为.那么就要有一些反反爬虫的策略.<br>常用操作有使用代理,降低操作频率.<br>添加多个 user-agent 用于随机调换.</p>
<h3 id="动态-userAgent"><a href="#动态-userAgent" class="headerlink" title="动态 userAgent"></a>动态 userAgent</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//userAgent</span></span><br><span class="line"><span class="keyword">const</span> userAgents = [</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0) ,Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Opera/9.25 (Windows NT 5.1; U; en), Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = userAgents;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;superagent&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> userAgents <span class="keyword">from</span> <span class="string">&quot;../src/userAgent&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doRequest</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> userAgent = userAgents[<span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * userAgents.<span class="property">length</span>)];</span><br><span class="line">  request</span><br><span class="line">    .<span class="title function_">get</span>(<span class="string">&quot;http://www.xxx.com&quot;</span>)</span><br><span class="line">    .<span class="title function_">set</span>(&#123; <span class="string">&quot;User-Agent&quot;</span>: userAgent &#125;) <span class="comment">//随机调用UA</span></span><br><span class="line">    .<span class="title function_">timeout</span>(&#123; <span class="attr">response</span>: <span class="number">5000</span>, <span class="attr">deadline</span>: <span class="number">60000</span> &#125;)</span><br><span class="line">    .<span class="title function_">end</span>(<span class="keyword">async</span> (err, res) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 处理数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="superagent-cache-plugin"><a href="#superagent-cache-plugin" class="headerlink" title="superagent-cache-plugin"></a>superagent-cache-plugin</h3><p>有的需要 cookie 才可正常访问的接口.使用此插件.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install superagent-cache-plugin --save</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheModule = <span class="built_in">require</span>(<span class="string">&quot;cache-service-cache-module&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> cache = <span class="keyword">new</span> <span class="title function_">cacheModule</span>(&#123; <span class="attr">storage</span>: <span class="string">&quot;session&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Require superagent-cache-plugin and pass your cache module</span></span><br><span class="line"><span class="keyword">var</span> superagentCache = <span class="built_in">require</span>(<span class="string">&quot;superagent-cache-plugin&quot;</span>)(cache);</span><br><span class="line"></span><br><span class="line">superagent</span><br><span class="line">  .<span class="title function_">get</span>(uri)</span><br><span class="line">  .<span class="title function_">use</span>(superagentCache)</span><br><span class="line">  .<span class="title function_">end</span>(<span class="keyword">function</span> (<span class="params">err, response</span>) &#123;</span><br><span class="line">    <span class="comment">// response is now cached!</span></span><br><span class="line">    <span class="comment">// subsequent calls to this superagent request will now fetch the cached response</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="节流模块-superagent-throttle"><a href="#节流模块-superagent-throttle" class="headerlink" title="节流模块 superagent-throttle"></a>节流模块 superagent-throttle</h3><p>设置限时,节流.<br><a target="_blank" rel="noopener" href="https://github.com/leviwheatcroft/superagent-throttle">github 地址</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request     = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Throttle</span>    = <span class="built_in">require</span>(<span class="string">&#x27;superagent-throttle&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> throttle = <span class="keyword">new</span> <span class="title class_">Throttle</span>(&#123;</span><br><span class="line">  <span class="attr">active</span>: <span class="literal">true</span>,     <span class="comment">// 插件开关</span></span><br><span class="line">  <span class="attr">rate</span>: <span class="number">5</span>,          <span class="comment">// how many requests can be sent every `ratePer`</span></span><br><span class="line">  <span class="attr">ratePer</span>: <span class="number">10000</span>,   <span class="comment">// number of ms in which `rate` requests may be sent</span></span><br><span class="line">  <span class="attr">concurrent</span>: <span class="number">2</span>     <span class="comment">// 并发数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">.<span class="title function_">get</span>(<span class="string">&#x27;http://placekitten.com/100/100&#x27;</span>)</span><br><span class="line">.<span class="title function_">use</span>(throttle.<span class="title function_">plugin</span>())</span><br><span class="line">.<span class="title function_">end</span>(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123; ... &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="限流模块-async"><a href="#限流模块-async" class="headerlink" title="限流模块 async"></a>限流模块 async</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchContents</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">async</span>.<span class="title function_">eachLimit</span>(</span><br><span class="line">      urls,</span><br><span class="line">      <span class="number">3</span>,</span><br><span class="line">      <span class="function">(<span class="params">url, callback</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">spider</span>(</span><br><span class="line">          &#123; <span class="attr">url</span>: url, <span class="attr">decoding</span>: <span class="string">&quot;gb2312&quot;</span> &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">url</span>: &#123;</span><br><span class="line">              <span class="attr">selector</span>: <span class="string">&quot;#Zoom table td a!text&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">title</span>: &#123;</span><br><span class="line">              <span class="attr">selector</span>: <span class="string">&quot;.title_all h1!text&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        ).<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">d</span>) =&gt;</span> &#123;</span><br><span class="line">            results.<span class="title function_">push</span>(d);</span><br><span class="line">            <span class="title function_">callback</span>();</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">callback</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(results);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态-ip"><a href="#动态-ip" class="headerlink" title="动态 ip"></a>动态 ip</h3><h3 id="构建个人代理池"><a href="#构建个人代理池" class="headerlink" title="构建个人代理池"></a>构建个人代理池</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ip-proxy-pool</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nothlu.com/detail?id=26">转载文章</a></p>
<h3 id="避免重复抓取"><a href="#避免重复抓取" class="headerlink" title="避免重复抓取"></a>避免重复抓取</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs-extra&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> uniqueArray = [];</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">UNIQUE_ARRAY_URL</span> = <span class="string">&quot;./_fetchedList.json&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  uniqueArray = <span class="built_in">require</span>(<span class="variable constant_">UNIQUE_ARRAY_URL</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dealListData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> urls = request.<span class="title function_">get</span>(data, <span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (urls) &#123;</span><br><span class="line">      urls = urls</span><br><span class="line">        .<span class="title function_">map</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;http://www.dytt8.net&quot;</span> + url;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">filter</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> uniqueArray.<span class="title function_">indexOf</span>(url) === -<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 如果为空就reject</span></span><br><span class="line">      urls.<span class="property">length</span> ? <span class="title function_">resolve</span>(urls) : <span class="title function_">reject</span>(<span class="string">&quot;empty urls&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(urls);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addUniqueArray</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  uniqueArray.<span class="title function_">push</span>(url);</span><br><span class="line">  <span class="keyword">if</span> (uniqueArray.<span class="property">length</span> &gt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="comment">// 超长就删掉多余的</span></span><br><span class="line">    uniqueArray.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchList</span>()</span><br><span class="line">  .<span class="title function_">then</span>(dealListData)</span><br><span class="line">  .<span class="title function_">then</span>(fetchContents)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">d</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d, d.<span class="property">length</span>);</span><br><span class="line">    <span class="comment">// json落地</span></span><br><span class="line">    fs.<span class="title function_">writeJson</span>(path.<span class="title function_">join</span>(__dirname, <span class="variable constant_">UNIQUE_ARRAY_URL</span>), uniqueArray);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>node 中文件读取写入有两种方法.<code>fs.readFile/writeFile</code> 和 <code>fs.createReadStream/writeStream</code>.</p>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><p><code>fs.writeFile</code>把文件内容全部读入内存，然后再写入文件，对于小型的文本文件，这没有多大问题，比如 grunt-file-copy 就是这样实现的。但是对于体积较大的二进制文件，比如音频、视频文件，动辄几个 GB 大小，如果使用这种方法，很容易使内存“爆仓”。理想的方法应该是读一部分，写一部分，不管文件有多大，只要时间允许，总会处理完成，这里就需要用到流的概念</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">createReadStream</span>(<span class="string">&quot;/path/to/source&quot;</span>).<span class="title function_">pipe</span>(</span><br><span class="line">  fs.<span class="title function_">createWriteStream</span>(<span class="string">&quot;/path/to/dest&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>以上都是我瞎编的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/03/HTTP%E3%80%81TCP-IP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/03/HTTP%E3%80%81TCP-IP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">HTTP、TCP/IP协议的原理及应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-12-03 13:18:21" itemprop="dateCreated datePublished" datetime="2019-12-03T13:18:21+08:00">2019-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:48" itemprop="dateModified" datetime="2022-11-01T18:08:48+08:00">2022-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HTML/" itemprop="url" rel="index"><span itemprop="name">HTML</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HTML/HTTP%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">HTTP基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="访问网页时发生了什么"><a href="#访问网页时发生了什么" class="headerlink" title="访问网页时发生了什么"></a>访问网页时发生了什么</h1><p>当用户在浏览器地址栏输入地址，敲下回车键，直到看到网页界面，一般时间不过两三秒左右。然而在这瞬时间，计算机实际上已经完成了非常复杂的操作。这段过程中发生的事情，其实有很大一部分就与 HTTP TCP&#x2F;IP 有关，我们可以简要的概括一下大概的流程。</p>
<h2 id="第一步，找服务器-IP"><a href="#第一步，找服务器-IP" class="headerlink" title="第一步，找服务器 IP"></a>第一步，找服务器 IP</h2><p>当用户输入一个网址并按下回车键的时候，浏览器得到了一个域名。而在实际通信过程中，浏览器需要的是一个 IP 地址。为了获得 IP 地址，浏览器会做如下操作，一般我们把浏览器通过域名查找对应 IP 的行为叫做 DNS 解析。</p>
<p>1.先找浏览器的本地的缓存</p>
<p>2.再找电脑硬盘里的 host 文件，有没有记录这个域名和 IP 的映射关系</p>
<p>3.实在没找到，只好通过网络链路去域名供应商那里查询</p>
<h2 id="第二步，建立-TCP-x2F-IP-连接"><a href="#第二步，建立-TCP-x2F-IP-连接" class="headerlink" title="第二步，建立 TCP&#x2F;IP 连接"></a>第二步，建立 TCP&#x2F;IP 连接</h2><p>1.浏览器获取到了服务器对应 IP，就会向对应 IP 的服务器发送 TCP 连接请求。</p>
<p>2.服务器收到请求后回应，双方多次确认后建立起 TCP 双向连接。</p>
<blockquote>
<p>从客户端发起连接请求一直到 TCP 连接建立，这个过程，叫做 三次握手。</p>
</blockquote>
<p>如果请求是 HTTPS 的，还需要在 TCP 连接上，再通过 SSL 或 TLS 提供加密处理数据、验证对方身份以及数据完整性，来保证数据传输的安全。</p>
<h2 id="第三步，请求资源"><a href="#第三步，请求资源" class="headerlink" title="第三步，请求资源"></a>第三步，请求资源</h2><p>1.TCP 连接创建完成，浏览器开始向服务端发送正式的 HTTP 请求的数据包。</p>
<p>2.服务端接受请求，对请求进行解析，经过数据操作后，返回客户端需要的数据包。</p>
<h2 id="第四步，浏览器渲染"><a href="#第四步，浏览器渲染" class="headerlink" title="第四步，浏览器渲染"></a>第四步，浏览器渲染</h2><p>浏览器获取到需要的数据以后，对数据进行拼接、解析、执行，最终将完整的网页绘制在页面上。</p>
<h2 id="第五步，浏览器缓存"><a href="#第五步，浏览器缓存" class="headerlink" title="第五步，浏览器缓存"></a>第五步，浏览器缓存</h2><p>浏览器拿到服务端返回的数据后，会根据一定的策略进行数据的缓存，这样在下一次请求同样数据的时候，就可直接到缓存拿取，不再请求服务器。</p>
<p>上述流程可以看作是一个应用在完整网络通信过程中的实践场景，其中带出了很多网络通信的知识点，下面就以这条线为索引，对其中涉及到的知识碎片进行阐述和说明。</p>
<h1 id="经典网络五层模型"><a href="#经典网络五层模型" class="headerlink" title="经典网络五层模型"></a>经典网络五层模型</h1><p><img src="https://s2.ax1x.com/2019/12/03/QKjjtx.md.png#alt=QKjjtx.md.png"></p>
<p>在每台计算机设备上，都有这么一套系统链路的关系，来保证网络传输的正常进行，因为统一集成了这么一套经典模型，所以自己使用的计算机也是可以作为一台服务器来提供网络服务的。</p>
<h2 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h2><p>应用层包含了我们所说的 HTTP 协议，为各个应用软件提供了很多服务，常见的应用层服务有：HTTP 服务 、FTP 服务 、Email 服务等。应用层屏蔽了底层模型的相关细节，作为应用支持，只提供给使用者一些必要的使用方式。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>常见的传输层协议有 TCP 和 UDP ，传输层作为为应用层的基础，定义了“端到端（end to end）”之间数据间的传输方式，比如：两台设备如何建立连接？设备之间需要以何种规范进行数据传输？需要以什么方式进行数据的分片、重组、拼接？这些都是传输层为我们定义好的。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>通常我们常说的 IP 协议就位于这一层。网络层为数据在结点之间传输创建逻辑链路，当我们在浏览器敲下域名，浏览器在网络里如何通过这个域名，找到对应的 IP 映射，这个查询的逻辑关系和链路，是网络层规范和定义的。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层在通信实体间建立数据链路连接，物理设备连接完成以后，需要相应的软件和驱动来连接和打通这些物理设备，创建电路的连接。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>定义物理设备如何传输数据，常见的物理层有网线，光缆，网卡，声卡等，物理层是一切软件的基础。</p>
<h1 id="URI、URL-和-URN"><a href="#URI、URL-和-URN" class="headerlink" title="URI、URL 和 URN"></a>URI、URL 和 URN</h1><p>对于 URL 我们基本比较熟悉，然而对 URI 和 URN 的了解可能比较少，URI、URL 和 URN 是识别、定位和命名互联网上的资源的标准途径。</p>
<p>当我们在浏览器地址栏里输入域名的那一刻，其实已经和这三个概念牵扯上了联系。</p>
<p><img src="https://s2.ax1x.com/2019/12/03/QKvAAI.md.png#alt=QKvAAI.md.png"></p>
<h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>Uniform Resource Identifier，统一资源标识符，简称为 URI。</p>
<p>每个 Web 服务器都有一个 URI 标识符，它在世界范围内唯一标识并定位信息资源，一个资源信息有了 URI 标识以后，在互联网上就能通过一个固定的地址访问到这个资源。</p>
<p>它具有两种形式，URN （统一资源名）、URL（统一资源定位符），也就是说 URL 和 URN 是它的子集。</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>Uniform Resource Locator，统一资源定位符，简称 URL，下图是一个完整的 URL 组成。</p>
<p><img src="https://s2.ax1x.com/2019/12/03/QKvYCV.md.png#alt=QKvYCV.md.png"></p>
<p>一个完整的 URL 从左到右包含如下部分：</p>
<ol>
<li>schema 标识了这个资源地址所基于的访问协议，常见的比如：HTTP 和 FTP。</li>
<li>user information 标识了用户信息（如果这个资源需要用户信息认证的话），不过一般现在的认证都不采用这种方式，一来输入非常麻烦，二来不安全。</li>
<li>host 标识了资源的域信息，可以是域名，也可以是 IP ，这块的作用主要是找到资源所存放的物理服务器地址。</li>
<li>port 端口号，一个物理服务器，通过开启不同的端口，就同时可以运行多个 web 服务器，资源文件会部署在某一个 web 服务器的某一个地方，而端口号就是用来定位资源存在的 web 服务器的。</li>
<li>path 路径，或者叫路由，一个 web 服务器下有许多目录，一般 path 就是用来定位到资源文件所存放的目录的。由于现在很多的 web 应用非常庞大，这个路径也不一定就是目录地址，也可能是 web 服务器指定的静态资源文件的请求地址。</li>
<li>query 查询字符串，一般用于 GET 查询，传递查询参数。</li>
<li>fragment 片段，哈希，或者叫锚点，主要用于前端文档的定位，或者是前端渲染时控制路由跳转的手段。</li>
</ol>
<blockquote>
<p>这里需要注意将 URL 与网址区别开来。</p>
</blockquote>
<p>URL 不仅仅包含了网页的资源地址，还包含了组成网页所需的图片、视频等超文本资源，以及 css js 等资源地址。</p>
<p>网址本质上是 IP 地址的一个更有辨别度的映射，在通过 DNS 解析之后，浏览器最先拿到的是 html 文档的 URL 地址，根据浏览器对 Html 文档的解析，继续通过网页内其他资源文件的 URL 获取对应的资源文件。</p>
<h2 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h2><p>Uniform Resource Name，统一资源名称，简称 URN，它的用处简单说就是永久定位资源，因为同一个资源可能会更换存储位置，存储位置一旦更换，再访问原来的 url 肯定是拿不到的，URN 就是解决这个问题的，不管资源位置怎么移动，只要访问同一个 URN 都能定位到。</p>
<h1 id="TCP-x2F-IP-协议族"><a href="#TCP-x2F-IP-协议族" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h1><blockquote>
<p>TCP&#x2F;IP 协议（传输控制协议&#x2F;互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP 等，这些被称为子协议。在这些协议中，最重要、最著名的就是 TCP 和 IP。因此我们习惯将整个协议族称为 TCP&#x2F;IP。</p>
</blockquote>
<h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><p>IP 协议使互联网成为一个允许连接不同类型的计算机和不同操作系统的网络。</p>
<p>IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，相当于这台机器的暂用名，别的机器可以通过这个名字找到它，进而能互相建立起连接进行通信和交流。</p>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p>TCP 协议是面向连接的全双工协议，因此不管是客户端还是服务端都能在 TCP 连接通道下向对端接收和发送数据。</p>
<p>TCP 相比于 UDP 的优势在于它的传输稳定性，在数据传输之前必须经过三次握手建立连接；在数据传输过程中必须保证数据有序完整地传到对端。</p>
<p>TCP 相比于 UDP 的劣势在于它的复杂度，连接建立、断开都是比较大的性能开销，而且数据传输过程中一旦卡住，则必须等前面的数据发送完毕以后，后续数据才能继续传输。</p>
<p>每台服务器可提供支持的 TCP 连接数量是有限的，所以这也使得 TCP 连接变成了稀缺资源，经不起浪费。</p>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p>UDP 协议是面向无连接的，不需要在传输数据前先建立连接，想发就发想传就传。</p>
<p>UDP 做的工作只是报文搬运，不负责有序且不丢失地传递到对端，因此容易出现丢包的情况。</p>
<p>UDP 不仅支持一对一的传输方式，还支持一对多、多对多、多对一的方式，也就是说 UPD 提供了单播、多播、广播的功能。</p>
<p>UDP 相比于 TCP 的优势在于它的轻量、高效和灵活，在一些对于实时性应用要求较高的场景下需要使用到 UDP，比如直播、视频会议、LOL 等实时对战游戏。</p>
<p>UDP 相比于 TCP 的劣势在于它的不可靠性和不稳定性。</p>
<h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h1><p>在客户端发送正式的 HTTP 请求之前，需要先创建一个 TCP 连接，在创建的 TCP Connect   通道下，所有的 HTTP 请求和响应才能正常的发送和接受。</p>
<p>在不同的 HTTP 协议版本里，这个 TCP 连接通道的创建和持续机制也有所不同。</p>
<p>在 HTTP1.0 中，每一次 HTTP 请求都会创建一个 TCP 连接，在请求发送完成，服务器响应以后，这个 TCP 连接就自动断开了。</p>
<p>在 HTTP1.1 中，可以通过手动设置 Connection： keep-alive 请求头来建立 TCP 的持久连接，多个 HTTP 请求可以共用一个 TCP 连接。但是 TCP 连接存在线头阻塞，即若干个请求排队等待发送，一旦有某请求超时等，后续请求只能被阻塞。</p>
<p>在 HTTP2 中，采用了信道复用，使 TCP 连接支持并发请求，即多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行吗，这样一来，大部分请求可以使用一个 TCP 连接，而不用创建新的 TCP 连接通道，既节省了三次握手的开销，又节约了服务端维护 TCP 端口的成本。</p>
<h1 id="TCP-的三次握手和四次挥手"><a href="#TCP-的三次握手和四次挥手" class="headerlink" title="TCP 的三次握手和四次挥手"></a>TCP 的三次握手和四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://s2.ax1x.com/2019/12/03/QKvH8f.md.png#alt=QKvH8f.md.png"></p>
<blockquote>
<p>提示：关于 ACK、FIN、SYN 状态码的含义</p>
</blockquote>
<p>1.ACK 用于确认，表示通知对方，我已经收到你发来的信息了。</p>
<p>2.FIN 用于结束，表示告知对方，我这边已经结束，数据全部发送完毕，没有后续输出，请求终止连接。</p>
<p>3.SYN 用于同步和建立连接，表示告知对方，我这边请求同步建立连接。</p>
<ol>
<li>第一次握手：由客户端向服务端发送连接请求 SYN 报文，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 SYN-SENT 状态。</li>
<li>第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个包含了 ACK 和 SYN 报文信息的应答，该应答中也会包含自身的数据通讯初始序号（在断开连接的“四次挥手”时，ACK 和 SYN 这两个报文是作为两次应答，独立开来发送的，因此会有四次挥手），服务端发送完成后便进入 SYN-RECEIVED 状态。</li>
<li>第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ol>
<blockquote>
<p>面试时可能会问的一个问题就是，明明两次握手就能确定的连接，为什么需要三次握手？</p>
</blockquote>
<p>因为由于很多不可控制的因素，例如网络原因，可能会造成第一次请求隔了很久才到达服务端，这个时候客户端已经等待响应等了很久，之前发起的请求已超时，已经被客户端废弃掉不再继续守着监听了。</p>
<p>然而服务端过了很久，收到了废弃的延迟请求，发起回应的同时又开启了一个新的 TCP 连接端口，在那里呆等客户端。</p>
<p>而服务端能维护的 TCP 连接是有限的，这种闲置的无用链接会造成服务端的资源浪费。</p>
<p>因此在服务端发送了 SYN 和 ACK 响应后，需要收到客户端接的再次确认，双方连接才能正式建立起来。三次握手就是为了规避这种由于网络延迟而导致服务器额外开销的问题。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://s2.ax1x.com/2019/12/03/QMkSIg.png#alt=QMkSIg.png"></p>
<p>和建立 TCP 连接类似，断开 TCP 连接也同样需要客户端于服务端的双向交流，因为整个断开动作需要双端共发送 4 个数据包才能完成，所以简称为“四次挥手”。</p>
<ol>
<li>第一次挥手：客户端认为自己这边的数据已经全部发送完毕了，于是发送一个 FIN 用来关闭客户端到服务端的数据传输，发送完成以后，客户端进入 FIN_WAIT_1 状态。</li>
<li>第二次挥手：服务端收到客户端发送回来的 FIN 以后，会告诉应用层要释放 TCP 链接，并且发送一个 ACK 给客户端，表明已经收到客户端的释放请求了，不会再接受客户端发来的数据，自此，服务端进入 CLOSE_WAIT 的状态。</li>
<li>第三次挥手：服务端如果此时还有未发送完的数据可以继续发送，发送完毕后，服务端也会发送一个释放连接的 FIN 请求用来关闭服务端到客户端的数据传送，然后服务端进入 LAST_ACK 状态。</li>
<li>第四次挥手：客户端接收到服务端的 FIN 请求后，发送最后一个 ACK 给服务端，接着进入 TIME_WAIT_2 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，客户端就进入 CLOSED 状态.服务端在收到应答消息后，也会进入 CLOSED 状态，至此完成四次挥手的过程，双方正式断开连接。</li>
</ol>
<p>上面的内容可能还是有些不够直观，所以我还准备了一段人话来描述整个过程：</p>
<ol>
<li>客户端：喂，我好了。</li>
<li>服务端：噢，你好了是吧，我知道了，我还没好，你等一哈。</li>
<li>服务端：OK，现在我也好了。</li>
<li>客户端：收到，这次玩的很开心，我们下次再约。</li>
</ol>
<blockquote>
<p>可能有些面试中会问，为什么建立连接有三次握手，而断开连接却有四次？</p>
</blockquote>
<p>这是因为在建立连接过程中，服务端在收到客户但建立连接请求的 SYN 报文后，会把 ACK 和 SYN 放在一个报文里发送给客户端。</p>
<p>而关闭连接时，服务端收到客户端的 FIN 报文，只是表示客户端不再发送数据了，但是还能接收数据，而且这会儿服务端可能还有数据没有发送完，不能马上发送 FIN 报文，只能先发送 ACK 报文，先响应客户端，在确认自己这边所有数据发送完毕以后，才会发送 FIN。</p>
<p>所以，在断开连接时，服务器的 ACK 和 FIN 一般都会单独发送，这就导致了断开连接比请求连接多了一次发送操作。</p>
<h1 id="HTTP-定义"><a href="#HTTP-定义" class="headerlink" title="HTTP 定义"></a>HTTP 定义</h1><p>一旦端对端成功建立起了 TCP 连接，下一步就要开始发送正式的 HTTP 请求了。流淌在 TCP Connect 通道里的 HTTP 只负责传输数据包，并没有连接的概念，因此 HTTP 也被叫做“无状态协议”。</p>
<blockquote>
<p>HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，它通常运行在 TCP 之上，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，HTTP 协议规定了超文本传输所要遵守的规则。</p>
</blockquote>
<ol>
<li>HTTP 协议是无状态的。这意味着客户端和服务端之间无法知晓当前对方的状态信息，HTTP 请求本身是不带有任何状态存储的。但实际情况下，客户端和服务端必然需要状态的认证和交互，所以就引入了 Cookie， 用于存储当前浏览器的一些状态信息，每次通过独立的 HTTP 请求进行收发，从而解决这个问题。</li>
<li>HTTP 请求互相独立。HTTP 互相之间都是一个独立的个体请求，在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应 HTML 页面，然后浏览器收到响应之后发现页面还引用了其他的资源，例如，CSS，JS 文件，图片等等，还会自动发送 HTTP 请求获取这些需要的资源。</li>
<li>HTTP 协议基于 TCP 协议。HTTP 协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节，底层是基于 TCP 实现的。现在使用的版本当中是默认持久连接的，也就是多次 HTTP 请求使用一个 TCP 连接。</li>
</ol>
<blockquote>
<p>注意：HTTP 请求和 TCP 连接是不一样的，HTTP 是在 TCP 连接建立的基础上而发起的传输请求，在同一个 TCP 连接通道下，可以发送多个 HTTP 请求，举个例子的话就是高速公路和车子的关系。</p>
</blockquote>
<h1 id="HTTP-发展历史"><a href="#HTTP-发展历史" class="headerlink" title="HTTP 发展历史"></a>HTTP 发展历史</h1><h2 id="HTTP-0-9-版本"><a href="#HTTP-0-9-版本" class="headerlink" title="HTTP 0.9 版本"></a>HTTP 0.9 版本</h2><p>只有一个 GET 命令。</p>
<p>没有请求头和响应头来描述传输相关的数据信息。</p>
<p>服务器发送完数据后，直接关闭 TCP 连接，不支持 TCP 持久化连接。</p>
<h2 id="HTTP-1-0-版本"><a href="#HTTP-1-0-版本" class="headerlink" title="HTTP 1.0 版本"></a>HTTP 1.0 版本</h2><p>增加了很多命令，HEAD、POST、PUT、DELETE 等。</p>
<p>增设了 status code 状态码和 header 请求头和响应头。</p>
<p>增加了多字符集支持、多部分发送、权限、缓存等。</p>
<p>可通过开启 Connection： keep-alive 来指定使用 TCP 长连接</p>
<h2 id="HTTP-1-1-（目前普遍使用）"><a href="#HTTP-1-1-（目前普遍使用）" class="headerlink" title="HTTP 1.1 （目前普遍使用）"></a>HTTP 1.1 （目前普遍使用）</h2><p>默认支持持久连接</p>
<p>默认支持长连接（PersistentConnection），即默认开启 Connection： keep-alive。</p>
<p>支持请求的流水线（Pipelining）处理，即在一个 TCP 连接上可以传送多个 HTTP 请求和响应。</p>
<p>增加了 host 请求头字段，通过对 host 解析，就能够允许在同一台物理服务器上运行多个软件服务，极大提高了服务器的使用率。目前的 nginx 反向代理就是根据 HTTP 请求头中的 host 来分辨不同的请求，从而将这些请求代理到同一台服务器不同的软件服务上。</p>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>HTTP1.x 的解析是基于文本，存在解析上的缺陷；而 HTTP2.0 直接使用二进制的解析方式来替代 HTTP 1.X 的字符串解析，更为高效和健壮。</p>
<p>HTTP2.0 所有数据以“帧”的方式进行传输，因此同一个连接中发送的多个请求不再需要按照顺序进行返回处理，可以达到并行的数据传输。</p>
<p>HTTP2.0 压缩头信息进行传输数据量的优化。HTTP1.x 的请求头带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的请求头大小，通讯双方各自缓存一份 header fields 表，既避免了重复的传输，又减小了传输信息的大小。</p>
<p>HTTP2.0 新增了 server push（服务端推送） 的概念，服务端可以主动发起一些数据推送。比如，服务端在接收到浏览器发来的 HTML 请求的同时，可以主动推送相关的资源文件（js&#x2F;css）给客户端，并行发送，提高网页的传输和渲染效率。</p>
<p>目前如果要使用 HTTP2 需要首先使用 HTTPS 在这基础上，才能使用 HTTP2</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>我们经常会在有些网页上看到悬浮的弹窗或者广告，有的时候甚至会在自己编写的上线网页上也看到这些垃圾广告，然而开发者明明没有写过这些东西，可是这种垃圾信息是怎么上去的呢？</p>
<p>究其根本原因就在于各种代理服务，当我们从客户端发起一个 HTTP 请求，并不是直接就能传递到目标服务器的，期间会经过层层的代理服务，我们常用的 nginx ，以及在 DNS 解析过程中要经过的宽带运营商，都是一种代理服务。</p>
<p>由于 HTTP 时使用明文字符串来传递数据的，那么这些数据就能很轻易地被中间服务读取甚至篡改，那么中间服务拿到了原始的 HTML 数据，想插入点小广告进去自然不是难事。</p>
<p>HTTPS 是为了解决 HTTP 明文传输而出现的安全问题而出现的一种解决机制 ———— 对 HTTP 请求中的信息进行加密之后传输，从而有效地防止了中间代理服务截获或篡改信息的问题。</p>
<p>HTTPS 其实就是一个安全加强版的 HTTP 1.1 ，有几点需要注意的是：</p>
<ol>
<li>HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费</li>
<li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL&#x2F;TLS 之上，SSL&#x2F;TLS 运行在 TCP 之上，所有传输的内容都经过加密的。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>
</ol>
<h1 id="HTTP-的报文组成"><a href="#HTTP-的报文组成" class="headerlink" title="HTTP 的报文组成"></a>HTTP 的报文组成</h1><p>HTTP 是以请求和响应的形式存在的，由于发起方主动发起一个 HTTP 请求，然后由响应方回应，双方按照一定的报文格式进行数据的互传，一个完整的 HTTP 报文通常由 首行、首部 和 主体 构成。</p>
<h2 id="首行"><a href="#首行" class="headerlink" title="首行"></a>首行</h2><p>首行并不属于 Http Headers ，它包含了：</p>
<ol>
<li>HTTP Method（GET、POST、PUT、DELETE 等 ），不同的 HTTP Method 有不同的语意。<table>
<thead>
<tr>
<th>HTTP Method</th>
<th>对应予以</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>一般用于获取服务器资源</td>
</tr>
<tr>
<td>POST</td>
<td>一般用于传输实体主体</td>
</tr>
<tr>
<td>PUT</td>
<td>一般用于传输文件</td>
</tr>
<tr>
<td>DELETE</td>
<td>用于删除文件</td>
</tr>
<tr>
<td>HEAD</td>
<td>用于获取报文首部，不返回报文主体</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>用于预检请求中，询问请求 URI 资源支持的方法</td>
</tr>
</tbody></table>
</li>
</ol>
<blockquote>
<p>HTTP Method 只是 HTTP 协议推崇的一种规范，就像 ESLint，你可以选择遵循，也可以选择不遵循，它们所作的事情实质上没有差别，只是语义化更明确。</p>
</blockquote>
<ol start="2">
<li><p>URL 请求资源的地址，这个地址只会包含请求的路由地址。</p>
</li>
<li><p>协议的版本，HTTP 1.0 &#x2F; HTTP 1.1 &#x2F; HTTP 2。</p>
</li>
<li><p>HTTP 返回状态码（响应报文首行包含）</p>
</li>
</ol>
<blockquote>
<p>HTTP 定义了 40 个标准状态代码，可用于传递客户端请求的结果，状态代码分为以下五类，关于各个分段下的返回状态码信息可以参考 HTTP 响应码：</p>
</blockquote>
<blockquote>
<p>这边需要注意的一点是，一个好的 HTTP 应用服务应该是有完善的 HTTP status code 的返回信息的，即访问者单从 HTTP status &gt; code 上就能得知当前 HTTP 请求的状态信息。</p>
</blockquote>
<p>而目前我们大部分的开发模式下的 HTTP 返回码，只有 200 和 500。服务端的同学会先把 200 返回过来，然后再告诉你出了什么 “没登录” &#x2F; “没认证” &#x2F; “没权限” 这一类的问题。</p>
<p>业界也有一句戏言：又不是不能用，其实这种开发方式是不正确的，不管从代码的维护性还是个人自身发展角度，我们都需要&gt; 尽量避免这种问题。</p>
<h2 id="HTTP-头信息"><a href="#HTTP-头信息" class="headerlink" title="HTTP 头信息"></a>HTTP 头信息</h2><p>HTTP 头信息，即 HTTP Header，首行换行后的信息都是 HTTP Header。HTTP header 里一般存放了客户端和服务端之间交互的非业务信息，例如：本次请求的数据类型、请求日期、字符集支持、自定义头部字段、一些通信凭证和缓存支持等。</p>
<p>HTTP Header 完整字段列表：传送门</p>
<h2 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h2><p>主体，即 HTTP body，HTTP Header 信息和主体信息间以一个空行 + 一个换行来区分。HTTP body 里一般会放置请求的一些具体业务信息</p>
<h1 id="HTTP-数据协商"><a href="#HTTP-数据协商" class="headerlink" title="HTTP 数据协商"></a>HTTP 数据协商</h1><p>在 HTTP 协议中，数据协商是这样一种机制，客户端通过请求头告知服务端本次请求希望获取的数据格式、展现形式、以及数据的压缩方式等。常见的数据协商例如，文档使用的自然语言，图片的格式，或者内容编码形式。</p>
<p>服务端可以对请求头中携带的数据协商字段进行解析，然后在返回客户端数据的时候，也会用相对字段来通知客户端：本次返回的数据格式、压缩方式等信息。这样浏览器就可以使用特定的解析方式，来对这些资源进行解析、处理和渲染。</p>
<p>下面简单列举一些常用的数据协商字段，完整的数据协商信息传送门</p>
<ul>
<li>Accept 请求头字段，指定期望获得的数据类型</li>
<li>Accept-Encoding 请求头字段，指定期望获得的数据需要以什么样的编码方式进行传输，常用于限制服务端对数据的压缩方式，常见的 JS 文件包大小优化的 GZIP 压缩，就使用了这个方法</li>
<li>Accept-Language 请求头字段，指定期望获得的数据语言类型：中文、英语、还是其他语言，这个头信息字段，一般是浏览器自动加上的</li>
<li>User-Agent 请求头字段，指定本次请求的浏览器信息，服务端可根据此信息选择不同兼容性的页面返回给用户，或者是做用户使用浏览器信息、操作系统等数据的统计</li>
<li>Content-Type 响应头字段，请求头里的 Accept 字段可能会指定好几种可以接受的数据格式，服务端最终会返回一种数据格式给客户端</li>
<li>Content-Encoding 响应头字段，对应 Accept-Encoding</li>
<li>Content-Language 响应头字段，对应 Accept-Language</li>
</ul>
<h1 id="HTTP-长连接"><a href="#HTTP-长连接" class="headerlink" title="HTTP 长连接"></a>HTTP 长连接</h1><p>每一个 HTTP 请求都需要在 TCP 连接通道里才能完成发送和接受。在 HTTP 协议的早期版本里，每一条 HTTP 请求发送之前，都会创建一条新的 TCP 连接通道，在这个请求完成以后，该条 TCP 通道就会自动关闭。</p>
<p>这样带来的问题就是，单条 TCP 连接没有办法复用，造成很大的新能浪费。好在这一问题随着 HTTP 协议的逐步完善已经得到解决。</p>
<p>在 HTTP 1.0 中引入的 Connection 头字段，允许对其设置 Keep-Alive 或者是 Close 来决定是否需要复用 TCP 连接，还是说在一次请求完成之后直接关闭。而在 HTTP 1.1 中默认双端都会默认开启这个字段，即默认支持 HTTP 的长连接。</p>
<blockquote>
<p>需要注意的是：Connection: Keep-Alive 需要双端同时开启才能启动 HTTP 长连接，如果任何一段手动设置 Connection 为 Close，长连接都无法位置，因为 TCP 连接的建立和持久保持是一个双端交互的过程。</p>
</blockquote>
<p>那么我们在本地如何看到 TCP 的连接 ID 呢，可以打开 Chrome 的调试工具来查看：</p>
<p><img src="https://s2.ax1x.com/2019/12/05/Q8eLHH.png#alt=Q8eLHH.png"></p>
<p>图上可以看到有不同的 Connection ID，这就代表着本次请求实际上是开启了一个新的 TCP 连接，最下面的请求的 Connection ID 都是相同的，代表着多个 HTTP 请求复用了同一个 TCP 连接。</p>
<blockquote>
<p>Chrome 浏览器所能够支持的最大并发 TCP 连接数是 6 个，并且在 HTTP 2.0 以下的 HTTP 版本中，请求是阻塞的。也就是说，一旦六个连接开满，前面的请求未完成，那么后续请求就会被阻塞，直到前面的请求返回，后续才能继续发送。</p>
</blockquote>
<h1 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h1><blockquote>
<p>虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括 request method 和目标 URI（一般只有 GET 请求才会被缓存）。</p>
</blockquote>
<h2 id="缓存读取策略"><a href="#缓存读取策略" class="headerlink" title="缓存读取策略"></a>缓存读取策略</h2><p>前端环境下的文件缓存，分为几个不同的位置。当我们打开 Chrome 控制台，查看 Network 下每条请求记录的 size 选项，会发现非常丰富的来源信息。</p>
<p><img src="https://s2.ax1x.com/2019/12/05/Q8mhqg.png#alt=Q8mhqg.png"></p>
<p>对于前端浏览器环境来说，缓存读取位置是由先后顺序的，顺序分别是（由上到下寻找，找到即返回；找不到则继续）</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>网络请求</li>
</ul>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><blockquote>
<p>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>
</blockquote>
<p>浏览器优先查找。</p>
<p>持久存储。</p>
<p>可以更加灵活地控制存储的内容，可以选择缓存哪些文件、定义缓存文件的路由匹配规则等。</p>
<p>可以从 Chrome 的 F12 中，Application -&gt; Cache Storage 查看。</p>
<h2 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h2><p>memory cache 是内存中的缓存存储。</p>
<p>读取速度快。</p>
<p>存储空间较小。</p>
<p>存储时间短，当浏览器的 tab 页被关闭，内存资源即被释放。</p>
<p>如果明确指定了 Cache-Control 为 no-store，浏览器则不会使用 memory-cache。</p>
<h2 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h2><p>Disk Cache 是硬盘中的缓存存储。</p>
<p>读取速度慢于 Memory Cache ，快于网络请求。</p>
<p>存储空间较大。</p>
<p>持久存储。</p>
<p>Disk Cache 严格依照 HTTP 头信息中的字段来判断资源是否可缓存、是否要认证等。</p>
<p>经常听到的“强制缓存”，“对比缓存”，以及 Cache-Control 等，归于此类。</p>
<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>如果一个请求的资源文件均未命中上述缓存策略，那么就会发起网络请求。浏览器拿到资源后，会把这个新资源加入缓存。</p>
<h1 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h1><blockquote>
<p>HTTP&#x2F;1.1 定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。需要注意的是，数据变化频率很快的场景并不适合开启 Cache-Control。</p>
</blockquote>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>公共缓存：表示该响应可以被任何中间人（比如中间代理、CDN 等）缓存。</td>
</tr>
<tr>
<td>private</td>
<td>私有缓存：表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</td>
</tr>
<tr>
<td>max-age</td>
<td>（单位&#x2F;秒）设置缓存的过期时间，过期需要重新请求，否则就读取本地缓存，并不实际发送请求</td>
</tr>
<tr>
<td>s-maxage</td>
<td>（单位&#x2F;秒）覆盖 max-age，作用一样，只在代理服务器中生效</td>
</tr>
<tr>
<td>max-stale</td>
<td>（单位&#x2F;秒）表示即使缓存过期，也使用这个过期缓存</td>
</tr>
<tr>
<td>no-store</td>
<td>禁止进行缓存</td>
</tr>
<tr>
<td>no-transform</td>
<td>不得对资源进行转换或压缩等操作，Content-Encoding、Content-Range、Content-Type 等 HTTP 头不能由代理修改（有时候资源比较大的情况下，代理服务器可能会自行做压缩处理，这个指令就是为了防止这种情况）。</td>
</tr>
<tr>
<td>no-cache</td>
<td>强制确认缓存：即每次使用本地缓存之前，需要请求服务器，查看缓存是否失效，若未过期（注：实际就是返回 304），则缓存才使用本地缓存副本。</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>缓存验证确认：意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>与 must-revalidate 作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</td>
</tr>
</tbody></table>
<p><img src="https://s2.ax1x.com/2019/12/05/Q8uaHe.png#alt=Q8uaHe.png"></p>
<h1 id="缓存校验"><a href="#缓存校验" class="headerlink" title="缓存校验"></a>缓存校验</h1><blockquote>
<p>在浏览器使用缓存的过程中，为了配合 Cache-Control 中 no-cache ，我们还需要一个机制来验证缓存是否有效。比如服务器的资源更新了，客户端需要及时刷新缓存；又或者客户端的资源过了有效期，但服务器上的资源还是旧的，此时并不需要重新发送。</p>
</blockquote>
<p>缓存校验就是用来解决这些问题的，在 http 1.1 中，我们主要关注下 Last-Modified 和 ETag 这两个字段。</p>
<h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><p>顾名思义，就是资源的最新一次修改时间。当客户端访问服务端的资源，服务端会将这个 Last-Modified 值返回给客户端，客户端收到之后，下次发送请求就会将服务端返回回来的 Last-Modified 值装在 If-Modified-Since 或者 If-Unmodified-Since 里，发送给服务端进行缓存校验。</p>
<p>这样服务器就可以通过读取 If-Modified-Since （较常用）或 If-UnModified-Since 的值，和本地的 Last-Modified 值做对比校验。如果校验发现这两个值是一样的，就代表本次请求的资源文件没有被修改过，那么服务器就会告诉浏览器，资源有效，可以继续使用，否则就需要使用最新的资源。</p>
<p>来看一下下面的两张图：</p>
<p>当请求服务端的 script.js 的脚本资源时，可以看到服务端返回了 Last-Modified，里面记录了该资源最后一次的修改时间</p>
<p>当客户端下次再次发起请求，会携带上这个过期时间给服务端进行验证</p>
<p>来看下服务端的部分代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ifModifiedSince = request.<span class="property">headers</span>[<span class="string">&quot;If-Modified-Since&quot;</span>];</span><br><span class="line">  <span class="keyword">const</span> lastModified =</span><br><span class="line">    <span class="string">&quot;Web Aug 19 2019 19:01:15 GMT+0800 (China Standard Time)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">url</span> === <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> html = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;test.html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/html&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    response.<span class="title function_">end</span>(html);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">url</span> === <span class="string">&quot;/script.js&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> js = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;script.js&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> status = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 如果读取到的 If-Modified-Since 和 lastModified 相同，则设置头部 304 表示可使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (ifModifiedSince === lastModified) &#123;</span><br><span class="line">      status = <span class="number">304</span>;</span><br><span class="line">      response.<span class="title function_">end</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(status, &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/javascript&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;no-cache,max-age=2000&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Last-Modified&quot;</span>: lastModified,</span><br><span class="line">    &#125;);</span><br><span class="line">    response.<span class="title function_">end</span>(js);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h1><p>Etag 的作用本质上和 Last-Modified 差别不大。相比于 Last-Modified 使用最后修改日期来比较资源是否失效的缓存校验策略，ETag 则是通过数据签名来做一个更加严格的缓存验证。</p>
<p>所谓数据签名，其实就是通过对资源内容进行一个唯一的签名标记，一旦资源内容改变，那么签名必将改变，服务端就以此签名作为暗号，来标记缓存的有效性。典型的做法是针对资源内容进行一个 hash 计算，类似于 webpack 打包线上资源所加的 hash 标识</p>
<p>和 Last-Modified 对应 If-Modified-Since 相同，ETag 也会对应 If-Match 或者 If-None-Match（If-None-Match 比较常用），如果前后的签名相同，则不需要返回新的资源内容。</p>
<h2 id="缓存校验的合理使用"><a href="#缓存校验的合理使用" class="headerlink" title="缓存校验的合理使用"></a>缓存校验的合理使用</h2><blockquote>
<p>Last-Modified 和 ETag 只是给服务端提供了一个控制缓存有效期的手段，并没有任何强制缓存的作用，最终决定是否使用缓存、还是使用新的资源文件，还是需要靠服务端指定对应的 http code 来决定。</p>
</blockquote>
<p>对于保存在服务器上的文件，都有最后修改日期的属性，当使用 Last-Modified 可以利用这个有效的属性进行数据缓存验证；或者在数据库存入一个 updatetime 字段来标识具体的修改日期，从而判断缓存是否有效。</p>
<p>具体如何构建一个能够合理使用缓存的服务器，就比较涉及后端知识了，这里不做具体描述。</p>
<h1 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h1><blockquote>
<p>浏览器的同源限制：当浏览器访问 URL 地址的协议（schema）&#x2F; 端口（port）&#x2F; 域名（host），三者中有任何一个与当前的 URL 片段信息不匹配的时候，便存在跨域问题。</p>
</blockquote>
<p>对于跨域的几点需要明确：</p>
<ol>
<li>跨域，是浏览器提供的一种保护手段，服务端是不存在跨域这一说的。这也就是为什么现在前后端分离的开发模式下，前端比较依赖 webpack-dev-server 启动代理服务来中转和代理后台接口的原因，因为两个服务器之间相互通信是没有跨域障碍的。</li>
<li>跨域，是对于 XMLHttpRequest 来说的，浏览器获取不同源服务器下的静态资源，是没有跨域限制的，这也是 JSONP 跨域请求得以实现的本质。</li>
<li>不同于 XMLHttpRequest 的是，通过 src 属性加载的脚本资源，浏览器限制了 Javascript 的权限，使其不能读写、返回内容。</li>
<li>对于浏览器来说，除了 DOM 、Cookie、XMLHttpRequest 会收到同源策略限制以外，一些常见的插件，比如 Flash、Java Applet 、Silverlight、Google Gears 等也都有自己的控制策略。</li>
</ol>
<blockquote>
<p>当浏览器向不同域的服务器发送请求时，请求是真能发出去，对方服务端也是真能接收到请求，并且真能给你的浏览器响应，浏览器也真能接收到有效数据。</p>
</blockquote>
<p>但是，如果在跨域的情况下、服务端返回数据的响应头里的 Access-Control-Allow-Origin 字段，没有把当前域名列进白名单，那么浏览器会把服务端返回的数据给藏起来，不告诉你，然后给你抛个 Access-Control-Allow-Origin 的错误。</p>
<blockquote>
<p>至于为什么资源文件不受同源策略限制呢？可以试想一下，如果资源文件也被限制跨域，那么现在大量使用的 CDN 缓存策略基本就没办法用了。而且现在很多网站的资源文件，都会放到云服务器的 OSS 上，OSS 资源对应的 url 地址肯定是不同域的，那这些资源也不能使用了。</p>
</blockquote>
<h1 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h1><p>Access-Control-Allow-Origin 标识了服务器允许的跨域白名单，它有以下几种设置方法：</p>
<ol>
<li>直接设置 * 通配符，简单粗暴，但是这么做等于把服务器的所有接口资源对外完全暴露，是不安全的。</li>
<li>设置制定域，比如 Access-Control-Allow-Origin: <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a> ，这样只会允许指定域的请求进行跨域访问。</li>
<li>由后端动态设置。Access-Control-Allow-Origin 限制只能写一个白名单，但是当我们有多个域都需要跨域请求怎么呢？这个时候，这时可以由服务端自己维护一套白名单列表，在请求进来的时候对请求的源 host 进行白名单比对，如果在白名单中，就将这个 Access-Control-Allow-Origin 动态设置上去，然后返回响应。</li>
</ol>
<h2 id="CORS-的预请求"><a href="#CORS-的预请求" class="headerlink" title="CORS 的预请求"></a>CORS 的预请求</h2><p>如果我们像上面一样，只设置的 Access-Control-Allow-Origin 白名单，是否就可以完全畅通无阻地进行跨域了呢？并不是。</p>
<p>就算对端开启了域名白名单认证，然鹅有一些操作仍然是需要进一步认证的，这种进一步的认证操作，就是 CORS 预请求。</p>
<h2 id="预请求触发过程"><a href="#预请求触发过程" class="headerlink" title="预请求触发过程"></a>预请求触发过程</h2><p>浏览器预请求的触发条件，是判断本次请求是否属于一个简单请求。</p>
<p>如果本次请求属于一个复杂请求，那么在发送正式的跨域请求之前，浏览器会先准备一个名为 OPTIONS 的 HTTP Method ，作为预请求发送。</p>
<p>在服务器通过预请求后，下面浏览器才会发生正式的数据请求。整个请求过程其实是发生了两次请求：一个预检请求，以及后续的实际数据请求。</p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><ol>
<li>请求方式只能是 GET POST HEAD</li>
<li>请求头字段只允许：</li>
</ol>
<p>Accept</p>
<p>Accept-Language</p>
<p>Content-Language</p>
<p>Content-Type</p>
<ol start="3">
<li>Content-Type 的值仅限于：</li>
</ol>
<p>text&#x2F;plain</p>
<p>multipart&#x2F;form-data</p>
<p>application&#x2F;x-www-form-urlencoded</p>
<ol start="4">
<li>XMLHttpRequestUpload 对象均没有注册任何事件监听器（了解就好）。</li>
<li>请求中没有使用 ReadableStream 对象（了解就好）。</li>
</ol>
<h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>除了简单请求里定义的，都是复杂请求，统统需要预请求。</p>
<h2 id="预请求的验证"><a href="#预请求的验证" class="headerlink" title="预请求的验证"></a>预请求的验证</h2><p>那么怎样使预检请求成功认证呢？还是需要服务端继续帮忙设置请求头的白名单：</p>
<ol>
<li>ccess-Control-Allow-Headers，设置允许的额外请求头字段。</li>
<li>Access-Control-Allow-Methods，设置允许的额外请求方法。</li>
<li>Access-Control-Max-Age （单位&#x2F;秒），指定了预请求的结果能够被缓存多久，在这个时间范围内，再次发送跨域请求不会被预检。</li>
</ol>
<h1 id="HTTP-性能优化方案"><a href="#HTTP-性能优化方案" class="headerlink" title="HTTP 性能优化方案"></a>HTTP 性能优化方案</h1><p>合理使用 HTTP 的缓存策略，避免同一资源多次请求服务端而导致的额外性能开销</p>
<p>尽量使用 HTTP 长连接，避免每次重建 TCP 连接带来的时间损耗</p>
<p>尽量使用 HTTPS 来保证网络传输的安全性。</p>
<p>可以使用 HTTP2 来大幅提高数据传输的效率，使用 server push 开启 HTTP2 的服务端推送功能</p>
<p>客户端开启 Accept-Encoding 压缩方式的支持，服务端传输压缩后的文件，减少传输数据的大小</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/11/28/%E8%99%9A%E6%8B%9Fdom/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/28/%E8%99%9A%E6%8B%9Fdom/" class="post-title-link" itemprop="url">虚拟dom</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-11-28 19:21:32" itemprop="dateCreated datePublished" datetime="2019-11-28T19:21:32+08:00">2019-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:50" itemprop="dateModified" datetime="2022-11-01T18:08:50+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一、真实 DOM 和其解析流程</p>
<p>本节我们主要介绍真实 DOM 的解析过程，通过介绍其解析过程以及存在的问题，从而引出为什么需要虚拟 DOM。一图胜千言，如下图为 webkit 渲染引擎工作流程图</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFFJz9.png#alt=QFFJz9.png"></p>
<p>所有的浏览器渲染引擎工作流程大致分为 5 步：创建 DOM 树 —&gt; 创建 Style Rules -&gt; 构建 Render 树 —&gt; 布局 Layout -—&gt; 绘制 Painting。</p>
<p>第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；</p>
<p>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；</p>
<p>第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；</p>
<p>第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；</p>
<p>第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。</p>
<h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>1、DOM 树的构建是文档加载完成开始的？ 构建 DOM 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完成之后才开始构建 render 树和布局。</p>
<p>2、Render 树是 DOM 树和 CSS 样式表构建完毕后才开始构建的？ 这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。</p>
<p>3、CSS 的解析注意点？ CSS 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。</p>
<p>4、JS 操作真实 DOM 的代价？ 用我们传统的开发模式，原生 JS 或 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行 10 次。例如，第一次计算完，紧接着下一个 DOM 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 DOM 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验</p>
<h1 id="二、Virtual-DOM-基础"><a href="#二、Virtual-DOM-基础" class="headerlink" title="二、Virtual-DOM 基础"></a>二、Virtual-DOM 基础</h1><h2 id="2-1、虚拟-DOM-的好处"><a href="#2-1、虚拟-DOM-的好处" class="headerlink" title="2.1、虚拟 DOM 的好处"></a>2.1、虚拟 DOM 的好处</h2><p>虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量。所以，用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。</p>
<h2 id="2-2、算法实现"><a href="#2-2、算法实现" class="headerlink" title="2.2、算法实现"></a>2.2、算法实现</h2><h3 id="2-2-1、用-JS-对象模拟-DOM-树"><a href="#2-2-1、用-JS-对象模拟-DOM-树" class="headerlink" title="2.2.1、用 JS 对象模拟 DOM 树"></a>2.2.1、用 JS 对象模拟 DOM 树</h3><h4 id="（1）如何用-JS-对象模拟-DOM-树"><a href="#（1）如何用-JS-对象模拟-DOM-树" class="headerlink" title="（1）如何用 JS 对象模拟 DOM 树"></a>（1）如何用 JS 对象模拟 DOM 树</h4><p>例如一个真实的 DOM 节点如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;virtual-dom&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Virtual DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>我们用 JavaScript 对象来表示 DOM 节点，使用对象的属性记录节点的类型、属性、子节点等。</p>
<p>element.js 中表示节点对象代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Element virdual-dom 对象定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; <span class="variable">tagName</span> - dom 元素名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">props</span> - dom 属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;Element|String&gt;</span>&#125; - 子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Element</span>(<span class="params">tagName, props, children</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tagName</span> = tagName;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">props</span> = props;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">children</span> = children;</span><br><span class="line">  <span class="comment">// dom 元素的 key 值，用作唯一标识符</span></span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = props.<span class="property">key</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  children.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">child, i</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child <span class="keyword">instanceof</span> <span class="title class_">Element</span>) &#123;</span><br><span class="line">      count += child.<span class="property">count</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      children[i] = <span class="string">&quot;&quot;</span> + child;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 子元素个数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">count</span> = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tagName, props, children</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Element</span>(tagName, props, children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = createElement;</span><br></pre></td></tr></table></figure>

<p>根据 element 对象的设定，则上面的 DOM 结构就可以简单表示为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">&quot;./element.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ul = <span class="title function_">el</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">id</span>: <span class="string">&quot;virtual-dom&quot;</span> &#125;, [</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;p&quot;</span>, &#123;&#125;, [<span class="string">&quot;Virtual DOM&quot;</span>]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;ul&quot;</span>, &#123; <span class="attr">id</span>: <span class="string">&quot;list&quot;</span> &#125;, [</span><br><span class="line">    <span class="title function_">el</span>(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, [<span class="string">&quot;Item 1&quot;</span>]),</span><br><span class="line">    <span class="title function_">el</span>(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, [<span class="string">&quot;Item 2&quot;</span>]),</span><br><span class="line">    <span class="title function_">el</span>(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, [<span class="string">&quot;Item 3&quot;</span>]),</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;div&quot;</span>, &#123;&#125;, [<span class="string">&quot;Hello World&quot;</span>]),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>现在 ul 就是我们用 JavaScript 对象表示的 DOM 结构，我们输出查看 ul 对应的数据结构如下：</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFE3i8.png#alt=QFE3i8.png"></p>
<h4 id="（2）渲染用-JS-表示的-DOM-对象"><a href="#（2）渲染用-JS-表示的-DOM-对象" class="headerlink" title="（2）渲染用 JS 表示的 DOM 对象"></a>（2）渲染用 JS 表示的 DOM 对象</h4><p>但是页面上并没有这个结构，下一步我们介绍如何将 ul 渲染成页面上真实的 DOM 结构，相关渲染函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * render 将virdual-dom 对象渲染为实际 DOM 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>);</span><br><span class="line">  <span class="keyword">var</span> props = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">  <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">var</span> propValue = props[propName];</span><br><span class="line">    el.<span class="title function_">setAttribute</span>(propName, propValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> children = <span class="variable language_">this</span>.<span class="property">children</span> || [];</span><br><span class="line">  children.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">child</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> childEl =</span><br><span class="line">      child <span class="keyword">instanceof</span> <span class="title class_">Element</span></span><br><span class="line">        ? child.<span class="title function_">render</span>() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">        : <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child); <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">    el.<span class="title function_">appendChild</span>(childEl);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> el;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们通过查看以上 render 方法，会根据 tagName 构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。</p>
<p>我们将构建好的 DOM 结构添加到页面 body 上面，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulRoot = ul.<span class="title function_">render</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(ulRoot);</span><br></pre></td></tr></table></figure>

<p>这样，页面 body 里面就有真正的 DOM 结构，效果如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFSQaQ.png#alt=QFSQaQ.png"></p>
<h3 id="2-2-2、比较两棵虚拟-DOM-树的差异-—-diff-算法"><a href="#2-2-2、比较两棵虚拟-DOM-树的差异-—-diff-算法" class="headerlink" title="2.2.2、比较两棵虚拟 DOM 树的差异 — diff 算法"></a>2.2.2、比较两棵虚拟 DOM 树的差异 — diff 算法</h3><p>diff 算法用来比较两棵 Virtual DOM 树的差异，如果需要两棵树的完全比较，那么 diff 算法的时间复杂度为 O(n^3)。但是在前端当中，你很少会跨越层级地移动 DOM 元素，所以 Virtual DOM 只会对同一个层级的元素进行对比，如下图所示， div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 O(n)。</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFSwa4.png#alt=QFSwa4.png"></p>
<p>####（1）深度优先遍历，记录差异</p>
<p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFScM6.png#alt=QFScM6.png"></p>
<p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diff 函数，对比两棵树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">diff</span>(<span class="params">oldTree, newTree</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>; <span class="comment">// 当前节点的标志</span></span><br><span class="line">  <span class="keyword">var</span> patches = &#123;&#125;; <span class="comment">// 用来记录每个节点差异的对象</span></span><br><span class="line">  <span class="title function_">dfsWalk</span>(oldTree, newTree, index, patches);</span><br><span class="line">  <span class="keyword">return</span> patches;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两棵树进行深度优先遍历</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dfsWalk</span>(<span class="params">oldNode, newNode, index, patches</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentPatch = [];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> oldNode === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> newNode === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 文本内容改变</span></span><br><span class="line">    <span class="keyword">if</span> (newNode !== oldNode) &#123;</span><br><span class="line">      currentPatch.<span class="title function_">push</span>(&#123; <span class="attr">type</span>: patch.<span class="property">TEXT</span>, <span class="attr">content</span>: newNode &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    newNode != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    oldNode.<span class="property">tagName</span> === newNode.<span class="property">tagName</span> &amp;&amp;</span><br><span class="line">    oldNode.<span class="property">key</span> === newNode.<span class="property">key</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 节点相同，比较属性</span></span><br><span class="line">    <span class="keyword">var</span> propsPatches = <span class="title function_">diffProps</span>(oldNode, newNode);</span><br><span class="line">    <span class="keyword">if</span> (propsPatches) &#123;</span><br><span class="line">      currentPatch.<span class="title function_">push</span>(&#123; <span class="attr">type</span>: patch.<span class="property">PROPS</span>, <span class="attr">props</span>: propsPatches &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较子节点，如果子节点有&#x27;ignore&#x27;属性，则不需要比较</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isIgnoreChildren</span>(newNode)) &#123;</span><br><span class="line">      <span class="title function_">diffChildren</span>(</span><br><span class="line">        oldNode.<span class="property">children</span>,</span><br><span class="line">        newNode.<span class="property">children</span>,</span><br><span class="line">        index,</span><br><span class="line">        patches,</span><br><span class="line">        currentPatch</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 新节点和旧节点不同，用 replace 替换</span></span><br><span class="line">    currentPatch.<span class="title function_">push</span>(&#123; <span class="attr">type</span>: patch.<span class="property">REPLACE</span>, <span class="attr">node</span>: newNode &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatch.<span class="property">length</span>) &#123;</span><br><span class="line">    patches[index] = currentPatch;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上可以得出，patches[1] 表示 p ，patches[3] 表示 ul ，以此类推。</p>
<h4 id="（2）差异类型"><a href="#（2）差异类型" class="headerlink" title="（2）差异类型"></a>（2）差异类型</h4><p>DOM 操作导致的差异类型包括以下几种：</p>
<p>节点替换：节点改变了，例如将上面的 div 换成 h1;</p>
<p>顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换；</p>
<p>属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除；</p>
<p>文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”；</p>
<p>以上描述的几种差异类型在代码中定义如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">REPLACE</span> = <span class="number">0</span>; <span class="comment">// 替换原先的节点</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">REORDER</span> = <span class="number">1</span>; <span class="comment">// 重新排序</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">PROPS</span> = <span class="number">2</span>; <span class="comment">// 修改了节点的属性</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">TEXT</span> = <span class="number">3</span>; <span class="comment">// 文本内容改变</span></span><br></pre></td></tr></table></figure>

<p>####（3）列表对比算法</p>
<p>子节点的对比算法，例如 p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。</p>
<p>将这个问题抽象出来其实就是字符串的最小编辑距离问题（Edition Distance），最常见的解决方法是 Levenshtein Distance , Levenshtein Distance 是一个度量两个字符序列之间差异的字符串度量标准，两个单词之间的 Levenshtein Distance 是将一个单词转换为另一个单词所需的单字符编辑（插入、删除或替换）的最小数量。Levenshtein Distance 是 1965 年由苏联数学家 Vladimir Levenshtein 发明的。Levenshtein Distance 也被称为编辑距离（Edit Distance），通过动态规划求解，时间复杂度为 O(M*N)。</p>
<p>定义：对于两个字符串 a、b，则他们的 Levenshtein Distance 为：</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFp50U.png#alt=QFp50U.png"></p>
<p>示例：字符串 a 和 b，a&#x3D;“abcde” ，b&#x3D;“cabef”，根据上面给出的计算公式，则他们的 Levenshtein Distance 的计算过程如下：</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFpTk4.png#alt=QFpTk4.png"></p>
<p>本文的 demo 使用插件 list-diff2 算法进行比较，该算法的时间复杂度伟 O(n*m)，虽然该算法并非最优的算法，但是用于对于 dom 元素的常规操作是足够的。该算法具体的实现过程这里不再详细介绍，该算法的具体介绍可以参照：<a target="_blank" rel="noopener" href="https://github.com/livoras/list-diff">https://github.com/livoras/list-diff</a></p>
<p>（4）实例输出</p>
<p>两个虚拟 DOM 对象如下图所示，其中 ul1 表示原有的虚拟 DOM 树，ul2 表示改变后的虚拟 DOM 树</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul1 = <span class="title function_">el</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">id</span>: <span class="string">&quot;virtual-dom&quot;</span> &#125;, [</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;p&quot;</span>, &#123;&#125;, [<span class="string">&quot;Virtual DOM&quot;</span>]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;ul&quot;</span>, &#123; <span class="attr">id</span>: <span class="string">&quot;list&quot;</span> &#125;, [</span><br><span class="line">    <span class="title function_">el</span>(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, [<span class="string">&quot;Item 1&quot;</span>]),</span><br><span class="line">    <span class="title function_">el</span>(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, [<span class="string">&quot;Item 2&quot;</span>]),</span><br><span class="line">    <span class="title function_">el</span>(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, [<span class="string">&quot;Item 3&quot;</span>]),</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;div&quot;</span>, &#123;&#125;, [<span class="string">&quot;Hello World&quot;</span>]),</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> ul2 = <span class="title function_">el</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">id</span>: <span class="string">&quot;virtual-dom&quot;</span> &#125;, [</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;p&quot;</span>, &#123;&#125;, [<span class="string">&quot;Virtual DOM&quot;</span>]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;ul&quot;</span>, &#123; <span class="attr">id</span>: <span class="string">&quot;list&quot;</span> &#125;, [</span><br><span class="line">    <span class="title function_">el</span>(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, [<span class="string">&quot;Item 21&quot;</span>]),</span><br><span class="line">    <span class="title function_">el</span>(<span class="string">&quot;li&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;item&quot;</span> &#125;, [<span class="string">&quot;Item 23&quot;</span>]),</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&quot;p&quot;</span>, &#123;&#125;, [<span class="string">&quot;Hello World&quot;</span>]),</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> patches = <span class="title function_">diff</span>(ul1, ul2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;patches:&quot;</span>, patches);</span><br></pre></td></tr></table></figure>

<p>我们查看输出的两个虚拟 DOM 对象之间的差异对象如下图所示，我们能通过差异对象得到，两个虚拟 DOM 对象之间进行了哪些变化，从而根据这个差异对象（patches）更改原先的真实 DOM 结构，从而将页面的 DOM 结构进行更改。</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFp7tJ.png#alt=QFp7tJ.png"></p>
<h3 id="2-2-3、将两个虚拟-DOM-对象的差异应用到真正的-DOM-树"><a href="#2-2-3、将两个虚拟-DOM-对象的差异应用到真正的-DOM-树" class="headerlink" title="2.2.3、将两个虚拟 DOM 对象的差异应用到真正的 DOM 树"></a>2.2.3、将两个虚拟 DOM 对象的差异应用到真正的 DOM 树</h3><h4 id="（1）深度优先遍历-DOM-树"><a href="#（1）深度优先遍历-DOM-树" class="headerlink" title="（1）深度优先遍历 DOM 树"></a>（1）深度优先遍历 DOM 树</h4><p>因为步骤一所构建的 JavaScript 对象树和 render 出来真正的 DOM 树的信息、结构是一样的。所以我们可以对那棵 DOM 树也进行深度优先的遍历，遍历的时候从步骤二生成的 patches 对象中找出当前遍历的节点差异，如下相关代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">node, patches</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> walker = &#123; <span class="attr">index</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="title function_">dfsWalk</span>(node, walker, patches);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dfsWalk</span>(<span class="params">node, walker, patches</span>) &#123;</span><br><span class="line">  <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line">  <span class="keyword">var</span> currentPatches = patches[walker.<span class="property">index</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = node.<span class="property">childNodes</span> ? node.<span class="property">childNodes</span>.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 深度遍历子节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = node.<span class="property">childNodes</span>[i];</span><br><span class="line">    walker.<span class="property">index</span>++;</span><br><span class="line">    <span class="title function_">dfsWalk</span>(child, walker, patches);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">    <span class="title function_">applyPatches</span>(node, currentPatches);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）对原有-DOM-树进行-DOM-操作"><a href="#（2）对原有-DOM-树进行-DOM-操作" class="headerlink" title="（2）对原有 DOM 树进行 DOM 操作"></a>（2）对原有 DOM 树进行 DOM 操作</h4><p>我们根据不同类型的差异对当前节点进行不同的 DOM 操作 ，例如如果进行了节点替换，就进行节点替换 DOM 操作；如果节点文本发生了改变，则进行文本替换的 DOM 操作；以及子节点重排、属性改变等 DOM 操作，相关代码如 applyPatches 所示 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyPatches</span>(<span class="params">node, currentPatches</span>) &#123;</span><br><span class="line">  currentPatches.<span class="title function_">forEach</span>(<span class="function">(<span class="params">currentPatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REPLACE</span>:</span><br><span class="line">        <span class="keyword">var</span> newNode =</span><br><span class="line">          <span class="keyword">typeof</span> currentPatch.<span class="property">node</span> === <span class="string">&quot;string&quot;</span></span><br><span class="line">            ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(currentPatch.<span class="property">node</span>)</span><br><span class="line">            : currentPatch.<span class="property">node</span>.<span class="title function_">render</span>();</span><br><span class="line">        node.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(newNode, node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REORDER</span>:</span><br><span class="line">        <span class="title function_">reorderChildren</span>(node, currentPatch.<span class="property">moves</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">PROPS</span>:</span><br><span class="line">        <span class="title function_">setProps</span>(node, currentPatch.<span class="property">props</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">TEXT</span>:</span><br><span class="line">        node.<span class="property">textContent</span> = currentPatch.<span class="property">content</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unknown patch type &quot;</span> + currentPatch.<span class="property">type</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）DOM-结构改变"><a href="#（3）DOM-结构改变" class="headerlink" title="（3）DOM 结构改变"></a>（3）DOM 结构改变</h4><p>通过将第 2.2.2 得到的两个 DOM 对象之间的差异，应用到第一个（原先）DOM 结构中，我们可以看到 DOM 结构进行了预期的变化，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFpI7F.png#alt=QFpI7F.png"></p>
<h2 id="2-3、结语"><a href="#2-3、结语" class="headerlink" title="2.3、结语"></a>2.3、结语</h2><p>Virtual DOM 算法主要实现上面三个步骤来实现：</p>
<p>用 JS 对象模拟 DOM 树 — element.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;virtual-dom&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Virtual DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>比较两棵虚拟 DOM 树的差异 — diff.js</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QF9XCj.png#alt=QF9XCj.png"></p>
<p>将两个虚拟 DOM 对象的差异应用到真正的 DOM 树 — patch.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyPatches</span>(<span class="params">node, currentPatches</span>) &#123;</span><br><span class="line">  currentPatches.<span class="title function_">forEach</span>(<span class="function">(<span class="params">currentPatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REPLACE</span>:</span><br><span class="line">        <span class="keyword">var</span> newNode =</span><br><span class="line">          <span class="keyword">typeof</span> currentPatch.<span class="property">node</span> === <span class="string">&quot;string&quot;</span></span><br><span class="line">            ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(currentPatch.<span class="property">node</span>)</span><br><span class="line">            : currentPatch.<span class="property">node</span>.<span class="title function_">render</span>();</span><br><span class="line">        node.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(newNode, node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REORDER</span>:</span><br><span class="line">        <span class="title function_">reorderChildren</span>(node, currentPatch.<span class="property">moves</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">PROPS</span>:</span><br><span class="line">        <span class="title function_">setProps</span>(node, currentPatch.<span class="property">props</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">TEXT</span>:</span><br><span class="line">        node.<span class="property">textContent</span> = currentPatch.<span class="property">content</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unknown patch type &quot;</span> + currentPatch.<span class="property">type</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、Vue-源码-Virtual-DOM-简析"><a href="#三、Vue-源码-Virtual-DOM-简析" class="headerlink" title="三、Vue 源码 Virtual-DOM 简析"></a>三、Vue 源码 Virtual-DOM 简析</h1><p>我们从第二章节（Virtual-DOM 基础）中已经掌握 Virtual DOM 渲染成真实的 DOM 实际上要经历 VNode 的定义、diff、patch 等过程，所以本章节 Vue 源码的解析也按这几个过程来简析。</p>
<h2 id="3-1、VNode-模拟-DOM-树"><a href="#3-1、VNode-模拟-DOM-树" class="headerlink" title="3.1、VNode 模拟 DOM 树"></a>3.1、VNode 模拟 DOM 树</h2><h3 id="3-1-1、VNode-类简析"><a href="#3-1-1、VNode-类简析" class="headerlink" title="3.1.1、VNode 类简析"></a>3.1.1、VNode 类简析</h3><p>在 Vue.js 中，Virtual DOM 是用 VNode 这个 Class 去描述，它定义在 src&#x2F;core&#x2F;vdom&#x2F;vnode.js 中 ，从以下代码块中可以看到 Vue.js 中的 Virtual DOM 的定义较为复杂一些，因为它这里包含了很多 Vue.js 的特性。实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库  snabbdom 的实现，然后加入了一些 Vue.js 的一些特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="attr">tag</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">ns</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">key</span>: string | number | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  <span class="attr">raw</span>: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line">  <span class="attr">asyncFactory</span>: <span class="title class_">Function</span> | <span class="keyword">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  <span class="attr">asyncMeta</span>: <span class="title class_">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">isAsyncPlaceholder</span>: boolean;</span><br><span class="line">  <span class="attr">ssrContext</span>: <span class="title class_">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">fnContext</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  <span class="attr">fnOptions</span>: ?<span class="title class_">ComponentOptions</span>; <span class="comment">// for SSR caching</span></span><br><span class="line">  <span class="attr">devtoolsMeta</span>: ?<span class="title class_">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  <span class="attr">fnScopeId</span>: ?string; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    tag?: string,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">    text?: string,</span></span><br><span class="line"><span class="params">    elm?: Node,</span></span><br><span class="line"><span class="params">    context?: Component,</span></span><br><span class="line"><span class="params">    componentOptions?: VNodeComponentOptions,</span></span><br><span class="line"><span class="params">    asyncFactory?: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elm</span> = elm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ns</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnContext</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnOptions</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnScopeId</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = data &amp;&amp; data.<span class="property">key</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentOptions</span> = componentOptions;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentInstance</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">raw</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isStatic</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRootInsert</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isComment</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCloned</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOnce</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncFactory</span> = asyncFactory;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncMeta</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isAsyncPlaceholder</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里千万不要因为 VNode 的这么属性而被吓到，或者咬紧牙去摸清楚每个属性的意义，其实，我们主要了解其几个核心的关键属性就差不多了，例如：</p>
<ul>
<li><code>tag</code> 属性即这个 vnode 的标签属性</li>
<li><code>data</code> 属性包含了最后渲染成真实 dom 节点后，节点上的 class，attribute，style 以及绑定的事件</li>
<li><code>children</code> 属性是 vnode 的子节点</li>
<li><code>text</code> 属性是文本属性</li>
<li><code>elm</code> 属性为这个 vnode 对应的真实 dom 节点</li>
<li><code>key</code> 属性是 vnode 的标记，在 diff 过程中可以提高 diff 的效率</li>
</ul>
<h3 id="3-1-2、源码创建-VNode-过程"><a href="#3-1-2、源码创建-VNode-过程" class="headerlink" title="3.1.2、源码创建 VNode 过程"></a>3.1.2、源码创建 VNode 过程</h3><h4 id="（1）初始化-vue"><a href="#（1）初始化-vue" class="headerlink" title="（1）初始化 vue"></a>（1）初始化 vue</h4><p>我们在实例化一个 vue 实例，也即 new Vue( ) 时，实际上是执行 src&#x2F;core&#x2F;instance&#x2F;index.js 中定义的 Function 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&quot;Vue is a constructor and should be called with the `new` keyword&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看 Vue 的 function，我们知道 Vue 只能通过 new 关键字初始化，然后调用 this._init 方法，该方法在 src&#x2F;core&#x2F;instance&#x2F;init.js 中定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略一系列其它初始化的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vm.$options.el:&quot;</span>, vm.<span class="property">$options</span>.<span class="property">el</span>);</span><br><span class="line">    vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="（2）Vue-实例挂载"><a href="#（2）Vue-实例挂载" class="headerlink" title="（2）Vue 实例挂载"></a>（2）Vue 实例挂载</h4><p>Vue 中是通过 $mount 实例方法去挂载 dom 的，下面我们通过分析 compiler 版本的 mount 实现，相关源码在目录 src&#x2F;platforms&#x2F;web&#x2F;entry-runtime-with-compiler.js 文件中定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略一系列初始化以及逻辑判断代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发现最终还是调用用原先原型上的 $mount 方法挂载 ，原先原型上的 $mount 方法在 src&#x2F;platforms&#x2F;web&#x2F;runtime&#x2F;index.js 中定义 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发现$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src&#x2F;core&#x2F;instance&#x2F;lifecycle.js 文件中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  el: ?Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el;</span><br><span class="line">  <span class="comment">// 省略一系列其它代码</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成虚拟 vnode</span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>();</span><br><span class="line">      <span class="comment">// 更新 DOM</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">before</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">          <span class="title function_">callHook</span>(vm, <span class="string">&quot;beforeUpdate&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  );</span><br><span class="line">  hydrating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，mountComponent 核心就是先实例化一个渲染 Watcher，在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。</p>
<h4 id="（3）创建虚拟-Node"><a href="#（3）创建虚拟-Node" class="headerlink" title="（3）创建虚拟 Node"></a>（3）创建虚拟 Node</h4><p>Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src&#x2F;core&#x2F;instance&#x2F;render.js 文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">   <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line">   <span class="keyword">let</span> vnode</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 省略一系列代码</span></span><br><span class="line">     currentRenderingInstance = vm</span><br><span class="line">     <span class="comment">// 调用 createElement 方法来返回 vnode</span></span><br><span class="line">     vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="title function_">handleError</span>(<span class="params">e, vm, <span class="string">`render`</span></span>)&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// set parent</span></span><br><span class="line">   vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vnode...:&quot;</span>,vnode);</span><br><span class="line">   <span class="keyword">return</span> vnode</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Vue.js 利用 _createElement 方法创建 VNode，它定义在 src&#x2F;core&#x2F;vdom&#x2F;create-elemenet.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  context: Component,</span></span><br><span class="line"><span class="params">  tag?: string | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  data?: VNodeData,</span></span><br><span class="line"><span class="params">  children?: any,</span></span><br><span class="line"><span class="params">  normalizationType?: number</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 省略一系列非主线代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (normalizationType === <span class="variable constant_">ALWAYS_NORMALIZE</span>) &#123;</span><br><span class="line">    <span class="comment">// 场景是 render 函数不是编译生成的</span></span><br><span class="line">    children = <span class="title function_">normalizeChildren</span>(children);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === <span class="variable constant_">SIMPLE_NORMALIZE</span>) &#123;</span><br><span class="line">    <span class="comment">// 场景是 render 函数是编译生成的</span></span><br><span class="line">    children = <span class="title function_">simpleNormalizeChildren</span>(children);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span>;</span><br><span class="line">    ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag);</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      <span class="comment">// 创建虚拟 vnode</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag),</span><br><span class="line">        data,</span><br><span class="line">        children,</span><br><span class="line">        <span class="literal">undefined</span>,</span><br><span class="line">        <span class="literal">undefined</span>,</span><br><span class="line">        context</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      (!data || !data.<span class="property">pre</span>) &amp;&amp;</span><br><span class="line">      <span class="title function_">isDef</span>((<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&quot;components&quot;</span>, tag)))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(tag, data, children, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(ns)) <span class="title function_">applyNS</span>(vnode, ns);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) <span class="title function_">registerDeepBindings</span>(data);</span><br><span class="line">    <span class="keyword">return</span> vnode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createEmptyVNode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_createElement 方法有 5 个参数，context 表示 VNode 的上下文环境，它是 Component 类型；tag 表示标签，它可以是一个字符串，也可以是一个 Component；data 表示 VNode 的数据，它是一个 VNodeData 类型，可以在 flow&#x2F;vnode.js 中找到它的定义；children 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 VNode 数组；</p>
<h3 id="3-1-3、实例查看"><a href="#3-1-3、实例查看" class="headerlink" title="3.1.3、实例查看"></a>3.1.3、实例查看</h3><p>为了更直观查看我们平时写的 Vue 代码如何用 VNode 类来表示，我们通过一个实例的转换进行更深刻了解。</p>
<p>例如，实例化一个 Vue 实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params">createElement</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createElement</span>(</span><br><span class="line">      <span class="string">&quot;div&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">attrs</span>: &#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">          <span class="attr">class</span>: <span class="string">&quot;class_box&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;Hello Vue!&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们打印出其对应的 VNode 表示：</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QF9L5Q.png#alt=QF9L5Q.png"></p>
<h2 id="3-2、diff-过程"><a href="#3-2、diff-过程" class="headerlink" title="3.2、diff 过程"></a>3.2、diff 过程</h2><h3 id="3-2-1、Vue-js-源码的-diff-调用逻辑"><a href="#3-2-1、Vue-js-源码的-diff-调用逻辑" class="headerlink" title="3.2.1、Vue.js 源码的 diff 调用逻辑"></a>3.2.1、Vue.js 源码的 diff 调用逻辑</h3><p>Vue.js 源码实例化了一个 watcher，这个 ~ 被添加到了在模板当中所绑定变量的依赖当中，一旦 model 中的响应式的数据发生了变化，这些响应式的数据所维护的 dep 数组便会调用 dep.notify() 方法完成所有依赖遍历执行的工作，这包括视图的更新，即 updateComponent 方法的调用。watcher 和 updateComponent 方法定义在  src&#x2F;core&#x2F;instance&#x2F;lifecycle.js 文件中 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  el: ?Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el;</span><br><span class="line">  <span class="comment">// 省略一系列其它代码</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成虚拟 vnode</span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>();</span><br><span class="line">      <span class="comment">// 更新 DOM</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">before</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">          <span class="title function_">callHook</span>(vm, <span class="string">&quot;beforeUpdate&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  );</span><br><span class="line">  hydrating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成视图的更新工作事实上就是调用了 vm._update 方法，这个方法接收的第一个参数是刚生成的 Vnode，调用的 vm._update 方法定义在 src&#x2F;core&#x2F;instance&#x2F;lifecycle.js 中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span>;</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span>;</span><br><span class="line">  <span class="keyword">const</span> restoreActiveInstance = <span class="title function_">setActiveInstance</span>(vm);</span><br><span class="line">  vm.<span class="property">_vnode</span> = vnode;</span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// 第一个参数为真实的node节点，则为初始化</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果需要diff的prevVnode存在，那么对prevVnode和vnode进行diff</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">restoreActiveInstance</span>();</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.<span class="property">__vue__</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">    vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">    vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个方法当中最为关键的就是 <code>vm.__patch__</code> 方法，这也是整个 virtual-dom 当中最为核心的方法，主要完成了 prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实 dom 节点并完成视图的更新工作。</p>
<p>接下来，让我们看下 <code>vm.__patch__</code> 的逻辑过程， <code>vm.__patch__</code> 方法定义在 src&#x2F;core&#x2F;vdom&#x2F;patch.js 中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// 当oldVnode不存在时，创建新的节点</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      <span class="title function_">createElm</span>(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对oldVnode和vnode进行diff，并对oldVnode打patch</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">      &#125;</span><br><span class="line">	......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 patch 方法中，我们看到会分为两种情况，一种是当 oldVnode 不存在时，会创建新的节点；另一种则是已经存在 oldVnode ，那么会对 oldVnode 和 vnode 进行 diff 及 patch 的过程。其中 patch 过程中会调用 sameVnode 方法来对对传入的 2 个 vnode 进行基本属性的比较，只有当基本属性相同的情况下才认为这个 2 个 vnode 只是局部发生了更新，然后才会对这 2 个 vnode 进行 diff，如果 2 个 vnode 的基本属性存在不一致的情况，那么就会直接跳过 diff 的过程，进而依据 vnode 新建一个真实的 dom，同时删除老的 dom 节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp;</span><br><span class="line">    a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;</span><br><span class="line">    a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp;</span><br><span class="line">    <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp;</span><br><span class="line">    <span class="title function_">sameInputType</span>(a, b)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>diff 过程中主要是通过调用 patchVnode 方法进行的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">const</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span></span><br><span class="line"><span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line"><span class="keyword">const</span> ch = vnode.<span class="property">children</span></span><br><span class="line"><span class="comment">// 如果vnode没有文本节点</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode的children属性存在且vnode的children属性也存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">    <span class="comment">// updateChildren，对子节点进行diff</span></span><br><span class="line">    <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">checkDuplicateKeys</span>(ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果oldVnode的text存在，那么首先清空text的内容,然后将vnode的children添加进去</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) &#123;</span><br><span class="line">    <span class="comment">// 删除elm下的oldchildren</span></span><br><span class="line">    <span class="title function_">removeVnodes</span>(elm, oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) &#123;</span><br><span class="line">    <span class="comment">// oldVnode有子节点，而vnode没有，那么就清空这个节点</span></span><br><span class="line">    nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素</span></span><br><span class="line">    nodeOps.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码得知，</p>
<p>diff 过程中又分了好几种情况，oldCh 为 oldVnode 的子节点，ch 为 Vnode 的子节点：</p>
<p>首先进行文本节点的判断，若 oldVnode.text !&#x3D;&#x3D; vnode.text，那么就会直接进行文本节点的替换；</p>
<p>在 vnode 没有文本节点的情况下，进入子节点的 diff；</p>
<p>当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；</p>
<p>若 oldCh 不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到 elm 真实 dom 节点当中；</p>
<p>若 oldCh 存在，ch 不存在，则删除 elm 真实节点下的 oldCh 子节点；</p>
<p>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。</p>
<h3 id="3-2-2、子节点-diff-流程分析"><a href="#3-2-2、子节点-diff-流程分析" class="headerlink" title="3.2.2、子节点 diff 流程分析"></a>3.2.2、子节点 diff 流程分析</h3><h4 id="（1）Vue-js-源码"><a href="#（1）Vue-js-源码" class="headerlink" title="（1）Vue.js 源码"></a>（1）Vue.js 源码</h4><p>这里着重分析下 updateChildren 方法，它也是整个 diff 过程中最重要的环节，以下为 Vue.js 的源码过程，为了更形象理解 diff 过程，我们给出相关的示意图来讲解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  parentElm,</span></span><br><span class="line"><span class="params">  oldCh,</span></span><br><span class="line"><span class="params">  newCh,</span></span><br><span class="line"><span class="params">  insertedVnodeQueue,</span></span><br><span class="line"><span class="params">  removeOnly</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 为oldCh和newCh分别建立索引，为之后遍历的依据</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到oldCh或者newCh被遍历完后跳出循环</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="title function_">patchVnode</span>(</span><br><span class="line">        oldStartVnode,</span><br><span class="line">        newStartVnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        newCh,</span><br><span class="line">        newStartIdx</span><br><span class="line">      );</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="title function_">patchVnode</span>(</span><br><span class="line">        oldEndVnode,</span><br><span class="line">        newEndVnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        newCh,</span><br><span class="line">        newEndIdx</span><br><span class="line">      );</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(</span><br><span class="line">        oldStartVnode,</span><br><span class="line">        newEndVnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        newCh,</span><br><span class="line">        newEndIdx</span><br><span class="line">      );</span><br><span class="line">      canMove &amp;&amp;</span><br><span class="line">        nodeOps.<span class="title function_">insertBefore</span>(</span><br><span class="line">          parentElm,</span><br><span class="line">          oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">          nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>)</span><br><span class="line">        );</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="title function_">patchVnode</span>(</span><br><span class="line">        oldEndVnode,</span><br><span class="line">        newStartVnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        newCh,</span><br><span class="line">        newStartIdx</span><br><span class="line">      );</span><br><span class="line">      canMove &amp;&amp;</span><br><span class="line">        nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx))</span><br><span class="line">        oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">        : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123;</span><br><span class="line">        <span class="comment">// New element</span></span><br><span class="line">        <span class="title function_">createElm</span>(</span><br><span class="line">          newStartVnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          parentElm,</span><br><span class="line">          oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">          <span class="literal">false</span>,</span><br><span class="line">          newCh,</span><br><span class="line">          newStartIdx</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeToMove = oldCh[idxInOld];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="title function_">patchVnode</span>(</span><br><span class="line">            vnodeToMove,</span><br><span class="line">            newStartVnode,</span><br><span class="line">            insertedVnodeQueue,</span><br><span class="line">            newCh,</span><br><span class="line">            newStartIdx</span><br><span class="line">          );</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">          canMove &amp;&amp;</span><br><span class="line">            nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="title function_">createElm</span>(</span><br><span class="line">            newStartVnode,</span><br><span class="line">            insertedVnodeQueue,</span><br><span class="line">            parentElm,</span><br><span class="line">            oldStartVnode.<span class="property">elm</span>,</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            newCh,</span><br><span class="line">            newStartIdx</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = <span class="title function_">isUndef</span>(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].<span class="property">elm</span>;</span><br><span class="line">    <span class="title function_">addVnodes</span>(</span><br><span class="line">      parentElm,</span><br><span class="line">      refElm,</span><br><span class="line">      newCh,</span><br><span class="line">      newStartIdx,</span><br><span class="line">      newEndIdx,</span><br><span class="line">      insertedVnodeQueue</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    <span class="title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开始遍历 diff 前，首先给 oldCh 和 newCh 分别分配一个 startIndex 和 endIndex 来作为遍历的索引，当 oldCh 或者 newCh 遍历完后(遍历完的条件就是 oldCh 或者 newCh 的 startIndex &gt;&#x3D; endIndex )，就停止 oldCh 和 newCh 的 diff 过程。接下来通过实例来看下整个 diff 的过程(节点属性中不带 key 的情况)。</p>
<h4 id="（2）无-key-的-diff-过程"><a href="#（2）无-key-的-diff-过程" class="headerlink" title="（2）无 key 的 diff 过程"></a>（2）无 key 的 diff 过程</h4><p>我们通过以下示意图对以上代码过程进行讲解：</p>
<p>####（2.1）首先从第一个节点开始比较，不管是 oldCh 还是 newCh 的起始或者终止节点都不存在 sameVnode ，同时节点属性中是不带 key 标记的，因此第一轮的 diff 完后，newCh 的 startVnode 被添加到 oldStartVnode 的前面，同时 newStartIndex 前移一位；</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QF9qUg.jpg#alt=QF9qUg.jpg"></p>
<p>（2.2）第二轮的 diff 中，满足 sameVnode(oldStartVnode, newStartVnode)，因此对这 2 个 vnode 进行 diff，最后将 patch 打到 oldStartVnode 上，同时 oldStartVnode 和 newStartIndex 都向前移动一位 ；</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QF9bVS.jpg#alt=QF9bVS.jpg"></p>
<p>（2.3）第三轮的 diff 中，满足 sameVnode(oldEndVnode, newStartVnode)，那么首先对 oldEndVnode 和 newStartVnode 进行 diff，并对 oldEndVnode 进行 patch，并完成 oldEndVnode 移位的操作，最后 newStartIndex 前移一位，oldStartVnode 后移一位；</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QF9v2n.jpg#alt=QF9v2n.jpg"></p>
<p>（2.4）第四轮的 diff 中，过程同步骤 3；</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QF9xvq.jpg#alt=QF9xvq.jpg"></p>
<p>（2.5）第五轮的 diff 中，同过程 1；</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFCSK0.jpg#alt=QFCSK0.jpg"></p>
<p>（2.6）遍历的过程结束后，newStartIdx &gt; newEndIdx，说明此时 oldCh 存在多余的节点，那么最后就需要将这些多余的节点删除。</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFCprV.jpg#alt=QFCprV.jpg"></p>
<h4 id="（3）有-key-的-diff-流程"><a href="#（3）有-key-的-diff-流程" class="headerlink" title="（3）有 key 的 diff 流程"></a>（3）有 key 的 diff 流程</h4><p>在 vnode 不带 key 的情况下，每一轮的 diff 过程当中都是起始和结束节点进行比较，直到 oldCh 或者 newCh 被遍历完。而当为 vnode 引入 key 属性后，在每一轮的 diff 过程中，当起始和结束节点都没有找到 sameVnode 时，然后再判断在 newStartVnode 的属性中是否有 key，且是否在 oldKeyToIndx 中找到对应的节点 ：</p>
<p>如果不存在这个 key，那么就将这个 newStartVnode 作为新的节点创建且插入到原有的 root 的子节点中；</p>
<p>如果存在这个 key，那么就取出 oldCh 中的存在这个 key 的 vnode，然后再进行 diff 的过；</p>
<p>通过以上分析，给 vdom 上添加 key 属性后，遍历 diff 的过程中，当起始点，结束点的搜寻及 diff 出现还是无法匹配的情况下时，就会用 key 来作为唯一标识，来进行 diff，这样就可以提高 diff 效率。</p>
<p>带有 Key 属性的 vnode 的 diff 过程可见下图：</p>
<p>（3.1）首先从第一个节点开始比较，不管是 oldCh 还是 newCh 的起始或者终止节点都不存在 sameVnode，但节点属性中是带 key 标记的， 然后在 oldKeyToIndx 中找到对应的节点，这样第一轮 diff 过后 oldCh 上的 B 节点被删除了，但是 newCh 上的 B 节点上 elm 属性保持对 oldCh 上 B 节点 的 elm 引用。</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFC9bT.jpg#alt=QFC9bT.jpg"></p>
<p>（3.2）第二轮的 diff 中，满足 sameVnode(oldStartVnode, newStartVnode)，因此对这 2 个 vnode 进行 diff，最后将 patch 打到 oldStartVnode 上，同时 oldStartVnode 和 newStartIndex 都向前移动一位 ；</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFCiaF.jpg#alt=QFCiaF.jpg"></p>
<p>（3.3）第三轮的 diff 中，满足 sameVnode(oldEndVnode, newStartVnode)，那么首先对 oldEndVnode 和 newStartVnode 进行 diff，并对 oldEndVnode 进行 patch，并完成 oldEndVnode 移位的操作，最后 newStartIndex 前移一位，oldStartVnode 后移一位；</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFCF54.jpg#alt=QFCF54.jpg"></p>
<p>（3.4）第四轮的 diff 中，过程同步骤 2；</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFCAPJ.jpg#alt=QFCAPJ.jpg"></p>
<p>（3.5）第五轮的 diff 中，因为此时 oldStartIndex 已经大于 oldEndIndex，所以将剩余的 Vnode 队列插入队列最后。</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFCEG9.jpg#alt=QFCEG9.jpg"></p>
<p>3.3、patch 过程</p>
<p>通过 3.2 章节介绍的 diff 过程中，我们会看到 nodeOps 相关的方法对真实 DOM 结构进行操作，nodeOps 定义在 src&#x2F;platforms&#x2F;web&#x2F;runtime&#x2F;node-ops.js 中，其为基本 DOM 操作，这里就不在详细介绍。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElementNS</span>(<span class="params">namespace: string, tagName: string</span>): <span class="title class_">Element</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createElementNS</span>(namespaceMap[namespace], tagName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createTextNode</span>(<span class="params">text: string</span>): <span class="title class_">Text</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComment</span>(<span class="params">text: string</span>): <span class="title class_">Comment</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createComment</span>(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">insertBefore</span>(<span class="params"></span></span><br><span class="line"><span class="params">  parentNode: Node,</span></span><br><span class="line"><span class="params">  newNode: Node,</span></span><br><span class="line"><span class="params">  referenceNode: Node</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  parentNode.<span class="title function_">insertBefore</span>(newNode, referenceNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">removeChild</span>(<span class="params">node: Node, child: Node</span>) &#123;</span><br><span class="line">  node.<span class="title function_">removeChild</span>(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.4、总结</p>
<p>通过前三小节简析，我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。</p>
<p><img src="https://s2.ax1x.com/2019/11/28/QFCV2R.png#alt=QFCV2R.png"></p>
<h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p>本文转载自<a target="_blank" rel="noopener" href="https://github.com/fengshi123/blog/issues/10">https://github.com/fengshi123/blog/issues/10</a></p>
<p>感谢作者<a href="/fengshi123">@fengshi123 </a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/17/vue-hackernews-2-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E9%80%82%E5%90%88%E5%85%A5%E9%97%A8-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/17/vue-hackernews-2-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E9%80%82%E5%90%88%E5%85%A5%E9%97%A8-%E4%BA%8C/" class="post-title-link" itemprop="url">vue-hackernews-2.0 源码解读(适合入门)(二)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-17 19:07:51" itemprop="dateCreated datePublished" datetime="2019-10-17T19:07:51+08:00">2019-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-01 18:08:52" itemprop="dateModified" datetime="2022-11-01T18:08:52+08:00">2022-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>书接上回</p>
<p>我们看下 entry-server.js 主要做了什么</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;./app&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isDev = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此导出的函数将由`bundleRenderer`调用。</span></span><br><span class="line"><span class="comment">//这是我们执行数据预取以确定</span></span><br><span class="line"><span class="comment">//实际渲染应用程序之前的状态。</span></span><br><span class="line"><span class="comment">//由于数据获取是异步的，因此该函数有望</span></span><br><span class="line"><span class="comment">//返回解析为应用实例的Promise。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This exported function will be called by `bundleRenderer`.</span></span><br><span class="line"><span class="comment">// This is where we perform data-prefetching to determine the</span></span><br><span class="line"><span class="comment">// state of our application before actually rendering it.</span></span><br><span class="line"><span class="comment">// Since data fetching is async, this function is expected to</span></span><br><span class="line"><span class="comment">// return a Promise that resolves to the app instance.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = isDev &amp;&amp; <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123; app, router, store &#125; = <span class="title function_">createApp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; url &#125; = context;</span><br><span class="line">    <span class="keyword">const</span> &#123; fullPath &#125; = router.<span class="title function_">resolve</span>(url).<span class="property">route</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fullPath !== url) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(&#123; <span class="attr">url</span>: fullPath &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置路由位置</span></span><br><span class="line">    <span class="comment">// set router&#x27;s location</span></span><br><span class="line">    router.<span class="title function_">push</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待路由可能的异步钩子</span></span><br><span class="line">    <span class="comment">// wait until router has resolved possible async hooks</span></span><br><span class="line">    router.<span class="title function_">onReady</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matchedComponents = router.<span class="title function_">getMatchedComponents</span>();</span><br><span class="line">      <span class="comment">// no matched routes</span></span><br><span class="line">      <span class="keyword">if</span> (!matchedComponents.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//路由上匹配的组件唤醒fetchData钩子</span></span><br><span class="line">      <span class="comment">//一个预置钩子匹配一个状态返回promise</span></span><br><span class="line">      <span class="comment">//当解析完成且状态更新</span></span><br><span class="line">      <span class="comment">// Call fetchData hooks on components matched by the route.</span></span><br><span class="line">      <span class="comment">// A preFetch hook dispatches a store action and returns a Promise,</span></span><br><span class="line">      <span class="comment">// which is resolved when the action is complete and store state has been</span></span><br><span class="line">      <span class="comment">// updated.</span></span><br><span class="line">      <span class="comment">// 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">        matchedComponents.<span class="title function_">map</span>(</span><br><span class="line">          <span class="function">(<span class="params">&#123; asyncData &#125;</span>) =&gt;</span></span><br><span class="line">            asyncData &amp;&amp;</span><br><span class="line">            <span class="title function_">asyncData</span>(&#123;</span><br><span class="line">              store,</span><br><span class="line">              <span class="attr">route</span>: router.<span class="property">currentRoute</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          isDev &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`data pre-fetch: <span class="subst">$&#123;<span class="built_in">Date</span>.now() - s&#125;</span>ms`</span>);</span><br><span class="line">          <span class="comment">//解析了所有prefetch钩子后,渲染app所需要的state充满了store,</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//在渲染上下文中公开状态，并让请求处理程序</span></span><br><span class="line">          <span class="comment">//内联HTML响应中的状态。这允许客户端</span></span><br><span class="line">          <span class="comment">//存储以获取服务器端状态，而不必重复</span></span><br><span class="line">          <span class="comment">//在客户端上获取初始数据。</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// After all preFetch hooks are resolved, our store is now</span></span><br><span class="line">          <span class="comment">// filled with the state needed to render the app.</span></span><br><span class="line">          <span class="comment">// Expose the state on the render context, and let the request handler</span></span><br><span class="line">          <span class="comment">// inline the state in the HTML response. This allows the client-side</span></span><br><span class="line">          <span class="comment">// store to pick-up the server-side state without having to duplicate</span></span><br><span class="line">          <span class="comment">// the initial data fetching on the client.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 把vuex的state设置到传入的context.initialState上</span></span><br><span class="line">          context.<span class="property">state</span> = store.<span class="property">state</span>;</span><br><span class="line">          <span class="comment">// 返回state, router已经设置好的Vue实例app</span></span><br><span class="line">          <span class="title function_">resolve</span>(app);</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(reject);</span><br><span class="line">    &#125;, reject);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>entry-server.js 的主要工作：</p>
<p>0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，</p>
<p>将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的 url。</p>
<p>1.手动路由切换到请求的 url，即’&#x2F;‘</p>
<p>2.找到该路由对应要渲染的组件，并调用组件的 asyncData 方法来预取数据</p>
<p>3.同步 vuex 的 state 数据至传入的 context.initialState 上，</p>
<p>后面会把这些数据直接发送到浏览器端与客户端的 vue 实例进行数据(状态)同步，</p>
<p>以避免客户端首屏重新加载数据（在客户端入口文件 entry-client.js）</p>
<p>还记得 index.template.html 被设置到 template 属性中吗？</p>
<p>此时 Vue 渲染器内部就会将 Vue 实例渲染进我们传入的这个 html 模板，那么 Vue render 内部是如何知道把 Vue 实例插入到模板的什么位置呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!--vue-ssr-outlet--&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>就是这里，这个<code>&lt;!--vue-ssr-outlet--&gt;</code>Vue 渲染器就是根据这个自动替换插入，所以这是个固定的 placeholder。</p>
<p>如果改动，服务端渲染时会有错误提示：Error: Content placeholder not found in template.</p>
<p>接下来，Vue 渲染器会回调 callback 方法，我们回到 server.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span> (req, res) &#123;</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line">  renderer.<span class="title function_">renderToString</span>(context, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(html)</span><br><span class="line">    ···</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时只需要将渲染好的 html 写入 http 响应体就结束了，浏览器客户端就可以看到页面了。</p>
<p>接下来我们看看服务端数据预取的实现</p>
<h1 id="服务端渲染时的数据预取流程"><a href="#服务端渲染时的数据预取流程" class="headerlink" title="服务端渲染时的数据预取流程"></a>服务端渲染时的数据预取流程</h1><p>上文提到，服务端渲染时，会手动将路由导航到请求地址即’&#x2F;‘下，然后调用该路由组件的 asyncData 方法来预取数据</p>
<p>那么我们看看路由配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router/index.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>);</span><br><span class="line"><span class="comment">// route-level code splitting</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createListView</span> = (<span class="params">id</span>) =&gt; <span class="function">() =&gt;</span></span><br><span class="line">  <span class="title class_">System</span>.<span class="title function_">import</span>(<span class="string">&quot;../views/CreateListView&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">m</span>) =&gt;</span> m.<span class="title function_">default</span>(id));</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ItemView</span> = (<span class="params"></span>) =&gt; <span class="title class_">System</span>.<span class="title function_">import</span>(<span class="string">&quot;../views/ItemView.vue&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserView</span> = (<span class="params"></span>) =&gt; <span class="title class_">System</span>.<span class="title function_">import</span>(<span class="string">&quot;../views/UserView.vue&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;history&quot;</span>,</span><br><span class="line">    <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/top/:page(\\d+)?&quot;</span>, <span class="attr">component</span>: <span class="title function_">createListView</span>(<span class="string">&quot;top&quot;</span>) &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/new/:page(\\d+)?&quot;</span>, <span class="attr">component</span>: <span class="title function_">createListView</span>(<span class="string">&quot;new&quot;</span>) &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/show/:page(\\d+)?&quot;</span>, <span class="attr">component</span>: <span class="title function_">createListView</span>(<span class="string">&quot;show&quot;</span>) &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/ask/:page(\\d+)?&quot;</span>, <span class="attr">component</span>: <span class="title function_">createListView</span>(<span class="string">&quot;ask&quot;</span>) &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/job/:page(\\d+)?&quot;</span>, <span class="attr">component</span>: <span class="title function_">createListView</span>(<span class="string">&quot;job&quot;</span>) &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/item/:id(\\d+)&quot;</span>, <span class="attr">component</span>: <span class="title class_">ItemView</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/user/:id&quot;</span>, <span class="attr">component</span>: <span class="title class_">UserView</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&quot;/top&quot;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地址’&#x2F;‘是做了 redirect 到’&#x2F;top’,其实就是默认地址就是到 top 页面，在看第一条路由配置，’&#x2F;top’路由对应的组件是 createListView(‘top’)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/views/CreateListView.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ItemList</span> <span class="keyword">from</span> <span class="string">&quot;./ItemList.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">camelize</span> = (<span class="params">str</span>) =&gt; str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a factory function for dynamically creating root-level list views,</span></span><br><span class="line"><span class="comment">// since they share most of the logic except for the type of items to display.</span></span><br><span class="line"><span class="comment">// They are essentially higher order components wrapping ItemList.vue.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">createListView</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">`<span class="subst">$&#123;type&#125;</span>-stories-view`</span>,</span><br><span class="line">    <span class="comment">//从store中取值</span></span><br><span class="line">    <span class="title function_">asyncData</span>(<span class="params">&#123; store &#125;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> store.<span class="title function_">dispatch</span>(<span class="string">&quot;FETCH_LIST_DATA&quot;</span>, &#123; type &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">title</span>: <span class="title function_">camelize</span>(type),</span><br><span class="line">    <span class="comment">//创建itemlist的节点,渲染节点</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params">h</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">ItemList</span>, &#123; <span class="attr">props</span>: &#123; type &#125; &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vuex-state-状态变更流程"><a href="#Vuex-state-状态变更流程" class="headerlink" title="Vuex state 状态变更流程"></a>Vuex state 状态变更流程</h1><p><img src="https://s2.ax1x.com/2019/10/17/KEZjTP.jpg#alt=KEZjTP.jpg"></p>
<p>asyncData 方法被调用，通过 store.dispatch 分发了一个数据预取的事件，接下来我们可以看到通过 FireBase 的 API 获取到 Top 分类的数据，然后又做了一系列的内部事件分发，保存数据状态到 Vuex store，获取 Top 页面的 List 子项数据，最后处理并保存数据到 store.</p>
<p>最后数据就都保存在 store 这里了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">&quot;./actions&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">&quot;./mutations&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&quot;./getters&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createStore</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">      <span class="attr">activeType</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">itemsPerPage</span>: <span class="number">20</span>,</span><br><span class="line">      <span class="attr">items</span>: &#123;</span><br><span class="line">        <span class="comment">/* [id: number]: Item */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">users</span>: &#123;</span><br><span class="line">        <span class="comment">/* [id: string]: User */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">lists</span>: &#123;</span><br><span class="line">        <span class="attr">top</span>: [</span><br><span class="line">          <span class="comment">/* number */</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">new</span>: [],</span><br><span class="line">        <span class="attr">show</span>: [],</span><br><span class="line">        <span class="attr">ask</span>: [],</span><br><span class="line">        <span class="attr">job</span>: [],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    getters,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将开始通过 Render 函数创建 HTML</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/views/CreateListView.js</span></span><br><span class="line">render (h) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`createListView render`</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">ItemList</span>, &#123; <span class="attr">props</span>: &#123; type &#125;&#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/views/ItemList.vue</span></span><br><span class="line">···</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news-view&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news-list-nav&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-if</span>=<span class="string">&quot;page &gt; 1&quot;</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/&#x27; + type + &#x27;/&#x27; + (page - 1)&quot;</span>&gt;</span>&lt; prev<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">&quot;disabled&quot;</span>&gt;</span>&lt; prev<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-if</span>=<span class="string">&quot;hasMore&quot;</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/&#x27; + type + &#x27;/&#x27; + (page + 1)&quot;</span>&gt;</span>more &gt;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">&quot;disabled&quot;</span>&gt;</span>more &gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">&quot;transition&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news-list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;displayedPage&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;displayedPage &gt; 0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">&quot;ul&quot;</span> <span class="attr">name</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">item</span> <span class="attr">v-for</span>=<span class="string">&quot;item in displayedItems&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>这样创建完 HTML Body 部分，前面提到的 Vue 渲染器会自动把这部分内容插入 index.template.html 中，替换对应的,然后就又回到前面的流程了，server.js 将整个 html 写入 http 响应体，浏览器就得到了整个 html 页面，整个首次访问过程完成。</p>
<p>暂时先这样</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zax Tseng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
