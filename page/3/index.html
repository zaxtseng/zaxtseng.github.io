<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Git版本管理工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/01/Git版本管理工具/" class="article-date">
  <time datetime="2019-10-01T05:44:59.000Z" itemprop="datePublished">2019-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/01/Git版本管理工具/">Git版本管理工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>去官网下载吧</p>
<h1 id="建立Git库"><a href="#建立Git库" class="headerlink" title="建立Git库"></a>建立Git库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//先新建一个空文件夹</span><br><span class="line">mkdir newBash</span><br><span class="line">//在git bash中</span><br><span class="line">cd newBash //切换到newBash文件夹下</span><br><span class="line">git  init //初始化仓库</span><br></pre></td></tr></table></figure>

<h1 id="设置基础信息"><a href="#设置基础信息" class="headerlink" title="设置基础信息"></a>设置基础信息</h1><p>配置相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在git bash中</span><br><span class="line">git init</span><br><span class="line">git config -l  //查看当前配置</span><br><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br><span class="line">git config --global color.ui true  //代码颜色高亮显示</span><br><span class="line">git config -l  //再查看一下对不对</span><br></pre></td></tr></table></figure>

<h1 id="提交commit"><a href="#提交commit" class="headerlink" title="提交commit"></a>提交commit</h1><p>基本步骤:</p>
<ol>
<li>建立文件(本地工作文件夹)</li>
<li>追加文件(索引区stage)</li>
<li>提交文件(本地库local,远程库remote)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//新建一个文件</span><br><span class="line">touch a.md</span><br><span class="line"></span><br><span class="line">//在文件中写字符</span><br><span class="line">echo &quot;helloworld&quot; &gt; a.md</span><br><span class="line"></span><br><span class="line">//查看此时状态</span><br><span class="line">git status (未提交文件名颜色为红色)</span><br><span class="line"></span><br><span class="line">//提交到索引区(也叫暂存区)</span><br><span class="line">git add a.md  (或者直接git add . 表示提交修改文件)</span><br><span class="line"></span><br><span class="line">//再看看状态</span><br><span class="line">git status  (提交了颜色变绿了)</span><br><span class="line"></span><br><span class="line">//将暂存区的文件提交到本地库(需要附带说明)</span><br><span class="line">git commit -m &quot;add file&quot;  //add file 就是说明,会显示在github的文件名后面</span><br><span class="line"></span><br><span class="line">//再看看状态</span><br><span class="line">git status  (提交到本地库后,暂存区里就空了)</span><br><span class="line"></span><br><span class="line">//看看提交历史</span><br><span class="line">git log </span><br><span class="line">//(会显示提交者的名字,时间,提交记录)</span><br><span class="line"></span><br><span class="line">//提交到远程仓库</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>一般远程仓库有一个master主分支,多个其他分支.<br>现在展示如何从远端dev分支下载并修改,再推送.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//切换到一个文件夹下</span><br><span class="line">cd newclone</span><br><span class="line">//从远端仓库clone</span><br><span class="line">git clone git@xxx.com</span><br><span class="line"></span><br><span class="line">//查看当前分支</span><br><span class="line">git branch  (发现远端仓库只有master被clone下来,其他没有)</span><br><span class="line"></span><br><span class="line">//查看所有分支(包括远端分支)</span><br><span class="line">git branch -a  (此时出现远端dev分支)</span><br><span class="line"></span><br><span class="line">//创建dev分支,映射远端dev分支</span><br><span class="line">git branch dev remotes/origin/dev </span><br><span class="line"></span><br><span class="line">//上面几步不执行也可以,直接执行切换分支就可以clone数据</span><br><span class="line"></span><br><span class="line">//切换到dev分支</span><br><span class="line">git checkout dev (此时dev下所有文件都会clone下来)</span><br><span class="line"></span><br><span class="line">//修改其中的文件</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//推送素质三连</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;修改情况&quot;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>

<h1 id="分支branch"><a href="#分支branch" class="headerlink" title="分支branch"></a>分支branch</h1><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//查看当前分支状态</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">//新建一个分支dev</span><br><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line">//切换到dev分支</span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line">//修改文件</span><br><span class="line">nano style.css</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//提交dev分支中内容到索引区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">//提交dev分支到本地库</span><br><span class="line">git commit -m &quot;added style.css&quot;</span><br><span class="line"></span><br><span class="line">//查看记录</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">//切换到主分支master</span><br><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>书接上回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查看分支状态</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">//在主分支master下,合并dev分支</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">//查看记录</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">//查看后没有问题,删除开发分支</span><br><span class="line">git branch -d dev</span><br><span class="line"></span><br><span class="line">//最后查看分支状态</span><br><span class="line">git branch</span><br></pre></td></tr></table></figure>

<h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h2><p>案例分析:<br>在dev分支创建index文件并修改.在主分支创建index文件并修改.合并分支,必有冲突<br>代码重现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//创建dev分支并切换到dev</span><br><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line">//创建文件.修改文件</span><br><span class="line">nano index.html</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//提交操作</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;modified by dev&quot;</span><br><span class="line"></span><br><span class="line">//切换到主分支</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">//重复上述操作</span><br><span class="line">nano index.html</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;modified by master&quot;</span><br><span class="line"></span><br><span class="line">//查看分支状态</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">//合并分支(必有冲突)</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">//报错,在冲突文件中出现提示</span><br><span class="line"></span><br><span class="line">//由leader决定以哪个分支的信息为准</span><br><span class="line">//编辑文件,去掉冲突提示,选择以哪个分支的修改为准</span><br><span class="line">nano index.html</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//重新提交,并将</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;meraged by leader.&quot;</span><br></pre></td></tr></table></figure>

<h1 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h1><p>书接上回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//提交之后,查看提交历史</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">//查看最近几次历史,接一个数字</span><br><span class="line">git log -3 (查看最近3次的)</span><br><span class="line"></span><br><span class="line">//把历史记录缩成一行.简略显示</span><br><span class="line">git log --oneline</span><br><span class="line"></span><br><span class="line">//详细显示</span><br><span class="line">git log -p (非常详细)</span><br></pre></td></tr></table></figure>

<h1 id="提交回退"><a href="#提交回退" class="headerlink" title="提交回退"></a>提交回退</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//把刚修改的文件退到未修改状态</span><br><span class="line">git checkout -- a.md (取消修改,恢复到初始状态)</span><br><span class="line"></span><br><span class="line">//查看状态</span><br><span class="line">git status (文件已恢复)</span><br></pre></td></tr></table></figure>

<p>提交到索引区,想回退</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//把文件从索引区头部退出</span><br><span class="line">git reset HEAD a.md </span><br><span class="line"></span><br><span class="line">//把刚修改的文件退到未修改状态</span><br><span class="line">git checkout -- a.md</span><br></pre></td></tr></table></figure>

<h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>回退到远程库最后提交的版本,覆盖本地工作区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//回退到最后一次</span><br><span class="line">git reset --hard HEAD</span><br><span class="line"></span><br><span class="line">//回退到倒数第二次</span><br><span class="line">git reset --hard HEAD~</span><br><span class="line"></span><br><span class="line">//回退到倒数第三次</span><br><span class="line">git reset --hard HEAD~2</span><br><span class="line"></span><br><span class="line">//回退到指定版本</span><br><span class="line">git reset --hard 5d79467</span><br><span class="line">(后面的数字是提交时的ID)</span><br><span class="line"></span><br><span class="line">//如果没记住ID,通过reflog找到现在位置的id,再从过去返回来.</span><br><span class="line">git reflog  (会出现所有最近的记录,可以加-3,显示最近3条记录)</span><br></pre></td></tr></table></figure>

<h1 id="比较修改内容"><a href="#比较修改内容" class="headerlink" title="比较修改内容"></a>比较修改内容</h1><p>修改文件后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//和修改前进行比较</span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line">//把修改后的文件加到索引区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">//和索引区的进行比较</span><br><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>

<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//将文件添加到索引区</span><br><span class="line">git add [file1 file2 ...]</span><br><span class="line"></span><br><span class="line">//将工作文件夹下所有文件添加到索引区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">git rm</span><br><span class="line">//删除索引区文件</span><br><span class="line">git rm --cached a.md</span><br><span class="line">//更名</span><br><span class="line">git mv a.md b.md</span><br></pre></td></tr></table></figure>

<h1 id="Git忽略管理"><a href="#Git忽略管理" class="headerlink" title="Git忽略管理"></a>Git忽略管理</h1><p>设置Git忽略文件,这些文件不参与Git库提交.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//新建.gitignore文件</span><br><span class="line">在该文件中写入要忽略的文件名</span><br></pre></td></tr></table></figure>

<h1 id="更新最后的提交"><a href="#更新最后的提交" class="headerlink" title="更新最后的提交"></a>更新最后的提交</h1><p>最后一条提交代码里有bug,想更改,又不想新增一条提交.把更改追加到最后一条提交里.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;最后一次提交&quot;</span><br><span class="line"></span><br><span class="line">//发现bug,修改bug后</span><br><span class="line">//此时文件已修改</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">//提交到最后一次修改里</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<h1 id="使用Tag标签"><a href="#使用Tag标签" class="headerlink" title="使用Tag标签"></a>使用Tag标签</h1><p>系统版本号管理<br>例如: 1.1.3</p>
<p>格式: NNN.abc.xxx</p>
<ul>
<li>NNN: 大版本号</li>
<li>abc: 每次做出小的更新时发布的版本号</li>
<li>xxx: 每次bug修正时发布的版本号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查看当前版本号</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">//设置当前版本号</span><br><span class="line">git tag v1.0.0</span><br><span class="line"></span><br><span class="line">//查询该版本号时文件状态</span><br><span class="line">git show v1.0.0</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/01/Git版本管理工具/" data-id="ck3pu18cf000b0sha835v7k5q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Axios" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/24/Axios/" class="article-date">
  <time datetime="2019-09-24T03:33:48.000Z" itemprop="datePublished">2019-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/24/Axios/">Axios</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>axios是一个基于Promise用于浏览器和nodejs的HTTP客户端，它本身具有以下特征：</p>
<ul>
<li>从浏览器中创建XMLHttpRequest </li>
<li>从node.js发出http请求 </li>
<li>支持 Promise API 拦截请求和响应 </li>
<li>转换请求和响应数据 </li>
<li>取消请求 </li>
<li>自动转换JSON数据 </li>
<li>客户端支持防止 CSRF/XSRF</li>
</ul>
<p>步骤:</p>
<ol>
<li>安装<br><code>$ npm install axios</code><br>或者CDN引入</li>
<li>引入</li>
<li>一般是把axios挂载到原型上,便于全局使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure>

<h2 id="Axios之get请求"><a href="#Axios之get请求" class="headerlink" title="Axios之get请求"></a>Axios之get请求</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    getData()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$http.get(<span class="string">'https://cnode.js.org/api/v1/topic'</span>,&#123;</span><br><span class="line">        params: &#123;</span><br><span class="line">            page: <span class="number">1</span>,</span><br><span class="line">            limit: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.items = res.data.data</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面get请求的其他写法</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>,&#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//如果只有一个选项</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>,&#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//将数据写到url里</span></span><br><span class="line">axios.get(<span class="string">'/user?page=1&amp;limit=10'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Axios之post请求"><a href="#Axios之post请求" class="headerlink" title="Axios之post请求"></a>Axios之post请求</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>,&#123;</span><br><span class="line">    firstName: <span class="string">'tom'</span>,</span><br><span class="line">    lastName: <span class="string">'green'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>POST传递参数有两种格式:</p>
<ul>
<li>form­-data 格式: <code>?page=1&amp;limit=48</code>.<strong>但是不能写在url里</strong></li>
<li>x-­www-­form-­urlencoded格式: <code>{ page: 1,limit: 10 }</code></li>
</ul>
<blockquote>
<p>在axios中，post请求接收的参数必须是form-­data<br>可以使用qs插件—­qs.stringify</p>
</blockquote>
<h2 id="执行多个并发请求"><a href="#执行多个并发请求" class="headerlink" title="执行多个并发请求"></a>执行多个并发请求</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 两个请求现在都执行完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">postData()&#123;</span><br><span class="line">    <span class="comment">//先要安装qs插件,然后引入</span></span><br><span class="line">    <span class="comment">//使用qs插件将对象格式转化为form-data格式</span></span><br><span class="line">    <span class="keyword">this</span>.$http.post(url,qs.stringify(&#123;</span><br><span class="line">        page: <span class="number">1</span>,</span><br><span class="line">        limit: <span class="number">10</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拦截器interceptors"><a href="#拦截器interceptors" class="headerlink" title="拦截器interceptors"></a>拦截器interceptors</h1><p>在请求或响应被 then 或 catch 处理前拦截它们。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>如果你想在稍后移除拦截器，可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>

<p>可以为自定义 axios 实例添加拦截器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/24/Axios/" data-id="ck3pu18bq00050sha2xio8igc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP进阶/">HTTP进阶</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS深入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/20/JS深入/" class="article-date">
  <time datetime="2019-09-20T11:52:59.000Z" itemprop="datePublished">2019-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/20/JS深入/">JS深入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript-自动垃圾收集机制"><a href="#JavaScript-自动垃圾收集机制" class="headerlink" title="JavaScript 自动垃圾收集机制"></a>JavaScript 自动垃圾收集机制</h1><p>垃圾回收又称为 GC(Garbage Collecation)。编写 JavaScript 程序时，开发者不需要手工跟踪内存的使用情况，只要按照标准写 JavaScript 代码，JavaScript 程序运行所需内存的分配以及无用内存的回收完全是自动管理。JavaScript 中自动垃圾回收机制的原理为：</p>
<blockquote>
<p>找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。</p>
</blockquote>
<h2 id="局部变量的正常生命周期"><a href="#局部变量的正常生命周期" class="headerlink" title="局部变量的正常生命周期"></a>局部变量的正常生命周期</h2><p>局部变量只在函数执行的过程中存在。<br>在函数执行过程中，会为局部变量在栈内存(或 堆内存)上分配相应的空间来存储它们的值。在函数中使用这些变量，直至函数执行结束，此时可以释放局部变量的内存供将来需要时使用。<br>以上情况下，较容易判断变量是否有存在的必要，更复杂的情况需要更精细的变量追踪策略。<br>JavaScript 中的垃圾收集器必须跟踪每个变量是否有用，需要为不再有用的变量打上标记，用于将来回收其占用的内存。标识无用变量的策略通常有两个：<strong>标记清除</strong> 和 <strong>引用计数</strong> 。</p>
<h2 id="JavaScript-中的栈内存与堆内存"><a href="#JavaScript-中的栈内存与堆内存" class="headerlink" title="JavaScript 中的栈内存与堆内存"></a>JavaScript 中的栈内存与堆内存</h2><p>上述过程中，JavaScript 中变量分为 基本类型值 和 引用类型值：</p>
<ul>
<li>基本类型值 在内存中占固定大小的空间，因此被保存在 <strong>栈内存</strong> 中；</li>
<li>引用类型值 是对象，保存在 <strong>堆内存</strong> 中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。</li>
</ul>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记清除(mark-and-sweep) 是 JavaScript 中最常用的垃圾回收方式。其执行机制如下：</p>
<ul>
<li>当变量进入环境时，就将其标记为“进入环境”</li>
<li>当变量离开环境时将其标记为“离开环境”</li>
</ul>
<p>逻辑上，永远不能释放进入环境的变量所占用的内存，因为执行流进入相应的环境时，可能会用到它们。<br>标记变量的方式有很多种，可以使用标记位的形式记录变量进入环境，也可单独为“进入环境”和“离开环境”添加变量列表来记录变化。</p>
<p>标记清除采用的收集策略为：</p>
<ol>
<li>JavaScript中的垃圾收集器运行时会给<strong>存储在内存中的所有变量</strong>都加上标记；</li>
<li>然后去掉环境中的变量以及被环境中的变量引用的变量的标记；</li>
<li>此后，再被加上标记的变量被视为准备删除的变量；</li>
<li>最后，垃圾收集器完成内存清除，销毁那些带标记的值并回收其占用的内存空间。</li>
</ol>
<p>2008年之前，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript实现使用的均为 标记清除式的垃圾回收策略，区别可能在垃圾收集的时间间隔。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数(reference counting) 是另一种垃圾收集策略。引用计数的本质是 <strong>跟踪记录每个值被引用的次数</strong>。其执行机制如下：</p>
<ol>
<li>当声明一个变量并将一个引用类型值赋值给该变量时，这个值的引用次数为1；</li>
<li>若同一个值(变量)又被赋值给另一个变量，则该值的引用次数加1；</li>
<li>但是如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1；</li>
<li>当这个值的引用次数为0时，则无法再访问这个值，就可回收其占用的内存空间。</li>
</ol>
<p>垃圾收集器下次运行时，会释放那些引用次数为零的值所占用的内存。<br>引用计数存在一个致命的问题： <strong>循环引用</strong>。循环引用是指，对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。下面的代码就是标准的循环引用的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cycleRefernce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    </span><br><span class="line">    objectA.someOtherObject = objectB;</span><br><span class="line">    objectB.anotherObject = objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中 objectA 和 objectB 通过各自属性相互引用。按照引用计数的策略，两个对象的引用次数均为 2。若采用标记清除策略，函数执行完毕，对象离开作用域就不存在相互引用。但采用引用计数后，函数执行完，两个对象的引用次数永不为0，会一直存尊内存中，若多次调用，导致大量内存得不到回收。</p>
<p>IE8浏览器 之前中有一部分对象并不是原生的 JavaScript 对象，可能是使用 C++ 以 COM 对象的形式实现的(BOM, DOM)。而 COM 对象的垃圾收集机制采用的是 引用计数策略。即使 IE 的 JavaScript 引擎是使用标记清除策略实现的，但 JavaScript 访问 COM 对象仍然是基于 引用计数策略的。在这种情况下，只要在 IE 中涉及 COM 对象，就可能存在循环引用的问题。</p>
<p>为避免出现循环引用，最好在不使用这些对象时，手动断开 原生 JavaScript 对象 与 DOM 元素之间的连接。IE中的循环引用与手动断开的操作如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element;</span><br><span class="line">element.someObject = myObject;</span><br><span class="line"><span class="comment">// 以上 存在循环引用</span></span><br><span class="line"><span class="comment">// ...... </span></span><br><span class="line"><span class="comment">// 以下 手工断开连接</span></span><br><span class="line">myObject.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject =<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>将变量设置成 null 即可切断变量与它之前引用的值之间的连接。下次垃圾收集器运行时，会删除这些值并回收它们占用的内存。<br>为解决上述问题，IE9及以上版本把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象，避免了两种垃圾回收算法并存引起的问题。</p>
<h2 id="垃圾回收的性能问题"><a href="#垃圾回收的性能问题" class="headerlink" title="垃圾回收的性能问题"></a>垃圾回收的性能问题</h2><p>垃圾收集器是周期运行的，确定<strong>垃圾收集的时间间隔</strong>是个重要的问题。</p>
<p>IE7之前的垃圾收集器是根据内存分配量运行的，即 256 个变量、4096 个对象(数组)字面量或 64 KB 的字符串。达到这些临界值的任何一个，垃圾收集器就会运行。所以就导致如果一个脚本含有很多变量，在整个生命周期中一直保有前面临界值大小的变量，就会频繁触发垃圾回收，会存在严重的性能问题。</p>
<p>IE7 重写了垃圾收集例程。新的工作方式为：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为 <strong>动态修正</strong>。初始值与之前版本相同，但如果垃圾收集例程回收的内存低于 15%，则临界值加倍。若回收内存分配量超过 85%，则临界值重置回默认值。</p>
<p>JavaScript V8 引擎的垃圾回收机制<br>在JavaScript脚本中，绝大多数对象的生存期很短，只有部分对象的生存期较长。所以，V8 中的垃圾回收主要使用的是 分代回收 (Generational collection)机制。</p>
<h2 id="分代回收机制"><a href="#分代回收机制" class="headerlink" title="分代回收机制"></a>分代回收机制</h2><p>V8 引擎将保存对象的 <strong>堆</strong> (heap) 进行了分代:</p>
<ol>
<li>对象最初会被分在 <strong>新生区</strong>(New Space) (1~8M)，新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理(小周期)，清理掉新生区中不再活跃的死对象。</li>
<li>对于超过 2 个小周期的对象，则需要将其移动至 <strong>老生区</strong>(Old Space)。老生区在 标记-清除 或 标记-紧缩 的过程(大周期) 中进行回收。<br>大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。</li>
</ol>
<h3 id="Scavenge-算法"><a href="#Scavenge-算法" class="headerlink" title="Scavenge 算法"></a>Scavenge 算法</h3><p>由于垃圾清理发生的比较频繁，清理的过程必须很快。V8 中的清理过程使用的是 Scavenge 算法，按照 经典的 Cheney 算法 实现的。Scavenge 算法的主要过程是：</p>
<ul>
<li>新生区被分为两个等大小的子区(semi-spaces)：to-space 和 from-space；</li>
<li>大多数的内存分配都是在 to-space 发生 (某些特定对象是在老生区)；</li>
<li>当 to-space 耗尽时，交换 to-space 和 from-space, 此时所有的对象都在 from-space；</li>
<li>然后将 from-space 中活跃的对象复制到 to-space 或者老生区中;</li>
<li>这些对象被直接压到 to-space，提升了 Cache 的内存局部性，可使内存分配简洁快速。</li>
</ul>
<p>算法的伪代码描述如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def scavenge():</span><br><span class="line">  swap(fromSpace, toSpace)</span><br><span class="line">  allocationPtr = toSpace.bottom</span><br><span class="line">  scanPtr = toSpace.bottom</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0.</span>.len(roots):</span><br><span class="line">    root = roots[i]</span><br><span class="line">    <span class="keyword">if</span> inFromSpace(root):</span><br><span class="line">      rootCopy = copyObject(&amp;allocationPtr, root)</span><br><span class="line">      setForwardingAddress(root, rootCopy)</span><br><span class="line">      roots[i] = rootCopy</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> scanPtr &lt; allocationPtr:</span><br><span class="line">    obj = object at scanPtr</span><br><span class="line">    scanPtr += size(obj)</span><br><span class="line">    n = sizeInWords(obj)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0.</span>.n:</span><br><span class="line">      <span class="keyword">if</span> isPointer(obj[i]) and not inOldSpace(obj[i]):</span><br><span class="line">        fromNeighbor = obj[i]</span><br><span class="line">        <span class="keyword">if</span> hasForwardingAddress(fromNeighbor):</span><br><span class="line">          toNeighbor = getForwardingAddress(fromNeighbor)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          toNeighbor = copyObject(&amp;allocationPtr, fromNeighbor)</span><br><span class="line">          setForwardingAddress(fromNeighbor, toNeighbor)</span><br><span class="line">        obj[i] = toNeighbor</span><br><span class="line"></span><br><span class="line">def copyObject(*allocationPtr, object):</span><br><span class="line">  copy = *allocationPtr</span><br><span class="line">  *allocationPtr += size(object)</span><br><span class="line">  memcpy(copy, object, size(object))</span><br><span class="line">  <span class="keyword">return</span> copy</span><br></pre></td></tr></table></figure>

<h3 id="不能被忽视的写屏障-Write-barriers"><a href="#不能被忽视的写屏障-Write-barriers" class="headerlink" title="不能被忽视的写屏障 Write barriers"></a>不能被忽视的写屏障 Write barriers</h3><p>如果新生区有某个对象，只有一个指向它的指针，恰好该指针在老生区的对象中，在垃圾回收之前我们如何得知新生区的该对象是活跃的呢？<br>为解决此问题，V8 在写缓冲区有一个列表，其中记录了所有老生区对象指向新生区的情况。新生区对象诞生时不会有指向它的指针，当老生区的对象出现指向新生区对象的指针时，便记录跨区指向，记录行为总是发生在写操作中。</p>
<h3 id="标记-清除算法-与-标记-紧缩算法"><a href="#标记-清除算法-与-标记-紧缩算法" class="headerlink" title="标记-清除算法 与 标记-紧缩算法"></a>标记-清除算法 与 标记-紧缩算法</h3><p>因为新生区的内存一般都不大，所以使用 Scavenge 算法进行垃圾回收效果比较好。老生区一般占用内存较大，因此采用的是 标记-清除(Mark-Sweep)算法 与 标记-紧缩(Mark-Compact)算法。</p>
<p>两种算法都包括两个阶段：标记阶段，清除或紧缩阶段。</p>
<h2 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h2><p>在标记阶段，堆上所有的活跃对象都会被发现并且标记。</p>
<p>每一页都包含用来标记的位图<br>位图都要占据空间 (3.1% on 32-bit, 1.6% on 64-bit systems)<br>使用两位二进制标记对象的状态<br>状态为白(white), 它尚未被垃圾回收器发现<br>状态为灰(gray), 它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕<br>状态为黑(black), 它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕</p>
<p>标记算法的核心是 <strong>深度优先搜索</strong>，具体过程为：</p>
<ol>
<li>在标记的初期，位图是空的，所有对象也都是白的。</li>
<li>从根可达的对象会被染色为灰色，并被放入标记用的一个单独分配的双端队列。</li>
<li>标记阶段的每次循环，GC会将一个对象从双端队列中取出，染色为黑，然后将它的邻接对象染色为灰，并把邻接对象放入双端队列。</li>
<li>这一过程在双端队列为空且所有对象都变黑时结束。</li>
<li>特别大的对象，如长数组，可能会在处理时分片，以防溢出双端队列。如果双端队列溢出了，则对象仍然会被染为灰色，但不会再被放入队列（这样他们的邻接对象就没有机会再染色了）。</li>
<li>因此当双端队列为空时，GC仍然需要扫描一次，确保所有的灰对象都成为了黑对象。对于未被染黑的灰对象，GC会将其再次放入队列，再度处理。</li>
</ol>
<p>标记算法结束后，所有的活跃对象都被染成黑色，所有的死对象仍是白的。下一步就可以清除或者紧缩了。</p>
<h2 id="清除-或-紧缩-算法"><a href="#清除-或-紧缩-算法" class="headerlink" title="清除 或 紧缩 算法"></a>清除 或 紧缩 算法</h2><p>标记算法执行后，可以选择清除 或是紧缩，这两个算法都可以收回内存，而且两者都作用于页级(V8 中的内存页是 1MB 的连续内存块)</p>
<p>清除算法扫描连续存放的死对象，将其变为空闲空间，并将其添加到空闲内存链表中。清除算法只需要遍历页的位图，搜索连续的白对象。[每一页都包含数个空闲内存链表，其分别代表小内存区（&lt;256字）、中内存区（&lt;2048字）、大内存区（&lt;16384字）和超大内存区（其它更大的内存）]</p>
<p>紧缩算法会尝试将对象从碎片页(包含大量小空闲内存的页)中迁移整合在一起，来释放内存。这些对象会被迁移到另外的页上，因此也可能会新分配一些页。而迁出后的碎片页就返还给操作系统。</p>
<p>对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块其它页的区域，将该对象复制至新页，并在碎片页中的该对象上写上转发地址。<br>迁出过程中，对象中的旧地址会被记录下来，这样在迁出结束后V8会遍历它所记录的地址，将其更新为新的地址。由于标记过程中也记录了不同页之间的指针，此时也会更新这些指针的指向。</p>
<h2 id="增量标记-与-惰性清除"><a href="#增量标记-与-惰性清除" class="headerlink" title="增量标记 与 惰性清除"></a>增量标记 与 惰性清除</h2><p>对于一个堆很大，活跃对象有很多的脚本时，标记-清除 与 标记-紧缩 的效率可能会很慢，为减少垃圾回收引起的停顿，引入了 增量标记(Incremental marking) 和 惰性清理(lazy sweeping)。</p>
<p>增量标记允许堆的标记(前面的标记阶段)发生在几次5-10毫秒的小停顿中。增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。就像普通的标记一样，增量标记也是一个深度优先搜索，并同样采用白灰黑机制来分类对象。<br>增量标记与普通标记的区别是，添加了从黑对象到白对象的指针，为此需要再次启用写屏障中，在记录 老-&gt;新 的同时，记录 黑-&gt;白。在进行清除时，一旦在写屏障中发现这样的指针，黑对象会被重新染色为灰对象，重新放回到双端队列中。</p>
<p>惰性清理是指在标记完成后，并不急着释放空间，无需一次清理所有的页，垃圾回收器会视情况逐一清理，直到所有页都清理完成。</p>
<p>余下的涉及垃圾回收原理的部分留着后面继续整理。(平行标记 与 并发标记)</p>
<h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。</p>
<p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。</p>
<h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h2><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 <strong>微任务（microtask）</strong> 和 <strong>宏任务（macrotask）</strong>。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p>以上代码虽然 setTimeout 写在 Promise 之前，但是因为 <code>Promise</code> 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。</p>
<p><strong>微任务</strong>包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code> ，<code>MutationObserver</code></p>
<p><strong>宏任务</strong>包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></p>
<p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了<code>script</code>，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p>
<h2 id="所以正确的一次-Event-loop-顺序是这样的"><a href="#所以正确的一次-Event-loop-顺序是这样的" class="headerlink" title="所以正确的一次 Event loop 顺序是这样的"></a>所以正确的一次 Event loop 顺序是这样的</h2><ol>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下一轮 Event loop，执行宏任务中的异步代码</li>
</ol>
<p>通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/JS深入/" data-id="ck3pu18df000o0shaa7qu0udy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS深入/">JS深入</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端安全防范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/20/前端安全防范/" class="article-date">
  <time datetime="2019-09-20T07:56:10.000Z" itemprop="datePublished">2019-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/20/前端安全防范/">前端安全防范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h1><blockquote>
<p>什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？</p>
</blockquote>
<p>XSS 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。<br>XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。<br>持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导 致大量正常访问页面的用户都受到攻击。<br>举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容<code>&lt;script&gt;alert(2)&lt;/script&gt;</code>.<br>这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。<br>非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。<br>举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- http:<span class="comment">//www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt; </span></span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我 们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器.</p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>对于 XSS 攻击来说，通常有两种方式可以用来防御。</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进 行转义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;      </span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)  </span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)  </span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)  </span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>)  </span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)  </span><br><span class="line">    str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>)  </span><br><span class="line">    str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>)  </span><br><span class="line">    <span class="keyword">return</span> str </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过转义可以将攻击代码  &lt;script&gt;alert(1)&lt;/script&gt;  变成</span></span><br><span class="line"><span class="comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt; </span></span><br><span class="line"><span class="built_in">escape</span>(<span class="string">'&lt;script&gt;alert(1)&lt;/script&gt;'</span>)</span><br></pre></td></tr></table></figure>

<p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p>
<h3 id="CSP-白名单"><a href="#CSP-白名单" class="headerlink" title="CSP(白名单)"></a>CSP(白名单)</h3><p>CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何 拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。<br>通常可以通过两种方式来开启 CSP：</p>
<ol>
<li>设置 HTTP Header 中的  Content-Security-Policy </li>
<li>设置meta标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ol>
<p>这里以设置 HTTP Header 来举例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只允许加载本站资源</span></span><br><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src ‘self’</span><br><span class="line"><span class="comment">//只允许加载 HTTPS 协议图片</span></span><br><span class="line">Content-Security-Policy: img-src https:<span class="comment">//*</span></span><br><span class="line"><span class="comment">//允许加载任何来源框架</span></span><br><span class="line">Content-Security-Policy: child-src <span class="string">'none'</span></span><br></pre></td></tr></table></figure>

<h1 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h1><blockquote>
<p>什么是CSRF攻击？如何防范CSRF攻击？</p>
</blockquote>
<p>CSRF中文名为跨站请求伪造。<br>原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。<br>举个例子，假设网站中有一个通过GET请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"http://www.domain.com/xxx?comment='attack'"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>那么你是否会想到使用POST方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交POST请求</p>
<h2 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h2><p>防范CSRF攻击可以遵循以下几种规则：</p>
<ol>
<li>GET请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie </li>
<li>阻止第三方网站请求接口 </li>
<li>请求时附带验证信息，比如验证码或者 Token</li>
</ol>
<p><strong>SameSite</strong><br>可以对Cookie设置SameSite属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。<br><strong>验证Referer</strong><br>对于需要防范CSRF的请求，我们可以通过验证Referer来判断该请求是否为第三方网站发起的。<br><strong>Token</strong><br>服务器下发一个随机Token，每次发起请求时将Token携带上，服务器验证Token是否有效。</p>
<h1 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h1><blockquote>
<p>什么是点击劫持？如何防范点击劫持？</p>
</blockquote>
<p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<h2 id="如何防御-1"><a href="#如何防御-1" class="headerlink" title="如何防御"></a>如何防御</h2><p><strong>X-FRAME-OPTIONS</strong><br>X-FRAME-OPTIONS是一个HTTP响应头，在现代浏览器有一个很好的支持。这个HTTP响应头就是为了防御用iframe嵌套的点击劫持攻击。<br>该响应头有三个值可选，分别是<br>DENY，表示页面不允许通过iframe的方式展示SAMEORIGIN，表示页面可以在相同域名下通过iframe的方式展示ALLOW-FROM，表示页面可以在指定来源的iframe中展示<br><strong>JS防御</strong><br>对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过JS的方式来防御点击劫持了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style id=<span class="string">"click-jack"</span>&gt;</span><br><span class="line">        html &#123;      </span><br><span class="line">            display: none !important;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (self == top) &#123;</span><br><span class="line">        <span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">'click-jack'</span>) </span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(style)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        top.location = self.location</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码的作用就是当通过<code>iframe</code>的方式加载页面时，攻击者的网页直接不显示所有内容了。</p>
<h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><blockquote>
<p>什么是中间人攻击？如何防范中间人攻击？</p>
</blockquote>
<p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。<br>通常来说不建议使用公共的Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。<br>当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS就可以用来防御中间人攻击，但是并不是说使用了HTTPS就可以高枕无忧了，因为如果你没有完全关闭HTTP访问的话，攻击方可以通过某些方式将HTTPS降级为HTTP从而实现中间人攻击。</p>
<h1 id="网页验证码是干嘛的，是为了解决什么安全问题。"><a href="#网页验证码是干嘛的，是为了解决什么安全问题。" class="headerlink" title="网页验证码是干嘛的，是为了解决什么安全问题。"></a>网页验证码是干嘛的，是为了解决什么安全问题。</h1><p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/前端安全防范/" data-id="ck3pu18hj002t0shat0dorkx4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP安全/">HTTP安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Vue服务端渲染" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/15/Vue服务端渲染/" class="article-date">
  <time datetime="2019-09-15T08:22:12.000Z" itemprop="datePublished">2019-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/15/Vue服务端渲染/">Vue服务端渲染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>Vue.js是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出Vue组件，进行生成DOM和操作DOM。然而，也可以将同一个组件渲染为服务器端的HTML字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
</blockquote>
<p>服务器渲染的Vue.js应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点: </p>
<ol>
<li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li>
<li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</li>
</ol>
<p>缺点:</p>
<ol>
<li>开发条件所限。</li>
<li>涉及构建设置和部署的更多要求。</li>
<li>更多的服务器端负载。</li>
</ol>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>npm install vue vue-server-renderer --save</code></p>
<h2 id="渲染实例"><a href="#渲染实例" class="headerlink" title="渲染实例"></a>渲染实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 步：创建一个 Vue 实例</span></span><br><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;Hello World&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 步：创建一个 renderer</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createRenderer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 步：将 Vue 实例渲染为 HTML</span></span><br><span class="line">renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="built_in">console</span>.log(html)</span><br><span class="line">  <span class="comment">// =&gt; &lt;div data-server-rendered="true"&gt;Hello World&lt;/div&gt;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 2.5.0+，如果没有传入回调函数，则会返回 Promise：</span></span><br><span class="line">renderer.renderToString(app).then(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(html)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="与服务端集成"><a href="#与服务端集成" class="headerlink" title="与服务端集成"></a>与服务端集成</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装</span></span><br><span class="line">npm install express --save</span><br><span class="line"><span class="comment">//操作express</span></span><br><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'express'</span>)()</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createRenderer()</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      url: req.url</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).end(<span class="string">'Internal Server Error'</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.end(<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">      &lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;<span class="subst">$&#123;html&#125;</span>&lt;/body&gt;</span></span><br><span class="line"><span class="string">      &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用页面模板"><a href="#使用页面模板" class="headerlink" title="使用页面模板"></a>使用页面模板</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.template.html</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">  &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!--vue-ssr-outlet--&gt;</span><br><span class="line">    &lt;!--这里将是应用程序 HTML 标记注入的地方--&gt;</span><br><span class="line">  &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>读取和传输文件到 Vue renderer 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> renderer = createRenderer(&#123;</span><br><span class="line">  template: <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(<span class="string">'./index.template.html'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(html) <span class="comment">// html 将是注入应用程序内容的完整页面</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="vue-srr范例详解"><a href="#vue-srr范例详解" class="headerlink" title="vue-srr范例详解"></a>vue-srr范例详解</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/15/Vue服务端渲染/" data-id="ck3pu18f6001j0sha1n4nzbu8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-SSR/">Vue-SSR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js/">Vue.js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-VueX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/14/VueX/" class="article-date">
  <time datetime="2019-09-14T13:38:29.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/14/VueX/">Vuex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vuex-介绍"><a href="#Vuex-介绍" class="headerlink" title="Vuex 介绍"></a>Vuex 介绍</h1><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的<strong>状态(state)</strong>。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交<strong>(commit)mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。<br>我的理解: Vuex 相当于一个扩展板的<code>bus</code>中介.起步虽相似,但功能更丰富.</li>
</ol>
<h2 id="Vuex-之-store"><a href="#Vuex-之-store" class="headerlink" title="Vuex 之 store"></a>Vuex 之 store</h2><p>起步: 安装,引入,<code>use</code>,创建状态仓库.在Vue实例中注入(把store写进去).一条龙服务.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建仓库格式</span></span><br><span class="line"><span class="keyword">var</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        <span class="comment">//定义你的状态</span></span><br><span class="line">        XXX: xxx</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="comment">//在此处定义状态改变的方法</span></span><br><span class="line">        increase(state)&#123;</span><br><span class="line">            state.num ++</span><br><span class="line">        &#125;</span><br><span class="line">        decrease(state)&#123;</span><br><span class="line">            state.num --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="comment">//actions中传递的不再是state,而是context</span></span><br><span class="line">        increaseAction(context)&#123;</span><br><span class="line">            <span class="comment">//actions中只能对mutations中的方法进行操作</span></span><br><span class="line">            context.commit(<span class="string">'increase'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mutations 改变状态:<br>直接通过<code>this.$store.state.XXX</code>拿到状态<br>在 methods 中.定义一个函数通过<code>this.$store.commit(&#39;xxx&#39;)</code>方法触发状态变更</p>
</blockquote>
<blockquote>
<p>actions 改变状态:<br>通过<code>this.$store.dispatch(xxx)</code>调用</p>
</blockquote>
<p>二者区别:</p>
<ol>
<li>传入参数不同,mutations 传入<code>state</code>.actions 传入<code>context</code></li>
<li>调用方式不同,前者<code>this.$store.commit(&#39;xxx&#39;)</code>.后者<code>this.$store.dispatch(xxx)</code></li>
<li>函数要求不同.mutations 中只能有同步操作,actions 中可以有异步操作.</li>
</ol>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>有时需要对 mutations 处理后的 state 进行处理.<br>可以当做 vuex 的计算属性(computed).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    getNum(state)&#123;</span><br><span class="line">        <span class="comment">//因为要处理state,自然传入state</span></span><br><span class="line">        <span class="keyword">return</span> state.num &gt; <span class="number">0</span> ? state.num : <span class="number">0</span></span><br><span class="line">        <span class="comment">//这里是防止一直减出现负数进行的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取状态也就改为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在组件中</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    getCount()&#123;</span><br><span class="line">        <span class="comment">//return this.$store.state.num</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.getNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vuex-状态管理流程"><a href="#Vuex-状态管理流程" class="headerlink" title="Vuex 状态管理流程"></a>Vuex 状态管理流程</h1><p>view–&gt;actions–&gt;mutations–&gt;state–&gt;view</p>
<h1 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h1><p>VueX 中<br><code>state</code>相当于<code>data</code><br><code>getter</code>相当于<code>computed</code><br><code>mutation</code>相当于<code>methods</code><br><code>action</code>是异步的<code>mutation</code><br><code>module</code>模块将上述进行封装分块</p>
<h2 id="mapState-和-mapGetters"><a href="#mapState-和-mapGetters" class="headerlink" title="mapState 和 mapGetters"></a>mapState 和 mapGetters</h2><p><code>mapState</code>辅助函数仅仅是将 store 中的<code>getter</code>映射到局部计算属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...Vuex.mapState([<span class="string">'firstName'</span>, <span class="string">'lastName'</span>])</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">firstName()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.firstName</span><br><span class="line">&#125;,</span><br><span class="line">lastName()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">..Vuex.mapGetters([<span class="string">'fullName'</span>])</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">fullName()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.fullName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>store.commit(&#39;xxFirstName&#39;, &#39;jirengu&#39;)</code><br>提交 mutation 中 xxFirstName 的方法。<br>第一个参数是 state 中有的，后添加的 jirengu 是载荷<code>payload</code>。</p>
<h2 id="提交载荷（payload）"><a href="#提交载荷（payload）" class="headerlink" title="提交载荷（payload）"></a>提交载荷（payload）</h2><p>向<code>store.commit</code>传入额外参数，即<code>mutation</code>的载荷</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">increment (state, payload)&#123;</span><br><span class="line">state.count += payload.amount</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">'increment'</span>, &#123;</span><br><span class="line">amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>actions 中传入第一个参数是<code>context</code>，第二个是<code>payload</code><br>触发 action</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">"increment"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="moudle-模块化"><a href="#moudle-模块化" class="headerlink" title="moudle(模块化)"></a>moudle(模块化)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/14/VueX/" data-id="ck3pu18eg00150shacmocd4rw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js进阶/">Vue.js进阶</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-VueRouter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/14/VueRouter/" class="article-date">
  <time datetime="2019-09-14T13:38:12.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/14/VueRouter/">VueRouter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h1><p>监听url的变化，然后匹配路由规则，显示相应页面，无需刷新。<br>目前前端路由只有两种实现方式</p>
<ol>
<li>hash模式</li>
</ol>
<p>监听hash值变化(url后的,从#号开始)<br><code>window.addEventListener(&#39;hashchange&#39;,()=&gt;{})</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听hash变化</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.oldURL, event.newURL);</span><br><span class="line">    <span class="keyword">let</span> hash = loaction.hash  <span class="comment">//通过location对象来获取hash地址</span></span><br><span class="line">    <span class="built_in">console</span>.log(hash)    <span class="comment">// "#/notebooks/260827/list"  从#号开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为hash发生变化的url都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用.<br>特点: hash 虽然出现在URL中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</p>
<ol start="2">
<li>history模式</li>
</ol>
<p>通过此模式改变url同样不会引起页面刷新，只会更新浏览器的历史记录’<br>修改为history模式:在router中添加<code>mode: &#39;history&#39;</code>.</p>
<p><code>history.pushState</code><br>替换当前历史记录<br><code>history.replaceState</code><br>点击后退触发popState事件<br><code>window.addEventListener(&#39;popState&#39;,e=&gt;{})</code></p>
<h3 id="切换历史状态"><a href="#切换历史状态" class="headerlink" title="切换历史状态"></a>切换历史状态</h3><p>包括back,forward,go三个方法，对应浏览器的前进，后退，跳转操作.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-2</span>);<span class="comment">//后退两次</span></span><br><span class="line">history.go(<span class="number">2</span>);<span class="comment">//前进两次</span></span><br><span class="line">history.back(); <span class="comment">//后退</span></span><br><span class="line">hsitory.forward(); <span class="comment">//前进</span></span><br></pre></td></tr></table></figure>

<h3 id="修改历史状态"><a href="#修改历史状态" class="headerlink" title="修改历史状态"></a>修改历史状态</h3><p>包括了pushState,replaceState两个方法,这两个方法接收三个参数:<code>stateObj,title,url</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;<span class="attr">color</span>:<span class="string">'red'</span>&#125;, <span class="string">'red'</span>, <span class="string">'red'</span>&#125;)</span><br><span class="line">history.back();</span><br><span class="line">history.forward();</span><br></pre></td></tr></table></figure>

<p>通过pushstate把页面的状态保存在state对象中，当页面的url再变回这个url时，可以通过event.state取到这个state对象.</p>
<h3 id="history模式缺点"><a href="#history模式缺点" class="headerlink" title="history模式缺点"></a>history模式缺点</h3><p>通过history api，我们丢掉了丑陋的#，但是它也有个毛病：<br>不怕前进，不怕后退，就怕刷新，f5（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的,不玩虚的。</p>
<p>在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题.但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会请求失败.</p>
<p>所以，如果你想在github.io上搭一个单页博客，就应该选择hash模式</p>
<h1 id="vue-router路由"><a href="#vue-router路由" class="headerlink" title="vue-router路由"></a>vue-router路由</h1><ol>
<li>安装vue-router<br><code>npm install --save vue-router</code></li>
<li>引用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line">Vue.use(router)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置路由文件,并在Vue实例中注入</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld'</span></span><br><span class="line"></span><br><span class="line">Vue.use(router) <span class="comment">//引入并且使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rt = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">//下面这个routes是数组,用[]</span></span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: <span class="string">'/hello'</span>, <span class="comment">//指定要跳转的路径</span></span><br><span class="line">        component: HelloWorld <span class="comment">//指定要跳转的组件</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    router: rt, <span class="comment">//把路由实例rt写到Vue实例中就注入了</span></span><br><span class="line">    components: &#123; App &#125;, <span class="comment">//组件直接注入.分开写便于模块化</span></span><br><span class="line">    template: <span class="string">'&lt;App/&gt;'</span> <span class="comment">//同上</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定视图加载的位置</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"><span class="comment">//把这个写到想注入的位置就可以了</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">## 路由跳转</span></span><br><span class="line"><span class="string">在路由文件中,一般是`</span>router/index.js<span class="string">`.就是把路由单独写一个文件</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld'</span></span><br><span class="line"><span class="keyword">import</span> HelloEarth <span class="keyword">from</span> <span class="string">'./components/Helloearth'</span></span><br><span class="line"></span><br><span class="line">Vue.use(router) <span class="comment">//引入并且使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> router(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: <span class="string">'/helloworld'</span>, <span class="comment">//指定要跳转的路径</span></span><br><span class="line">        component: HelloWorld <span class="comment">//指定要跳转的组件</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/helloearth'</span>, <span class="comment">//指定要跳转的路径</span></span><br><span class="line">        component: HelloEarth <span class="comment">//指定要跳转的组件</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后在页面组件中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;router-link to=<span class="string">"/helloworld"</span>&gt;HelloWorld&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;router-link to=<span class="string">"/helloearth"</span>&gt;HelloEarth&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="vue-router路由参数传递-传参"><a href="#vue-router路由参数传递-传参" class="headerlink" title="vue-router路由参数传递(传参)"></a>vue-router路由参数传递(传参)</h2><ol>
<li>必须在路由内加入路由的<code>name</code></li>
<li>必须在<code>path</code>后加<code>/:</code>加传递的参数</li>
<li>传递参数(传值)和接收参数(具体看下面两种方法)</li>
</ol>
<p>传递参数方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//params: </span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">  name: <span class="string">'xxx'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//params读取参数: this.$route.params.id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//query</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">  path: <span class="string">'/xxx'</span>,</span><br><span class="line">  query: &#123;</span><br><span class="line">    id: id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//query读取参数: this.$route.query.id</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: params传参,push里只能是name:’xxx’,不能是path:’/xxx’,因为params只能用name来引入路由,如果这个写成path,接收参数页面会是undefined.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种方式:</span></span><br><span class="line">  &lt;router-link :to=<span class="string">"&#123;name: helloworld,params:&#123;worldmsg: '你好世界' &#125;&#125;"</span>&gt;</span><br><span class="line">      helloworld&lt;/router-link&gt;</span><br><span class="line">  <span class="comment">//接收参数:$route.params.xxx   </span></span><br><span class="line">  <span class="comment">//这种方式等同于./helloworld/你好世界</span></span><br><span class="line"></span><br><span class="line"><span class="function">export <span class="keyword">default</span> new <span class="title">router</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    routes: [&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        name: <span class="string">'helloworld'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        path: <span class="string">'/helloworld/:id'</span>, //动态绑定,各个不同id就都使用HelloWorld组件了</span></span></span><br><span class="line"><span class="function"><span class="params">        component: HelloWorld //指定要跳转的组件</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        name: <span class="string">'helloearth'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        path: <span class="string">'/helloearth/:earthmsg'</span>, //指定要跳转的路径</span></span></span><br><span class="line"><span class="function"><span class="params">        component: HelloEarth //指定要跳转的组件</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    ]</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &lt;router-link :to=<span class="string">"&#123;path: '/helloearth',query:&#123;msg: 只有一个地球&#125;&#125;"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/方式等同于./</span>helloworld?name=xxx&amp;count=xxx</span><br><span class="line">  <span class="comment">//接收参数this.$route.query.xxx</span></span><br><span class="line">  </span><br><span class="line">coust couter = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[&#123;</span><br><span class="line">    path: <span class="string">'/search'</span>, </span><br><span class="line">    component: SearchUser, </span><br><span class="line">    props: <span class="function">(<span class="params">route</span>) =&gt;</span>(&#123;</span><br><span class="line">      query: route.query.q </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1><p>导航守卫就是路由跳转过程中的一些钩子函数.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//钩子函数执行后输出的顺序</span></span><br><span class="line">全局前置守卫: beforeEach</span><br><span class="line">路由独享守卫: beforeEnter</span><br><span class="line">组件路由守卫: beforeRouteEnter,此时<span class="keyword">this</span>并不指向该组件实例</span><br><span class="line">全局解析守卫: beforeResolve</span><br><span class="line">全局后置守卫: aferEach</span><br><span class="line">组件生命周期: beforeCreate</span><br><span class="line">组件生命周期: created</span><br><span class="line">组件生命周期: borforeMount</span><br><span class="line">组件生命周期: mounted</span><br><span class="line">组件路由守卫: beforeRouteEnter的next回调</span><br></pre></td></tr></table></figure>

<p>导航守卫分为：<strong>全局的、单个路由独享的、组件内</strong>的三种.</p>
<h2 id="全局的"><a href="#全局的" class="headerlink" title="全局的"></a>全局的</h2><p>分别是<code>beforeEach</code>,<code>beforeResolve</code>,<code>afterEach</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>beforeEach</code>: 全局前置守卫.在路由跳转前触发,参数:to,from,next.这个钩子函数主要用于登录验证.<br><code>beforeResolve</code>: 全局解析守卫.和<code>beforeEach</code>类似.区别是在<code>beforeEach</code>和组件内<code>beforeRouteEnter</code>之后，<code>afterEach</code>之前调用.<br><code>afterEach</code>: 全局后置钩子.和<code>beforeEach</code>相反,在路由跳转完成后触发,参数: to,from.他发生在<code>beforeEach</code>和<code>beforeResolve</code>之后.</p>
<h3 id="三个参数-to-from-next"><a href="#三个参数-to-from-next" class="headerlink" title="三个参数(to,from,next)"></a>三个参数(to,from,next)</h3><ol>
<li><code>to</code>: <code>Route</code>: 即将要进入的目标路由对象</li>
<li><code>from</code>: <code>Route</code>: 当前导航正要离开的路由</li>
<li><code>next</code>: <code>Function</code>: 必须调用该方法来resolve这个钩子.否则不能进入路由.执行效果依赖next方法的调用函数.</li>
<li><code>next(false)</code>: 中断当前导航.如果浏览器的URL改变,那么URL会重置到from路由对应的地址.</li>
<li><code>next(&#39;/&#39;)</code>: 跳转到一个不同的地址.</li>
<li><code>next(error)</code>: 如果传入的next的参数是一个Error实例.则导航会被终止且该错误会被传递给<code>router.onerror()</code>注册过的回调.</li>
</ol>
<blockquote>
<p>确保要调用<code>next</code>方法,否则钩子就不会被<code>resolved</code>.</p>
</blockquote>
<h2 id="路由独享的守卫beforeEnter"><a href="#路由独享的守卫beforeEnter" class="headerlink" title="路由独享的守卫beforeEnter"></a>路由独享的守卫beforeEnter</h2><p>可以在路由配置上直接定义beforeEnter守卫:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      brforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h2><p><code>beforeRouteEnter</code> 进入路由前<br><code>beforeRouteUpdate</code> 路由复用同一个组件时<br><code>beforeRouteLeave</code> 离开当前路由时</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter(to, <span class="keyword">from</span>, next)&#123;</span><br><span class="line">    <span class="comment">//在渲染该组件的对应路由被confirm前调用</span></span><br><span class="line">    <span class="comment">//不能!!获取组件实例this</span></span><br><span class="line">    <span class="comment">//因为当守卫执行前,组件实例还未创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate(to, <span class="keyword">from</span>, next)&#123;</span><br><span class="line">    <span class="comment">//在当前路由改变,但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">//举例来说,对于一个带有动态参数的路径 /foo/:id,在/foo/1和/foo/2之间跳转的时候,</span></span><br><span class="line">    <span class="comment">//由于会渲染同样的Foo组件,因此组件实例会被复用.而这个钩子就会在这个情况下被调用.</span></span><br><span class="line">    <span class="comment">//可以访问组件实例this</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next)&#123;</span><br><span class="line">    <span class="comment">//导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">//可以访问组件实例this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beforeRouteEnter守卫不能访问this"><a href="#beforeRouteEnter守卫不能访问this" class="headerlink" title="beforeRouteEnter守卫不能访问this"></a>beforeRouteEnter守卫不能访问this</h3><p>因为钩子在组件实例还没被创建的时候调用,可以通过传一个回调给<code>next</code>来访问组件实例 。<br>不过,可以通过传一个回调给next来访问组件实例.在导航被确认的时候执行回调,并且把组件实例作为回调方法的参数.<br>但是回调的执行时机在mounted后面,所以在我看来这里对this的访问意义不太大，可以放在<code>created</code>或者<code>mounted</code>里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter(to, <span class="keyword">from</span>, next)&#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//通过`vm`访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beforeRouteLeave"><a href="#beforeRouteLeave" class="headerlink" title="beforeRouteLeave"></a>beforeRouteLeave</h3><p>导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将s<code>etInterval</code>销毁，防止离开之后，定时器还在调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span> , next) &#123;</span><br><span class="line">  <span class="keyword">if</span> (文章保存) &#123;</span><br><span class="line">    next(); <span class="comment">// 允许离开或者可以跳到别的路由 上面讲过了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="literal">false</span>); <span class="comment">// 取消离开</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="路由钩子函数的错误捕获"><a href="#路由钩子函数的错误捕获" class="headerlink" title="路由钩子函数的错误捕获"></a>路由钩子函数的错误捕获</h4><p>如果在导航守卫的钩子函数中有错误,可以这样捕获:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.onError(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(callback, <span class="string">'callback'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>假设是从a组件离开，第一次进入b组件</p>
<h1 id="完整的路由导航解析流程"><a href="#完整的路由导航解析流程" class="headerlink" title="完整的路由导航解析流程:"></a>完整的路由导航解析流程:</h1><ol>
<li>触发进入其他路由。</li>
<li>调用要离开路由的组件守卫<code>beforeRouteLeave</code></li>
<li>调用全局前置守卫: <code>beforeEach</code></li>
<li>在重用的组件里调用<code>beforeRouteUpdate</code></li>
<li>调用路由独享守卫<code>beforeEnter</code></li>
<li>解析异步路由组件</li>
<li>在将要进入的路由组件中调用<code>beforeRouteEnter</code></li>
<li>调用全局解析守卫<code>beforeResolve</code></li>
<li>导航被确认</li>
<li>调用全局后置钩子<code>afterEach</code></li>
<li>触发DOM更新(mounted)</li>
<li>执行<code>beforeRouteEnter</code>守卫中传给next的回调函数</li>
</ol>
<h1 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h1><h2 id="监听物理返回键或页面返回"><a href="#监听物理返回键或页面返回" class="headerlink" title="监听物理返回键或页面返回"></a>监听物理返回键或页面返回</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unit.js</span></span><br><span class="line"><span class="comment">//存储当前历史记录点,实现控制手机物理返回键的按钮事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> pushHistory = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = &#123;</span><br><span class="line">    title: <span class="string">''</span>,</span><br><span class="line">    url: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.history.pushState(state, state.title, state.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; pushHistory &#125; <span class="keyword">from</span> <span class="string">'@/misc/utils'</span> <span class="comment">//引入工具</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    pushHistory()</span><br><span class="line">    <span class="comment">//监听历史记录点,添加返回事件监听</span></span><br><span class="line">    <span class="built_in">window</span>.onpopstate = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$router.push(...) </span><br><span class="line">      <span class="comment">//输入要返回的上一级路由地址</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed()&#123;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'popstate'</span>, <span class="keyword">this</span>.fun, <span class="literal">false</span>);<span class="comment">//false阻止默认事件</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//页面销毁时，取消监听。否则其他vue路由页面也会被监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/14/VueRouter/" data-id="ck3pu18ea00120sha7bl4ss5n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js进阶/">Vue.js进阶</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Vuejs进阶" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/13/Vuejs进阶/" class="article-date">
  <time datetime="2019-09-13T07:47:32.000Z" itemprop="datePublished">2019-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/13/Vuejs进阶/">Vue.js进阶</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于h"><a href="#关于h" class="headerlink" title="关于h"></a>关于<code>h</code></h1><p>将 <code>h</code> 作为 <code>createElement</code> 的别名是 Vue 生态系统中的一个通用惯例.</p>
<h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><p><strong>官网解释</strong><br>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<p><strong>官方解释总结</strong>:</p>
<ol>
<li>任何一个Vue组件都有一个与之对应的<code>Watcher</code>实例。</li>
<li>Vue的<code>data</code>上的属性会被添加<code>getter</code>和<code>setter</code>属性。</li>
<li>当Vue组件的<code>render</code>函数被执行的时候,<code>data</code>上会被触碰(<code>touch</code>),即被读,<code>getter</code>方法会被调用,此时Vue会去记录此Vue组件所依赖的所有<code>data</code>。(这一过程被称为<strong>依赖收集</strong>)</li>
<li><code>data</code>被改动时（主要是用户操作）,即被写,<code>setter</code>方法会被调用,此时Vue会去通知所有依赖于此<code>data</code>的组件去调用他们的<code>render</code>函数进行更新。</li>
</ol>
<p><strong>其他说法</strong>:<br>mvvm用来初始化数据<br><code>observer</code>用来对初始数据通过<code>Object.defineProperty</code>添加<code>setter</code>和<code>getter</code>，当取数据（即调用get）的时候添加订阅对象（<code>watcher</code>）到数组里， 当给数据赋值（即调用set）的时候就能知道数据的变化，此时调用发布订阅中心的<code>notify</code>，从而遍历当前这个数据的订阅数组，执行里面所有的<code>watcher</code>，通知变化<code>update</code>。<br>compiler是用来把data编译到dom中。分三步：1.先把真实的dom移入到内存中<code>fragment</code>，2.编译：提取想要的元素节点<code>v-model</code>和文本节点；3.把编译好的fragment塞回到页面去。第二步骤中会对编译到dom中的<code>data</code>添加<code>watcher</code>,当<code>data</code>变化时，这里的<code>watcher</code>回调也能收到通知得到执行。<br><code>watcher</code>是<code>oberver</code>和<code>compiler</code>之间通信的桥梁。</p>
<h2 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h2><ol>
<li>无法监听数组变化。</li>
<li>只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</li>
</ol>
<h1 id="使用Proxy实现Vue数据劫持"><a href="#使用Proxy实现Vue数据劫持" class="headerlink" title="使用Proxy实现Vue数据劫持"></a>使用Proxy实现Vue数据劫持</h1><p>proxy定义: Proxy对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）.</p>
<blockquote>
<p>Proxy第一个参数是目标对象，第二个参数是一个对象，其属性是当执行一个操作时定义代理的行为的函数。这时可以在第二个参数中加入一个set方法，这时可以监听到是哪个key做了改变。并且通过Reflect的set方法去模拟真实的set方法。</p>
</blockquote>
<h2 id="为什么说Proxy的性能比Object-defineProperty更好呢？"><a href="#为什么说Proxy的性能比Object-defineProperty更好呢？" class="headerlink" title="为什么说Proxy的性能比Object.defineProperty更好呢？"></a>为什么说Proxy的性能比Object.defineProperty更好呢？</h2><p><code>Object.defineProperty</code>只能监听属性，而Proxy能监听整个对象，省去对非对象或数组类型的劫持，也能做到监听。</p>
<p>vue是对对象每一个属性进行<code>Object.defineProperty</code>。<br>第二点，<code>Object.defineProperty</code>不能监测到数组变化</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改；<br>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利<br>当然,Proxy的劣势就是兼容性问题,而且无法用<code>polyfill</code>实现</p>
<h2 id="Proxy基本语法"><a href="#Proxy基本语法" class="headerlink" title="Proxy基本语法"></a>Proxy基本语法</h2><p><code>const obj = new Proxy(target, handler);</code><br>参数说明如下：<br><code>target</code>: 被代理对象。<br><code>handler</code>: 是一个对象，声明了代理target的一些操作。<br><code>obj</code>: 是被代理完成之后返回的对象。</p>
<p>但是当外界每次对obj进行操作时，就会执行handler对象上的一些方法。handler中常用的对象方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">get</span>(target, propKey, receiver)</span><br><span class="line">2. <span class="keyword">set</span>(target, propKey, value, receiver)</span><br><span class="line">3. has(target, propKey)</span><br><span class="line">4. construct(target, args):</span><br><span class="line">5. apply(target, object, args)</span><br></pre></td></tr></table></figure>

<h1 id="常用-考-组件之keep-alive"><a href="#常用-考-组件之keep-alive" class="headerlink" title="常用(考)组件之keep-alive"></a>常用(考)组件之<code>keep-alive</code></h1><p>作用: 缓存组件内部状态，避免重新渲染<br>注意: 和<code>&lt;transition&gt;</code>相似,<code>&lt;keep-alive&gt;</code>是一个抽象组件:自身不会渲染一个DOM元素,也不会出现在父组件链中.</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h2><h3 id="缓存动态组件"><a href="#缓存动态组件" class="headerlink" title="缓存动态组件:"></a>缓存动态组件:</h3><p><code>&lt;keep-alive&gt;</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，此种方式并无太大的实用意义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 基本 --&gt;</span><br><span class="line"> &lt;keep-alive&gt;</span><br><span class="line">   &lt;component :is=<span class="string">"view"</span>&gt;&lt;/component&gt;</span><br><span class="line"> &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> &lt;!-- 多个条件判断的子组件 --&gt;</span></span><br><span class="line"><span class="regexp"> &lt;keep-alive&gt;</span></span><br><span class="line"><span class="regexp">   &lt;comp-a v-if="a &gt; 1"&gt;&lt;/</span>comp-a&gt;</span><br><span class="line">   &lt;comp-b v-<span class="keyword">else</span>&gt;&lt;/comp-b&gt;</span><br><span class="line"> &lt;<span class="regexp">/keep-alive&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>keep-alive</code>可以将所有路径匹配到的路由组件都缓存起来，包括路由组件里面的组件，<code>keep-alive</code>大多数使用场景就是这种。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="常用-考-API之nextTick"><a href="#常用-考-API之nextTick" class="headerlink" title="常用(考)API之nextTick"></a>常用(考)API之<code>nextTick</code></h1><p>作用: <code>$nextTick</code>是将回调推迟到下次DOM更新循环之后再执行，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的DOM，<br>Vue实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">'Hello'</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了在数据变化之后等待Vue完成更新DOM，可以在数据变化之后立即使用<code>Vue.nextTick(callback)</code>。这样回调函数将在DOM更新完成后被调用。在组件内使用<code>vm.$nextTick()</code>实例方法特别方便，因为它不需要全局Vue，并且回调函数中的this将自动绑定到当前的Vue实例上.因为 <code>$nextTick()</code>返回一个Promise对象，所以可以使用ES6语法.</p>
</blockquote>
<h1 id="常用-考-API之set"><a href="#常用-考-API之set" class="headerlink" title="常用(考)API之set"></a>常用(考)API之set</h1><p>返回: 设置的值.<br>用法: 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 .</p>
<blockquote>
<p>注意对象不能是Vue实例，或者Vue实例的根数据对象。</p>
</blockquote>
<h1 id="常用-考-API之watch"><a href="#常用-考-API之watch" class="headerlink" title="常用(考)API之watch"></a>常用(考)API之watch</h1><p>一个对象，<strong>键</strong>是需要<strong>观察的表达式</strong>，<strong>值</strong>是<strong>对应回调函数</strong>。值也可以是方法名，或者包含选项的对象。<br>Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> v-model:value=<span class="string">"childrens.name"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> v-model:value=<span class="string">"lastName"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;	</span></span><br><span class="line"><span class="string">    var vm = new Vue( &#123;</span></span><br><span class="line"><span class="string">        el: '#app',</span></span><br><span class="line"><span class="string">        data: &#123;</span></span><br><span class="line"><span class="string">            children: &#123;</span></span><br><span class="line"><span class="string">                name: '小强',</span></span><br><span class="line"><span class="string">                age: 20,</span></span><br><span class="line"><span class="string">                sex: '男'</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            tdArray:["</span><span class="number">1</span><span class="string">","</span><span class="number">2</span><span class="string">"],</span></span><br><span class="line"><span class="string">            lastName:"</span>张三<span class="string">"</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        watch:&#123;</span></span><br><span class="line"><span class="string">            children:&#123;</span></span><br><span class="line"><span class="string">                //如果childrens发生变化,函数就会执行</span></span><br><span class="line"><span class="string">                handler:function(val,oldval)&#123;</span></span><br><span class="line"><span class="string">                    console.log(val.name)</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                deep:true//对象内部的属性监听，也叫深度监听</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            'children.name':function(val,oldval)&#123;</span></span><br><span class="line"><span class="string">                console.log(val+"</span>aaa<span class="string">")</span></span><br><span class="line"><span class="string">            &#125;,//键路径必须加上引号</span></span><br><span class="line"><span class="string">            lastName:&#123;function(val,oldval)&#123;</span></span><br><span class="line"><span class="string">                console.log(this.lastName)</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                immediate:true //立即以'childern.name'触发回调</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;,//以V-model绑定数据时使用的数据变化监测</span></span><br><span class="line"><span class="string">    &#125; );</span></span><br><span class="line"><span class="string">    vm.$watch("</span>lastName<span class="string">",function(val,oldval)&#123;</span></span><br><span class="line"><span class="string">        console.log(val)</span></span><br><span class="line"><span class="string">    &#125;)//主动调用$watch方法来进行数据监测</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>取消观察</strong><br>vm.$watch 返回一个取消观察函数，用来停止触发回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unwatch = vm.$watch(<span class="string">'a'</span>, cb)</span><br><span class="line"><span class="comment">// 之后取消观察</span></span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，不应该使用箭头函数来定义<code>watcher</code>函数 (例如<code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以<code>this</code>将不会按照期望指向Vue实例，<code>this.updateAutocomplete</code>将是<code>undefined</code>。</p>
</blockquote>
<h1 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h1><h2 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend(options)"></a>Vue.extend(options)</h2><p>用法: 使用基础Vue构造器创建一个子类.参数是一个包含组件选项的对象.<br>data在<code>Vue.extend</code>中是函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建构造器</span></span><br><span class="line"><span class="keyword">var</span> Profile = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      firstName: <span class="string">'Walter'</span>,</span><br><span class="line">      lastName: <span class="string">'White'</span>,</span><br><span class="line">      alias: <span class="string">'Heisenberg'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span></span><br><span class="line"><span class="keyword">new</span> Profile().$mount(<span class="string">'#mount-point'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Vue-set-target-propertyName-index-value"><a href="#Vue-set-target-propertyName-index-value" class="headerlink" title="Vue.set(target,propertyName/index,value)"></a>Vue.set(target,propertyName/index,value)</h2><p>返回值: 设置的值<br>用法: 向响应式添加新属性,并确保这个新属性同样是响应式的.且触发识图更新.它必须用于响应式对象上添加新属性,因为Vue无法探测新增的属性.<br>如果我们在创建实例以后，再在实例上绑定新属性，vue是无法进行双向绑定的。</p>
<blockquote>
<p>注意: 对象不能是Vue实例,或者Vue实例的根数据对象.</p>
</blockquote>
<h2 id="Vue-mixin"><a href="#Vue-mixin" class="headerlink" title="Vue.mixin"></a>Vue.mixin</h2><p>用法: 全局注册一个混入,影响注册之后所有创建的每个Vue实例.插件作者可以使用混入,向组件注入自定义行为.不推荐在应用代码中使用.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">        <span class="comment">//..逻辑</span></span><br><span class="line">        <span class="comment">//这种方法会影响到每个组件的beforeCreate钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然文档不建议我们在应用中直接使用mixin ，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的ajax或者一些工具函数等等。</p>
<p> <code>mixins</code>应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过<code>mixins</code>混入代码，比如上拉下拉加载数据这种逻辑等等。<br>另外需要注意的是<code>mixins</code>混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并.</p>
<h1 id="Vue页面优化-spa首屏单页面"><a href="#Vue页面优化-spa首屏单页面" class="headerlink" title="Vue页面优化(spa首屏单页面)"></a>Vue页面优化(spa首屏单页面)</h1><ol>
<li>压缩代码</li>
<li>框架和插件按需加载</li>
<li>框架和插件从CDN中引入</li>
<li>路由懒加载</li>
<li>SSR服务端渲染</li>
</ol>
<h2 id="函数化组件"><a href="#函数化组件" class="headerlink" title="函数化组件"></a>函数化组件</h2><p>先设置<code>functional: true</code>,表示该组件无状态无实例,不能使用<code>this</code><br>使用上下文<code>context</code>进行替换<br>替换规律:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.text-----context.props.text</span><br><span class="line"><span class="keyword">this</span>.$slots.default------context.children</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;my-component value=<span class="string">"haha"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/my-component&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    functional: <span class="literal">true</span>, <span class="comment">//开启函数化,无实例,无状态.this失效</span></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement,context</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//添加context参数</span></span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'button'</span>,&#123;</span><br><span class="line">            on: &#123;</span><br><span class="line">                click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(context)</span><br><span class="line">                    <span class="built_in">console</span>.log(context.parent) <span class="comment">//父组件</span></span><br><span class="line">                    <span class="built_in">console</span>.log(context.parent.msg) </span><br><span class="line">                    <span class="built_in">console</span>.log(context.props.value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">'点击我'</span>) <span class="comment">//第三个参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    props:[<span class="string">'value'</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      msg: <span class="string">"我是父组件内容"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h1><p>虚拟DOM到底是什么，说简单点，就是一个普通的 JavaScript 对象，包含了 <code>tag</code>、<code>props</code>、<code>children</code> 三个属性。</p>
<h2 id="虚拟dom优点"><a href="#虚拟dom优点" class="headerlink" title="虚拟dom优点"></a>虚拟dom优点</h2><p>用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text"</span>&gt;hello world!!!&lt;/p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的 HTML 转换为虚拟 DOM 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: <span class="string">'app'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  chidren: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">'p'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        className: <span class="string">'text'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      chidren: [</span><br><span class="line">        <span class="string">'hello world!!!'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该对象就是我们常说的虚拟 DOM 了，因为 DOM 是树形结构，所以使用 JavaScript 对象就能很简单的表示。而原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图. </p>
<h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1><p>diff 算法用来比较两棵 Virtual DOM 树的差异，如果需要两棵树的完全比较，那么 diff 算法的时间复杂度为O(n^3)。但是在前端当中，你很少会跨越层级地移动 DOM 元素，所以 Virtual DOM 只会对同一个层级的元素进行对比，如下图所示， div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 O(n)。</p>
<h2 id="Vue中的虚拟dom"><a href="#Vue中的虚拟dom" class="headerlink" title="Vue中的虚拟dom"></a>Vue中的虚拟dom</h2><p>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> createElement(<span class="string">'h1'</span>, <span class="keyword">this</span>.blogTitle)</span><br></pre></td></tr></table></figure>

<p>createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>
<h1 id="render函数-渲染函数"><a href="#render函数-渲染函数" class="headerlink" title="render函数(渲染函数)"></a>render函数(渲染函数)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">"hdom"</span>&gt;</span><br><span class="line"><span class="comment">//template下只允许有一个子节点,所以用div包裹三个标题</span></span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;h1 v-<span class="keyword">if</span>=<span class="string">"level==1"</span>&gt;</span><br><span class="line">			&lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">		&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">		&lt;h2 v-if="level==2"&gt;</span></span><br><span class="line"><span class="regexp">			&lt;slot&gt;&lt;/</span>slot&gt;</span><br><span class="line">		&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">		&lt;h3 v-if="level==3"&gt;</span></span><br><span class="line"><span class="regexp">			&lt;slot&gt;&lt;/</span>slot&gt;</span><br><span class="line">		&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt; </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> Vue.component('child', &#123;</span></span><br><span class="line"><span class="regexp">     /</span><span class="regexp">/使用template命名的方法将大段代码写在html里</span></span><br><span class="line"><span class="regexp">     props: ['level'],</span></span><br><span class="line"><span class="regexp">     template: '#hdom'</span></span><br><span class="line"><span class="regexp"> &#125;) </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> Vue.component('child', &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/使用render函数替代template,节省大量代码</span></span><br><span class="line"><span class="regexp">     render: function (createElement) &#123;</span></span><br><span class="line"><span class="regexp">         return createElement('h' + this.level, this.$slots.default);</span></span><br><span class="line"><span class="regexp">     &#125;,</span></span><br><span class="line"><span class="regexp">     props: ['level']</span></span><br><span class="line"><span class="regexp"> &#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="render函数的第一个参数"><a href="#render函数的第一个参数" class="headerlink" title="render函数的第一个参数"></a>render函数的第一个参数</h2><p>在render函数的方法中,参数必须是<code>createElement</code>,它的类型是<code>function</code><br><code>createElement</code>的第一个参数<strong>必选</strong>.类型可以是<code>String|Object|Function</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createELement(<span class="string">'h1'</span>)</span><br><span class="line">        <span class="comment">//参数是字符串.返回&lt;h1&gt;&lt;/h1&gt;</span></span><br><span class="line">        <span class="keyword">return</span> createElement(&#123;</span><br><span class="line">            template: <span class="string">`&lt;div&gt;鹅鹅鹅&lt;/div&gt;`</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//参数是对象.返回&lt;div&gt;鹅鹅鹅&lt;/div&gt;</span></span><br><span class="line">        <span class="keyword">var</span> domFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                template: <span class="string">`&lt;div&gt;鹅鹅鹅&lt;/div&gt;`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createELement(domFun())</span><br><span class="line">        <span class="comment">//参数是函数.返回&lt;div&gt;鹅鹅鹅&lt;/div&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="render函数的第二个参数"><a href="#render函数的第二个参数" class="headerlink" title="render函数的第二个参数"></a>render函数的第二个参数</h2><p><code>createElement</code>的第二个参数<strong>可选</strong>.参数是数据对象,只能是<code>Object</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CreateElement(&#123;</span><br><span class="line">            template: <span class="string">`&lt;div&gt;鹅鹅鹅&lt;/div&gt;`</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="comment">//添加class选项,其中为true的会添加到模板&lt;div&gt;中</span></span><br><span class="line">            <span class="string">'class'</span>:&#123;</span><br><span class="line">                foo: <span class="literal">true</span></span><br><span class="line">                baz: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//添加style属性</span></span><br><span class="line">            style: &#123;</span><br><span class="line">                color: <span class="string">'red'</span>,</span><br><span class="line">                fontSize: <span class="string">'18px'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//正常的html属性</span></span><br><span class="line">            attrs: &#123;</span><br><span class="line">                id: <span class="string">'foo'</span>,</span><br><span class="line">                src: <span class="string">'xxxx'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//原生DOM属性</span></span><br><span class="line">            domProps: &#123;</span><br><span class="line">                innerHTML: <span class="string">'&lt;span style="color:blue"&gt;我是蓝色&lt;/span&gt;'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="render函数的第三个参数"><a href="#render函数的第三个参数" class="headerlink" title="render函数的第三个参数"></a>render函数的第三个参数</h2><p><code>createElement</code>的第三个参数<strong>可选</strong>.参数可以是<code>String|Array</code>,代表子节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">            createElement(<span class="string">'h1'</span>, <span class="string">'我是h1标题'</span>), createElement(<span class="string">'h6'</span>, <span class="string">'我是h6标题'</span>)</span><br><span class="line">            ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="在render函数中使用this-slots"><a href="#在render函数中使用this-slots" class="headerlink" title="在render函数中使用this.$slots"></a>在render函数中使用<code>this.$slots</code></h2><p>第三个参数存的是VNode,也就是虚拟节点.组件树中的所有 VNode 必须是唯一的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> header = <span class="keyword">this</span>.$slots.header</span><br><span class="line">        <span class="comment">//返回的就是含有VNode的数组</span></span><br><span class="line">        <span class="keyword">var</span> main = <span class="keyword">this</span>.$slots.default</span><br><span class="line">        <span class="keyword">var</span> footer = <span class="keyword">this</span>.$slots.footer</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>,[</span><br><span class="line">            createElement(<span class="string">'header'</span>,header),</span><br><span class="line">            createElement(<span class="string">'main'</span>,main),</span><br><span class="line">            createElement(<span class="string">'footer'</span>,footer)</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="在render函数中使用props传数据"><a href="#在render函数中使用props传数据" class="headerlink" title="在render函数中使用props传数据"></a>在render函数中使用props传数据</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;button @click="switchShow"&gt;点击切换&lt;/button&gt;</span><br><span class="line">    &lt;my-component :show="show"&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    props: [<span class="string">'show'</span>],</span><br><span class="line">    render: function(createElement)&#123;</span><br><span class="line">        <span class="keyword">var</span> imgsrc</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.show)&#123;</span><br><span class="line">            imgsrc = <span class="string">'img/001.jpg'</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            imgsrc = <span class="string">'img/002.jpg'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'img'</span>,&#123;</span><br><span class="line">            attrs: &#123;</span><br><span class="line">                scr: imgsrc</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        show: <span class="keyword">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        switchShow: function()&#123;</span><br><span class="line">            <span class="keyword">this</span>.show = !<span class="keyword">this</span>.show</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="在render函数中使用v-model"><a href="#在render函数中使用v-model" class="headerlink" title="在render函数中使用v-model"></a>在render函数中使用<code>v-model</code></h2><p><code>v-model</code>作用: 接收<code>input</code>的内容并绑定到后面的值上.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;my-component v-bind:name=<span class="string">"name"</span> v-model=<span class="string">"name"</span>&gt;&lt;/my-component&gt;</span><br><span class="line">&#123;&#123; name &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('my-component',&#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement)&#123;</span></span><br><span class="line"><span class="regexp">        props:['name'],</span></span><br><span class="line"><span class="regexp">        var self = this /</span><span class="regexp">/指的是当前的Vue实例</span></span><br><span class="line"><span class="regexp">        return createElement('input',&#123;</span></span><br><span class="line"><span class="regexp">            domProps: &#123;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/原生DOM </span></span><br><span class="line"><span class="regexp">                value: self.name</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            on: &#123;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/这里添加事件</span></span><br><span class="line"><span class="regexp">                input: function(event)&#123;</span></span><br><span class="line"><span class="regexp">                    /</span><span class="regexp">/此处的this是window,所以需要声明self指代vue实例</span></span><br><span class="line"><span class="regexp">                    self.$emit('input',event.target.value)</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: "#app",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        name: "Tom"</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="render函数中使用作用域插槽"><a href="#render函数中使用作用域插槽" class="headerlink" title="render函数中使用作用域插槽"></a>render函数中使用作用域插槽</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;my-component&gt;</span><br><span class="line">    &lt;template scoped=<span class="string">"prop"</span>&gt;</span><br><span class="line">        &#123;&#123; prop.text &#125;&#125;</span><br><span class="line">        &#123;&#123; prop.msg &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;/my</span>-component&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('my-component',&#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement)&#123;</span></span><br><span class="line"><span class="regexp">        return createElement('div',this.$scopedSlots.default(&#123;</span></span><br><span class="line"><span class="regexp">            text: '我是子组件传递的数据',</span></span><br><span class="line"><span class="regexp">            msg: 'scopetext'</span></span><br><span class="line"><span class="regexp">        &#125;))</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: "#app",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">      </span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/13/Vuejs进阶/" data-id="ck3pu18et001c0shaxrw85z8v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js进阶/">Vue.js进阶</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Vue组件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/09/Vue组件/" class="article-date">
  <time datetime="2019-09-09T03:23:52.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/09/Vue组件/">Vue组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>提高代码复用性</p>
<h1 id="组件使用方法"><a href="#组件使用方法" class="headerlink" title="组件使用方法"></a>组件使用方法</h1><h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-counter'</span>,&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优点：所有的vue实例都可以用<br>缺点：权限太大，容错率降低 </p>
<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">'my-component'</span>: &#123;</span><br><span class="line">            template: <span class="string">'&lt;div&gt;我是组件的内容&lt;/div&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意局部注册的组件在其子组件相互之间是不可用的。<br>如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者采用import方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"components-demo"</span>&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。</p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>vue组件的模板在某些情况下会受到html标签的限制，比如 <code>&lt;table&gt;</code> 中只能还 有 <code>&lt;tr&gt;</code> , <code>&lt;td&gt;</code>这些元素，所以直接在table中使用组件是无效的，此时可以使用<code>is</code>属性来挂载组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;         </span><br><span class="line">   &lt;tbody is=<span class="string">"my-component"</span>&gt;&lt;/tbody&gt;     </span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="组件使用技巧"><a href="#组件使用技巧" class="headerlink" title="组件使用技巧"></a>组件使用技巧</h2><ol>
<li>必须使用小写字母加­进行命名<code>child,my­component</code>命名组件 </li>
<li>template中的内容必须被一个DOM元素包括,也可以嵌套 </li>
<li>在组件的定义中，除了template之外还可以使用其他选项,比如<code>data,computed,methods</code></li>
<li>一个组件的 <code>data</code> 选项<strong>必须是一个函数</strong>,否则就会出现点一个其他按钮也跟着变化的情况</li>
</ol>
<h1 id="组件中data什么时候可以用对象"><a href="#组件中data什么时候可以用对象" class="headerlink" title="组件中data什么时候可以用对象"></a>组件中data什么时候可以用对象</h1><p>因为组件内data会复用。一个组件修改，就都会改<br>解决办法:<br><code>new Vue()</code>，生成一个根实例。该组件不会复用，也就不会共享。</p>
<h1 id="通过prop父传子通信"><a href="#通过prop父传子通信" class="headerlink" title="通过prop父传子通信"></a>通过prop父传子通信</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"blog-post-demo"</span>&gt;</span><br><span class="line">    &lt;blog-post</span><br><span class="line">        v-<span class="keyword">for</span>=<span class="string">"post in posts"</span></span><br><span class="line">        v-bind:key=<span class="string">"post.id"</span></span><br><span class="line">        v-bind:title=<span class="string">"post.title"</span></span><br><span class="line">    &gt;</span><br><span class="line">    &lt;<span class="regexp">/blog-post&gt; </span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#blog-post-demo"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            posts: [</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: aaa &#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: bbb &#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: ccc &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue.component(<span class="string">'blog-post'</span>,&#123;</span><br><span class="line">        props: [<span class="string">'title'</span>],</span><br><span class="line">        template: <span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个组件默认可以拥有任意数量的<code>prop</code>，任何值都可以传递给任何<code>prop</code>。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问<code>data</code>中的值一样。<br>如上所示，你会发现我们可以使用<code>v-bind</code>来动态传递<code>prop</code>。这在你一开始不清楚要渲染的具体内容，比如从一个 API 获取博文列表的时候，是非常有用的。<br><strong>总结</strong></p>
<ol>
<li>在组件中使用<code>props</code>来从父亲组件接收参数，注意，在<code>props</code>中定义的属性，都可以在组件中直接使用</li>
<li>props来自父级，而组件中data return的数据就是组件自己的数据，两种情况作用域就是 组件本身，可以在template，computed，methods中直接使用 </li>
<li>props的值有两种，一种是字符串数组，一种是对象，本节先只讲数组 </li>
<li>可以使用v-­bind动态绑定父组件来的内容</li>
</ol>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><ul>
<li>解释: 通过<code>props</code>传递数据是单向的了,也就是父组件数据变化时会传递给子组件,但是反过来不行。 </li>
<li>目的: 是尽可能将父子组件解耦，避免子组件无意中修改了父组件的状态。 </li>
<li>应用场景: 业务中会经常遇到两种需要改变<code>prop</code>的情况</li>
</ul>
<p>一种是父组件传递初始值进来，子组件将它作为初始值保存起来，在自己的作用域下可以随意使用和修改。这种情况可以在组件data内再声明一个数据，引用父组件的<code>prop</code><br>步骤一：注册组件<br>步骤二：将父组件的数据传递进来，并在子组件中用props接收<br>步骤三：将传递进来的数据通过初始值保存起来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;my-comp init-count=<span class="string">"666"</span>&gt;&lt;/my-comp&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">        el: '#app',</span></span><br><span class="line"><span class="regexp">        components: &#123;</span></span><br><span class="line"><span class="regexp">            'my-comp': &#123;</span></span><br><span class="line"><span class="regexp">                props: ['init-count'],</span></span><br><span class="line"><span class="regexp">                template: '&lt;div&gt;&#123;&#123;init-count&#125;&#125;&lt;/</span>div&gt;<span class="string">',</span></span><br><span class="line"><span class="string">                data: function() &#123;</span></span><br><span class="line"><span class="string">                    return &#123;</span></span><br><span class="line"><span class="string">                        count: this.initCount</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;) </span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>另一种情况就是<code>prop</code>作为需要被转变的原始值传入。这种情况用计算属性就可以了<br>步骤一：注册组件<br>步骤二：将父组件的数据传递进来，并在子组件中用props接收<br>步骤三：将传递进来的数据通过计算属性进行重新计算</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"width"</span>&gt;</span><br><span class="line">    &lt;my-comp :width="width"&gt;&lt;/my-comp&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        width: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">'my-comp'</span>: &#123;</span><br><span class="line">            props: [<span class="string">'init-count'</span>, <span class="string">'width'</span>],</span><br><span class="line">            template: <span class="string">'&lt;div :style="style"&gt;&#123;&#123; init-count &#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                style: function()&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        width: <span class="keyword">this</span>.width + <span class="string">'px'</span>,</span><br><span class="line">                        background: <span class="string">'red'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="驼峰命名与短横线命名"><a href="#驼峰命名与短横线命名" class="headerlink" title="驼峰命名与短横线命名"></a>驼峰命名与短横线命名</h2><ol>
<li>在html中,<code>myMessage</code>和<code>mymessage</code>是一样的.因此<strong>在组件中的html中必须使用短横线命名</strong>.</li>
<li>在组件中,父组件给子组件传数据必须用<strong>短横线</strong>(属于HTML范围内),因为html不识别驼峰,在<code>props</code>中无所谓.在<code>template</code>中必须使用<strong>驼峰命名</strong>.</li>
<li>在组件中的<code>data</code>中,用<code>this.XXX</code>引用时,必须使用<strong>驼峰命名</strong>.</li>
</ol>
<h1 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h1><p>验证的 type 类型可以是：<br>• String<br>• Number<br>• Boolean<br>• Object<br>• Array<br>• Function</p>
<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><p>组件通信分为父子通信,兄弟通信,跨级通信.</p>
<h2 id="子传父通信"><a href="#子传父通信" class="headerlink" title="子传父通信"></a>子传父通信</h2><p>使用<code>v­-on</code>除了监听DOM事件外，还可以用于组件之间的自定义事件.JavaScript的设计模式 一一观察者模式， dispatchEvent和addEventListener这两个方法.Vue组件也有与之类似的一套模式，子组件用<code>$emit()</code>来触发事件,父组件用<code>$on()</code>来监昕子组件的事件.</p>
<ol>
<li>自定义事件<code>change</code></li>
<li>在子组件中用<code>$emit</code>触发<code>change</code>,即<code>this.$emit(&#39;change&#39;,this.count)</code>.括号里前面是用户名,后面是传递参数.</li>
<li>在自定义事件中用一个参数来接受</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt;您的余额为&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;btn-component @change="handleTotal"&gt;&lt;/btn-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        total: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleTotal: function(total)&#123;</span><br><span class="line">            <span class="keyword">this</span>.total = total</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">'btn-component'</span>: &#123;</span><br><span class="line">            template: <span class="string">'&lt;div&gt;\</span></span><br><span class="line"><span class="string">                &lt;button @click="handleIncrease"&gt;+1&lt;/button&gt;\</span></span><br><span class="line"><span class="string">                &lt;button @click="handleReduce"&gt;-1&lt;/button&gt;\</span></span><br><span class="line"><span class="string">            &lt;/div&gt;'</span>,</span><br><span class="line">            data: function()&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    count: <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                handleIncrease: function()&#123;</span><br><span class="line">                    <span class="keyword">this</span>.count++;</span><br><span class="line">                    <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, <span class="keyword">this</span>.count)</span><br><span class="line">                &#125;,</span><br><span class="line">                handleReduce: function()&#123;</span><br><span class="line">                    <span class="keyword">this</span>.count--</span><br><span class="line">                    <span class="keyword">this</span>.$emit(<span class="string">'change'</span>, <span class="keyword">this</span>.count)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="在组件中使用v-model"><a href="#在组件中使用v-model" class="headerlink" title="在组件中使用v-model"></a>在组件中使用v-model</h2><p><code>$emit</code>的代码实际上会触发一个input事件,<code>input</code>后的参数就是传递给<code>v-model</code>绑定的属性的值.<br><code>v-model</code>其实是一个语法糖,其实绑定了两层操作:</p>
<ol>
<li><code>v-bind</code>绑定一个value值</li>
<li><code>v-on</code>指令给当前元素绑定input事件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"total"</span>&gt;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">&lt;input</span><br><span class="line">  v-bind:value=<span class="string">"total"</span></span><br><span class="line">  v-on:input=<span class="string">"total = $event.target.value"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>要使用<code>v-model</code>,要做到:</p>
<ol>
<li>接收一个value属性</li>
<li>在有新的value时触发input事件</li>
</ol>
<p>修改上面的实例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt;您的余额为&#123;&#123; total &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;btn-component v-model="total"&gt;&lt;/</span>btn-component&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: "#app",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        total: 0</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    components: &#123;</span></span><br><span class="line"><span class="regexp">        'btn-component': &#123;</span></span><br><span class="line"><span class="regexp">            template: `&lt;div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button @click="handleincrease"&gt;+1&lt;/</span>button&gt;</span><br><span class="line">                &lt;button @clcik=<span class="string">"handlereduce"</span>&gt;<span class="number">-1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;<span class="string">`,</span></span><br><span class="line"><span class="string">            data: function()&#123;</span></span><br><span class="line"><span class="string">                return &#123;</span></span><br><span class="line"><span class="string">                    count: 0</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            methods: &#123;</span></span><br><span class="line"><span class="string">                handleincrease: function()&#123;</span></span><br><span class="line"><span class="string">                    this.count++</span></span><br><span class="line"><span class="string">                    this.$emit('input',this.count)</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                handlereduce: function()&#123;</span></span><br><span class="line"><span class="string">                    this.count--</span></span><br><span class="line"><span class="string">                    this.$emit('input',this.count)</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="非父子组件通信-兄弟通信"><a href="#非父子组件通信-兄弟通信" class="headerlink" title="非父子组件通信(兄弟通信)"></a>非父子组件通信(兄弟通信)</h1><p>方法: 使用bus中介<br>使用一个空的Vue实例作为中央事件总线(bus):<br><code>var bus = new Vue()</code><br>触发组件A中的事件<br><code>bus.$emit(&#39;id-selected&#39;,1)</code><br>在组件B创建的钩子中监听事件<br><code>bus.$on(&#39;id-selected&#39;,function(id){//....})</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;my-acomponent&gt;&lt;/my-acomponent&gt;</span><br><span class="line">&lt;my-bcomponent&gt;&lt;/my-bcomponent&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('my-acomponent',&#123;</span></span><br><span class="line"><span class="regexp">    template: `&lt;div&gt;&lt;button @click="handle"&gt;点击我向B组件传数据&lt;/</span>button&gt;&lt;/div&gt;<span class="string">`,</span></span><br><span class="line"><span class="string">    data: function()&#123;</span></span><br><span class="line"><span class="string">        return &#123;</span></span><br><span class="line"><span class="string">            aaa: '我来自a组件'</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">     methods: &#123;</span></span><br><span class="line"><span class="string">         handle: function()&#123;</span></span><br><span class="line"><span class="string">             this.$root.bus.$emit('lala', this.aaa)</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Vue.component('my-bcomponent',&#123;</span></span><br><span class="line"><span class="string">    template: `</span>&lt;div&gt;我是B组件&lt;<span class="regexp">/div&gt;`,</span></span><br><span class="line"><span class="regexp">    created: function()&#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/A组件在实例创建的时候就监听事件--lala事件</span></span><br><span class="line"><span class="regexp">        this.$root.bus.$on('lala',function(value)&#123;</span></span><br><span class="line"><span class="regexp">            alert(value)</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el:"#app",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/bus中介</span></span><br><span class="line"><span class="regexp">        bus: new Vue()</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="父链和子链"><a href="#父链和子链" class="headerlink" title="父链和子链"></a>父链和子链</h2><h3 id="this-parent-从父组件里拿内容"><a href="#this-parent-从父组件里拿内容" class="headerlink" title="this.$parent(从父组件里拿内容)"></a><code>this.$parent</code>(从父组件里拿内容)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-component'</span>,&#123;</span><br><span class="line">    template:<span class="string">`&lt;button @click="setFatherData"&gt;通过我修改父亲的数据&lt;/button&gt;`</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        setFatherData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.$parent.msg = <span class="string">"数据已修改"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="this-refs-从子组件里拿内容"><a href="#this-refs-从子组件里拿内容" class="headerlink" title="this$refs(从子组件里拿内容 )"></a><code>this$refs</code>(从子组件里拿内容 )</h3><p>为子组件提供索引的方法,用特殊的属性ref为其增加一个索引<br>如果用<code>$children</code>会把所有子组件都拿到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;my-acomponent ref="A"&gt;&lt;/my-acomponent&gt;</span><br><span class="line">    &lt;my-bcomponent ref="B"&gt;&lt;/my-bcomponent&gt;</span><br><span class="line">    &lt;button @click="getChildData"&gt;我是父组件,我要拿到子组件的数据&lt;/button&gt;---&#123;&#123; msg &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        bus: <span class="keyword">new</span> Vue()</span><br><span class="line">        msg: <span class="string">'数据未拿到'</span>,</span><br><span class="line">        formchild: <span class="string">'还未拿到'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getChildData: function()&#123;</span><br><span class="line">            <span class="comment">//用来拿子组件中的内容---$refs</span></span><br><span class="line">            <span class="keyword">this</span>.fromChild = <span class="keyword">this</span>.$refs.b.msg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'my-acomponent'</span>,&#123;</span><br><span class="line">    template: `&lt;div&gt;&lt;/div&gt;`,</span><br><span class="line">    data: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="string">'我来自a组件'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用slot插槽分发内容"><a href="#使用slot插槽分发内容" class="headerlink" title="使用slot插槽分发内容"></a>使用slot插槽分发内容</h1><h2 id="什么是插槽"><a href="#什么是插槽" class="headerlink" title="什么是插槽"></a>什么是插槽</h2><p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为<code>内容分发</code>.Vue.js 实现了一个内容分发API，使用特殊的<code>slot</code>元素作为原始内容的插槽.</p>
<h2 id="编译的作用域"><a href="#编译的作用域" class="headerlink" title="编译的作用域"></a>编译的作用域</h2><p>父组件的作用域在父组件内,即<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>内部(便于理解).<br>子组件的作用域在子组件的<code>template</code>里.</p>
<h2 id="插槽的用法"><a href="#插槽的用法" class="headerlink" title="插槽的用法"></a>插槽的用法</h2><blockquote>
<p>混合父组件的内容和子组件的模板</p>
</blockquote>
<ol>
<li>单个插槽</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;my-component&gt;</span><br><span class="line">        &lt;p&gt;父组件&lt;<span class="regexp">/p&gt; </span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/虽然是父组件的作用域,但没有slot插槽,父组件的信息是无法显示</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/插槽的作用是把父组件的内容插入到下面的子组件中,最后会显示出来</span></span><br><span class="line"><span class="regexp">    &lt;/my</span>-component&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('my-component',&#123;</span></span><br><span class="line"><span class="regexp">    template: `&lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;slot&gt;</span></span><br><span class="line"><span class="regexp">            如果父组件没有插入内容,那么我就作为默认出现</span></span><br><span class="line"><span class="regexp">        &lt;/</span>slot&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;`</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el:"#app",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>具名插槽</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;my-component&gt;</span><br><span class="line">        &lt;h3 slot=<span class="string">"header"</span>&gt;我是标题&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/给父组件的插槽命名,可以和子组件模板的slot一一对应</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;父组件&lt;/</span>p&gt; </span><br><span class="line">        <span class="comment">//这个不命名的自然就对应那个没有命名的slot</span></span><br><span class="line">        &lt;p slot=<span class="string">"footer"</span>&gt;我是底部信息&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/my</span>-component&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('my-component',&#123;</span></span><br><span class="line"><span class="regexp">    template: `&lt;div&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div class="header"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;slot name="header"&gt;&lt;/</span>slot&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div class="container"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;slot&gt;&lt;/</span>slot&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div class="footer"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;slot name="footer"&gt;&lt;/</span>slot&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;<span class="string">`</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">var app = new Vue(&#123;</span></span><br><span class="line"><span class="string">    el:"#app",</span></span><br><span class="line"><span class="string">    data: &#123;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>作用域插槽</li>
</ol>
<p>作用域插槽是一种特殊的插槽,使用一个可复用的模板来替换已渲染的元素</p>
<ul>
<li>从子组件获取数据</li>
<li><code>&lt;template&gt;</code>标签是不会渲染出来的,Vue版本更新后,也可以写在其他标签上</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;my-component&gt;</span><br><span class="line">        &lt;template slot=<span class="string">"abc"</span> slot-scope=<span class="string">"prop"</span>&gt;</span><br><span class="line">        <span class="comment">//写一个临时变量prop,用临时变量拿子组件的信息</span></span><br><span class="line">            &#123;&#123; prop.text &#125;&#125;</span><br><span class="line">        &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/my</span>-component&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('my-component',&#123;</span></span><br><span class="line"><span class="regexp">    template: `&lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;slot name="abc" text="我是子组件的内容"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>slot&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;`</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el:"#app",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="访问slot"><a href="#访问slot" class="headerlink" title="访问slot"></a>访问<code>slot</code></h2><p>通过<code>this.$slots.(name)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;my-component&gt;</span><br><span class="line">        &lt;h3 slot=<span class="string">"header"</span>&gt;我是标题&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;父组件&lt;/</span>p&gt; </span><br><span class="line">        &lt;p slot=<span class="string">"footer"</span>&gt;我是底部信息&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/my</span>-component&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('my-component',&#123;</span></span><br><span class="line"><span class="regexp">    template: `&lt;div&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div class="header"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;slot name="header"&gt;&lt;/</span>slot&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div class="container"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;slot&gt;&lt;/</span>slot&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div class="footer"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;slot name="footer"&gt;&lt;/</span>slot&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;<span class="string">`,</span></span><br><span class="line"><span class="string">    mounted: function()&#123;</span></span><br><span class="line"><span class="string">        //访问插槽</span></span><br><span class="line"><span class="string">        var header = this.$slots.header</span></span><br><span class="line"><span class="string">        var text = header[0].elm.innerText</span></span><br><span class="line"><span class="string">        console.log(header)</span></span><br><span class="line"><span class="string">        //打印一个虚拟节点</span></span><br><span class="line"><span class="string">        console.log(text)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">var app = new Vue(&#123;</span></span><br><span class="line"><span class="string">    el:"#app",</span></span><br><span class="line"><span class="string">    data: &#123;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="组件高级用法-动态组件"><a href="#组件高级用法-动态组件" class="headerlink" title="组件高级用法-动态组件"></a>组件高级用法-动态组件</h1><p>实现需求: 点击不同按钮切换不同页面<br>使用<code>is</code>动态绑定组件,调用方法切换不同页面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;component :is="thisView"&gt;&lt;/component&gt;</span><br><span class="line">    &lt;button @click="handleView('A')"&gt;第一句&lt;/button&gt;</span><br><span class="line">    &lt;button @click="handleView('B')"&gt;第二句&lt;/button&gt;</span><br><span class="line">    &lt;button @click="handleView('C')"&gt;第三句&lt;/button&gt;</span><br><span class="line">    &lt;button @click="handleView('D')"&gt;第四句&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.component(<span class="string">'comA'</span>,&#123;</span><br><span class="line">  template:`&lt;div&gt;鹅鹅鹅&lt;/div&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'comB'</span>,&#123;</span><br><span class="line">  template:`&lt;div&gt;曲项向天歌&lt;/div&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'comC'</span>,&#123;</span><br><span class="line">  template:`&lt;div&gt;白毛浮绿水&lt;/div&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'comD'</span>,&#123;</span><br><span class="line">  template:`&lt;div&gt;红掌拨清波&lt;/div&gt;`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        thisView: <span class="string">'comA'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleView: function(tag)&#123;</span><br><span class="line">            <span class="keyword">this</span>.thisView = <span class="string">'com'</span> + tag</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="解析-DOM-模板时的注意事项"><a href="#解析-DOM-模板时的注意事项" class="headerlink" title="解析 DOM 模板时的注意事项"></a>解析 DOM 模板时的注意事项</h1><p>有些 HTML 元素，诸如<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;</span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的<code>is</code>特性给了我们一个变通的办法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=<span class="string">"blog-post-row"</span>&gt;&lt;/tr&gt;</span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：</p>
<ol>
<li>字符串 (例如：template: ‘…’)</li>
<li>单文件组件 (.vue)</li>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
</ol>
<h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><h1 id="在模块系统中局部注册"><a href="#在模块系统中局部注册" class="headerlink" title="在模块系统中局部注册"></a>在模块系统中局部注册</h1><p>推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。<br>然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 <code>ComponentB.js</code> 或 <code>ComponentB.vue</code> 文件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA'</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">'./ComponentC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了</p>
<h1 id="基础组件的自动化全局注册"><a href="#基础组件的自动化全局注册" class="headerlink" title="基础组件的自动化全局注册"></a>基础组件的自动化全局注册</h1><p>可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。<br>所以会导致很多组件里都会有一个包含基础组件的长列表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BaseButton <span class="keyword">from</span> <span class="string">'./BaseButton.vue'</span></span><br><span class="line"><span class="keyword">import</span> BaseIcon <span class="keyword">from</span> <span class="string">'./BaseIcon.vue'</span></span><br><span class="line"><span class="keyword">import</span> BaseInput <span class="keyword">from</span> <span class="string">'./BaseInput.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    BaseButton,</span><br><span class="line">    BaseIcon,</span><br><span class="line">    BaseInput</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">'lodash/upperFirst'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash/camelCase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">'./components'</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 获取和目录深度无关的文件名</span></span><br><span class="line">      fileName</span><br><span class="line">        .split(<span class="string">'/'</span>)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>记住全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生.</p>
</blockquote>
<h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><h2 id="Prop-的大小写"><a href="#Prop-的大小写" class="headerlink" title="Prop 的大小写"></a>Prop 的大小写</h2><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符.<br>当使用dom中的模板时,驼峰命名的prop需要使用其等价的短横线命名替换:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 驼峰 的</span></span><br><span class="line">  props: [<span class="string">'postTitle'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;!-- 在 HTML 中是短横线的 --&gt;</span><br><span class="line">&lt;blog-post post-title=<span class="string">"hello!"</span>&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<h2 id="prop的类型"><a href="#prop的类型" class="headerlink" title="prop的类型"></a>prop的类型</h2><p>字符串和对象<br>字符串:<code>props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]</code><br>对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a>传递静态或动态 Prop</h2><p>传静态值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post title=<span class="string">"My journey with Vue"</span>&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<p>动态赋值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post v-bind:title=<span class="string">"post.title"</span>&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<p>布尔值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 <span class="string">`true`</span>。--&gt;</span><br><span class="line">&lt;blog-post is-published&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 即便 <span class="string">`false`</span> 是静态的，我们仍然需要 <span class="string">`v-bind`</span> 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post v-bind:is-published=<span class="string">"false"</span>&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:is-published=<span class="string">"post.isPublished"</span>&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<p>数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即便数组是静态的，我们仍然需要 <span class="string">`v-bind`</span> 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post v-bind:comment-ids=<span class="string">"[234, 266, 273]"</span>&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:comment-ids=<span class="string">"post.commentIds"</span>&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<p>对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即便对象是静态的，我们仍然需要 <span class="string">`v-bind`</span> 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:author=<span class="string">"&#123;</span></span><br><span class="line"><span class="string">    name: 'Veronica',</span></span><br><span class="line"><span class="string">    company: 'Veridian Dynamics'</span></span><br><span class="line"><span class="string">  &#125;"</span></span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:author=<span class="string">"post.author"</span>&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<h1 id="禁用特性继承"><a href="#禁用特性继承" class="headerlink" title="禁用特性继承"></a>禁用特性继承</h1><p>如果你不希望组件的根元素继承特性，你可以在组件的选项中设置 inheritAttrs: false。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这尤其适合配合实例的$attrs属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  required: <span class="literal">true</span>,</span><br><span class="line">  placeholder: <span class="string">'Enter your username'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;base-input</span><br><span class="line">  v-model=<span class="string">"username"</span></span><br><span class="line">  required</span><br><span class="line">  placeholder=<span class="string">"Enter your username"</span></span><br><span class="line">&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 <code>inheritAttrs: false</code> 选项不会影响 style 和 class 的绑定。</p>
</blockquote>
<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><h2 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h2><p>不同于组件和 prop，事件名不会被用作一个js变量名或属性名，所以就没有理由使用驼峰命名了。并且<code>v-on</code>事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以推荐始终使用<strong>短横线命名</strong>.</p>
<h2 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的v-model</h2><p>一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="checkbox"</span></span><br><span class="line"><span class="string">      v-bind:checked="checked"</span></span><br><span class="line"><span class="string">      v-on:change="$emit('change', $event.target.checked)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-checkbox v-model=<span class="string">"lovingVue"</span>&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 <code>&lt;base-checkbox&gt;</code>触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新。</p>
<blockquote>
<p>注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。</p>
</blockquote>
<h1 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h1><p>使用<code>v-on</code>的修饰符<code>.native</code>直接监听一个组件根元素上的原生事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-input v-on:focus.native=<span class="string">"onFocus"</span>&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure>

<p>但当上述 <code>&lt;base-input&gt;</code> 组件做了如下重构，那么根元素实际上是一个 <code>&lt;label&gt;</code> 元素:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;</span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  &lt;input</span><br><span class="line">    v-bind=<span class="string">"$attrs"</span></span><br><span class="line">    v-bind:value=<span class="string">"value"</span></span><br><span class="line">    v-on:input=<span class="string">"$emit('input', $event.target.value)"</span></span><br><span class="line">  &gt;</span><br><span class="line">&lt;<span class="regexp">/label&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。</p>
<p>为了解决这个问题，Vue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a><code>$listeners</code></h3><p>有了这个 $listeners 属性，你就可以配合 v-on=”$listeners” 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <code>&lt;input&gt;</code> 的你希望它也可以配合 <code>v-model</code> 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="keyword">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">'input'</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on="inputListeners"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在<code>&lt;base-input&gt;</code>组件是一个完全透明的包裹器了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code>元素一样使用了：所有跟它相同的特性和监听器的都可以工作。</p>
<h2 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a><code>.sync</code> 修饰符</h2><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。<br>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newTitle)</span><br></pre></td></tr></table></figure>

<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-<span class="built_in">document</span></span><br><span class="line">  v-bind:title=<span class="string">"doc.title"</span></span><br><span class="line">  v-on:update:title=<span class="string">"doc.title = $event"</span></span><br><span class="line">&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure>

<p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-<span class="built_in">document</span> v-bind:title.sync=<span class="string">"doc.title"</span>&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</p>
</blockquote>
<p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 v-bind 配合使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-<span class="built_in">document</span> v-bind.sync=<span class="string">"doc"</span>&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure>

<p>这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。</p>
<blockquote>
<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=&quot;{ title: doc.title }&quot;</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
</blockquote>
<h1 id="动态组件和异步组件"><a href="#动态组件和异步组件" class="headerlink" title="动态组件和异步组件"></a>动态组件和异步组件</h1><h2 id="动态组件is"><a href="#动态组件is" class="headerlink" title="动态组件is"></a>动态组件is</h2><p>使用<code>is特性</code>切换不同的组件,如果想在标签的组件实例被在它们第一次被创建的时候缓存下来,避免重复渲染.可以使用<code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 失活的组件将会被缓存！--&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component v-bind:is=<span class="string">"currentTabComponent"</span>&gt;&lt;/component&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向 `resolve` 回调传递组件定义</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>函数有2个参数，resolve和reject，它们是两个函数，由javascript引擎提供，不用自己定义。resolve会在你从服务器得到组件定义的时候被调用。</p>
<p>如你所见，这个工厂函数会收到一个 <code>resolve</code>回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 <code>reject(reason)</code> 来表示加载失败。这里的 setTimeout 是为了演示用的，如何获取组件取决于你自己.<br>一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包，这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这里使用的是webpack模块方法require(AMD版本)，将其对应的文件拆分到一个单独的 bundle 中，</span></span><br><span class="line"><span class="comment">//此 bundle 会被异步加载，然后调用resolve回调函数</span></span><br></pre></td></tr></table></figure>

<p>你也可以在工厂函数中返回一个 Promise，所以把 webpack 2 和 ES2015 语法加在一起，我们可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//这里使用的webpack模块方法import()，可以通过注释的方法定义新chunk的名称</span></span><br></pre></td></tr></table></figure>

<h2 id="处理加载状态"><a href="#处理加载状态" class="headerlink" title="处理加载状态"></a>处理加载状态</h2><p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当使用局部注册的时候，也可以直接提供一个返回promise的函数，比如在使用vue的路由懒加载时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒加载方式,当路由被访问时才加载对应组件</span></span><br><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/Login'</span>)</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/components/Home'</span>], resolve)</span><br><span class="line"><span class="keyword">const</span> UserList = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/components/user/list'</span>], resolve)</span><br></pre></td></tr></table></figure>

<p>这样只有当要访问路由时，才会加载指定路由下的组件.</p>
<h1 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h1><h1 id="访问元素和组件"><a href="#访问元素和组件" class="headerlink" title="访问元素和组件"></a>访问元素和组件</h1><h2 id="访问根实例"><a href="#访问根实例" class="headerlink" title="访问根实例"></a>访问根实例</h2><p>在每个<code>new Vue</code>实例的子组件中,其根实例可以通过<code>$root</code>属性进行访问.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    baz: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问根组件的计算属性</span></span><br><span class="line"><span class="keyword">this</span>.$root.bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用根组件的方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.baz()</span><br></pre></td></tr></table></figure>

<h2 id="访问父组件实例"><a href="#访问父组件实例" class="headerlink" title="访问父组件实例"></a>访问父组件实例</h2><p>和 <code>$root</code>类似，<code>$parent</code> 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。</p>
<h2 id="访问子组件实例"><a href="#访问子组件实例" class="headerlink" title="访问子组件实例"></a>访问子组件实例</h2><p>通过<code>$ref</code></p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>依赖注入用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code>。<br>provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 <code>getMap</code> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="keyword">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inject: [<span class="string">'getMap'</span>]</span><br></pre></td></tr></table></figure>

<p>相比<code>$parent</code>来说，这个用法可以让我们在任意后代组件中访问 getMap，而不需要暴露整个 <code>&lt;google-map&gt;</code> 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 props 一样。</p>
<p>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p>
<ol>
<li>祖先组件不需要知道哪些后代组件使用它提供的属性</li>
<li>后代组件不需要知道被注入的属性来自哪里</li>
</ol>
<blockquote>
<p>然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 <code>$root</code>做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。</p>
</blockquote>
<h1 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h1><p>现在，你已经知道了 <code>$emit</code> 的用法，它可以被 <code>v-on</code> 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以：</p>
<ol>
<li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ol>
<p>让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">'startDateInput'</span>)</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">'endDateInput'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  attachDatepicker: <span class="function"><span class="keyword">function</span> (<span class="params">refName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="keyword">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><h2 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h2><p>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 name 选项来做这件事：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="string">'unique-name-of-my-component'</span></span><br></pre></td></tr></table></figure>

<p>稍有不慎，递归组件就可能导致无限循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">template: <span class="string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>

<p>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 false 的 <code>v-if</code>)。</p>
<h2 id="组件之间的循环引用"><a href="#组件之间的循环引用" class="headerlink" title="组件之间的循环引用"></a>组件之间的循环引用</h2><p>解决方法:<br>把 <code>&lt;tree-folder&gt;</code> 组件设为了那个点。我们知道那个产生悖论的子组件是 <code>&lt;tree-folder-contents&gt;</code> 组件，所以我们会等到生命周期钩子 beforeCreate 时去注册它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，在本地注册组件的时候，你可以使用 webpack 的异步 import：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./tree-folder-contents.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模板定义的替代品"><a href="#模板定义的替代品" class="headerlink" title="模板定义的替代品"></a>模板定义的替代品</h1><h2 id="内联模板-inline-template"><a href="#内联模板-inline-template" class="headerlink" title="内联模板(inline-template)"></a>内联模板(inline-template)</h2><p>当子组件中出现<code>inline-template</code>时,这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component inline-template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;These are compiled <span class="keyword">as</span> the component<span class="string">'s own template.&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Not parent'</span>s transclusion content.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/my-component&gt;</span></span><br></pre></td></tr></table></figure>

<p>内联模板需要定义在 Vue 所属的 DOM 元素内。<br>不过，<code>inline-template</code> 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 template 选项或 .vue 文件里的一个 <code>&lt;template&gt;</code> 元素来定义模板。</p>
<h2 id="X-template"><a href="#X-template" class="headerlink" title="X-template"></a>X-template</h2><p>另一个定义模板的方式是在一个 <code>&lt;script&gt;</code> 元素中，并为其带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;script type=<span class="string">"text/x-template"</span> id=<span class="string">"hello-world-template"</span>&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//js</span></span><br><span class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#hello-world-template'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>x-template 需要定义在 Vue 所属的 DOM 元素外。</p>
<blockquote>
<p>这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。</p>
</blockquote>
<h1 id="控制更新"><a href="#控制更新" class="headerlink" title="控制更新"></a>控制更新</h1><h2 id="强制更新"><a href="#强制更新" class="headerlink" title="强制更新"></a>强制更新</h2><blockquote>
<p>如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。<br>你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。</p>
</blockquote>
<p>然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 $forceUpdate 来做这件事。</p>
<h2 id="通过-v-once-创建低开销的静态组件"><a href="#通过-v-once-创建低开销的静态组件" class="headerlink" title="通过 v-once 创建低开销的静态组件"></a>通过 v-once 创建低开销的静态组件</h2><p>渲染包含大量静态内容的组件,你可以在根元素上添加 v-once 特性以确保这些内容只计算一次然后缓存起来;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... a lot of static content ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意事项:</p>
<blockquote>
<p>不要过度使用这个模式。当需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 v-once 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/09/Vue组件/" data-id="ck3pu18em00190shavmdag1mo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js基础/">Vue.js基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Vue-js基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/07/Vue-js基础/" class="article-date">
  <time datetime="2019-09-07T01:42:13.000Z" itemprop="datePublished">2019-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/07/Vue-js基础/">Vue.js基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。<br><strong>vue和react都不是mvvm框架，只是借鉴</strong></p>
<h2 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h2><p>MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。<br>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。viewmodel是组件的实例.<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<h2 id="Vue-js的优点："><a href="#Vue-js的优点：" class="headerlink" title="Vue.js的优点："></a>Vue.js的优点：</h2><ol>
<li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>
<li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li>
<li>易用灵活高效</li>
</ol>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在html内引入:<br><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code><br>工程化时最好使用<code>vue/cli</code>构建.</p>
<h1 id="实例和数据绑定"><a href="#实例和数据绑定" class="headerlink" title="实例和数据绑定"></a>实例和数据绑定</h1><p>通过构造函数<code>Vue</code>就可以创建一个<code>Vue</code>的实例.并启动<code>Vue</code>应用.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;<span class="attr">msg</span>: <span class="string">'hello world'</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>el</code>用于指定页面中的DOM元素来挂载Vue实例.可以是标签,可以是css语法.<br>通过<code>Vue</code>实例的<code>data</code>选项,可以声明应用内可以双向绑定的数据.建议所有会用到的数据都预先在<code>data</code>内声明,也可以指向一个已有的变量.值可以先设置默认值.<br>挂载成功后,可以通过<code>app.$el</code>来访问该元素,<code>Vue</code>实例本身也代理了<code>data</code>对象里的所有属性,所以可以这样访问:<br>访问Vue实例的属性: <code>app.$el, app.$data</code>.<br>访问data元素的属性: <code>app.msg</code></p>
<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>钩子(hook),可以理解为挂载点.在整个Vue实例创建过程中,有一些挂载点.<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Alt"></p>
<p>生命周期流程:</p>
<blockquote>
<p>所有的生命周期钩子自动绑定<code>this</code>上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你<strong>不能使用箭头函数来定义一个生命周期方法</strong> (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">生命周期钩子</th>
<th align="left">类型</th>
<th align="left">详细</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">Function</td>
<td align="left">在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</td>
</tr>
<tr>
<td align="left"><strong>created</strong></td>
<td align="left">Function</td>
<td align="left">在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code>属性目前不可见。</td>
</tr>
<tr>
<td align="left">beforeMoute</td>
<td align="left">Function</td>
<td align="left">在挂载开始之前被调用：相关的<code>render</code>函数首次被调用。</td>
</tr>
<tr>
<td align="left"><strong>mounted</strong></td>
<td align="left">Function</td>
<td align="left"><code>el</code>被新创建的<code>vm.$el</code>替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">Function</td>
<td align="left">数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</td>
</tr>
<tr>
<td align="left"><strong>updated</strong></td>
<td align="left">Function</td>
<td align="left">由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或<code>watcher</code>取而代之</td>
</tr>
<tr>
<td align="left">actived</td>
<td align="left">Function</td>
<td align="left">keep-alive 组件激活时调用。</td>
</tr>
<tr>
<td align="left">deactivated</td>
<td align="left">Function</td>
<td align="left">keep-alive 组件停用时调用。</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">Function</td>
<td align="left">实例销毁之前调用。在这一步，实例仍然完全可用。</td>
</tr>
<tr>
<td align="left"><strong>destroyed</strong></td>
<td align="left">Function</td>
<td align="left">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</td>
</tr>
<tr>
<td align="left">errorCaptured</td>
<td align="left"><code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></td>
<td align="left">当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回<code>false</code>以阻止该错误继续向上传播。</td>
</tr>
</tbody></table>
<blockquote>
<p>不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。<br>注意<code>mounted</code>不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用<code>vm.$nextTick</code>替换掉<code>mounted</code>：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>updated</code>不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用<code>vm.$nextTick</code>替换掉<code>updated</code>：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">updated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been re-rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文本插值和表达式"><a href="#文本插值和表达式" class="headerlink" title="文本插值和表达式"></a>文本插值和表达式</h1><p>使用双大括号(Mustache语法)的方法是最基本的文本插值的语法,它会自动将双向绑定的数据实时显示出来.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 <code>v-html</code> 指令：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;Using v-html directive: &lt;span v-html="rawHtml"&gt;&lt;/</span>span&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</p>
</blockquote>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p><code>v-bind</code>可缩写成<code>:</code>.<br>双大括号语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=<span class="string">"dynamicId"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>对于布尔特性 (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled=<span class="string">"isButtonDisabled"</span>&gt;Button&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果<code>isButtonDisabled</code>的值是<code>null、undefined</code>或<code>false</code>，则<code>disabled</code>特性甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中。</p>
<h2 id="js表达式"><a href="#js表达式" class="headerlink" title="js表达式"></a>js表达式</h2><p> Vue .js 只支持单个表达式，不支持语句和流控制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + <span class="number">1</span> &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? <span class="string">'YES'</span> : <span class="string">'NO'</span> &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) &#125;&#125;</span><br><span class="line">&lt;div v-bind:id=<span class="string">"'list-' + id"</span>&gt;&lt;/div&gt;<span class="comment">//文本插值的形式，其中不能书写表达式,支持单个表达式</span></span><br></pre></td></tr></table></figure>

<p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。<br>有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line">&#123;&#123; <span class="keyword">var</span> a = <span class="number">1</span> &#125;&#125;</span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; <span class="keyword">if</span> (ok) &#123; <span class="keyword">return</span> message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。</p>
</blockquote>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example"</span>&gt;</span><br><span class="line">  &#123;&#123; message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里是想要显示变量 message 的翻转字符串,但是更复杂的就需要计算属性.<br>所有的计算属性都以函数的形式写在 Vue 实例内的<code>computed</code>选项内，最终返回计算后的结果。<br>范例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example"</span>&gt;</span><br><span class="line">&lt;p&gt;message: <span class="string">"&#123;&#123; message &#125;&#125;"</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;reversed message: "&#123;&#123; reversedMessage &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">//计算属性的getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//this指向vm实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse.().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//message: "hello"</span></span><br><span class="line"><span class="comment">//reversed message: "olleh"</span></span><br></pre></td></tr></table></figure>

<h2 id="计算属性缓存"><a href="#计算属性缓存" class="headerlink" title="计算属性缓存"></a>计算属性缓存</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用methods方法也可以起到和计算属性同样效果<br><strong>区别</strong>:<br>methods: 如果调用方法,只要页面重新渲染.方法就会重新执行,不需要渲染就不需要重新执行<br>计算属性: 不管渲不渲染,只要计算属性依赖的数据不变,就不会变<br><em>何时使用</em>: 取决于是否需要缓存,当遍历大量数组或大量计算,应该使用计算属性.</p>
<h2 id="计算属性缓存-vs-方法methods"><a href="#计算属性缓存-vs-方法methods" class="headerlink" title="计算属性缓存 vs 方法methods"></a>计算属性缓存 vs 方法methods</h2><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下，<strong>每当触发重新渲染时，调用方法methods将总会再次执行函数。</strong><br>计算属性 vs 侦听属性watch<br><strong>watch</strong>:主要用来监听数据变化.可以监听:props,data,computed内的数据.<br>属于我的变化影响别人.<br><strong>计算属性computed:</strong> 依赖data中的数据,只有该依赖的数据发生变化才会变化.<br>属于别人的变化影响我.<br>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。<br>例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"demo"</span>&gt;&#123;&#123; fullName &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#demo',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    firstName: 'Foo',</span></span><br><span class="line"><span class="regexp">    lastName: 'Bar',</span></span><br><span class="line"><span class="regexp">    fullName: 'Foo Bar'</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  watch: &#123;</span></span><br><span class="line"><span class="regexp">    firstName: function (val) &#123;</span></span><br><span class="line"><span class="regexp">      this.fullName = val + ' ' + this.lastName</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    lastName: function (val) &#123;</span></span><br><span class="line"><span class="regexp">      this.fullName = this.firstName + ' ' + val</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>计算属性版本:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h2><p>计算属性默认只有<code>getter</code>，不过在需要时你也可以提供一个<code>setter</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p>
<h2 id="侦听器watch"><a href="#侦听器watch" class="headerlink" title="侦听器watch"></a>侦听器watch</h2><p>当需要在数据变化时执行异步或开销较大的操作时,更适合用watch.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"watch-example"</span>&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=<span class="string">"question"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/axios@<span class="number">0.12</span><span class="number">.0</span>/dist/axios.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>https:<span class="comment">//cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#watch-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: <span class="string">''</span>,</span><br><span class="line">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    question: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span><br><span class="line">      <span class="keyword">this</span>.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `_.debounce` 是一个通过 Lodash 创建的函数防抖.</span></span><br><span class="line">    <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getAnswer: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//如果要检索的字符串值没有出现，则indexOf返回 -1。</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">          vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">          vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h1 id="v-bind与class和style的绑定"><a href="#v-bind与class和style的绑定" class="headerlink" title="v-bind与class和style的绑定"></a>v-bind与class和style的绑定</h1><p>应用场景: dom元素经常绑定一些class类名或style样式</p>
<h2 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h2><p>可以给<code>v-bind:class</code>传一个对象,动态切换class:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>也可以传入多个属性来动态切换class.<code>v-bind:class</code>指令也可以与普通class属性共存.<br>绑定的数据对象也可以写在<code>data</code>里.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>当class的表达式过长或者逻辑复杂,可以绑定一个计算属性.一般当条件多于两个时,就可以使用<code>data</code>或<code>computed</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h2><p>当应用多个class时,可以使用数组语法,给<code>v-bind:class</code>绑定一个数组.数组成员直接对应类名.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"active text-danger"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>根据条件切换,也可以使用三元表达式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>也可以数组语法,对象语法混用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h1><h2 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h2><p><code>v-bind:style</code>的对象语法十分直观——看着非常像CSS，但其实是一个JavaScript对象.CSS属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"&#123;color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  color: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样的，对象语法常常结合返回对象的计算属性使用。</p>
<h2 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h2><p>数组语法可以将多个样式对象应用到同一个元素上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用多个样式对象时,可以使用数组语法.在实际业务中,style的数组语法并不常用,因为往往可以写在一个对象里面.而较为常用的应当是计算属性.<br>使用<code>:style</code>时,Vue会自动给特殊的css属性名称增加前缀,比如transform,无需再加前缀属性.</p>
</blockquote>
<h1 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h1><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p>解决因为初始化慢,导致页面闪动的情况.这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕.<br>一般和<code>CSS规则</code>如 <code>[v-cloak] { display: none }</code>配合使用(需要写到css里).</p>
<h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>只渲染元素和组件一次.之后的重新渲染被当做静态内容跳过,用于优化性能.<br>写在标签里.</p>
<h2 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h2><p>跳过这个元素和他子元素的编译过程.可以加快编译.</p>
<h2 id="其他的单独写"><a href="#其他的单独写" class="headerlink" title="其他的单独写"></a>其他的单独写</h2><p>v-text, v-html, v-show, v-if, v-else, v-else-if, v-for, v-on, v-bind, v-model, v-slot.</p>
<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if-v-else-v-else-if"><a href="#v-if-v-else-v-else-if" class="headerlink" title="v-if,v-else,v-else-if"></a>v-if,v-else,v-else-if</h2><p>用法: 根据表达式值的真假条件渲染元素.在切换时元素及它的数据绑定/组件被销毁并重建.<br>如果元素是<code>&lt;template&gt;</code>,将提出他的内容作为条件块.<br>当条件变化时,该指令触发过渡效果.</p>
<blockquote>
<p>当和<code>v-for</code>一起使用时,<code>v-for</code>的优先级更高.</p>
</blockquote>
<p>也可以用 v-else 添加一个“else 块”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-<span class="keyword">if</span>=<span class="string">"awesome"</span>&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-<span class="keyword">else</span>&gt;Oh no 😢&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="在-lt-template-gt-上使用v-if"><a href="#在-lt-template-gt-上使用v-if" class="headerlink" title="在&lt;template&gt;上使用v-if"></a>在<code>&lt;template&gt;</code>上使用<code>v-if</code></h3><p>因为<code>v-if</code>是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个<code>&lt;template&gt;</code>元素当做不可见的包裹元素，并在上面使用<code>v-if</code>。最终的渲染结果将不包含<code>&lt;template&gt;</code>元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">"ok"</span>&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;Paragraph 1&lt;/</span>p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph <span class="number">2</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-else-if</code>，顾名思义，充当 <code>v-if</code> 的“else-if 块”，可以连续使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">if</span>=<span class="string">"type === 'A'"</span>&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-else-if="type === 'B'"&gt;</span></span><br><span class="line"><span class="regexp">  B</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;div v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"type === 'C'"</span>&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-else&gt;</span></span><br><span class="line"><span class="regexp">  Not A/</span>B/C</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="用key管理可复用元素"><a href="#用key管理可复用元素" class="headerlink" title="用key管理可复用元素"></a>用<code>key</code>管理可复用元素</h2><p>Vue会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染.<code>&lt;input&gt;</code>不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。<br>如果要表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的<code>key</code>属性即可.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your username" key="username-input"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;template v-<span class="keyword">else</span>&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your email address" key="email-input"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=<span class="string">"ok"</span>&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-show</code>只是切换css属性<code>display</code>.<code>v-show</code>不支持<code>&lt;template&gt;</code>元素,也不支持<code>v-else</code>.</p>
<h3 id="v-if和v-show相比"><a href="#v-if和v-show相比" class="headerlink" title="v-if和v-show相比"></a>v-if和v-show相比</h3><p><code>v-if</code>: 真正的条件渲染,条件为真就渲染,为false就移除.<br><code>v-show</code>: 不管初始条件是什么,都会渲染.只是切换css的display属性.<br>总结: 如果需要非常频繁地切换，则使用<code>v-show</code>较好；如果在运行时条件很少改变，则使用<code>v-if</code>较好</p>
<h2 id="v-for列表渲染"><a href="#v-for列表渲染" class="headerlink" title="v-for列表渲染"></a>v-for列表渲染</h2><p>两种使用场景:</p>
<ol>
<li>遍历多个对象</li>
<li>遍历一个对象的多个属性</li>
</ol>
<p>遍历数组语法: <code>v-for=&quot;(item, index) in items&quot;</code><br>第一个是数组元素名,第二个是索引.<br>遍历对象的多个属性语法: <code>v-for=&quot;(value, name, index) in object&quot;</code><br>第一个是属性值,第二个是属性名,第三个是索引.</p>
<blockquote>
<p>在遍历对象时，会按 <code>Object.keys()</code> 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。</p>
</blockquote>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">"item in items"</span> v-bind:key=<span class="string">"item.id"</span>&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>建议尽可能在使用 <code>v-for</code> 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<blockquote>
<p>不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 key。请用字符串或数值类型的值。</p>
</blockquote>
<h3 id="Vue-中的-key"><a href="#Vue-中的-key" class="headerlink" title="Vue 中的 key"></a>Vue 中的 key</h3><blockquote>
<p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p>
</blockquote>
<p>这里的就地复用的策略复用的是没有发生改变的元素，其他的还要依次重排。</p>
<p>所以我们需要使用key来给每个节点做一个唯一标识，Vue的Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点，所以一句话，key的作用主要是为了高效的更新虚拟DOM.</p>
<h2 id="v-for和v-if"><a href="#v-for和v-if" class="headerlink" title="v-for和v-if"></a>v-for和v-if</h2><p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个<code>v-for</code> 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"todo in todos"</span> v-<span class="keyword">if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码将只渲染未完成的 todo。</p>
<p>而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <template>)上。如：</template></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-<span class="keyword">if</span>=<span class="string">"todos.length"</span>&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"todo in todos"</span>&gt;</span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">&lt;p v-<span class="keyword">else</span>&gt;No todos left!&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在组件上使用-v-for"><a href="#在组件上使用-v-for" class="headerlink" title="在组件上使用 v-for"></a>在组件上使用 v-for</h3><p>当在组件上使用 <code>v-for</code> 时，<code>key</code> 现在是必须的.<br>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 <code>prop</code>,<br>不自动将 <code>item</code> 注入到组件里的原因是，这会使得组件与 <code>v-for</code>的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;div id=<span class="string">"todo-list-example"</span>&gt;</span><br><span class="line">  &lt;form v-on:submit.prevent=<span class="string">"addNewTodo"</span>&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">"new-todo"</span>&gt;Add a todo&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input</span></span><br><span class="line"><span class="regexp">      v-model="newTodoText"</span></span><br><span class="line"><span class="regexp">      id="new-todo"</span></span><br><span class="line"><span class="regexp">      placeholder="E.g. Feed the cat"</span></span><br><span class="line"><span class="regexp">    &gt;</span></span><br><span class="line"><span class="regexp">    &lt;button&gt;Add&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li</span></span><br><span class="line"><span class="regexp">      is="todo-item"</span></span><br><span class="line"><span class="regexp">      v-for="(todo, index) in todos"</span></span><br><span class="line"><span class="regexp">      v-bind:key="todo.id"</span></span><br><span class="line"><span class="regexp">      v-bind:title="todo.title"</span></span><br><span class="line"><span class="regexp">      v-on:remove="todos.splice(index, 1)"</span></span><br><span class="line"><span class="regexp">    &gt;&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>注意这里的 <code>is=&quot;todo-item&quot;</code>属性。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&lt;ul&gt;</code> 元素内只有<code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'title'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#todo-list-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: <span class="string">''</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        title: <span class="string">'Mow the lawn'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    nextTodoId: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.nextTodoId++,</span><br><span class="line">        title: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="数组更新过滤排序"><a href="#数组更新过滤排序" class="headerlink" title="数组更新过滤排序"></a>数组更新过滤排序</h2><p>改变数组的一系列方法：</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<p>两个数组变动Vue检测不到:</p>
<ol>
<li>改变数组指定项,<code>vm.items[indexOfItem] = newValue</code></li>
<li>改变数组长度,<code>vm.items.length = newLength</code></li>
</ol>
<p>解决办法:<br>改变指定项: Vue.set(app.arr, 1, ‘car’)<br>改变数组长度: app.arr.splice(1)</p>
<h3 id="显示过滤-排序后的结果"><a href="#显示过滤-排序后的结果" class="headerlink" title="显示过滤/排序后的结果"></a>显示过滤/排序后的结果</h3><p>有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。<br><strong>计算属性</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"n in evenNumbers"</span>&gt;&#123;&#123; n &#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  numbers: [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">computed: &#123;</span></span><br><span class="line"><span class="regexp">  evenNumbers: function () &#123;</span></span><br><span class="line"><span class="regexp">    return this.numbers.filter(function (number) &#123;</span></span><br><span class="line"><span class="regexp">      return number % 2 === 0</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用methods</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"n in even(numbers)"</span>&gt;&#123;&#123; n &#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  numbers: [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">  even: function (numbers) &#123;</span></span><br><span class="line"><span class="regexp">    return numbers.filter(function (number) &#123;</span></span><br><span class="line"><span class="regexp">      return number % 2 === 0</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code>用来绑定事件监听器.<code>v-on</code>可以缩写成<code>@</code>.<br>在普通元素上,<code>v­-on</code>可以监听原生的DOM事件，除了<code>click</code>外，还有<code>dblclick</code>、<code>keyup</code>,<code>mousemove</code>等。<br>表达式可以是一个方法名，这些方法都写在Vue实例的methods属性内，并且是函数的形式，<br>函数内的<code>this</code>指向的是当前Vue实例本身，因此可以直接使用<code>this.xxx</code>的形式来访问或修改数据.</p>
<blockquote>
<p>如果方法中带有参数，但是没有加括号，默认传原生事件对象event</p>
</blockquote>
<h2 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h2><p>从2.6.0开始，可以用方括号括起来的JavaScript表达式作为一个指令的参数：<br><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code><br>方括号里的属性可以被替换.<br>可以使用动态参数为一个动态的事件名绑定处理函数：<br><code>&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</code><br>当 <code>eventName</code>的值为 “focus” 时,<code>v-on:[eventName]</code>将等价于 <code>v-on:focus</code>。</p>
<blockquote>
<p>动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在HTML特性名里是无效的。同样，在DOM中使用模板时你需要回避大写键名。</p>
</blockquote>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在Vue中传入event对象用<code>$event</code><br>修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。<br><code>.stop</code> 阻止单击事件冒泡 <code>&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</code><br><code>.prevent</code> 提交事件不再重载页面<br><code>.capture</code> 添加事件侦听器时使用时间捕获模式<br><code>.self</code> 只当事件在该元素本身（而不是子元素）触发时触发回调<br><code>.once</code>只执行一次的方法<br><code>.passive</code><br>Vue 还对应 addEventListener 中的 passive 选项提供了 <code>.passive</code>修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 <span class="string">`onScroll`</span> 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 <span class="string">`event.preventDefault()`</span> 的情况 --&gt;</span><br><span class="line">&lt;div v-on:scroll.passive=<span class="string">"onScroll"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p>
<blockquote>
<p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code>将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你不想阻止事件的默认行为。<br>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止所有的点击，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
</blockquote>
<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 只有在 <span class="string">`key`</span> 是 <span class="string">`Enter`</span> 时调用 <span class="string">`vm.submit()`</span> --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=<span class="string">"submit"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.page-down=<span class="string">"onPageDown"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，处理函数只会在 <code>$event.key</code> 等于 PageDown 时被调用。</p>
<h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><p>.ctrl<br>.alt<br>.shift<br>.meta<br>.exact</p>
<p>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.exact=<span class="string">"onClick"</span>&gt;A&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>用于在表单类元素上双向绑定<br>可以用于input框，以及textarea等<br>注意:所显示的值只依赖于所绑定的数据，不再关心初始化时的插入的value</p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"message"</span> placeholder=<span class="string">"edit me"</span>&gt;</span><br><span class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><p>将<code>v-model</code>绑定到<code>textarea</code>上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Multiline message is:&lt;/span&gt;</span><br><span class="line">&lt;p style=<span class="string">"white-space: pre-line;"</span>&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;br&gt;</span></span><br><span class="line"><span class="regexp">&lt;textarea v-model="message" placeholder="add multiple lines"&gt;&lt;/</span>textarea&gt;</span><br></pre></td></tr></table></figure>

<h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><ol>
<li>单个单选按钮，直接用v-­bind绑定一个布尔值，用v-­model是不可以的 </li>
<li>如果是组合使用，就需要v-­model来配合value使用，绑定选中的单选框的value值.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example-4"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"radio"</span> id=<span class="string">"one"</span> value=<span class="string">"One"</span> v-model=<span class="string">"picked"</span>&gt;</span><br><span class="line">  &lt;label <span class="keyword">for</span>=<span class="string">"one"</span>&gt;One&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;br&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input type="radio" id="two" value="Two" v-model="picked"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;label for="two"&gt;Two&lt;/</span>label&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-4'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>单个复选框,绑定到布尔值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"checkbox"</span> id=<span class="string">"checkbox"</span> v-model=<span class="string">"checked"</span>&gt;</span><br><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">"checkbox"</span>&gt;&#123;&#123; label &#125;&#125;&lt;<span class="regexp">/label&gt;</span></span><br></pre></td></tr></table></figure>

<p>多个复选框,绑定到同一个数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">'example-3'</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"checkbox"</span> id=<span class="string">"jack"</span> value=<span class="string">"Jack"</span> v-model=<span class="string">"checkedNames"</span>&gt;</span><br><span class="line">  &lt;label <span class="keyword">for</span>=<span class="string">"jack"</span>&gt;Jack&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;label for="john"&gt;John&lt;/</span>label&gt;</span><br><span class="line">  &lt;input type=<span class="string">"checkbox"</span> id=<span class="string">"mike"</span> value=<span class="string">"Mike"</span> v-model=<span class="string">"checkedNames"</span>&gt;</span><br><span class="line">  &lt;label <span class="keyword">for</span>=<span class="string">"mike"</span>&gt;Mike&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;br&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: "#example-3",</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    checkedNames: []</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><h4 id="单选下拉"><a href="#单选下拉" class="headerlink" title="单选下拉:"></a>单选下拉:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example-5"</span>&gt;</span><br><span class="line">  &lt;select v-model=<span class="string">"selected"</span>&gt;</span><br><span class="line">  <span class="comment">// 将v-model绑定到select上,data中selected使用空字符串</span></span><br><span class="line">    &lt;option disabled value=<span class="string">""</span>&gt;请选择&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">    &lt;option&gt;A&lt;/</span>option&gt;</span><br><span class="line">    &lt;option&gt;B&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">    &lt;option&gt;C&lt;/</span>option&gt;</span><br><span class="line">  &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: "#example-5",</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">      selected: ''</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="多选下拉"><a href="#多选下拉" class="headerlink" title="多选下拉:"></a>多选下拉:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example-6"</span>&gt;</span><br><span class="line">  &lt;select v-model=<span class="string">"selected"</span> multiple style=<span class="string">"width: 50px"</span>&gt;</span><br><span class="line">  <span class="comment">// 将v-model绑定到select上,data中selected使用空数组</span></span><br><span class="line">    &lt;option&gt;A&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">    &lt;option&gt;B&lt;/</span>option&gt;</span><br><span class="line">    &lt;option&gt;C&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>select&gt;</span><br><span class="line">  &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-6'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用v-for配合"><a href="#使用v-for配合" class="headerlink" title="使用v-for配合"></a>使用<code>v-for</code>配合</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;select v-model=<span class="string">"selected"</span>&gt;</span><br><span class="line">  &lt;option v-<span class="keyword">for</span>=<span class="string">"option in options"</span> v-bind:value=<span class="string">"option.value"</span>&gt;</span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>select&gt;</span><br><span class="line">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: "...",</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    selected: 'A',</span></span><br><span class="line"><span class="regexp">    options: [</span></span><br><span class="line"><span class="regexp">      &#123; text: 'One', value: 'A' &#125;,</span></span><br><span class="line"><span class="regexp">      &#123; text: 'Two', value: 'B' &#125;,</span></span><br><span class="line"><span class="regexp">      &#123; text: 'Three', value: 'C' &#125;</span></span><br><span class="line"><span class="regexp">    ]</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="绑定值"><a href="#绑定值" class="headerlink" title="绑定值"></a>绑定值</h3><ul>
<li>单选按钮<br>只需要用v-­bind给单个单选框绑定一个value值，此时,v­-model绑定的就是他的value值 </li>
<li>复选框 </li>
<li>下拉框<br>在select标签上绑定value值对option并没有影响<h3 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a>修饰符</h3><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lazy</td>
<td align="left">v-­model默认是在input输入时实时同步输入框的数据，而lazy修饰符，可以使其在失去焦点或者敲回车键之后再更新</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">将输入的字符串转化为number类型</td>
</tr>
<tr>
<td align="left">trim</td>
<td align="left">trim自动过滤输入过程中首尾输入的空格</td>
</tr>
</tbody></table>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/07/Vue-js基础/" data-id="ck3pu18e0000y0shainjdxpdz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue-js基础/">Vue.js基础</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/HTML基础/">HTML基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/HTTP基础/">HTTP基础</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML5/">HTML5</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML5/canvas/">canvas</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JS/ES6/">ES6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/JS基础/">JS基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/JS进阶/">JS进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/jQuery/">jQuery</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/前端工程化/">前端工程化</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/css/css3/">css3</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/Node-js/">Node.js</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP安全/">HTTP安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP进阶/">HTTP进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS深入/">JS深入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS进阶/">JS进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-SSR/">Vue-SSR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js基础/">Vue.js基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js进阶/">Vue.js进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试题/">面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目/">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTML/" style="font-size: 16px;">HTML</a> <a href="/tags/HTTP安全/" style="font-size: 10px;">HTTP安全</a> <a href="/tags/HTTP进阶/" style="font-size: 10px;">HTTP进阶</a> <a href="/tags/JS/" style="font-size: 12px;">JS</a> <a href="/tags/JS深入/" style="font-size: 10px;">JS深入</a> <a href="/tags/JS进阶/" style="font-size: 10px;">JS进阶</a> <a href="/tags/Vue-SSR/" style="font-size: 14px;">Vue-SSR</a> <a href="/tags/Vue-js/" style="font-size: 20px;">Vue.js</a> <a href="/tags/Vue-js基础/" style="font-size: 12px;">Vue.js基础</a> <a href="/tags/Vue-js进阶/" style="font-size: 18px;">Vue.js进阶</a> <a href="/tags/css/" style="font-size: 14px;">css</a> <a href="/tags/css3/" style="font-size: 10px;">css3</a> <a href="/tags/html5/" style="font-size: 14px;">html5</a> <a href="/tags/javascript/" style="font-size: 18px;">javascript</a> <a href="/tags/后端/" style="font-size: 12px;">后端</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/小程序/" style="font-size: 10px;">小程序</a> <a href="/tags/移动端/" style="font-size: 10px;">移动端</a> <a href="/tags/面试题/" style="font-size: 16px;">面试题</a> <a href="/tags/项目/" style="font-size: 14px;">项目</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/03/he/">he</a>
          </li>
        
          <li>
            <a href="/2019/11/28/虚拟dom/">虚拟dom</a>
          </li>
        
          <li>
            <a href="/2019/11/27/全栈开发后台资金管理系统项目/">全栈开发后台资金管理系统项目</a>
          </li>
        
          <li>
            <a href="/2019/11/27/cNode社区项目/">cNode社区项目</a>
          </li>
        
          <li>
            <a href="/2019/11/27/多人博客项目/">多人博客项目</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>