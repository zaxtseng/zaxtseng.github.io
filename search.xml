<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F08%2F22%2FjQuery%2F</url>
    <content type="text"><![CDATA[jQuery选择器 jQuery基本选择器 解释 $(‘*‘) 匹配所有元素 $(‘#id’) id选择器 $(‘.class’) 类选择器 $(‘element’) 标签选择器 组合选择器 解释 $(‘E,F’) 多元素选择器，同时匹配E和F $(‘E F’) 后代选择器,用空格分隔,匹配E元素所有后代 $(‘E&gt;F’) 子元素选择器,匹配E元素所有直接子元素 $(‘E+F’) 直接相邻子元素,匹配E元素之后的相邻的同级元素F $(‘E~F’) 普通相邻子元素(弟弟选择器),匹配E元素之后的同级元素F(无论是否直接相邻) $(‘class1.class2’) 匹配类名中既含有class1又含有class2的元素 基本过滤选择器 解释 $(‘E:first’) 所有E中的第一个 $(‘E:last’) 所有E中的最后一个 $(‘E:not(selector)’) 按照selector过滤E $(‘E:even’) 所有E中index是偶数 $(‘E:odd’) 所有E中index是奇数 $(‘E:eq(n)’) 所有E中index为n的元素 $(‘E:gt(n)’) 所有E中index大于n的元素 $(‘E:lt(n)’) 所有E中index小于n的元素 $(‘header’) 选择h1~h6元素 $(‘div:animated’) 选择正在执行动画效果的元素 内容过滤器 解释 $(‘E:contains(value)’) 内容包含value的元素 $(‘E:empty’) 内容为空的元素 $(‘E:has(F)’) 子元素中有F的元素,$(‘div:has(a)’):包含a标签的div $(‘E:parent’) 父元素是E的元素 可视化选择器 解释 $(‘E:hidden’) 所有被隐藏的E $(‘E:visible’) 所有可见的E 属性过滤选择器 解释 $(‘E[attr]’) 含有属性attr的E $(‘E[attr=value]’) 属性attr=value的E $(‘E[attr !=value]’) 属性attr！=value的E $(‘E[attr ^=value]’) 属性attr以value开头的E $(‘E[attr $=value]’) 属性attr以value结尾的E $(‘E[attr *=value]’) 属性attr包含value的E $(‘E[attr][attr*value]’) 可以连用 子元素过滤器 解释 $(‘E:nth-child(n)’) E的第n个子节点 $(‘E:nth-child(3n+1)’) E的第3n+1个子节点 $(‘E:nth-child(even)’) E的index为偶数的子节点 $(‘E:nth-child(odd)’) E的index为奇数的子节点 $(‘E:first-child’) 所有E的第一个子节点 $(‘E:last-child’) 所有E的最后一个子节点 $(‘E:only-child’) 只有唯一子节点的E的子节点 表单元素选择器 解释 $(‘E:type’) 特定类型的input $(‘:checked’) 被选中的checkbox或者radio $(‘option:selected’) 被选中的option 其他查找相关元素的方法.eq(index), .get([index])$(&#39;div&#39;).eq(3) //获取所有div中第4个jQuery对象$(&#39;div&#39;)[2] 或者 $(&#39;div&#39;).get(2) //获取第三个的DOM对象get()不写参数把所有对象转为DOM对象返回 兄弟元素获取 选择器 解释 .next([selector]) 没有写selcetor,返回所有后面的兄弟元素.写了就返回满足条件的 .prev([selector]) 和上面相反,获取前面的兄弟元素 .nextAll([selector]) 获取所有后面的兄弟元素 .prevAll([selector]) 获取所有前面的兄弟元素 .siblings([selector]) 获取所有前后邻居的元素 父子元素获取 选择器 解释 .parent([selector]) 获取父元素,可选筛选器 .parents([selector]) 获取祖先元素,可选筛选器 .children([selector]) 获取子元素,可选筛选器 .find([selector]) 查找符合选择器的后代 筛选当前结果集 选择器 解释 .first() 获取当前结果集第一个对象 .last() 获取当前结果集最后一个对象 .filter(slector), .filter(function(index)) 筛选当前结果集符合条件的对象 .not(selector), .not(function(index)) 从当前结果集中移除指定元素 .is(selector), is(function(index)), is(dom/jqObj) 判断结果集中的元素，是否为一个选择器，DOM元素，或者jQuery对象，如果这些元素至少一个匹配给定的参数，那么返回true .has(seletor), has(dom) 筛选匹配结果集中符合条件的后代元素 jQueryDOM操作创建元素将DOM传入$方法即可返回一个jQuery对象var obj = $(&#39;&lt;div class=&quot;test&quot;&gt;&lt;p&gt;&lt;span&gt;Done&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&#39;) 添加元素 方法 解释 示例 .append(content[,content]) / .append(function(index,html)) 可以添加多个内容,DOM对象,字符串,jQuery对象 $(‘p’).append($newdiv); $(‘p’).append($(‘strong’)); $(‘p’).append(document.createTextNode(‘hello’)) .appendTo(target) 把对象插入到目标尾部,可以是selector,DOM对象,字符串,元素集合,jQuery对象 $(‘h2’).appendTo($(‘.container’)); $(‘&lt;p&gt;Test&lt;/p&gt;’).appendTo(‘.inner’) .prepend(content[,content]) / .prepend(function(index, html)) 向头部追加内容,内容添加到最前面 $(‘.inner’).prepend(‘&lt;p&gt;Test&lt;/p&gt;’) .prependTo(Target) 把对象插入到目标头部 $(‘&lt;p&gt;Test&lt;/p&gt;’).prependTo(‘.inner’) .before([content][,content]) / .before(function) 在对象前面(不是头部,而是外面,和对象并列同级)插入内容 $(‘.inner’).before(‘&lt;p&gt;Test&lt;/p&gt;’); $(‘.container’).before($(‘h2’)); $( “p” ).before( document.createTextNode( “Hello” ) ) .insertBefore(target) 把对象插入到target之前(不是头部,是同级) $(‘h2’).insertBefore($(‘.container)) .after([content][,content]) / .after(function（index）) 和before相反，在对象后面(不是尾部，而是外面，和对象并列同级)插入内容，参数和append类似 $( “.inner” ).after( “&lt;p&gt;Test&lt;/p&gt;” ); $( “p” ).after( document.createTextNode( “Hello” ) ); .insertAfter(target) 和insertBefore相反，把对象插入到target之后（同样不是尾部，是同级） $( “&lt;p&gt;Test&lt;/p&gt;” ).insertAfter( “.inner” ); $( “p” ).insertAfter( “#foo” ); 删除元素 方法 解释 示例 .remove([selector]) 删除被选元素及其子元素 $(‘.div’).remove() .empty() 清空被选元素内所有子元素 $(‘body’).empty() .detach() .detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。 $(‘.div’).detach() 包裹元素 方法 解释 示例 .wrap(wrapElement) / .wrap(function(index)) 为每个对象包裹一层HTML结构，可以是selector, element, HTML string, jQuery object $( “.inner” ).wrap( “&lt;div class=’new’&gt;&lt;/div&gt;” ) .wrapAll(wrappingElement) 把所有匹配对象包裹在同一个html结构里 $(‘.inner’).wrapAll(‘&lt;div class=”new”&gt;&lt;/div&gt;) .wrapInner(wrapingElement) 为每个匹配的对象包裹一层HTML结构 $(‘.inner’).wrapInner(‘&lt;div class=”new”&gt;&lt;/div&gt;) .unwrap 把DOM元素外的壳去掉 $(‘p’).unwrap() html([string])$(&#39;div&#39;).html()$(&#39;div&#39;).html(&#39;123&#39;)这是一个读写两用的方法,用于获取修改元素的innerHTML 没有传递参数的时候,返回元素的innerHTML 当传递一个string参数时,修改元素的innerHTML为参数值 text()和html方法类似，操作的是DOM的innerText值 jQuery属性操作属性相关.val([value])这是一个读写双用的方法,用来处理input的value值,当方法没有参数时返回input的value值.当传递一个参数时,方法修改input的value值为参数值. 12$('.input').val()$('.input').val('newValue') .attr().attr(attributeName)获取元素特定属性的值var title = $(&#39;em&#39;).attr(&#39;title&#39;) .attr(attributeName,value)/.attr(attributesJson)/.attr(attributeName,funtion(index,attr))为元素属性赋值$( &quot;#greatphoto&quot; ).attr( &quot;alt&quot;, &quot;Beijing&quot; ) .removeAttr()为匹配的元素集合中的每个元素移除一个属性$(&#39;div&#39;).removeAttr(&#39;id&#39;) .prop()/.removeProp()这两个方法是用来操作元素的property的 CSS相关.css().css(propertyName) / .css(propertyNames)获取元素style特定property的值 12345678var color = $( this ).css( "background-color" )var styleProps = $( this ).css([ "width", "height", "color", "background-color"]) .css(propertyName,value) / .css(propertyName, function(index, value)) / .css(propertiesJson)设置元素style特定property的值 123456789101112$( "div.example" ).css( "width", function( index ) &#123; return index * 50;&#125;)$( this ).css( "width", "+=200" )$( this ).css( "background-color", "yellow" )$( this ).css(&#123; "background-color": "yellow", "font-weight": "bolder"&#125;) .addClass(className) / .addClass(function(index,currentClass))为元素添加class，不是覆盖原class，是追加，也不会检查重复 12345$( "p" ).addClass( "myClass yourClass" )$( "ul li" ).addClass(function( index ) &#123; return "item-" + index;&#125;) .removeClass([className])/.removeClass(function(index,class))移除元素单个/多个/所有class 12345$( "p" ).removeClass( "myClass yourClass" );$( "li:last" ).removeClass(function() &#123; return $( this ).prev().attr( "class" );&#125;) .hasClass(className)检查元素是否包含某个class，返回true/false 1$( "#mydiv" ).hasClass( "foo" ) .toggleClass(className)toggle是切换的意思，方法用于切换，switch是个bool类型值 123456789&lt;div class="tumble"&gt;Some text.&lt;/div&gt;//第一次执行 $( "div.tumble" ).toggleClass( "bounce" )&lt;div class="tumble bounce"&gt;Some text.&lt;/div&gt;//第二次执行$( "div.tumble" ).toggleClass( "bounce" )&lt;div class="tumble"&gt;Some text.&lt;/div&gt; jQuery常用方法.each(fnction(index, Element))遍历一个jQuery对象,为每个匹配元素执行一个函数 12345$('li').each(function(index)&#123; console.log(index + ':' + $(this).text())&#125;)//回调函数返回的是DOM对象,所以this需要加$变成jQuery对象才能使用.text()方法//否则使用this.innerText方法 jQuery.each(collection, callback(indexInArray, valueOfElement))一个通用迭代函数,可以迭代对象和数组.数组和类数组对象通过长度属性来迭代数字索引,从0到length-1.其他对象通过其属性名进行迭代.上面jQuery可以用$替代,即$.each(). 1234567var obj = &#123; "fla" : "infla", "duh" : " no duh"&#125;$.each(obj, function(key, value)&#123; console.log(key + ":" + value)&#125; .map(callback(index, domElement))通过一个函数匹配当前集合中的每个元素,返回一个包含新的jQuery对象 123$('.div').map(function(i, ele)&#123; return this.id&#125;) jQuery.extend([deep,]target[,ovject1][,objectN]) 当提供两个或多个]]></content>
      <categories>
        <category>JS</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F21%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[cookie存储信息到浏览器，可以用js设置，也可以在服务器端通过set-cookie让浏览器种下cookie，存在于响应头里。每次请求都会带上cookie，最大容量4k用途：记录用户名设置cookie时的参数： path: cookie影响到的路径，匹配该路径才发送cookie expires和maxAge:告诉浏览器cookie多久过期不设置就会产生session cookie，当关闭浏览器，cookie就被清除 secure: 为true时，在http无效，在https生效 httpOnly: 浏览器不允许通过js修改cookie session用来保存状态。当用户输入用户名密码提交给服务器后，服务器验证通过后创建session用于记录用户信息，session可保存在服务器，也可以保存在数据库 创建session后，会把关联的session_id通过是set-cookie添加到响应头 浏览器加载页面发现有set-cookie，就把这个cookie种到指定域名下 下次刷新页面，发送的请求带上cookie，服务器接受后根据session_id来识别用户 localStorage 本地存储，永不过期，除非手动js删除。5M大小。 不参与网络传输 一般用于性能优化 ajaxajax是一种技术方案，核心依赖浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出http请求与接受响应。 如何与后端交互 form表单提交.缺点会跳转，无后台反馈 ajax websocket 实现方法 XMLHttpRequest对象 fetch 范例123456789101112var xhr = new XMLHttpRequst() xhr.open("get", "/xxx.com") xhr.onreadystate = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; //成功 console.log(xhr.responseText) &#125; else &#123; console.log("服务器异常") &#125; &#125; xhr.send() API123456789101112131. let request = new XMLHttpRequest();2. request.open('GET','/xxx') //初始化request3. request.send() //发送请求4. request.onreadystatechange //监听请求状态的变化5. request.readyState === 1 //request.open()已经完成6. request.readyState === 2 //request.send()已经完成7. request.readyState === 3 //request.responseText正在下载5. request.readyState === 4 //响应完成6. request.status //HTTP状态码7. var string = request.responseText //响应的内容8. var value = JSON.parse(request.responseText) //把符合JSON语法的字符串转换成JS，解析响应返回的内容9. value.node //若value是对象，这就是对象里内容10. value.node.name //对象里的name的值 post形式需要将数据放入到send中 跨域同源策略同协议，域名，端口 实现跨域的方法JSONPJSON with padding 通过script标签加载数据的方式获取数据当做js代码来执行。jsonp需要对应接口的后端配合才可以实现。 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; "ip": "8.8.8.8"&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 必考面试题：JSONP为什么不支持POST请求答：因为JSONP是通过动态创建script的方法进行的，而script只能发送get请求不能发送post请求。 jquery的写法123456789$.ajax(&#123; url:"http://jack.com:8002/pay", dataType: "jsonp", success:function (response) &#123; if(response === 'success')&#123; amount.innerText = amount.innerText-1; &#125; &#125; &#125;) CORS跨域资源共享，是一种ajax跨域请求资源的方式。当使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给请求加一个请求头:Origin。后台进行处理，如果确定接受请求，则在返回结果中加响应头：Access-Control-Allow-Origin。浏览器判断该响应头中是否包含Origin的值，如果有，浏览器会处理响应，就可以拿到响应数据。 postMessage A页面1234567891011121314151617181920componentDidMount() &#123; window.addEventListener('message', this.receiveMessage, false) const iframeImg = this.iframe.contentWindow iframeImg.onload = function() &#123; iframeImg.postMessage('message', 'http://www.blogoog.com:8088') &#125;&#125;receiveMessage = (event) =&gt;&#123; const origin = event.origin || event.originalEvent.origin const thisData = JSON.parse(event.data) const imgUrl = Object.values(thisData) this.setState(&#123; imgUrl &#125;) setTimeout(() =&gt;&#123; this.closeIframe(); message.success('上传成功') &#125;,1000) if (origin !== 'http://www.blogoog.com:80881) &#123; window.location.hash = '#/exception/404' &#125;&#125; 123&lt; iframe className = &#123; styles.iframeWrap &#125;src="http://www.blogoog.com:8088" name="imgIframe" frameBorder="0" scrolling="auto" ref=&#123;dom =&gt; &#123;this.iframe = dom &#125;&#125;&gt;您的浏览器不支持iframe&lt;/iframe&gt; A页面使用的语法 window.postMessage()otherWindow.postMessage(message, targetOrigin, [transfer]) otherWindow：其他窗口的一个引用（在这里我使用了iframe的contentWindow属性） message：将要发送到其他window的数据（可以不受限制的将数据对象安全的传送给目标窗口而无需自己序列化，原因是因为采用了结构化克隆算法） targetOrigin：接收信息的URL（在这里我当然填的B页面的URL） transfer：可选参数 window.addEventListener(‘message’, receiveMessage, false)target.addEventListener(type, listener, options) type：表示监听事件类型的字符串 listener：当所监听的事件类型触发时，会通知的一个对象或者一个函数 potions：可选参数（在此我用false，表示在listener被调用之后不会自动移除） receiveMessage = (event) =&gt; {} event.data：从另一个window传递过来的对象（包含传递过来的所有信息） event.origin||event.originalEvent.origin：window.postMessage()发送消息的目标URL event.source：对发送消息的窗口对象的引用注意点！！！ 在页面内嵌入iframe页面的情况下，需要等到页面内的iframe页面，也就是B页面加载完成之后，才能进行postMessage跨域通信 event.origin中的origin不能保证是该窗口的当前origin或者未来origin，因为postMessage被调用后，可能会被导航到不同的位置，所以需要做个异常情况判断处理origin !== &#39;http://www.blogoog.com:8088&#39; B页面 123456789101112created() &#123; window.addEventListener&#123;"message", this.receiveMessage, false) &#125;,receiveMessage(e) &#123; if (e origin === 'http://www.blogoog.com:8080' || e.origin === 'http://www.blogoog.com:8088') &#123; this.sendBtnShow = true this.originSource = e.origin this.magicBuildData = JSON.parse(e.data) &#125;, sendMsg() &#123; top.postMessage(JSON.stringify(data), 'http://www.blogoog.com:8000') &#125; B页面使用到的语法top.postMessage(&#39;data&#39;, &#39;http://www.blogoog.com:8000&#39;)参考上面A页面的语法为什么用top而不用window下面再讲window.addEventListener(&#39;message&#39;, receiveMessage, false)参考上面A页面的语法receiveMessage = (event) =&gt; {}参考上面A页面的语法 window.postMessage()中的window到底是啥？始终是你需要通信的目标窗口 A页面中：A页面向B页面发送跨域信息，window就是在A页面中嵌入的iframe指向的B页面的window，即：iframe.contentWindow B页面中：B页面想A页面发送跨域信息，window就是A页面的window，在这里因为B页面时嵌入到A页面中的，对于B页面来讲，window就是top或者parent需要特别注意的坑 一定要等A页面嵌入的B页面加载完成之后，再进行postMessage跨域通信 一定要对origin做判断，去掉不是来自我们目标窗口的origin，防止来自其他origin的攻击 着重注意window.postMessage()中window的用法，明确目标窗口的window]]></content>
      <categories>
        <category>JS</category>
        <category>HTML基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础]]></title>
    <url>%2F2019%2F08%2F19%2FJS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据类型number, boolean, string, undefined, null, object, symbol原始类型，number, string, boolean。指保存在栈内存里的简单数据段引用类型，对象。又可分为狭义的对象，数组，函数，正则。指保存在堆内存中的对象typeof undefined 输出 undefinedtypeof null 输出 object 运算符 &amp;&amp; (And) || (or) ! (not) == 和 ===，前者先转化类型，后进行判断，后者比较类型和值 三元运算符condition ? true case : false case boolean值false: undefined null 0 NaN 空字符串 JS函数函数会声明前置 1234foo() //hellofunction foo()&#123; return "hello"&#125; 函数表达式不会 1234fn()//报错var fn() = fnction()&#123; return "hello" &#125; 深拷贝js对象查看所有属性 12var objects = &#123; p: 1&#125;Object.keys(obj) 删除命令delete object.p 循环判断 12345678910switch(判断语句）&#123; case 条件： 输出; break; case 条件: 输出; break; default: 输出&#125; while循环 12345while(expression)&#123; statement&#125;//如果expression为true，执行，//循环继续执行直到判断不成立。 do-while循环 1234do&#123; statement;&#125;while(expression);//先执行，够判断 for循环 break退出本次循环continue跳过本次循环执行下次循环 字符串12str.charAt(0) //获取第一个字符str.charCodeAt(0) //获取字符对应的ASC码 字符串截取 1234var str= "hello"str.substr(1,3) //第一个开始，第二个长度str.substring(1,3) //第一个开始，第二个结束str.slice(1,3) //同上，允许负参 查找 1234str.search("he") //返回下标strong.indexOf("he") //同上str.replace("he", "you") //替换str.match("he") //匹配 大小写 12str.toUpperCase()str.toLowerCase() //本身不变化 数组1234567891011121314151617181920212223242526272829303132333435arr.push(newelement) //末尾新增一个arr.pop() //末尾踢出一个字arr.shift() //开头拿出一个arr.unshift() //开头新增一个arr.splice(index,替换几个，替换内容) //原数组变//返回由删除元素组成的新数组arr.slice(start，end) //原数组不变arr.join("-") //将数组变成字符串并用-连接arr.reverse() //数组反转arr.sort(v1-v2) //没有参数按顺序排列，但是会出现10,11,7,8,9排列，//有参数设置比较函数，函数结果v1-v2如果大于0，两两替换位置。否则，不变a.concat(array) //拼接，返回数组a和array的集合。原数组不变Array.isArray(obj) //判断传入的obj是不是数组a.indexof(2) //判断数组a中是否含有2,返回其索引a.forEach(fn(element,index,arr)&#123;&#125;)//forEach里是一个回调函数，有三个参数，分别是当前元素，索引值，整个数组a.map(fn(element)&#123;&#125;)//与forEach类似，返回新数组，原数组不变//而forEach会修改原数组a.every(fn(element,index,arr)&#123;&#125;)//every是所有函数返回true才会返回true，遇到false终止，并返回falsea.some(fn(element,index,arr)&#123;&#125;)//some是存在一个返回true时就终止返回truea.filter(fn(element)&#123;&#125;)//返回新数组，回调函数用于逻辑判断，为true则把当前元素加到返回的数组中//为false则不加a.reduce(fn(v1,v2),value)//将数组元素合成一个值，从索引值最小开始。value表示初始值a.abs(x) //返回x的绝对值 Math四舍五入 12Math.round(0.5)//1Math.round(-1.5)//-1 绝对值 1Math.abs(-1) //1 1234floor返回小于参数值的最大整数.向下取整Math.floor(-3.2) //-4ceil返回大于参数值的最小参数，向上取整Math.ceil(-3.2) //-3 parseInt(值，进制) 123parseInt(string,radix)//将一个字符串 string 转换为 radix 进制的整数，// radix 为介于2-36之间的数。 parseInt()可以将字符串转为数字，也可以将数字取整。向下取整。radix不写默认是2进制.如果第一个字符是数字会解析直到遇到非数字结束，如果第一个字符不是数字或者符号（如：+、-）就返回NaN。带自动净化功能；带自动截断小数功能，且取整，不四舍五入。 几次方 12Math.pow(x,y) //返回 x 的 y 次幂的值。Math.pow(2,2) //4 平方根 12Math.sqrt(4) // 2Math.sqrt(-4) //NaN random 12Math.random()//返回0-1之间的伪随机数.0≦x&lt;1 Date123Date.now() //获取1970年至今的毫秒数Date.parse() //解析日期字符串，返回距离1970年的毫秒数Date.parse("2011-01-11") //13234436600000 1234567new Date() //使用Date构造函数创建一个Date实例，//不传时间就返回当前时间的字符串var str = "2019-01-11"new Date(str) //Fri Jan 11 2019 08:00:00 GMT+0800 (香港标准时间)//获取的是东八区8点的时间，因为格林尼治时间伦敦是0点 get方法 12345678getDate() //日getDay() //星期几，周日是0，周一是1getFullyear() //返回四位的年份getMouth() //返回月份，一月是0，腊月是11getHours() //小时（0-23）getMinutes() // 返回分钟getSenconds() // 秒getMilliseconds() // 毫秒(0-999) set方法类似于get方法，是设置时间 node.js基础 12345678910node index.js //启动服务器index.js文件中引入http模块var http = require("http") //引入http模块var server = http.creatserve(fn(res,req))//创建服务器response.end() //结束server.listen(9000) //启动服务器，监听9000端口res.setHeader("Content-Type", "text/plain; chartset=gbk")//设置响应头res.writeHead(200,"ok") //设置状态码console.log("open http://localhost:9000") 进阶 12345678910111213141516171819202122232425262728293031323334var http = require("http") //引入http模块var path = require("path") //自动处理路径问题var fs = require("fs") //读写文件var url = require("url") //解析urlfunction staticRoot(staticPath, req, res)&#123; var pathObj = url.parse(req.url, true) //url.parse是node.js方法，将一个URL字符串转换成对象并返回 console.log(pathObj) if(pathObj.pathname === "/")&#123; pathObj.pathname += "index.html" &#125; //不加后缀可以默认加后缀var filePath = path.join(staticPath, pathObj.pathname)//拼接文件地址fs.readFile(filePath, "binary", function(err, fileContent)&#123; if(err)&#123; res.writeHead(404, "not found") res.end("&lt;h1&gt;404 Not Found&lt;/h1&gt;")&#125;else&#123; res.writeHead(200, "ok") res.write(fileContent, "binary") res.end() &#125;&#125;)console.log("path.join(_dirname, "static")var server = http.createServer(function(res,req)&#123; staticRoot(path.join(__dirname, "static"), req, res) //__dirname代表当前文件server.listen(8080)console.log("visit http://localhost:8080") 异步和回调函数节流，在时间内，如果执行，就重新开始原理：当达到了一定的时间间隔就会执行一次；可以理解为是缩减执行频率 12345678910111213function throttle(fn,delay)&#123; const timer = null return function()&#123; clearTimeout(timer) timer = setTimeout(function()&#123; fn(arguments) &#125;,delay) &#125;&#125;function fn()&#123; console.log("hello")&#125;var fn2 = throttle(fn, 1000) 函数防抖原理：将若干函数调用合成为一次，并在给定时间过去之后，或者连续事件完全触发完成之后，调用一次(仅仅只会调用一次) 12345678910111213function debounce(fn,ms)&#123; let timer = null return function()&#123; clearTimeout(timer) timer = setTimerout(()=&gt;&#123; fn() &#125;,ms) &#125;&#125;Function _log()&#123; console.log(1)&#125;Window.onscroll = debounce(_log,500) 区别 他们的区别在于防抖只会在连续的事件周期结束时执行一次，而节流会在事件周期内按间隔时间有规律的执行多次。 DOM元素创建和选取DOM是文档对象模型，是html的编程接口readyState加载状态 1234567891011document.location//location属性返回一个只读对象，提供当前文档的url信息document.location.href //获取urldocument.location.protocol //获取"http:"document.location.hostname // "www.example.com"document.location.port // "4097" document.location.pathname // "/path/a.html"document.location.assign("http://www.Google.com") //跳转到指定网址document.location.reload(true) //优先从服务器重新加载document.location.reload(false) //优先从本地缓存加载 123document.open() //新建文档可以使用write写入document.close() //关闭文档document.write() //写入文档 Element表示html元素 element的属性： nodeName: 元素标签名 nodeType:元素类型 className:类名 id:元素id children:子元素列表 childNodes: 子元素列表（NodeList） firstChild: 第一个子元素 lastChild:最后一个 nextSibling: 下一个兄弟元素 previousSibling: 上一个兄弟元素 parentNode.parentElement: 父元素 查询元素 12345678910111213document.getElementById("target")document.getElementsByClassName("box")//上述为ES3写法//下面是ES5写法document.querySelector(".box")document.querySelector("#tatget")//多个元素只会选择第一个//选择多个document.querySelectorAll("div")//浏览器控制台测试时可以用$替代document.querySelector//用$$替代document.querySelectorAll 创建元素 1234567document.createElement("div")//生成文本节点document.createTextNode("Hello")//生成DocumentFragment对象document.createDocumentFragment()//存在于内存中的DOM片段，不属于当前文档。//对它的任何改动，都不会引发网页的重新渲染 修改元素 1234567891011121314151617在元素末尾添加元素appendChild()newDiv.appendChild(newContent)在元素之前插入元素insertBefore()替换元素replaceChild(newElement,oldElement)删除元素parentNode.removeChild(childNode)clone元素node.cloneNode(true)//方法有一个布尔值，传入true时会深拷贝，//复制元素及其子元素，false只会复制元素本身 DOM元素属性123456789101112获取属性node.getAttribute("id")生成新的属性对象节点attribute = document.createAttribute(name)一般用 setAttribute()设置元素属性var node = document.getElementById("id")node.setAttribute("id", "newVal")删除属性节点node.removeAttribute("id") innerText可写属性，返回元素内包含的文本内容，在多层次的时候按照元素由浅到深的顺序拼接内容123456&lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 外层div的innerText返回内容是 &quot;123456&quot; innerHTML返回元素html结构，在写入的时候也会自动构建DOM 样式修改样式 1document.querySelector("p").style.color = "red" 获取样式getComputedStyle 1234var node = document.querySelector('p') var color = window.getComputedStyle(node).color console.log(color)//获取计算后的样式，只读。全局属性 class操作的增删改查123456var nodeBox = document.querySelector(".box")console.log(nodeBox.classList)nodeBox.classList.add("active") //新增classnodeBox.classList.remove("active") //删除nodeBox.classList.toggle("active") //新增删除切换node.classList.contains("active") //判断是否拥有class 页面宽高 12345clientWidth() //包括paddingoffsetHeight() //包括borderscrollHeight() //滚动内容的总高度scrollTop() //滚动的高度innerHeight() //窗口的高度 事件捕获阶段，目标阶段，冒泡阶段 事件绑定12345678&lt;input id="btnClick" type="button" value="Click here"&gt; &lt;script type="text/javascript"&gt;var btnClick = document.getElementById("btnClick")btnClick.onclick = function showMessage()&#123; alert(this.id)&#125;&lt;/script&gt; 会存在覆盖 DOM2事件处理(升级版) addEventListener //绑定事件 removeEventListener //解绑事件 所有DOM节点都包含这两个方法，且都接受三个函数： 事件类型 事件处理方法 布尔参数，true表示在捕获阶段调用，false表示在事件冒泡阶段处理，默认是冒泡阶段123btnClick.addEventListener("click", function()&#123; alert(this.id)&#125;, false) 不存在覆盖，可以写多个方法 属性方法123preventDefault() //取消默认事件行为stopPropagation() //取消事件进一步捕获或冒泡target() //事件的目标元素 事件代理使用事件代理来实现它，监听的元素应该是这些元素的父元素，当我点击父元素内的元素时，父元素都会得到响应，并分发相应的事件。 e.target就是点击的元素。 1234567$('.container').onclick = function(e)&#123; console.log(this) console.log(e.target) if(e.target.classList.contains('box'))&#123; console.log(e.target.innerText) &#125; &#125; 常见事件及自定义事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950鼠标事件clickdblclick //双击左键mouseover //鼠标放上mouseout //鼠标移出mouseenter //类似over，区别不计算子元素mouseleave //类似out，区别不计算子元素mousedown //鼠标按下mouseup //鼠标松开触摸事件touchstarttouchendtouchmove键盘事件keyup //按键后松开触发keydown //按键即会触发keypress //按下松开页面相关事件onload //加载完成时触发onmove //浏览器窗口被移动scroll //滚动条滚动resize //窗口大小变化表单相关focus //获取焦点blur //失去焦点change //失去焦点且内容发生改变reset //reset属性被激活submit //提交，一般是表格提交input //在input元素内容修改后立即触发onload //页面所有资源加载完成DOMContentLoaded //dom结构解析完成编辑事件beforecopy //复制之前beforecut //剪切之前beforepaste //粘贴之前beforeeditfocus //将要进去编辑状态contextmenu //按右键出现菜单或者键盘触发页面菜单losecapture //失去鼠标移动所形成的选择焦点select //被选择时拖动事件drag //某个对象被拖动dragdrop //外部对象被拖到当前窗口dragend //拖动结束dragenter //被拖动对象进入其容器范围 自定义事件123456789101112131415var EventCenter = &#123; on: function(type, handler)&#123; document.addEventListener(type, handler) &#125;, fire: function(type, data)&#123; return document.dispatchEvent(new CustomEvent(type, &#123; detail: data &#125;)) &#125; &#125; EventCenter.on('hello', function(e)&#123; console.log(e.detail) &#125;) EventCenter.fire('hello', '你好') //一个监听函数，一个处理函数 JS动画requestAnimationFrame可以在一定时间内自动执行 123456789function move()&#123; if(moveOffset &lt; offsetX)&#123; ball.style.left = parseInt(getComputedStyle(ball).left) + step +"px" moveOffset += step requestAnimationFrame(move) &#125;&#125;move() BOMbom指浏览器对象模型，核心是window对象。是浏览器的实例window.innerHeight属性，window.innerWidth属性.这两个属性返回网页的CSS布局占据的浏览器窗口的高度和宽度，单位为像素。很显然，当用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。 注意，这两个属性值包括滚动条的高度和宽度。 scrollX：滚动条横向偏移 scrollY：滚动条纵向偏移 这两个值随着滚动位置变化而变化 window.frames返回一个类似数组的对象，成员为页面内的所有框架，包括frame元素和iframe元素。需要注意的是，window.frames的每个成员对应的是框架内的窗口（即框架的window对象），获取每个框架的DOM树，需要使用window.frames[0].document。 12var iframe = window.getElementsByTagName("iframe")[0];var iframe_title = iframe.contentWindow.title; 上面代码用于获取框架页面的标题。 iframe元素遵守同源政策，只有当父页面与框架页面来自同一个域名，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。在iframe框架内部，使用window.parent指向父页面。 navigator指向一个包含浏览器相关信息的对象. window.getComputedStylegetComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值 1var style = window.getComputedStyle("元素", "伪类") URL的编码/解码方法JavaScript提供四个URL的编码/解码方法。 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 区别 encodeURI方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!@#$&amp;*()=:/,;?+' encodeURIComponent方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!*()' alert()，prompt()，confirm()alert()、prompt()、confirm()都是浏览器用来与用户互动的方法。它们会弹出不同的对话框，要求用户做出回应。 需要注意的是，alert()、prompt()、confirm()这三个方法弹出的对话框，都是浏览器统一规定的式样，是无法定制的。]]></content>
      <categories>
        <category>JS</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
