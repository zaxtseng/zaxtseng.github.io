<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React-CommentBox]]></title>
    <url>%2F2020%2F05%2F08%2FReact-CommonBox%2F</url>
    <content type="text"><![CDATA[综合实例-留言本]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React入门]]></title>
    <url>%2F2020%2F05%2F05%2FReact%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[React特点 声明式写法 组件化 可开发多种任务 开发环境官方脚手架 creat-react-app需求: node &gt; 6.0安装命令npm install create-react-app创建命令create-reate-app my-project运行命令npm start 文件入口/src/App.js 书写格式src下新建一个组件Demo.js 123456789101112//src/Demo.js//引入reactimport React from 'react'//新建类classclass Demo extends React.Component &#123; //render方法渲染 render() &#123; return &lt;h1&gt; Hello React &lt;h1&gt; &#125;&#125;export default Demo 组件挂载将组件挂载到ReactDOM节点上 123456//index.jsimport React from 'react'import ReactDOM from 'react-dom'import Demo from './Demo'ReactDom.render(&lt;Demo /&gt;, document.getElementById('root')) JSXjavascript语法扩展.在花括号{}中可以添加任意js的表达式(expressions). 12345678910111213141516171819202122//Demo.jsimport React from 'react'class Demo extends React.Component&#123; render() &#123; const todoList = ['Learn React', 'Learn Redux'] return ( &lt;div&gt; &lt;h1&gt;Hello React&lt;/h1&gt; &lt;ul&gt; &#123; todoList.map(item =&gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt; ) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default Demo JSX实质JSX是语法糖–React.createElement()JSX返回ReactElement对象 Props/State/FormsProps(属性) 组件像函数一样,接受特定的输入(props),产生特定的输出(React Elements) V = f(props) props像纯函数一样,只读,不可变化示例:1234567891011121314151617181920212223import React from 'react'class NameCard extends React.Component&#123; render()&#123; const &#123;name, number, isHuman, tags &#125; = this.props return ( &lt;div&gt; &lt;h4&gt;&#123;name&#125;&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;电话: &#123;number&#125;&lt;/li&gt; &lt;li&gt;&#123; isHuman ? '人类' : '外星人' &#125;&lt;/li&gt; &lt;hr/&gt; &lt;p&gt; &#123; tags.map((tag,index) =&gt; ( &lt;span key=&#123;index&#125;&gt;&#123;tag&#125;&lt;/span&gt; ))&#125; &lt;/p&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default NameCard 函数写法1234567891011121314151617181920const NameCard = (props) =&gt; &#123; render()&#123; const &#123;name, number, isHuman, tags &#125; = this.props return ( &lt;div&gt; &lt;h4&gt;&#123;name&#125;&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;电话: &#123;number&#125;&lt;/li&gt; &lt;li&gt;&#123; isHuman ? '人类' : '外星人' &#125;&lt;/li&gt; &lt;hr/&gt; &lt;p&gt; &#123; tags.map((tag,index) =&gt; ( &lt;span key=&#123;index&#125;&gt;&#123;tag&#125;&lt;/span&gt; ))&#125; &lt;/p&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; State(状态) 组件内部的数据可以动态改变 this.setState()是更新state的唯一途径示例:LikesButton1234567891011121314151617181920212223242526272829//cpmponents/LikesButton.jsimport React from 'react'class LikesButton extends React.Component ( constuctor(props)&#123; super(props) this.state = &#123; likes: 0 &#125; //如果未使用箭头函数说明this,需绑定this this.increaseLikes = this.increaseLikes.bind(this) &#125; render()&#123; return ( &lt;div&gt; &lt;button type="button" // 函数要使用驼峰式,最好使用箭头函数,否则this指向不明 onClick = &#123; ()=&gt; &#123; this.increaseLikes() &#125;&#125; &gt; 点赞 &#123;this.state.likes&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;)export default LikesButton 生命周期 组件初始化 组件更新 组件卸载 示例: 电子钟表12345678910111213141516171819202122232425262728293031323334//components/DigitalClock.jsimport React from 'react'class DigitalClock extends React.Component &#123; constructor(props)&#123; super(props) this.state = &#123; //初始值 date: new Date() &#125; &#125; //挂载后使用定时器更新时间 componentDidMount()&#123; this.timer = setIntervalo(() =&gt; &#123; this.setState(&#123; date: new Date() &#125;) &#125;,1000) &#125; //结束时,卸载 componentWillUnmount()&#123; clearInterval(this.timer) &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.date.toLocalTimeString()&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default DigitalClock Forms表单受控组件和非受控组件受控组件: React控制输入的表单元素 实例: 留言框 123456789101112131415161718192021222324252627282930313233343536373839404142//CommentBox.jsimport React from 'react'class CommentBox extends React.Component &#123; constuctor(props)&#123; super(props) this.state = &#123; value: '' &#125; this.handleChange = this.handleChange.bind(this) this.handleSubmit = this.handleSubmit.bind(this) &#125; handleChange(event)&#123; this.setState(&#123; value: event.target.value &#125;) &#125; handleSubmit(event)&#123; alert(this.state.value) event.preventDefault() &#125; render()&#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;div&gt; &lt;label&gt;留言内容&lt;/label&gt; &lt;input type="text" placeholder="请输入内容" onChange = &#123; this.handlechange &#125; value = &#123; this.state.value&#125; /&gt; &lt;/div&gt; &lt;button type="submit"&gt;留言&lt;/button&gt; &lt;/form&gt; ) &#125;&#125;export default CommonBox 非受控组件写法将真实数据保存在DOM中 1234567891011121314151617181920212223242526272829303132//CommentBox.jsimport React from 'react'class CommentBox extends React.Component &#123; constuctor(props)&#123; super(props) this.handleSubmit = this.handleSubmit.bind(this) &#125; handleSubmit(event)&#123; alert(this.textInput.value) event.preventDefault() &#125; render()&#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;div&gt; &lt;label&gt;留言内容&lt;/label&gt; &lt;input type="text" placeholder="请输入内容" ref = &#123;(textInput) =&gt; &#123;this.textInput = textInput&#125;&#125; /&gt; &lt;/div&gt; &lt;button type="submit"&gt;留言&lt;/button&gt; &lt;/form&gt; ) &#125;&#125;export default CommonBox]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[taichi]]></title>
    <url>%2F2019%2F12%2F20%2Ftaichi%2F</url>
    <content type="text"><![CDATA[what is TaiChi?TaiChi is a framework that can use Xposed modules. Modules can change the behavior of systems and applications through it. TaiChi App can run without needing to root, unlock the bootloader; and it supports Android 5.0 ~ 10. In simple terms, TaiChi is an Xposed-like framework, which can load Xposed modules, modify the system and APP, intercept methods, and execute hook logic. Relationship with Xposed TaiChi is an Xposed-like framework, but it has nothing to do with Xposed itself. The only thing that might be related is that TaiChi is compatible with the Xposed modules. Besides, the two are completely different in design thinking, implementation mechanism, and operation logic. Here are some unique features of TaiChi: 1. TaiChi can support Android 10. 2. TaiChi can run in your device with no rooting, no flashing, no hassle. 3. TaiChi does not affect the overall situation. You can enable the Xposed function only for a specific application, and it does not need to use the Xposed app to run as if the system does not have Xposed; this means that TaiChi can easily pass SafetyNet. 4. detection and perfectly fit some financial / banking / exotic apps. 5. In most cases, the modules in TaiChi will take effect immediately without restarting. 6. TaiChi is more difficult to detect. The weakly invasive nature of TaiChi no longer modifies the ART runtime and leaves no trace in the global environment; therefore, if you want to do it, you can easily escape the detection of various code types. How to use TaiChi? TaiChi has two working modes: non-root mode and magisk mode. If you don't want to unlock the bootloader/flash system images, the non-root mode is perfect for you, if you want more control over the system, you can try magisk mode. What is the difference between non-root mode and magisk mode? The only different support is that the magisk mode can modify the system, so it can support more modules; such as Greenify / CorePatch, etc. However, Magisk mode requires unlocking the bootloader and installing Magisk, while non-root mode only requires installing a simple APP (TaiChi). Non-Root mode 1. Click on the floating button in the bottom right corner of the TaiChi Homepage, and then click on the button Create App in the pop-up menu. 2. Select the APP you want to apply Xposed modules in the app selection interface, such as SnapChat. 3. Then click on the Create button and wait patiently for the creation. 4. After the creation is completed, TaiChi will prompt you to uninstall the original APP; this is a necessary step in non-root mode (not required for Magisk mode), and you can uninstall it. 5. Follow the TaiChi APP's instructions to complete the rest of the operations, such as installation-optimization. 6. Click on the floating button in the bottom right corner of the TaiChi homepage, and click Module Manager in the menu. 7. Go to the module management page and Check the SnapFreedom module. 8. Kill the process of SnapChat; then reopen it. At this time, the Xposed module should already work normally (no need to restart the system). Magisk mode Although the Non-Root mode of TaiChi does not require unlocking the bootloader and is extremely convenient to use, it has some disadvantages, such as the inability to modify the system and the need to uninstall the original APP. Therefore,Magisk module of TaiChi, which can give TaiChi more powerful functions through Magisk; thus breaking through the limitations of the Non-Root mode. After you flash in the Magisk Module provided by TaiChi, the TaiChi APP will automatically switch from Non-Root mode to Magisk mode: TaiChi APP + TaiChi Magisk Module = TaiChi Magisk. When Magisk Module of TaiChi is disabled or uninstalled, TaiChi will automatically return to Non-Root mode. If you want to use magisk mode, please download the latest Magisk Module. page2 TaiChi module download]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[magisk]]></title>
    <url>%2F2019%2F12%2F15%2Fmagisk%2F</url>
    <content type="text"><![CDATA[magiskMagisk manager is a magic mask to alter system systemless-ly. Installing Magisk will give you ROOT, a super powerful Systemless Interface,Magisk Modules support, and hide from tons of integrity tests like SafetyNet! What is Magisk?Magisk is a great open-source root solution for Android devices which is developed by topjohnwu[https://forum.xda-developers.com/member.php?u=4470081], offering a “Systemless Interface”, allowing easy modification of your favourite device with peace of mind. Magisk is a module based application, so its configuration can be as individual as the member applying them. Many modules exist for Magisk, providing all sorts of modifications, such as cloaking your device from SafetyNet. HighlightsOpen Source:100% open source and easy to build on all Google supported platforms.Magic Mount:Modify system (vendor) without tampering the partitions.MagiskSU:Unleash your device’s root access.MagiskHide:Hide Magisk from detections: Google SafetyNet, enterprise / bank system integrity checks, game tamper checks.Resetprop:Modify or delete any system properties, including read-only props.Magisk Modules:Install Magisk Modules from the community driven Magisk Module Repo.Many custom modules for Magisk,like Fonts,Audio Mod,DNS. What is Magisk Manager?Magisk Manager is the application same as SuperSU which is pre-installed on your device after you have rooted your Android device. If you want to use the magisk manager you can unroot your device and then root it with the help flashing Magisk-v20.zip or else you can install the magisk manager application and do the system less rooting on your device. There are many questions raised, and people has a query that is How to root with magisk? The rooting procedure is simple, and you need a custom recovery installed on your device. If you have the custom recovery, then you can root your Android device by flashing the Magisk-v20.zip file. Magisk and superSuIf you root your device with the help of magisk, then the magisk won’t do any changes in your system files. Magisk will modify the boot.img to magisk.img. Magisk won’t add any files in your system files. When SuperSU roots your device, it will do the changes in the System files and also adds some files in the system partition. If you install SuperSU, you won’t be getting any OTA updates or any financial application won’t work on your device. guideBefore Installing Magisk,you must Unlocking Bootloader. Download Magisk Zip and Magisk Manager APKYou can usually download Magisk from the original development thread at XDA. But it only provides Magisk download link for the latest version. However, sometimes, the latest version isn’t the best version for you. For instance, a newer version of Magisk may not be able to hide from an app like Google Pay which is actually known to run into problems despite using MagiskHide. Using an older version of Magisk that you know works for you might be a temporary solution until it’s fixed. In that case, though, you’re out of luck. But not anymore. You can download all Magisk versions from below. The list below is comprehensive and contains all Magisk versions since it was released publicly. Below, you will find oldest to the latest version of Magisk zip for Android Nougat, Oreo, and Pie and download them directly from the Magisk Github repository. Just click the direct Magisk download links below. Moreover, we’ve also listed the compatible version of Magisk Manager and Magisk Uninstaller for each Magisk release. You can use Magisk Uninstaller zip file to remove Magisk from your Android device. How to install Magisk?If you don’t have a Android device with a TWRP recovery,you can refer to Plan A.But I suggest you install it,it’s very userful.If you have a Android device with a TWRP recovery,you can refer to Plan B. If you are using a Huawei device running EMUI 8 and higher, please check its section.If you are using a Samsung device that is launched with Android 9.0 (new devices in 2019), please check its section. Plan A Download Magisk Manager on your Android device. Install the application, and you might get an unknown source warning. You need to turn on Unknown Sources to turn it on, click on “Settings”. Now, try to repeat the installation process again. Try installing the application and open it. If you have already installed the Chainfire SuperSU on your device, then you need to grant the root permission. Now, click on the Install button to install the magisk on your device. If you will click on Install button you will see that it will ask you to select method. Just click on Direct Install if you want to directly install the file on your phone without using custom recovery on your phone, or you can click on Download Zip File Only. Now, if the download is the done. Magisk Manager will automatically install the file on your phone. Plan B Download the Magisk zip file. Place the zip file in your internal storage. Make sure that you remember the proper location of the zip file. Reboot your phone into recovery ensure that you have a custom recovery such as TWRP is installed on your phone. Now, click on the Install button in the TWRP recovery. Navigate the Magisk-v20.zip on your internal storage or SD card. Now, install the zip file on your device and wait till it is getting installed on your device. You have successfully flashed the Magisk-v20.zip on your device. Reboot your phone and see if it works on your device. Download the magisk manager application from the link given above. Install the application by following the above procedure. Open it and then you will see magisk is installed on your Android device. How to use Magisk Hide?Magisk Hide is the feature which is available in the Magisk Manager application and if you want to hide the root permission for the particular banking application. You can turn the Magisk hide option from the settings of the magisk application then you can easily enjoy your favorite app without any issues. If you want to activate the Magisk Hide option, then you can follow the below tutorial, and you can hide the root permission on your device. First, check the application which is not working on your rooted Android device. Open Magisk on your device and click on the Menu button. Now, Click on the Settings to turn on the magisk hide option. Now, scroll down and enable the Magisk Hide option. Press the Menu key again and click on the “Magisk Hide” option. Now, you need to select the application from which you need to hide the root. Open your banking application and then that’s it. You can run the banking application on your device now. HuaweiHuawei devices using Kirin processors have a different partitioning method from most common devices. Magisk is usually installed to the boot partition of the device, however Huawei devices do not have this partition. Depending on what EMUI version your device is running, the instructions will be slightly different. Obtain Stock ImagesHuawei does not release official factory images, however most firmware zips can be downloaded from the Huawei Firmware Database. To extract images from UPDATE.APP in the zip, you have to use Huawei Update Extractor (Windows only!) EMUI 8For EMUI 8 devices, your device has a partition named ramdisk, which is where Magisk is going to be installed. If you plan to use custom recoveries, simply follow the instructions for custom recovery and you’re all set.If you plan not to use custom recoveries, you will have to extract RAMDISK.img from your firmware. Follow the instructions for boot image patching above, but use the RAMDISK.img file instead of a boot image.To flash the patched image to your device, here is the fastboot command:fastboot flash ramdisk /path/to/magisk_patched.imgBe aware you are flashing to ramdisk, not boot!EMUI 9 or HigherFor EMUI 9+ devices, the ramdisk partition no longer exists. As a workaround, Magisk will be installed to the recovery_ramdisk partition. Please read the Magisk in Recovery section before following the instructions below! Note: As I tested on my Honor View 10, Huawei’s kernel does not seem to be able to capture key button press events in early boot, so long pressing Volume Up does NOT boot to recovery on my device. Your experience may vary. If you plan to use custom recoveries, simply follow the instructions for custom recovery and you’re all set.Warning: Magisk will overwrite the custom recovery.If you plan not to use custom recoveries, you will have to extract RECOVERY_RAMDIS.img from your firmware. Follow the instructions for boot image patching above, but use the RECOVERY_RAMDIS.img file instead of a boot image.To flash the patched image to your device, here is the fastboot command:fastboot flash recovery_ramdisk /path/to/magisk_patched.imgBe aware you are flashing to recovery_ramdisk, not boot! Samsung (System-as-root)If your device is NOT launched with Android 9.0 or higher (released after 2019), you are reading the wrong section. Before Installing MagiskYour device is non-A/B and uses system-as-root, so Magisk will be installed to the recovery partition of your device. Please read the Magisk in Recovery section!Installing Magisk WILL trip KNOXInstalling Magisk for the first time REQUIRES a full data wipe, backup before continueYou have to have your bootloader unlocked before following the instructionsUnlocking BootloaderNormally I wouldn’t provide instructions for this, but since things had changed drastically from previous Samsung devices, and there are some caveats, I figure this would be helpful. Allow bootloader unlocking in Developer options → OEM unlockingReboot your device to download mode. Either use adb reboot download, or use the key combo for your device.Long press volume up to unlock the bootloader. This will wipe your data and automatically reboot.Just when you think the bootloader is unlocked, it is actually not! Samsung introduced VaultKeeper, meaning the bootloader will reject any unofficial partitions before VaultKeeper explicitly allows it. Go through the initial setup. Skip through all the steps since data will be wiped again later when we are installing Magisk. Connect the device to internet in the setup!Enable developer options, and confirm that the OEM unlocking option exists and grayed out! The VaultKeeper service will unleash the bootloader after it confirms that the user has the OEM unlocking option enabled.Your bootloader now accepts unofficial images in download mode.InstructionsDownload the firmware for your device.Unzip the firmware and copy the AP tar file to your device. It is normally named as AP_[device_model_sw_ver].tar.md5Install the latest Magisk ManagerIn Magisk Manager: Install → Install → Select and Patch a File and select the AP tar file.Magisk Manager will patch the whole firmware file and store the output to [Internal Storage]/Download/magisk_patched.tarCopy the patched file to your PC with adb pull /sdcard/Download/magisk_patched.tar. Do not use MTP as it is reported to corrupt files.Reboot to download mode, and flash magisk_patched.tar as AP in Odin, together with the BL, CP and HOME_CSC files. Never flash only an AP file, as Odin can shrink your /data file-system if you do.Important: Uncheck “Auto Reboot” in Options!Magisk is now successfully flashed to your device! But there are still several steps before you can properly use the device.We now want to boot into the stock recovery to factory reset our device.Full data wipe is mandatory! Do not skip this step.Press Power + Volume Down to exit download mode. As soon as the screen turns off, immediately press the combo key to boot to recovery (e.g. on the S10 it is Power + Bixby + Volume Up). Since we want to boot into stock recovery, continue pressing the volume up button until you see the stock recovery screen.Use volume buttons to navigate through the stock recovery menu, and the power button to select an option. Choose Wipe data/factory reset to wipe the data of the device.This time, we can finally boot to the system with Magisk. Select Reboot system now, and immediately press the combo key to recovery. After seeing the bootloader warning screen, release all buttons so it can boot to the system.The device will automatically reboot for the first time it boots. This is completely normal and done by design.After the device is booted up, do the usual initial setup. The following steps will need an internet connection.You shall see Magisk Manager in your app drawer; if not, manually install the APK you downloaded in step 3 and continue to the next step. The app would be a stub and it shall automatically upgrade to the full Magisk Manager when you open it.Magisk Manager will ask to do additional setups. Let it do its job and the app will automatically reboot your device.Voila! Enjoy Magisk :)Additional InfoMagisk actually patches 3 partitions on your device:vbmeta: replace with empty vbmeta image to disable partition verificationboot: remove the signature of the image to prevent soft bricksrecovery: this is where Magisk is actually installedNever, ever try to restore either of the 3 images mentioned back to stock! You can easily brick your device by doing so, and the only way out is to do full Odin restore following with factory reset. Just don’t do it.If you want to upgrade your device, never flash the stock AP tar file with the reasons mentioned above. Always pre-patch the firmware before flashing in Odin.If you don’t need to patch the full firmware, you can manually create a tar file with at least vbmeta.img, boot.img, and recovery.img to let Magisk Manager patch your images in the proper way. Magisk Modules]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F12%2F05%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法和数据结构是相互依存的.前端的数据结构主要用数组和对象.js没有指针,无法使用链表. 排序算法冒泡排序(体育委员两两对比)时间复杂度：O(n^2^)需求: 数组a=[3,2,4,5,1,6]从小到大排列打印出来.方法: 找出最大的放在最右边,然后排前5个.然后依次把最大的放在最右边. 选择排序(体育老师点人)时间复杂度：O(n^2^)方法: 选出最小的一个放在最前面.然后看剩下的.剩下的最小的再放前面. 插入排序(排扑克牌)时间复杂度：O(n^2^)声明空数组.取第一张牌,第二个数字和数组中比较,比最后一个大,就放后面,比最后一个小,就往前放. 基数排序(桶排序)(整理扑克牌)优点：和计数排序不同的是一个桶里可放多个数字，效率高，计数排序的改良版，时间复杂度：O(N+C)缺点：需要hash工具，和计数排序不同的是每个桶里都是无序的，还要再排一次序用途：高考总分排序，每100分放在一个桶里，数字很分散的时候不好用，可用基数排序（比如从几十到几千）有重复的数.类似于4张1,4张2,4张3.拿到1放到最前面,2依次,如果还是1,放在1那一摞.每一种放一摞.最后排序. 快排优点：效率高,时间复杂度：O(n*log2n)缺点：有时候比计数排序慢挑选一个数,放中间,比它小的放左边,比它大的放右边.它的位置就固定了.看前面的部分,再挑一个数,比它小的放左边,比它大的放右边.后面的部分,再挑一个数,比它小的放左边,比它大的放右边.又有两个数固定了.]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP、TCP/IP协议的原理及应用]]></title>
    <url>%2F2019%2F12%2F03%2FHTTP%E3%80%81TCP-IP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[访问网页时发生了什么当用户在浏览器地址栏输入地址，敲下回车键，直到看到网页界面，一般时间不过两三秒左右。然而在这瞬时间，计算机实际上已经完成了非常复杂的操作。这段过程中发生的事情，其实有很大一部分就与 HTTP TCP/IP 有关，我们可以简要的概括一下大概的流程。 第一步，找服务器 IP当用户输入一个网址并按下回车键的时候，浏览器得到了一个域名。而在实际通信过程中，浏览器需要的是一个 IP 地址。为了获得 IP 地址，浏览器会做如下操作，一般我们把浏览器通过域名查找对应 IP 的行为叫做 DNS 解析。 1.先找浏览器的本地的缓存2.再找电脑硬盘里的 host 文件，有没有记录这个域名和 IP 的映射关系3.实在没找到，只好通过网络链路去域名供应商那里查询 第二步，建立 TCP/IP 连接1.浏览器获取到了服务器对应 IP，就会向对应 IP 的服务器发送 TCP 连接请求。2.服务器收到请求后回应，双方多次确认后建立起 TCP 双向连接。 从客户端发起连接请求一直到 TCP 连接建立，这个过程，叫做 三次握手。如果请求是 HTTPS 的，还需要在 TCP 连接上，再通过 SSL 或 TLS 提供加密处理数据、验证对方身份以及数据完整性，来保证数据传输的安全。 第三步，请求资源1.TCP 连接创建完成，浏览器开始向服务端发送正式的 HTTP 请求的数据包。2.服务端接受请求，对请求进行解析，经过数据操作后，返回客户端需要的数据包。 第四步，浏览器渲染浏览器获取到需要的数据以后，对数据进行拼接、解析、执行，最终将完整的网页绘制在页面上。 第五步，浏览器缓存浏览器拿到服务端返回的数据后，会根据一定的策略进行数据的缓存，这样在下一次请求同样数据的时候，就可直接到缓存拿取，不再请求服务器。上述流程可以看作是一个应用在完整网络通信过程中的实践场景，其中带出了很多网络通信的知识点，下面就以这条线为索引，对其中涉及到的知识碎片进行阐述和说明。 经典网络五层模型在每台计算机设备上，都有这么一套系统链路的关系，来保证网络传输的正常进行，因为统一集成了这么一套经典模型，所以自己使用的计算机也是可以作为一台服务器来提供网络服务的。 应用层：应用层包含了我们所说的 HTTP 协议，为各个应用软件提供了很多服务，常见的应用层服务有：HTTP 服务 、FTP 服务 、Email 服务等。应用层屏蔽了底层模型的相关细节，作为应用支持，只提供给使用者一些必要的使用方式。 传输层常见的传输层协议有 TCP 和 UDP ，传输层作为为应用层的基础，定义了“端到端（end to end）”之间数据间的传输方式，比如：两台设备如何建立连接？设备之间需要以何种规范进行数据传输？需要以什么方式进行数据的分片、重组、拼接？这些都是传输层为我们定义好的。 网络层通常我们常说的 IP 协议就位于这一层。网络层为数据在结点之间传输创建逻辑链路，当我们在浏览器敲下域名，浏览器在网络里如何通过这个域名，找到对应的 IP 映射，这个查询的逻辑关系和链路，是网络层规范和定义的。 数据链路层数据链路层在通信实体间建立数据链路连接，物理设备连接完成以后，需要相应的软件和驱动来连接和打通这些物理设备，创建电路的连接。 物理层定义物理设备如何传输数据，常见的物理层有网线，光缆，网卡，声卡等，物理层是一切软件的基础。 URI、URL 和 URN对于 URL 我们基本比较熟悉，然而对 URI 和 URN 的了解可能比较少，URI、URL 和 URN 是识别、定位和命名互联网上的资源的标准途径。当我们在浏览器地址栏里输入域名的那一刻，其实已经和这三个概念牵扯上了联系。 URIUniform Resource Identifier，统一资源标识符，简称为 URI。每个 Web 服务器都有一个 URI 标识符，它在世界范围内唯一标识并定位信息资源，一个资源信息有了 URI 标识以后，在互联网上就能通过一个固定的地址访问到这个资源。它具有两种形式，URN （统一资源名）、URL（统一资源定位符），也就是说 URL 和 URN 是它的子集。 URLUniform Resource Locator，统一资源定位符，简称 URL，下图是一个完整的 URL 组成。一个完整的 URL 从左到右包含如下部分： schema 标识了这个资源地址所基于的访问协议，常见的比如：HTTP 和 FTP。 user information 标识了用户信息（如果这个资源需要用户信息认证的话），不过一般现在的认证都不采用这种方式，一来输入非常麻烦，二来不安全。 host 标识了资源的域信息，可以是域名，也可以是 IP ，这块的作用主要是找到资源所存放的物理服务器地址。 port 端口号，一个物理服务器，通过开启不同的端口，就同时可以运行多个 web 服务器，资源文件会部署在某一个 web 服务器的某一个地方，而端口号就是用来定位资源存在的 web 服务器的。 path 路径，或者叫路由，一个 web 服务器下有许多目录，一般 path 就是用来定位到资源文件所存放的目录的。由于现在很多的 web 应用非常庞大，这个路径也不一定就是目录地址，也可能是 web 服务器指定的静态资源文件的请求地址。 query 查询字符串，一般用于 GET 查询，传递查询参数。 fragment 片段，哈希，或者叫锚点，主要用于前端文档的定位，或者是前端渲染时控制路由跳转的手段。 这里需要注意将 URL 与网址区别开来。URL 不仅仅包含了网页的资源地址，还包含了组成网页所需的图片、视频等超文本资源，以及 css js 等资源地址。网址本质上是 IP 地址的一个更有辨别度的映射，在通过 DNS 解析之后，浏览器最先拿到的是 html 文档的 URL 地址，根据浏览器对 Html 文档的解析，继续通过网页内其他资源文件的 URL 获取对应的资源文件。 URNUniform Resource Name，统一资源名称，简称 URN，它的用处简单说就是永久定位资源，因为同一个资源可能会更换存储位置，存储位置一旦更换，再访问原来的 url 肯定是拿不到的，URN 就是解决这个问题的，不管资源位置怎么移动，只要访问同一个 URN 都能定位到。 TCP/IP 协议族 TCP/IP 协议（传输控制协议/互联网协议）不是简单的一个协议，而是一组特别的协议，包括：TCP，IP，UDP，ARP等，这些被称为子协议。在这些协议中，最重要、最著名的就是 TCP 和 IP。因此我们习惯将整个协议族称为 TCP/IP。 IP 协议IP 协议使互联网成为一个允许连接不同类型的计算机和不同操作系统的网络。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，相当于这台机器的暂用名，别的机器可以通过这个名字找到它，进而能互相建立起连接进行通信和交流。 TCP 协议TCP 协议是面向连接的全双工协议，因此不管是客户端还是服务端都能在 TCP 连接通道下向对端接收和发送数据。TCP 相比于 UDP 的优势在于它的传输稳定性，在数据传输之前必须经过三次握手建立连接；在数据传输过程中必须保证数据有序完整地传到对端。TCP 相比于 UDP 的劣势在于它的复杂度，连接建立、断开都是比较大的性能开销，而且数据传输过程中一旦卡住，则必须等前面的数据发送完毕以后，后续数据才能继续传输。每台服务器可提供支持的 TCP 连接数量是有限的，所以这也使得 TCP 连接变成了稀缺资源，经不起浪费。 UDP 协议UDP 协议是面向无连接的，不需要在传输数据前先建立连接，想发就发想传就传。UDP 做的工作只是报文搬运，不负责有序且不丢失地传递到对端，因此容易出现丢包的情况。UDP 不仅支持一对一的传输方式，还支持一对多、多对多、多对一的方式，也就是说 UPD 提供了单播、多播、广播的功能。UDP 相比于 TCP 的优势在于它的轻量、高效和灵活，在一些对于实时性应用要求较高的场景下需要使用到 UDP，比如直播、视频会议、LOL等实时对战游戏。UDP 相比于 TCP 的劣势在于它的不可靠性和不稳定性。 TCP 连接在客户端发送正式的 HTTP 请求之前，需要先创建一个 TCP 连接，在创建的 TCP Connect 通道下，所有的 HTTP 请求和响应才能正常的发送和接受。在不同的 HTTP 协议版本里，这个 TCP 连接通道的创建和持续机制也有所不同。 在 HTTP1.0 中，每一次 HTTP 请求都会创建一个 TCP 连接，在请求发送完成，服务器响应以后，这个 TCP 连接就自动断开了。在 HTTP1.1 中，可以通过手动设置 Connection： keep-alive 请求头来建立 TCP 的持久连接，多个 HTTP 请求可以共用一个 TCP 连接。但是 TCP 连接存在线头阻塞，即若干个请求排队等待发送，一旦有某请求超时等，后续请求只能被阻塞。在 HTTP2 中，采用了信道复用，使 TCP 连接支持并发请求，即多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行吗，这样一来，大部分请求可以使用一个 TCP 连接，而不用创建新的 TCP 连接通道，既节省了三次握手的开销，又节约了服务端维护 TCP 端口的成本。 TCP 的三次握手和四次挥手三次握手 提示：关于 ACK、FIN、SYN 状态码的含义1.ACK 用于确认，表示通知对方，我已经收到你发来的信息了。2.FIN 用于结束，表示告知对方，我这边已经结束，数据全部发送完毕，没有后续输出，请求终止连接。3.SYN 用于同步和建立连接，表示告知对方，我这边请求同步建立连接。 第一次握手：由客户端向服务端发送连接请求 SYN 报文，该报文段中包含自身的数据通讯初始序号，请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个包含了 ACK 和 SYN 报文信息的应答，该应答中也会包含自身的数据通讯初始序号（在断开连接的“四次挥手”时，ACK 和 SYN 这两个报文是作为两次应答，独立开来发送的，因此会有四次挥手），服务端发送完成后便进入 SYN-RECEIVED 状态。 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 面试时可能会问的一个问题就是，明明两次握手就能确定的连接，为什么需要三次握手？因为由于很多不可控制的因素，例如网络原因，可能会造成第一次请求隔了很久才到达服务端，这个时候客户端已经等待响应等了很久，之前发起的请求已超时，已经被客户端废弃掉不再继续守着监听了。然而服务端过了很久，收到了废弃的延迟请求，发起回应的同时又开启了一个新的 TCP 连接端口，在那里呆等客户端。而服务端能维护的 TCP 连接是有限的，这种闲置的无用链接会造成服务端的资源浪费。因此在服务端发送了 SYN 和 ACK 响应后，需要收到客户端接的再次确认，双方连接才能正式建立起来。三次握手就是为了规避这种由于网络延迟而导致服务器额外开销的问题。 四次挥手和建立 TCP 连接类似，断开 TCP 连接也同样需要客户端于服务端的双向交流，因为整个断开动作需要双端共发送 4 个数据包才能完成，所以简称为“四次挥手”。 第一次挥手：客户端认为自己这边的数据已经全部发送完毕了，于是发送一个 FIN 用来关闭客户端到服务端的数据传输，发送完成以后，客户端进入 FIN_WAIT_1 状态。 第二次挥手：服务端收到客户端发送回来的 FIN 以后，会告诉应用层要释放 TCP 链接，并且发送一个 ACK 给客户端，表明已经收到客户端的释放请求了，不会再接受客户端发来的数据，自此，服务端进入 CLOSE_WAIT 的状态。 第三次挥手：服务端如果此时还有未发送完的数据可以继续发送，发送完毕后，服务端也会发送一个释放连接的 FIN 请求用来关闭服务端到客户端的数据传送，然后服务端进入 LAST_ACK 状态。 第四次挥手：客户端接收到服务端的 FIN 请求后，发送最后一个 ACK 给服务端，接着进入 TIME_WAIT_2 状态，该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，客户端就进入 CLOSED 状态.服务端在收到应答消息后，也会进入 CLOSED 状态，至此完成四次挥手的过程，双方正式断开连接。 上面的内容可能还是有些不够直观，所以我还准备了一段人话来描述整个过程： 客户端：喂，我好了。 服务端：噢，你好了是吧，我知道了，我还没好，你等一哈。 服务端：OK，现在我也好了。 客户端：收到，这次玩的很开心，我们下次再约。 可能有些面试中会问，为什么建立连接有三次握手，而断开连接却有四次？这是因为在建立连接过程中，服务端在收到客户但建立连接请求的 SYN 报文后，会把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，服务端收到客户端的 FIN 报文，只是表示客户端不再发送数据了，但是还能接收数据，而且这会儿服务端可能还有数据没有发送完，不能马上发送 FIN 报文，只能先发送 ACK 报文，先响应客户端，在确认自己这边所有数据发送完毕以后，才会发送 FIN。所以，在断开连接时，服务器的 ACK 和 FIN 一般都会单独发送，这就导致了断开连接比请求连接多了一次发送操作。 HTTP 定义一旦端对端成功建立起了 TCP 连接，下一步就要开始发送正式的 HTTP 请求了。流淌在 TCP Connect 通道里的 HTTP 只负责传输数据包，并没有连接的概念，因此 HTTP 也被叫做“无状态协议”。 HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，它通常运行在 TCP 之上，通过浏览器和服务器进行数据交互，进行超文本（文本、图片、视频等）传输的规定。也就是说，HTTP 协议规定了超文本传输所要遵守的规则。 HTTP 协议是无状态的。这意味着客户端和服务端之间无法知晓当前对方的状态信息，HTTP 请求本身是不带有任何状态存储的。但实际情况下，客户端和服务端必然需要状态的认证和交互，所以就引入了 Cookie， 用于存储当前浏览器的一些状态信息，每次通过独立的 HTTP 请求进行收发，从而解决这个问题。 HTTP 请求互相独立。HTTP 互相之间都是一个独立的个体请求，在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应 HTML 页面，然后浏览器收到响应之后发现页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送 HTTP 请求获取这些需要的资源。 HTTP 协议基于 TCP 协议。HTTP 协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节，底层是基于 TCP 实现的。现在使用的版本当中是默认持久连接的，也就是多次 HTTP 请求使用一个 TCP 连接。 注意：HTTP 请求和 TCP 连接是不一样的，HTTP 是在 TCP 连接建立的基础上而发起的传输请求，在同一个 TCP 连接通道下，可以发送多个 HTTP 请求，举个例子的话就是高速公路和车子的关系。 HTTP 发展历史HTTP 0.9 版本只有一个 GET 命令。没有请求头和响应头来描述传输相关的数据信息。服务器发送完数据后，直接关闭 TCP 连接，不支持 TCP 持久化连接。 HTTP 1.0 版本增加了很多命令，HEAD、POST、PUT、DELETE 等。增设了 status code 状态码和 header 请求头和响应头。增加了多字符集支持、多部分发送、权限、缓存等。可通过开启 Connection： keep-alive 来指定使用 TCP 长连接 HTTP 1.1 （目前普遍使用）默认支持持久连接默认支持长连接（PersistentConnection），即默认开启 Connection： keep-alive。支持请求的流水线（Pipelining）处理，即在一个 TCP 连接上可以传送多个 HTTP 请求和响应。增加了 host 请求头字段，通过对 host 解析，就能够允许在同一台物理服务器上运行多个软件服务，极大提高了服务器的使用率。目前的 nginx 反向代理就是根据 HTTP 请求头中的 host 来分辨不同的请求，从而将这些请求代理到同一台服务器不同的软件服务上。 HTTP 2.0HTTP1.x 的解析是基于文本，存在解析上的缺陷；而 HTTP2.0 直接使用二进制的解析方式来替代 HTTP 1.X 的字符串解析，更为高效和健壮。HTTP2.0 所有数据以“帧”的方式进行传输，因此同一个连接中发送的多个请求不再需要按照顺序进行返回处理，可以达到并行的数据传输。HTTP2.0 压缩头信息进行传输数据量的优化。HTTP1.x 的请求头带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的请求头大小，通讯双方各自缓存一份 header fields 表，既避免了重复的传输，又减小了传输信息的大小。HTTP2.0 新增了 server push（服务端推送） 的概念，服务端可以主动发起一些数据推送。比如，服务端在接收到浏览器发来的 HTML 请求的同时，可以主动推送相关的资源文件（js/css）给客户端，并行发送，提高网页的传输和渲染效率。目前如果要使用 HTTP2 需要首先使用 HTTPS 在这基础上，才能使用 HTTP2 HTTPS我们经常会在有些网页上看到悬浮的弹窗或者广告，有的时候甚至会在自己编写的上线网页上也看到这些垃圾广告，然而开发者明明没有写过这些东西，可是这种垃圾信息是怎么上去的呢？究其根本原因就在于各种代理服务，当我们从客户端发起一个 HTTP 请求，并不是直接就能传递到目标服务器的，期间会经过层层的代理服务，我们常用的 nginx ，以及在 DNS 解析过程中要经过的宽带运营商，都是一种代理服务。由于 HTTP 时使用明文字符串来传递数据的，那么这些数据就能很轻易地被中间服务读取甚至篡改，那么中间服务拿到了原始的 HTML 数据，想插入点小广告进去自然不是难事。HTTPS 是为了解决 HTTP 明文传输而出现的安全问题而出现的一种解决机制 ———— 对 HTTP 请求中的信息进行加密之后传输，从而有效地防止了中间代理服务截获或篡改信息的问题。HTTPS 其实就是一个安全加强版的 HTTP 1.1 ，有几点需要注意的是： HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费 HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的。 HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题。 HTTP 的报文组成HTTP 是以请求和响应的形式存在的，由于发起方主动发起一个 HTTP 请求，然后由响应方回应，双方按照一定的报文格式进行数据的互传，一个完整的 HTTP 报文通常由 首行、首部 和 主体 构成。 首行首行并不属于 Http Headers ，它包含了： HTTP Method（GET、POST、PUT、DELETE 等 ），不同的 HTTP Method 有不同的语意。 HTTP Method 对应予以 GET 一般用于获取服务器资源 POST 一般用于传输实体主体 PUT 一般用于传输文件 DELETE 用于删除文件 HEAD 用于获取报文首部，不返回报文主体 OPTIONS 用于预检请求中，询问请求URI资源支持的方法 HTTP Method 只是 HTTP 协议推崇的一种规范，就像 ESLint，你可以选择遵循，也可以选择不遵循，它们所作的事情实质上没有差别，只是语义化更明确。 URL请求资源的地址，这个地址只会包含请求的路由地址。 协议的版本，HTTP 1.0 / HTTP 1.1 / HTTP 2。 HTTP 返回状态码（响应报文首行包含） HTTP 定义了40个标准状态代码，可用于传递客户端请求的结果，状态代码分为以下五类，关于各个分段下的返回状态码信息可以参考 HTTP 响应码： 这边需要注意的一点是，一个好的 HTTP 应用服务应该是有完善的 HTTP status code 的返回信息的，即访问者单从 HTTP status &gt; code 上就能得知当前 HTTP 请求的状态信息。而目前我们大部分的开发模式下的 HTTP 返回码，只有 200 和 500。服务端的同学会先把 200 返回过来，然后再告诉你出了什么 “没登录” / “没认证” / “没权限” 这一类的问题。业界也有一句戏言：又不是不能用，其实这种开发方式是不正确的，不管从代码的维护性还是个人自身发展角度，我们都需要&gt; 尽量避免这种问题。 HTTP 头信息HTTP 头信息，即 HTTP Header，首行换行后的信息都是 HTTP Header。HTTP header 里一般存放了客户端和服务端之间交互的非业务信息，例如：本次请求的数据类型、请求日期、字符集支持、自定义头部字段、一些通信凭证和缓存支持等。HTTP Header 完整字段列表：传送门 主体主体，即 HTTP body，HTTP Header 信息和主体信息间以一个空行 + 一个换行来区分。HTTP body 里一般会放置请求的一些具体业务信息 HTTP 数据协商在 HTTP 协议中，数据协商是这样一种机制，客户端通过请求头告知服务端本次请求希望获取的数据格式、展现形式、以及数据的压缩方式等。常见的数据协商例如，文档使用的自然语言，图片的格式，或者内容编码形式。服务端可以对请求头中携带的数据协商字段进行解析，然后在返回客户端数据的时候，也会用相对字段来通知客户端：本次返回的数据格式、压缩方式等信息。这样浏览器就可以使用特定的解析方式，来对这些资源进行解析、处理和渲染。下面简单列举一些常用的数据协商字段，完整的数据协商信息传送门 Accept 请求头字段，指定期望获得的数据类型 Accept-Encoding 请求头字段，指定期望获得的数据需要以什么样的编码方式进行传输，常用于限制服务端对数据的压缩方式，常见的 JS 文件包大小优化的 GZIP 压缩，就使用了这个方法 Accept-Language 请求头字段，指定期望获得的数据语言类型：中文、英语、还是其他语言，这个头信息字段，一般是浏览器自动加上的 User-Agent 请求头字段，指定本次请求的浏览器信息，服务端可根据此信息选择不同兼容性的页面返回给用户，或者是做用户使用浏览器信息、操作系统等数据的统计 Content-Type 响应头字段，请求头里的 Accept 字段可能会指定好几种可以接受的数据格式，服务端最终会返回一种数据格式给客户端 Content-Encoding 响应头字段，对应 Accept-Encoding Content-Language 响应头字段，对应 Accept-Language HTTP 长连接每一个 HTTP 请求都需要在 TCP 连接通道里才能完成发送和接受。在 HTTP 协议的早期版本里，每一条 HTTP 请求发送之前，都会创建一条新的 TCP 连接通道，在这个请求完成以后，该条 TCP 通道就会自动关闭。这样带来的问题就是，单条 TCP 连接没有办法复用，造成很大的新能浪费。好在这一问题随着 HTTP 协议的逐步完善已经得到解决。在 HTTP 1.0 中引入的 Connection 头字段，允许对其设置 Keep-Alive 或者是 Close 来决定是否需要复用 TCP 连接，还是说在一次请求完成之后直接关闭。而在 HTTP 1.1 中默认双端都会默认开启这个字段，即默认支持 HTTP 的长连接。 需要注意的是：Connection: Keep-Alive 需要双端同时开启才能启动 HTTP 长连接，如果任何一段手动设置 Connection 为 Close，长连接都无法位置，因为 TCP 连接的建立和持久保持是一个双端交互的过程。 那么我们在本地如何看到 TCP 的连接 ID 呢，可以打开 Chrome 的调试工具来查看： 图上可以看到有不同的 Connection ID，这就代表着本次请求实际上是开启了一个新的 TCP 连接，最下面的请求的 Connection ID 都是相同的，代表着多个 HTTP 请求复用了同一个 TCP 连接。 Chrome 浏览器所能够支持的最大并发 TCP 连接数是 6个，并且在 HTTP 2.0 以下的 HTTP 版本中，请求是阻塞的。也就是说，一旦六个连接开满，前面的请求未完成，那么后续请求就会被阻塞，直到前面的请求返回，后续才能继续发送。 HTTP 缓存 虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括 request method 和目标 URI（一般只有 GET 请求才会被缓存）。 缓存读取策略前端环境下的文件缓存，分为几个不同的位置。当我们打开 Chrome 控制台，查看 Network 下每条请求记录的 size 选项，会发现非常丰富的来源信息。对于前端浏览器环境来说，缓存读取位置是由先后顺序的，顺序分别是（由上到下寻找，找到即返回；找不到则继续） Service Worker Memory Cache Disk Cache 网络请求 Service Worker Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 浏览器优先查找。持久存储。可以更加灵活地控制存储的内容，可以选择缓存哪些文件、定义缓存文件的路由匹配规则等。可以从 Chrome 的 F12 中，Application -&gt; Cache Storage 查看。 Memory Cachememory cache 是内存中的缓存存储。读取速度快。存储空间较小。存储时间短，当浏览器的 tab 页被关闭，内存资源即被释放。如果明确指定了 Cache-Control 为 no-store，浏览器则不会使用 memory-cache。 Disk CacheDisk Cache 是硬盘中的缓存存储。读取速度慢于 Memory Cache ，快于网络请求。存储空间较大。持久存储。Disk Cache 严格依照 HTTP 头信息中的字段来判断资源是否可缓存、是否要认证等。经常听到的“强制缓存”，“对比缓存”，以及 Cache-Control 等，归于此类。 网络请求如果一个请求的资源文件均未命中上述缓存策略，那么就会发起网络请求。浏览器拿到资源后，会把这个新资源加入缓存。 Cache-Control HTTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。需要注意的是，数据变化频率很快的场景并不适合开启 Cache-Control。 指令 作用 public 公共缓存：表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。 private 私有缓存：表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。 max-age （单位/秒）设置缓存的过期时间，过期需要重新请求，否则就读取本地缓存，并不实际发送请求 s-maxage （单位/秒）覆盖 max-age，作用一样，只在代理服务器中生效 max-stale （单位/秒）表示即使缓存过期，也使用这个过期缓存 no-store 禁止进行缓存 no-transform 不得对资源进行转换或压缩等操作，Content-Encoding、Content-Range、Content-Type 等 HTTP 头不能由代理修改（有时候资源比较大的情况下，代理服务器可能会自行做压缩处理，这个指令就是为了防止这种情况）。 no-cache 强制确认缓存：即每次使用本地缓存之前，需要请求服务器，查看缓存是否失效，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。 must-revalidate 缓存验证确认：意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用 proxy-revalidate 与 must-revalidate 作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。 缓存校验 在浏览器使用缓存的过程中，为了配合 Cache-Control 中 no-cache ，我们还需要一个机制来验证缓存是否有效。比如服务器的资源更新了，客户端需要及时刷新缓存；又或者客户端的资源过了有效期，但服务器上的资源还是旧的，此时并不需要重新发送。缓存校验就是用来解决这些问题的，在http 1.1 中，我们主要关注下 Last-Modified 和 ETag 这两个字段。 Last-Modified顾名思义，就是资源的最新一次修改时间。当客户端访问服务端的资源，服务端会将这个 Last-Modified 值返回给客户端，客户端收到之后，下次发送请求就会将服务端返回回来的 Last-Modified 值装在 If-Modified-Since 或者 If-Unmodified-Since 里，发送给服务端进行缓存校验。这样服务器就可以通过读取 If-Modified-Since （较常用）或 If-UnModified-Since 的值，和本地的 Last-Modified 值做对比校验。如果校验发现这两个值是一样的，就代表本次请求的资源文件没有被修改过，那么服务器就会告诉浏览器，资源有效，可以继续使用，否则就需要使用最新的资源。来看一下下面的两张图：当请求服务端的 script.js 的脚本资源时，可以看到服务端返回了 Last-Modified，里面记录了该资源最后一次的修改时间 当客户端下次再次发起请求，会携带上这个过期时间给服务端进行验证 来看下服务端的部分代码： 123456789101112131415161718192021222324252627282930const http = require('http');const fs = require('fs');http.createServer((request, response) =&gt; &#123; const ifModifiedSince = request.headers['If-Modified-Since']; const lastModified = 'Web Aug 19 2019 19:01:15 GMT+0800 (China Standard Time)'; if (request.url === '/') &#123; const html = fs.readFileSync('test.html', 'utf-8'); response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); response.end(html); &#125; if (request.url === '/script.js') &#123; const js = fs.readFileSync('script.js', 'utf-8'); let status = 200; // 如果读取到的 If-Modified-Since 和 lastModified 相同，则设置头部 304 表示可使用缓存 if (ifModifiedSince === lastModified) &#123; status = 304; response.end(''); &#125; response.writeHead(status, &#123; 'Content-Type': 'text/javascript', 'Cache-Control': 'no-cache,max-age=2000', 'Last-Modified': lastModified &#125;); response.end(js); &#125;&#125;); ETagEtag 的作用本质上和 Last-Modified 差别不大。相比于 Last-Modified 使用最后修改日期来比较资源是否失效的缓存校验策略，ETag 则是通过数据签名来做一个更加严格的缓存验证。所谓数据签名，其实就是通过对资源内容进行一个唯一的签名标记，一旦资源内容改变，那么签名必将改变，服务端就以此签名作为暗号，来标记缓存的有效性。典型的做法是针对资源内容进行一个 hash 计算，类似于 webpack 打包线上资源所加的 hash 标识和 Last-Modified 对应 If-Modified-Since 相同，ETag 也会对应 If-Match 或者 If-None-Match（If-None-Match 比较常用），如果前后的签名相同，则不需要返回新的资源内容。 缓存校验的合理使用 Last-Modified 和 ETag 只是给服务端提供了一个控制缓存有效期的手段，并没有任何强制缓存的作用，最终决定是否使用缓存、还是使用新的资源文件，还是需要靠服务端指定对应的 http code 来决定。对于保存在服务器上的文件，都有最后修改日期的属性，当使用 Last-Modified 可以利用这个有效的属性进行数据缓存验证；或者在数据库存入一个 updatetime 字段来标识具体的修改日期，从而判断缓存是否有效。具体如何构建一个能够合理使用缓存的服务器，就比较涉及后端知识了，这里不做具体描述。 浏览器的同源策略 浏览器的同源限制：当浏览器访问 URL 地址的协议（schema）/ 端口（port）/ 域名（host），三者中有任何一个与当前的 URL 片段信息不匹配的时候，便存在跨域问题。 对于跨域的几点需要明确： 跨域，是浏览器提供的一种保护手段，服务端是不存在跨域这一说的。这也就是为什么现在前后端分离的开发模式下，前端比较依赖 webpack-dev-server 启动代理服务来中转和代理后台接口的原因，因为两个服务器之间相互通信是没有跨域障碍的。 跨域，是对于 XMLHttpRequest 来说的，浏览器获取不同源服务器下的静态资源，是没有跨域限制的，这也是 JSONP 跨域请求得以实现的本质。 不同于 XMLHttpRequest 的是，通过 src 属性加载的脚本资源，浏览器限制了 Javascript 的权限，使其不能读写、返回内容。 对于浏览器来说，除了 DOM 、Cookie、XMLHttpRequest 会收到同源策略限制以外，一些常见的插件，比如 Flash、Java Applet 、Silverlight、Google Gears 等也都有自己的控制策略。 当浏览器向不同域的服务器发送请求时，请求是真能发出去，对方服务端也是真能接收到请求，并且真能给你的浏览器响应，浏览器也真能接收到有效数据。但是，如果在跨域的情况下、服务端返回数据的响应头里的 Access-Control-Allow-Origin 字段，没有把当前域名列进白名单，那么浏览器会把服务端返回的数据给藏起来，不告诉你，然后给你抛个 Access-Control-Allow-Origin 的错误。 至于为什么资源文件不受同源策略限制呢？可以试想一下，如果资源文件也被限制跨域，那么现在大量使用的 CDN 缓存策略基本就没办法用了。而且现在很多网站的资源文件，都会放到云服务器的 OSS 上，OSS 资源对应的 url 地址肯定是不同域的，那这些资源也不能使用了。 Access-Control-Allow-OriginAccess-Control-Allow-Origin 标识了服务器允许的跨域白名单，它有以下几种设置方法： 直接设置 * 通配符，简单粗暴，但是这么做等于把服务器的所有接口资源对外完全暴露，是不安全的。 设置制定域，比如 Access-Control-Allow-Origin: https://www.baidu.com ，这样只会允许指定域的请求进行跨域访问。 由后端动态设置。Access-Control-Allow-Origin 限制只能写一个白名单，但是当我们有多个域都需要跨域请求怎么呢？这个时候，这时可以由服务端自己维护一套白名单列表，在请求进来的时候对请求的源 host 进行白名单比对，如果在白名单中，就将这个 Access-Control-Allow-Origin 动态设置上去，然后返回响应。 CORS 的预请求如果我们像上面一样，只设置的 Access-Control-Allow-Origin 白名单，是否就可以完全畅通无阻地进行跨域了呢？并不是。就算对端开启了域名白名单认证，然鹅有一些操作仍然是需要进一步认证的，这种进一步的认证操作，就是 CORS 预请求。 预请求触发过程浏览器预请求的触发条件，是判断本次请求是否属于一个简单请求。如果本次请求属于一个复杂请求，那么在发送正式的跨域请求之前，浏览器会先准备一个名为 OPTIONS 的 HTTP Method ，作为预请求发送。在服务器通过预请求后，下面浏览器才会发生正式的数据请求。整个请求过程其实是发生了两次请求：一个预检请求，以及后续的实际数据请求。 简单请求 请求方式只能是 GET POST HEAD 请求头字段只允许： AcceptAccept-LanguageContent-LanguageContent-Type Content-Type 的值仅限于： text/plainmultipart/form-dataapplication/x-www-form-urlencoded XMLHttpRequestUpload 对象均没有注册任何事件监听器（了解就好）。 请求中没有使用 ReadableStream 对象（了解就好）。 复杂请求除了简单请求里定义的，都是复杂请求，统统需要预请求。 预请求的验证那么怎样使预检请求成功认证呢？还是需要服务端继续帮忙设置请求头的白名单： ccess-Control-Allow-Headers，设置允许的额外请求头字段。 Access-Control-Allow-Methods，设置允许的额外请求方法。 Access-Control-Max-Age （单位/秒），指定了预请求的结果能够被缓存多久，在这个时间范围内，再次发送跨域请求不会被预检。 HTTP 性能优化方案合理使用 HTTP 的缓存策略，避免同一资源多次请求服务端而导致的额外性能开销尽量使用 HTTP 长连接，避免每次重建 TCP 连接带来的时间损耗尽量使用 HTTPS 来保证网络传输的安全性。可以使用 HTTP2 来大幅提高数据传输的效率，使用 server push 开启 HTTP2 的服务端推送功能客户端开启 Accept-Encoding 压缩方式的支持，服务端传输压缩后的文件，减少传输数据的大小]]></content>
      <categories>
        <category>HTML</category>
        <category>HTTP基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见跨域解决方案]]></title>
    <url>%2F2019%2F12%2F03%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域：1.) 资源跳转： A链接、重定向、表单提交2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 跨域建议方案简单的跨域请求jsonp即可，复杂的cors，窗口之间JS跨域postMessage，开发环境下接口跨域用nginx反向代理或node中间件比较方便。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为：1.) Cookie、LocalStorage 和 IndexDB 无法读取2.) DOM 和 Js对象无法获得3.) AJAX 请求不能发送 常见跨域场景1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.js http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域解决方案1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域 一、 通过jsonp跨域通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.）原生实现：1234567891011var script = document.createElement('script');script.type = 'text/javascript';// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback';document.head.appendChild(script);// 回调执行函数function handleCallback(res) &#123; alert(JSON.stringify(res));&#125; 服务端返回如下（返回时即执行全局函数）： 1handleCallback(&#123;"status": true, "user": "admin"&#125;) 2.）jquery ajax：1234567$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: "handleCallback", // 自定义回调函数名 data: &#123;&#125;&#125;); 3.）vue.js：123456this.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'handleCallback'&#125;).then((res) =&gt; &#123; console.log(res); &#125;) 后端node.js代码示例：1234567891011121314151617var querystring = require('querystring');var http = require('http');var server = http.createServer();server.on('request', function(req, res) &#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.）父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id="iframe" src="http://child.domain.com/b.html"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt; 2.）子窗口：(http://child.domain.com/b.html) 12345&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 三、 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.）a.html：(http://www.domain1.com/a.html) 1234567891011121314&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + '#user=admin'; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert('data from c.html ---&gt; ' + res); &#125;&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 123456789&lt;iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; 3.）c.html：(http://www.domain1.com/c.html) 1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); &#125;;&lt;/script&gt; 四、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) 1234567891011121314151617181920212223242526272829303132333435var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;); 2.）proxy.html：(http://www.domain1.com/proxy....)中间代理页，与a.html同域，内容为空即可。 3.）b.html：(http://www.domain2.com/b.html) 123&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 1.）a.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; 六、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置：1.）原生ajax12// 前端设置是否带cookiexhr.withCredentials = true; 示例代码： 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 2.）jQuery ajax12345678$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 3.）vue框架a.) axios设置： 1axios.defaults.withCredentials = true b.) vue-resource设置： 1Vue.http.options.credentials = true 2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台：12345678910111213/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); // 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示response.setHeader("Access-Control-Allow-Credentials", "true"); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With"); 2.）Nodejs后台示例：12345678910111213141516171819202122232425262728293031323334var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) &#123; postData += chunk; &#125;); // 数据接收完毕 req.addListener('end', function() &#123; postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, &#123; 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie &#125;); res.write(JSON.stringify(postData)); res.end(); &#125;);&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 七、 nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： 123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 1.) 前端代码示例：12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 2.) Nodejs后台示例：123456789101112131415161718var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 八、 Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 1、 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 1.）前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);xhr.send(); 2.）中间件服务器： 123456789101112131415161718192021var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy(&#123; // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) &#123; res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); &#125;, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改&#125;));app.listen(3000);console.log('Proxy server is listen at port 3000...'); 3.）Nodejs后台同（六：nginx） 2、 vue框架Vue-cli2.0的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 webpack.config.js部分配置： 1234567891011121314151617//webpack.config.jsmodule.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 &#125;], noInfo: true &#125;&#125; 3. vue-cli3.0的跨域在根目录新建vue.config.js. 123456789101112131415161718192021//vue.config.jsmodule.exports = &#123; devServer:&#123; open:true, host:'localhost', port:8080, https:false, hotOnly:false, proxy:&#123; //配置跨域 '/api':&#123; target:'http://localhost:5000/api', ws:true, //websockets changOrigin:true, pathRewrite:&#123; '^/api':'' &#125; &#125; &#125; &#125;&#125; 九、 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.）前端代码：12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type="text"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; 2.）Nodejs socket后台：123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;);]]></content>
      <categories>
        <category>HTML</category>
        <category>HTTP基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟dom]]></title>
    <url>%2F2019%2F11%2F28%2F%E8%99%9A%E6%8B%9Fdom%2F</url>
    <content type="text"><![CDATA[一、真实DOM和其解析流程本节我们主要介绍真实 DOM 的解析过程，通过介绍其解析过程以及存在的问题，从而引出为什么需要虚拟DOM。一图胜千言，如下图为 webkit 渲染引擎工作流程图所有的浏览器渲染引擎工作流程大致分为5步：创建 DOM 树 —&gt; 创建 Style Rules -&gt; 构建 Render 树 —&gt; 布局 Layout -—&gt; 绘制 Painting。 第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树； 第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表； 第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树； 第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标； 第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。 注意点：1、DOM 树的构建是文档加载完成开始的？ 构建 DOM 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完成之后才开始构建 render 树和布局。 2、Render 树是 DOM 树和 CSS 样式表构建完毕后才开始构建的？ 这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。 3、CSS 的解析注意点？ CSS 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。 4、JS 操作真实 DOM 的代价？ 用我们传统的开发模式，原生 JS 或 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。例如，第一次计算完，紧接着下一个 DOM 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 DOM 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验 二、Virtual-DOM 基础2.1、虚拟 DOM 的好处​ 虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量。所以，用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。 2.2、算法实现2.2.1、用 JS 对象模拟 DOM 树（1）如何用 JS 对象模拟 DOM 树例如一个真实的 DOM 节点如下： 123456789&lt;div id="virtual-dom"&gt;&lt;p&gt;Virtual DOM&lt;/p&gt;&lt;ul id="list"&gt; &lt;li class="item"&gt;Item 1&lt;/li&gt; &lt;li class="item"&gt;Item 2&lt;/li&gt; &lt;li class="item"&gt;Item 3&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Hello World&lt;/div&gt;&lt;/div&gt; 我们用 JavaScript 对象来表示 DOM 节点，使用对象的属性记录节点的类型、属性、子节点等。 element.js 中表示节点对象代码如下： 1234567891011121314151617181920212223242526272829303132/** * Element virdual-dom 对象定义 * @param &#123;String&#125; tagName - dom 元素名称 * @param &#123;Object&#125; props - dom 属性 * @param &#123;Array&lt;Element|String&gt;&#125; - 子节点 */function Element(tagName, props, children) &#123; this.tagName = tagName this.props = props this.children = children // dom 元素的 key 值，用作唯一标识符 if(props.key)&#123; this.key = props.key &#125; var count = 0 children.forEach(function (child, i) &#123; if (child instanceof Element) &#123; count += child.count &#125; else &#123; children[i] = '' + child &#125; count++ &#125;) // 子元素个数 this.count = count&#125;function createElement(tagName, props, children)&#123; return new Element(tagName, props, children);&#125;module.exports = createElement; 根据 element 对象的设定，则上面的 DOM 结构就可以简单表示为： 12345678910var el = require("./element.js");var ul = el('div',&#123;id:'virtual-dom'&#125;,[ el('p',&#123;&#125;,['Virtual DOM']), el('ul', &#123; id: 'list' &#125;, [ el('li', &#123; class: 'item' &#125;, ['Item 1']), el('li', &#123; class: 'item' &#125;, ['Item 2']), el('li', &#123; class: 'item' &#125;, ['Item 3']) ]), el('div',&#123;&#125;,['Hello World'])]) 现在 ul 就是我们用 JavaScript 对象表示的 DOM 结构，我们输出查看 ul 对应的数据结构如下： （2）渲染用 JS 表示的 DOM 对象但是页面上并没有这个结构，下一步我们介绍如何将 ul 渲染成页面上真实的 DOM 结构，相关渲染函数如下： 123456789101112131415161718192021/** * render 将virdual-dom 对象渲染为实际 DOM 元素 */Element.prototype.render = function () &#123; var el = document.createElement(this.tagName) var props = this.props // 设置节点的DOM属性 for (var propName in props) &#123; var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children = this.children || [] children.forEach(function (child) &#123; var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125; 我们通过查看以上 render 方法，会根据 tagName 构建一个真正的 DOM 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。 我们将构建好的 DOM 结构添加到页面 body 上面，如下： 12ulRoot = ul.render();document.body.appendChild(ulRoot); 这样，页面 body 里面就有真正的 DOM 结构，效果如下图所示： 2.2.2、比较两棵虚拟 DOM 树的差异 — diff 算法diff 算法用来比较两棵 Virtual DOM 树的差异，如果需要两棵树的完全比较，那么 diff 算法的时间复杂度为O(n^3)。但是在前端当中，你很少会跨越层级地移动 DOM 元素，所以 Virtual DOM 只会对同一个层级的元素进行对比，如下图所示， div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 O(n)。 ####（1）深度优先遍历，记录差异 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 1234567891011121314151617181920212223242526272829303132333435363738394041// diff 函数，对比两棵树function diff(oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk(oldNode, newNode, index, patches) &#123; var currentPatch = [] if (typeof (oldNode) === "string" &amp;&amp; typeof (newNode) === "string") &#123; // 文本内容改变 if (newNode !== oldNode) &#123; currentPatch.push(&#123; type: patch.TEXT, content: newNode &#125;) &#125; &#125; else if (newNode!=null &amp;&amp; oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) &#123; // 节点相同，比较属性 var propsPatches = diffProps(oldNode, newNode) if (propsPatches) &#123; currentPatch.push(&#123; type: patch.PROPS, props: propsPatches &#125;) &#125; // 比较子节点，如果子节点有'ignore'属性，则不需要比较 if (!isIgnoreChildren(newNode)) &#123; diffChildren( oldNode.children, newNode.children, index, patches, currentPatch ) &#125; &#125; else if(newNode !== null)&#123; // 新节点和旧节点不同，用 replace 替换 currentPatch.push(&#123; type: patch.REPLACE, node: newNode &#125;) &#125; if (currentPatch.length) &#123; patches[index] = currentPatch &#125;&#125; 从以上可以得出，patches[1] 表示 p ，patches[3] 表示 ul ，以此类推。 （2）差异类型DOM 操作导致的差异类型包括以下几种： 节点替换：节点改变了，例如将上面的 div 换成 h1;顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换；属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除；文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”；以上描述的几种差异类型在代码中定义如下所示： 1234var REPLACE = 0 // 替换原先的节点var REORDER = 1 // 重新排序var PROPS = 2 // 修改了节点的属性var TEXT = 3 // 文本内容改变 ####（3）列表对比算法 ​ 子节点的对比算法，例如 p, ul, div 的顺序换成了 div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如 p 和 div 的 tagName 不同，p 会被 div 所替代。最终，三个节点都会被替换，这样 DOM 开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 ​ 将这个问题抽象出来其实就是字符串的最小编辑距离问题（Edition Distance），最常见的解决方法是 Levenshtein Distance , Levenshtein Distance 是一个度量两个字符序列之间差异的字符串度量标准，两个单词之间的 Levenshtein Distance 是将一个单词转换为另一个单词所需的单字符编辑（插入、删除或替换）的最小数量。Levenshtein Distance 是1965年由苏联数学家 Vladimir Levenshtein 发明的。Levenshtein Distance 也被称为编辑距离（Edit Distance），通过动态规划求解，时间复杂度为 O(M*N)。 定义：对于两个字符串 a、b，则他们的 Levenshtein Distance 为： 示例：字符串 a 和 b，a=“abcde” ，b=“cabef”，根据上面给出的计算公式，则他们的 Levenshtein Distance 的计算过程如下： 本文的 demo 使用插件 list-diff2 算法进行比较，该算法的时间复杂度伟 O(n*m)，虽然该算法并非最优的算法，但是用于对于 dom 元素的常规操作是足够的。该算法具体的实现过程这里不再详细介绍，该算法的具体介绍可以参照：https://github.com/livoras/list-diff （4）实例输出 两个虚拟 DOM 对象如下图所示，其中 ul1 表示原有的虚拟 DOM 树，ul2 表示改变后的虚拟 DOM 树 12345678910111213141516171819var ul1 = el('div',&#123;id:'virtual-dom'&#125;,[ el('p',&#123;&#125;,['Virtual DOM']), el('ul', &#123; id: 'list' &#125;, [ el('li', &#123; class: 'item' &#125;, ['Item 1']), el('li', &#123; class: 'item' &#125;, ['Item 2']), el('li', &#123; class: 'item' &#125;, ['Item 3']) ]), el('div',&#123;&#125;,['Hello World'])]) var ul2 = el('div',&#123;id:'virtual-dom'&#125;,[ el('p',&#123;&#125;,['Virtual DOM']), el('ul', &#123; id: 'list' &#125;, [ el('li', &#123; class: 'item' &#125;, ['Item 21']), el('li', &#123; class: 'item' &#125;, ['Item 23']) ]), el('p',&#123;&#125;,['Hello World'])]) var patches = diff(ul1,ul2);console.log('patches:',patches); 我们查看输出的两个虚拟 DOM 对象之间的差异对象如下图所示，我们能通过差异对象得到，两个虚拟 DOM 对象之间进行了哪些变化，从而根据这个差异对象（patches）更改原先的真实 DOM 结构，从而将页面的 DOM 结构进行更改。 2.2.3、将两个虚拟 DOM 对象的差异应用到真正的 DOM 树（1）深度优先遍历 DOM 树​ 因为步骤一所构建的 JavaScript 对象树和 render 出来真正的 DOM 树的信息、结构是一样的。所以我们可以对那棵 DOM 树也进行深度优先的遍历，遍历的时候从步骤二生成的 patches 对象中找出当前遍历的节点差异，如下相关代码所示： 1234567891011121314151617181920212223function patch (node, patches) &#123; var walker = &#123;index: 0&#125; dfsWalk(node, walker, patches)&#125;function dfsWalk (node, walker, patches) &#123; // 从patches拿出当前节点的差异 var currentPatches = patches[walker.index] var len = node.childNodes ? node.childNodes.length : 0 // 深度遍历子节点 for (var i = 0; i &lt; len; i++) &#123; var child = node.childNodes[i] walker.index++ dfsWalk(child, walker, patches) &#125; // 对当前节点进行DOM操作 if (currentPatches) &#123; applyPatches(node, currentPatches) &#125;&#125; （2）对原有 DOM 树进行 DOM 操作我们根据不同类型的差异对当前节点进行不同的 DOM 操作 ，例如如果进行了节点替换，就进行节点替换 DOM 操作；如果节点文本发生了改变，则进行文本替换的 DOM 操作；以及子节点重排、属性改变等 DOM 操作，相关代码如 applyPatches 所示 ： 1234567891011121314151617181920212223function applyPatches (node, currentPatches) &#123; currentPatches.forEach(currentPatch =&gt; &#123; switch (currentPatch.type) &#123; case REPLACE: var newNode = (typeof currentPatch.node === 'string') ? document.createTextNode(currentPatch.node) : currentPatch.node.render() node.parentNode.replaceChild(newNode, node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; （3）DOM结构改变通过将第 2.2.2 得到的两个 DOM 对象之间的差异，应用到第一个（原先）DOM 结构中，我们可以看到 DOM 结构进行了预期的变化，如下图所示： 2.3、结语Virtual DOM 算法主要实现上面三个步骤来实现： 用 JS 对象模拟 DOM 树 — element.js 123456789&lt;div id="virtual-dom"&gt;&lt;p&gt;Virtual DOM&lt;/p&gt;&lt;ul id="list"&gt; &lt;li class="item"&gt;Item 1&lt;/li&gt; &lt;li class="item"&gt;Item 2&lt;/li&gt; &lt;li class="item"&gt;Item 3&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;Hello World&lt;/div&gt;&lt;/div&gt; 比较两棵虚拟 DOM 树的差异 — diff.js 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树 — patch.js 1234567891011121314151617181920212223function applyPatches (node, currentPatches) &#123; currentPatches.forEach(currentPatch =&gt; &#123; switch (currentPatch.type) &#123; case REPLACE: var newNode = (typeof currentPatch.node === 'string') ? document.createTextNode(currentPatch.node) : currentPatch.node.render() node.parentNode.replaceChild(newNode, node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; 三、Vue 源码 Virtual-DOM 简析我们从第二章节（Virtual-DOM 基础）中已经掌握 Virtual DOM 渲染成真实的 DOM 实际上要经历 VNode 的定义、diff、patch 等过程，所以本章节 Vue 源码的解析也按这几个过程来简析。 3.1、VNode 模拟 DOM 树3.1.1、VNode 类简析在 Vue.js 中，Virtual DOM 是用 VNode 这个 Class 去描述，它定义在 src/core/vdom/vnode.js 中 ，从以下代码块中可以看到 Vue.js 中的 Virtual DOM 的定义较为复杂一些，因为它这里包含了很多 Vue.js 的特性。实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库 snabbdom 的实现，然后加入了一些 Vue.js 的一些特性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // strictly internal raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? asyncFactory: Function | void; // async component factory function asyncMeta: Object | void; isAsyncPlaceholder: boolean; ssrContext: Object | void; fnContext: Component | void; // real context vm for functional nodes fnOptions: ?ComponentOptions; // for SSR caching devtoolsMeta: ?Object; // used to store functional render context for devtools fnScopeId: ?string; // functional scope id support constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125;&#125; 这里千万不要因为 VNode 的这么属性而被吓到，或者咬紧牙去摸清楚每个属性的意义，其实，我们主要了解其几个核心的关键属性就差不多了，例如： tag 属性即这个vnode的标签属性 data 属性包含了最后渲染成真实dom节点后，节点上的class，attribute，style以及绑定的事件 children 属性是vnode的子节点 text 属性是文本属性 elm 属性为这个vnode对应的真实dom节点 key 属性是vnode的标记，在diff过程中可以提高diff的效率 3.1.2、源码创建 VNode 过程（1）初始化 vue我们在实例化一个 vue 实例，也即 new Vue( ) 时，实际上是执行 src/core/instance/index.js 中定义的 Function 函数。 12345678function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; 通过查看 Vue 的 function，我们知道 Vue 只能通过 new 关键字初始化，然后调用 this._init 方法，该方法在 src/core/instance/init.js 中定义。 12345678910Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // 省略一系列其它初始化的代码 if (vm.$options.el) &#123; console.log('vm.$options.el:',vm.$options.el); vm.$mount(vm.$options.el) &#125;&#125; （2）Vue 实例挂载Vue 中是通过 $mount 实例方法去挂载 dom 的，下面我们通过分析 compiler 版本的 mount 实现，相关源码在目录 src/platforms/web/entry-runtime-with-compiler.js 文件中定义： 1234567891011const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) // 省略一系列初始化以及逻辑判断代码 return mount.call(this, el, hydrating)&#125; 我们发现最终还是调用用原先原型上的 $mount 方法挂载 ，原先原型上的 $mount 方法在 src/platforms/web/runtime/index.js 中定义 。 1234567Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 我们发现$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js 文件中 1234567891011121314151617181920212223242526272829303132333435export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el // 省略一系列其它代码 let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; // 生成虚拟 vnode const vnode = vm._render() // 更新 DOM vm._update(vnode, hydrating) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法 new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false return vm&#125; 从上面的代码可以看到，mountComponent 核心就是先实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。 （3）创建虚拟 NodeVue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src/core/instance/render.js 文件中： 1234567891011121314151617Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options let vnode try &#123; // 省略一系列代码 currentRenderingInstance = vm // 调用 createElement 方法来返回 vnode vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`)&#123;&#125; &#125; // set parent vnode.parent = _parentVnode console.log("vnode...:",vnode); return vnode &#125; Vue.js 利用 _createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849export function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; // 省略一系列非主线代码 if (normalizationType === ALWAYS_NORMALIZE) &#123; // 场景是 render 函数不是编译生成的 children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; // 场景是 render 函数是编译生成的 children = simpleNormalizeChildren(children) &#125; let vnode, ns if (typeof tag === 'string') &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) &#123; // 创建虚拟 vnode vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; vnode = createComponent(tag, data, context, children) &#125; if (Array.isArray(vnode)) &#123; return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125; _createElement 方法有 5 个参数，context 表示 VNode 的上下文环境，它是 Component 类型；tag表示标签，它可以是一个字符串，也可以是一个 Component；data 表示 VNode 的数据，它是一个 VNodeData 类型，可以在 flow/vnode.js 中找到它的定义；children 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 VNode 数组； 3.1.3、实例查看为了更直观查看我们平时写的 Vue 代码如何用 VNode 类来表示，我们通过一个实例的转换进行更深刻了解。 例如，实例化一个 Vue 实例： 1234567891011121314var app = new Vue(&#123; el: '#app', render: function (createElement) &#123; return createElement('div', &#123; attrs: &#123; id: 'app', class: "class_box" &#125;, &#125;, this.message) &#125;, data: &#123; message: 'Hello Vue!' &#125;&#125;) 我们打印出其对应的 VNode 表示： 3.2、diff 过程3.2.1、Vue.js 源码的 diff 调用逻辑Vue.js 源码实例化了一个 watcher，这个 ~ 被添加到了在模板当中所绑定变量的依赖当中，一旦 model 中的响应式的数据发生了变化，这些响应式的数据所维护的 dep 数组便会调用 dep.notify() 方法完成所有依赖遍历执行的工作，这包括视图的更新，即 updateComponent 方法的调用。watcher 和 updateComponent 方法定义在 src/core/instance/lifecycle.js 文件中 。 1234567891011121314151617181920212223242526272829303132333435export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el // 省略一系列其它代码 let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; // 生成虚拟 vnode const vnode = vm._render() // 更新 DOM vm._update(vnode, hydrating) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法 new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false return vm&#125; 完成视图的更新工作事实上就是调用了vm._update方法，这个方法接收的第一个参数是刚生成的Vnode，调用的vm._update方法定义在 src/core/instance/lifecycle.js中。 1234567891011121314151617181920212223242526Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode if (!prevVnode) &#123; // 第一个参数为真实的node节点，则为初始化 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // 如果需要diff的prevVnode存在，那么对prevVnode和vnode进行diff vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125;&#125; 在这个方法当中最为关键的就是 vm.__patch__ 方法，这也是整个 virtual-dom 当中最为核心的方法，主要完成了prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实 dom 节点并完成视图的更新工作。 接下来，让我们看下 vm.__patch__ 的逻辑过程， vm.__patch__ 方法定义在 src/core/vdom/patch.js 中。 12345678910111213141516function patch (oldVnode, vnode, hydrating, removeOnly) &#123; ...... if (isUndef(oldVnode)) &#123; // 当oldVnode不存在时，创建新的节点 isInitialPatch = true createElm(vnode, insertedVnodeQueue) &#125; else &#123; // 对oldVnode和vnode进行diff，并对oldVnode打patch const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; ...... &#125;&#125; 在 patch 方法中，我们看到会分为两种情况，一种是当 oldVnode 不存在时，会创建新的节点；另一种则是已经存在 oldVnode ，那么会对 oldVnode 和 vnode 进行 diff 及 patch 的过程。其中 patch 过程中会调用 sameVnode 方法来对对传入的2个 vnode 进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个vnode 只是局部发生了更新，然后才会对这2个 vnode 进行 diff，如果2个 vnode 的基本属性存在不一致的情况，那么就会直接跳过 diff 的过程，进而依据 vnode 新建一个真实的 dom，同时删除老的 dom 节点。 123456789function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) )&#125; diff 过程中主要是通过调用 patchVnode 方法进行的: 12345678910111213141516171819202122232425262728293031function patchVnode (oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) &#123;...... const elm = vnode.elm = oldVnode.elmconst oldCh = oldVnode.childrenconst ch = vnode.children// 如果vnode没有文本节点if (isUndef(vnode.text)) &#123; // 如果oldVnode的children属性存在且vnode的children属性也存在 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // updateChildren，对子节点进行diff if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; if (process.env.NODE_ENV !== 'production') &#123; checkDuplicateKeys(ch) &#125; // 如果oldVnode的text存在，那么首先清空text的内容,然后将vnode的children添加进去 if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; // 删除elm下的oldchildren removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; // oldVnode有子节点，而vnode没有，那么就清空这个节点 nodeOps.setTextContent(elm, '') &#125;&#125; else if (oldVnode.text !== vnode.text) &#123; // 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素 nodeOps.setTextContent(elm, vnode.text)&#125;......&#125; 从以上代码得知， diff 过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode 的子节点： 首先进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换；在vnode 没有文本节点的情况下，进入子节点的 diff；当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；若 oldCh 不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm 真实 dom 节点当中；若 oldCh 存在，ch 不存在，则删除 elm 真实节点下的 oldCh 子节点；若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。 3.2.2、子节点 diff 流程分析（1）Vue.js 源码​ 这里着重分析下 updateChildren方法，它也是整个 diff 过程中最重要的环节，以下为 Vue.js 的源码过程，为了更形象理解 diff 过程，我们给出相关的示意图来讲解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;// 为oldCh和newCh分别建立索引，为之后遍历的依据let oldStartIdx = 0let newStartIdx = 0let oldEndIdx = oldCh.length - 1let oldStartVnode = oldCh[0]let oldEndVnode = oldCh[oldEndIdx]let newEndIdx = newCh.length - 1let newStartVnode = newCh[0]let newEndVnode = newCh[newEndIdx]let oldKeyToIdx, idxInOld, vnodeToMove, refElm// 直到oldCh或者newCh被遍历完后跳出循环while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125;&#125;if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)&#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 在开始遍历 diff 前，首先给 oldCh 和 newCh 分别分配一个 startIndex 和 endIndex 来作为遍历的索引，当oldCh 或者 newCh 遍历完后(遍历完的条件就是 oldCh 或者 newCh 的 startIndex &gt;= endIndex )，就停止oldCh 和 newCh 的 diff 过程。接下来通过实例来看下整个 diff 的过程(节点属性中不带 key 的情况)。 （2）无 key 的 diff 过程我们通过以下示意图对以上代码过程进行讲解： ####（2.1）首先从第一个节点开始比较，不管是 oldCh 还是 newCh 的起始或者终止节点都不存在 sameVnode ，同时节点属性中是不带 key 标记的，因此第一轮的 diff 完后，newCh 的 startVnode 被添加到 oldStartVnode的前面，同时 newStartIndex 前移一位；（2.2）第二轮的 diff 中，满足 sameVnode(oldStartVnode, newStartVnode)，因此对这2个 vnode 进行diff，最后将 patch 打到 oldStartVnode 上，同时 oldStartVnode 和 newStartIndex 都向前移动一位 ；（2.3）第三轮的 diff 中，满足 sameVnode(oldEndVnode, newStartVnode)，那么首先对 oldEndVnode和newStartVnode 进行 diff，并对 oldEndVnode 进行 patch，并完成 oldEndVnode 移位的操作，最后newStartIndex 前移一位，oldStartVnode 后移一位；（2.4）第四轮的 diff 中，过程同步骤3；（2.5）第五轮的 diff 中，同过程1；（2.6）遍历的过程结束后，newStartIdx &gt; newEndIdx，说明此时 oldCh 存在多余的节点，那么最后就需要将这些多余的节点删除。 （3）有 key 的 diff 流程在 vnode 不带 key 的情况下，每一轮的 diff 过程当中都是起始和结束节点进行比较，直到 oldCh 或者newCh 被遍历完。而当为 vnode 引入 key 属性后，在每一轮的 diff 过程中，当起始和结束节点都没有找到sameVnode 时，然后再判断在 newStartVnode 的属性中是否有 key，且是否在 oldKeyToIndx 中找到对应的节点 ： 如果不存在这个 key，那么就将这个 newStartVnode 作为新的节点创建且插入到原有的 root 的子节点中；如果存在这个 key，那么就取出 oldCh 中的存在这个 key 的 vnode，然后再进行 diff 的过；通过以上分析，给vdom上添加 key 属性后，遍历 diff 的过程中，当起始点，结束点的搜寻及 diff 出现还是无法匹配的情况下时，就会用 key 来作为唯一标识，来进行 diff，这样就可以提高 diff 效率。 带有 Key 属性的 vnode的 diff 过程可见下图： （3.1）首先从第一个节点开始比较，不管是 oldCh 还是 newCh 的起始或者终止节点都不存在 sameVnode，但节点属性中是带 key 标记的， 然后在 oldKeyToIndx 中找到对应的节点，这样第一轮 diff 过后 oldCh 上的B节点被删除了，但是 newCh 上的B节点上 elm 属性保持对 oldCh 上 B节点 的elm引用。 （3.2）第二轮的 diff 中，满足 sameVnode(oldStartVnode, newStartVnode)，因此对这2个 vnode 进行diff，最后将 patch 打到 oldStartVnode上，同时 oldStartVnode 和 newStartIndex 都向前移动一位 ； （3.3）第三轮的 diff 中，满足 sameVnode(oldEndVnode, newStartVnode)，那么首先对 oldEndVnode 和newStartVnode 进行 diff，并对 oldEndVnode 进行 patch，并完成 oldEndVnode 移位的操作，最后newStartIndex 前移一位，oldStartVnode 后移一位； （3.4）第四轮的diff中，过程同步骤2； （3.5）第五轮的diff中，因为此时 oldStartIndex 已经大于 oldEndIndex，所以将剩余的 Vnode 队列插入队列最后。 3.3、patch 过程通过3.2章节介绍的 diff 过程中，我们会看到 nodeOps 相关的方法对真实 DOM 结构进行操作，nodeOps 定义在 src/platforms/web/runtime/node-ops.js 中，其为基本 DOM 操作，这里就不在详细介绍。 12345678910111213141516171819export function createElementNS (namespace: string, tagName: string): Element &#123; return document.createElementNS(namespaceMap[namespace], tagName)&#125;export function createTextNode (text: string): Text &#123; return document.createTextNode(text)&#125;export function createComment (text: string): Comment &#123; return document.createComment(text)&#125;export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) &#123; parentNode.insertBefore(newNode, referenceNode)&#125;export function removeChild (node: Node, child: Node) &#123; node.removeChild(child)&#125; 3.4、总结通过前三小节简析，我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。 转载本文转载自https://github.com/fengshi123/blog/issues/10感谢作者@fengshi123]]></content>
      <tags>
        <tag>JS</tag>
        <tag>JS进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全栈开发后台资金管理系统项目]]></title>
    <url>%2F2019%2F11%2F27%2F%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%90%8E%E5%8F%B0%E8%B5%84%E9%87%91%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[后端部分1. nodemon 使用当我们做服务器的时候，每次变更都要重启才能生效。如：我们创建了一个名为 server.js 的文件，作为服务器使用node ./server.js即可启动，但我们对其修改后，要看效果就要关闭之前的再启动。而 nodemon 帮我们解决这个问题。 1npm install nodemon -g //全局安装nodemon 然后就可以使用 nodemon 运行我们的服务器了 1nodemon ./server.js 这时，修改文件，服务器会自动重启。将命令设置到 package.json。 12345//在package.json中修改"scripts": &#123; "start": "node server.js", "server": "nodemon server.js" &#125;, 这样在就可以使用npm run start或npm run server来运行服务器 2.连接数据库12//node-app下执行npm install mongoose 为方便修改配置，新建文件 /config/keys.js, 内容： 1234module.exports = &#123; mongoURI: "mongodb://&lt;username&gt;:&lt;password&gt;@cluster0-shard-00-00-oqdfe.mongodb.net:27017,cluster0-shard-00-01-oqdfe.mongodb.net:27017,cluster0-shard-00-02-oqdfe.mongodb.net:27017/test?ssl=true&amp;replicaSet=Cluster0-shard-0&amp;authSource=admin&amp;retryWrites=true&amp;w=majority"&#125;; 该链接需要到 mongoDB 官网注册账户，获取 500M 免费空间，创建一个 Preject 再创建 Clusters，之后点击”Connect”,选择”Connect your Application”进入下一步，域名选择默认确定即可.DRIVER 选择“node.js”, VERSION 选择”2.2.12 or later”,然后 copy 下面的链接即可，注意修改&lt;username&gt;:&lt;password&gt;为对应的用户名和密码。可以在”Database Access”中添加和修改用户。在 server.js 中引用 1234567891011121314//DB configconst db = require("./config/keys").mongoURI;//连接数据库//Connect to mongodbmongoose.connect(db, &#123; //第一个参数db是在线数据库的地址,也可以直接将地址写入这里,美观起见,另写一个文件存储 useNewUrlParser: true,//防止弃用警告 useUnifiedTopology: true,//防止弃用警告 useFindAndModify: false //防止弃用警告 &#125;) //提供promise调用 .then(() =&gt; console.log("mongoDB Connected")) //成功 .catch(err =&gt; console.log(err)); //失败 3.配置路由和接口在 node-app 下创建 /route/api/users.js,内容:用于登录和注册 12345678910111213141516171819//users.js//引入expressconst express = require("express");//实例化路由const router = express.Router();// $route GET api/users/test//@desc 返回请求的json数据//@access public(公有接口)//验证路由，访问/test，将返回`msg:"login works"`router.get("/test", (req, res) =&gt; &#123; //返回json数据 res.json(&#123; msg: "login works" &#125;);&#125;);//导出routermodule.exports = router; 在 server.js 中引用和使用 12345678//server.jsconst express = require('express')const app = express()//引入users.jsconst users = require("./route/api/users");//路由访问这个地址时,就会访问usersapp.use("/api/users", users); 这时 使用浏览器访问 http://localhost:5000/api/users/test即可看到返回的msg:&quot;login works&quot; 4.创建模型新建 /models/User.js, 12345678910111213141516171819202122232425262728293031//User.js//引入mongoose.可以将数据存储到mongooseconst mongoose = require("mongoose");//创建Schema模型const Schema = mongoose.Schema;//create Schemaconst UserSchema = new Schema(&#123; name: &#123; type: String, required: true &#125;, email: &#123; type: String, required: true &#125;, password: &#123; type: String &#125;, avatar: &#123; type: String, required: true &#125;, date: &#123; type: Date, default: Date.now &#125;&#125;);module.exports = User = mongoose.model("users", UserSchema); 4.5 下载postman,安装可以用来测试接口是否通. 4.6 创建register接口首先需要安装body-parser. 5.配置注册安装 body-parser，方便发送 POST 请求 1npm install body-parser 在 server.js 中引用 12345const bodyParser = require("body-parser");//使用body-parser中间件app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json()); 在 users.js 中配置接口 123456//$route POST api/uers/register//@desc 返回请求的JSON数据//@access public （公有接口）router.post("/register", (req, res) =&gt; &#123; console.log(req.body); //用来测试是否连接&#125;); //此处如果连接不上mongoDB,可能是白名单失效.再添加一个白名单在mongoDB即可. 功能 12345678910111213141516171819//1.是否有邮箱//router.post("/register", (req, res) =&gt; &#123; //查询数据库中是否拥有邮箱 User.findOne(&#123; email: req.body.email &#125;).then(user =&gt; &#123; if (user) &#123; //如果存在 return res.status(400).json(&#123; email: "邮箱已被注册！" &#125;); &#125; else &#123; //否则不存在 const newUser = new User(&#123; name: req.body.name, email: req.body.email, password: req.body.password &#125;); &#125; &#125;);&#125;); 密码加密安装 bcrypt 1npm install bcrypt 在 users.js 中引入， 1const bcrypt = require("bcrypt"); 官方详细说明链接 123456789101112131415bcrypt.genSalt(10, function(err, salt) &#123; //10是加密的一种模式 bcrypt.hash(newUser.password, salt, (err, hash) =&gt; &#123; //newUser.password 是加密对象，salt是回调函数，最后是加密结果 if (err) throw err; //如果存在错误，则抛出。 throw是js语法，抛出 //没有错误，则把加密过的密码hash赋值给password newUser.password = hash; //将newUser存储 newUser .save() .then(user =&gt; res.json(user)) .catch(err =&gt; console.log(err)); &#125;);&#125;); 头像 avatargravatar 官方说明链接安装 1npm i gravatar user.js 中引入 1const gravatar = require("gravatar"); 在接口位置使用(user.js) 1234567891011if (user) &#123; return res.status(400).json(&#123; email: "邮箱已被注册！" &#125;);&#125; else &#123; const avatar = gravatar.url(req.body.email, &#123; s: "200", r: "pg", d: "mm" &#125;); //s是大小。r是头像格式。mm是灰色的头像 const newUser = new User(&#123; name: req.body.name, email: req.body.email, avatar, //引入头像 password: req.body.password &#125;);&#125; 如何得到头像？ 打开 gravatar 网址 注册 gravatar，其注册实际是注册了 wordpress.com 网站的账户，然后登录 gravatar，任意格式的邮箱均可申请成功，但无法收到邮件，则无法验证并修改头像。因此要使用可以收到验证的邮箱。 上传头像。上传图片时，最后会选择图片会有Choose a rating for your Gravatar ，有四个选项，G、PG、R、X,这里我们选择 pg，我们在使用时也是r: &#39;pg&#39;，需要保持一致。 这时，我们使用 postman 向 http://localhost:5000/api/users/register 发送 post 请求，使用(application/x-www-form-urlencoded)(key:email value:user@usertest.com) 就能得到设置的头像了。 7.登录接口users.js 123456789101112131415161718192021222324//$route POST api/users/login//@desc 返回taken jwt passport//@access public （公有接口）router.post("/login", (req, res) =&gt; &#123; const email = req.body.email; const password = req.body.password; //查询数据库,看email是否存在 User.findOne(&#123; email &#125;).then(user =&gt; &#123; if (!user) &#123; return res.status(404).json(&#123; email: "用户不存在" &#125;); //如果用户不存在 &#125; //如果email存在 //密码匹配 //第一个password是前端传入密码，user.password是系统内密码 bcrypt.compare(password, user.password).then(isMatch =&gt; &#123; if (isMatch) &#123; res.json(&#123; msg: "success" &#125;); //如果密码对比正确,(实际这里返回token,但暂时先返回msg) &#125; else &#123; return res.status(400).json(&#123; password: "密码错误！" &#125;); //如果密码对比不正确 &#125; &#125;); &#125;);&#125;); 返回 token安装 jsonwebtoken (jwt) 1npm install jsonwebtoken 在 users.js 引入 1const jwt = require("jsonwebtoken"); 在密码验证成功处插入 我们在 config/keys.js 导出的对象中，加入了 secretOrKey:”secret” 属性和值，再引入到 users.js 以方便统一管理配置。过期时间的 3600 单位为秒token 前必须是 “Bearer ”(送信人的意思)，末尾空格也不可缺少。如果 success 为 true，就应该得到 token 值 123456789101112131415//替换上面的res.json(&#123; msg: "success" &#125;);//jwt.sign("规则","加密名字","过期时间","箭头函数")const rule = &#123; id: user.id, name: user.name &#125;; //可以更多//sign签名jwt.sign(rule, keys.secretOrKey, &#123; expiresIn: 3600 &#125;, (err, token) =&gt; &#123; if (err) throw err; res.json(&#123; success: true, //"Bearer "前缀是固定的,意思是送信者.后面有个空格 token: "Bearer " + token &#125;);&#125;);// res.json(&#123;msg:"success"&#125;); 验证 tokentoken相当于一个令牌或者钥匙.使用passport-jwt进行token验证. users.js 加入接口 123456789//$route GET api/users/current//@desc return current user//@access Privates//router.get("/current", "验证token",(req, res) =&gt; &#123;//在中间验证token,但是需要passport,还没装,会报错,暂时删掉router.get("/current", (req, res) =&gt; &#123; res.json(&#123; msg: "success" &#125;); //测试使用，后期有修改&#125;); 安装 passport-jwt 和 passport1npm install passport-jwt passport passport 网址passport-jwt 网址在 server.js 中引入,并初始化 12345//server.jsconst passport = require("passport");//passport初始化app.use(passport.initialize()); 新建文件 /config/passport.js,内容 123456789101112131415161718192021222324252627282930const JwtStrategy = require("passport-jwt").Strategy, ExtractJwt = require("passport-jwt").ExtractJwt;const mongoose = require("mongoose");const User = mongoose.model("users");const keys = require("../config/keys");const opts = &#123;&#125;;opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();opts.secretOrKey = keys.secretOrKey;module.exports = passport =&gt; &#123; passport.use( new JwtStrategy(opts, (jwt_payload, done) =&gt; &#123; //console.log(jwt_payload); //通过id获取用户 User.findById(jwt_payload.id) //获取成功 .then(user =&gt; &#123; //如果用户存在 if (user) &#123; return done(null, user); &#125; //如果用户不存在 return done(null, false); &#125;) //获取失败 .catch(err =&gt; console.log(err)); &#125;) );&#125;; 在 server.js 中引入 passport.js 1234//server.jsapp.use(passport.initialize());require("./config/passport")(passport); //这样代码就不需要在当前server.js中写了 这里使用了一个技巧，require(&quot;xxx.js&quot;)（对象） 将对象传入xxx.js,同时将该js引入当前文件中。这样就可以在xxx.js中编写代码，实现分离，而且在xxx.js可以使用传入的对象。 在 users.js 中引入 passport， 1234567891011121314151617181920//users.jsconst passport = require("passport");//完成token验证，返回部分信息//$route GET api/users/current//@desc return current user//@access Privatesrouter.get( "/current", passport.authenticate("jwt", &#123; session: false &#125;), (req, res) =&gt; &#123; res.json(&#123; id: req.user.id, name: req.user.name, email: req.user.email &#125;); &#125;); 这里调整了一些输出的内容，将输出对象改为了字符串，可能造成代码实际和上面有些出入。 添加身份如果想在 user 中添加其他信息(比如添加管理员)可参考此内容在 models/User.js 的 UserSchema 中添加身份字段 1234identity:&#123; type:String, required:true &#125;, 在 api/users.js 中加入信息 1234567891011121314151617181920212223242526// newUser中const newUser = new User(&#123; name: req.body.name, email: req.body.email, avatar, password: req.body.password, identity: req.body.identity //添加的信息&#125;);//密码匹配规则中const rule = &#123; id: user.id, name: user.name, avatar: user.avatar, identity: user.identity&#125;;//验证token输出信息时router.get("/current",passport.authenticate("jwt",&#123;session:false&#125;), (req,res) =&gt; &#123; res.json(&#123; id:req.user.id, name:req.user.name, email:req.user.email, identity:req.user.identity //添加的内容 &#125;);&#125;) 配置信息接口新建 models/Profile.js 建立ProfileSchema，内容 123456789101112131415161718192021222324252627282930313233const mongoose = require("mongoose");const Schema = mongoose.Schema;//create Schemaconst ProfileSchema = new Schema(&#123; type:&#123; type:String &#125;, describe:&#123; type:String &#125;, income:&#123; type:String, required:true &#125;, expend:&#123; type:String, required:true &#125;, cash:&#123; type:String, required:true &#125;, remark:&#123; type:String &#125;, date:&#123; type:Date, default:Date.now &#125;&#125;);module.exports = Profile = mongoose.model("profile",ProfileSchema); 新建 api/profiles.js 暂不写内容，将其在server.js中引入 12345//server.jsconst profiles = require("./route/api/profiles");//使用routeapp.use("/api/profiles", profiles); 在 api/profiles.js 配置信息进行测试 1234567891011121314//@login &amp; register const express = require("express");const router = express.Router();const passport = require("passport");const Profile = require("../../models/Profile");//$route GET api/profile/test//@desc 返回请求的JSON数据//@access public （公有接口）router.get("/test",(req,res)=&gt;&#123; res.json(&#123;msg:"Profile works"&#125;)&#125;)module.exports = router; postman 发送到 http://localhost:5000/api/profiles/test 返回 Profile works 即链接成功。 更改数据库接口如果要更改数据库接口，可以/config/keys.js中的mongoURI的值，该值的获取方法，参考上述创建时的内容。 创建添加信息的接口profiles.js 123456789101112131415//$route POST api/profile/add//@desc 创建信息接口//@access Privaterouter.post("/add",passport.authenticate("jwt",&#123;session:false&#125;),(req,res)=&gt;&#123; const profileFields = &#123;&#125;; if (req.body.type) profileFields.type = req.body.type; if (req.body.describe) profileFields.describe = req.body.describe; if (req.body.income) profileFields.income = req.body.income; if (req.body.expend) profileFields.expend = req.body.expend; if (req.body.cash) profileFields.cash = req.body.cash; if (req.body.remark) profileFields.remark = req.body.remark;new Profile(profileFields).save().then(profile =&gt; &#123;res.json(profile);&#125;)&#125;) 获取所有信息profiles.js 12345678910111213141516//$route GET api/profile//@desc 获取所有信息//@access Privaterouter.get( "/", passport.authenticate("jwt", &#123; session: false &#125;), (req, res) =&gt; &#123; Profile.find() .then(profile =&gt; &#123; if (!profile) &#123; return res.status(404).json("没有任何内容"); &#125; res.json(profile); &#125;).catch((err) =&gt; res.status(404).json("err")); &#125;) 获取单个信息 profiles.js 123456789101112131415161718//$route GET api/profile/:id//@desc 获取单个信息//@access Privaterouter.get( "/:id", passport.authenticate("jwt", &#123; session: false &#125;), (req, res) =&gt; &#123; Profile.findOne(&#123; _id: req.params.id &#125;) .then(profile =&gt; &#123; if (!profile) &#123; return res.status(404).json("没有任何内容"); &#125; res.json(profile); &#125;).catch((err) =&gt; res.status(404).json(err)); &#125;) 编辑信息profiles.js 12345678910111213141516171819202122//$route POST api/profile/edit//@desc 编辑信息接口//@access Privaterouter.post( "/edit/:id", passport.authenticate("jwt", &#123; session: false &#125;), (req, res) =&gt; &#123; const profileFields = &#123;&#125;; if (req.body.type) profileFields.type = req.body.type; if (req.body.describe) profileFields.describe = req.body.describe; if (req.body.income) profileFields.income = req.body.income; if (req.body.expend) profileFields.expend = req.body.expend; if (req.body.cash) profileFields.cash = req.body.cash; if (req.body.remark) profileFields.remark = req.body.remark; Profile.findOneAndUpdate( &#123; _id: req.params.id &#125;, &#123; $set: profileFields &#125;, &#123; new: true &#125; ).then(profile =&gt; res.json(profile)) &#125;) 删除信息profiles.js 12345678910111213141516//$route delete api/profile/delete/:id//@desc 删除信息接口//@access Privaterouter.delete( "/delete/:id", passport.authenticate("jwt", &#123; session: false &#125;), (req, res) =&gt; &#123; Profile.findOneAndRemove(&#123; _id: req.params.id &#125;) .then(profile =&gt; &#123; profile.save().then(profile =&gt; res.json(profile)); &#125; ).catch((err) =&gt; res.status(404).json("删除失败")) &#125;) 至此，信息的增删改查均已实现。要创建其他 schema 可以参考此方式 前后端连载查看vue版本，是否在3.0.0以上，我们要求是在3.0.0以上。 vue-cli的安装见 vue官网 ，这里就不说了 123456789101112131415161718192021222324252627282930313233343536373839//终端中执行vue -V //查看vue-cli版本 本案例要求3.0.0以上//创建项目 client是自己起的名字，意为"客户端"vue create client接下来进入选择流程，后面 √ 为我们作出的选择项，-----表示回车到下一选项页? Please pick a preset: ❯ default (babel, eslint) (默认配置) Manually select features （手动选择) √-----按键盘a表示全选，i表示反选，空格键 表示切换选中，如果你需要什么就选什么就可以了，这里选择Babel、Router、Vuex。? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◯ Babel √ ◯ TypeScript ◯ Progressive Web App (PWA) Support ◯ Router √ ◯ Vuex √ ◯ CSS Pre-processors ◯ Linter / Formatter ◯ Unit Testing ◯ E2E Testing ----- 是否使用history ，我们输入y，回车，会继续显示其他问题。 ? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) In dedicated config files In package.json √ Save this as a preset for future projects? (y/N) (是否要保存你当前预制模板) N （第一次时可以保存一次方便之后用） ----- 接下来就是等待安装成功。 会产生一个 client的文件夹 //启动项目 cd client npm run serve //注意，是serve 不是server 此时使用 http://localhost:8080/ 就可以打开前端了,再新建终端，执行 nodemon就打开了后台。这需要两个终端打开，较为繁琐，因此采用前后端连载，借助concurrently将多个终端启动的项目绑在一起安装 concurrently 1npm install concurrently 打开 /client/package.json 12345"scripts": &#123; "serve": "vue-cli-service serve", "build": "vue-cli-service build", "start": "npm run serve" &#125;, 此时，我们在client中 使用 npm run start即可启动前端 在根目录的 package.json 中配置client-stall、client和dev。 1234567"scripts": &#123; "client-install":"npm install --prefix client", "client":"npm start --prefix client", "start": "node server.js", "server": "nodemon server.js", "dev":"concurrently \"npm run server\" \"npm run client\"" &#125;, 此时我们可以在根目录的终端下执行npm run dev即可同时启动 前端和后台 前端部分接后端部分，此文档为 前端部分 内容。 准备工作为使内容整洁，我们将vue-cli创建项目时生成的我们不需要的文件进行整理我们接下来更多的是在client这个文件夹下工作，非强调指明，则以client视为根目录。 删除 /src/assets/logo.png （vue的logo图片） 删除 /src/components/HelloWorld.vue 删除 /src/views/ 中的About.vue 和Home.vue 新建 /src/views/Index.vue,内容为 123456789101112&lt;template&gt; &lt;div class=&quot;index&quot;&gt; 初始化页面 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;index&quot;, components:&#123;&#125;&#125;&lt;/script&gt; 打开 /src/router.js,重新整理为: 123456789101112131415161718192021import Vue from 'vue'import Router from 'vue-router'import Index from './views/Index.vue'Vue.use(Router)export default new Router(&#123; mode: 'history', base: process.env.BASE_URL, routes: [ &#123; path: '/', redirect:'/index' &#125;, &#123; path: '/index', name:'index', component: Index &#125;, ]&#125;) 打开 /src/App.vue,重新整理为 1234567891011121314&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;html,body,#app &#123; width: 100%; height: 100%;&#125;&lt;/style&gt; 新建 /public/css/reset.css ,在 /public/index.html 中引入该css文件 1&lt;link rel="stylesheet" href="css/reset.css"&gt; reset.css内容可以访问 CSS reset得到，也可在下面设置自己需要的初始样式本案例中，我们在reset.css中追加了el中加载相关的样式 123456789101112131415161718192021.el-loading&#123; position: absolute; z-index: 2000; background-color: rgba(255, 255, 255, .7); margin:0; padding: 0; top:0; right: 0; bottom: 0; left: 0; -webkit-transition:opacity .3s; transition: opacity .3s;&#125;.el-loading-spinner&#123; top:50%; margin-top:-21px; width:100%; text-align: center; position: absolute;&#125; 注册页和404 安装elementUI 12//此时目录在client中npm i element-ui -S 在/src/main.js中引入 1234import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI); 将 图片文件 放在 /src/asset/ 文件夹下面分别是404.gif,bg.jpg,logo.png,showcase.png 初始注册，新建 /src/views/Register.vue,内容 (只是简单布局，还未设置表单内容) 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div class="register"&gt; &lt;section class="form_container"&gt; &lt;div class="manage_tip"&gt; &lt;span class="title"&gt;万事屋在线后台管理系统&lt;/span&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:"register", components:&#123;&#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;.register&#123; position: relative; width: 100%; height: 100%; background: url(../assets/bg.jpg) no-repeat center center; background-size: 100% 100%;&#125;.form_container&#123; width: 370px; height: 210px; position: absolute; top:10%; left:34%; padding:25px; border-radius: 5px; text-align: center;&#125;.form_container .manage_tip .title&#123; font-family: 'Microsooft YaHei'; font-weight: bold; font-size: 26px; color: #fff;&#125;&lt;/style&gt; 在 router.js中设置路由 123456789//引入组件import Register from './views/Register.vue'//添加路由 &#123; path: '/register', name:'register', component: Register &#125;, 设置 404 页面 新建 /src/views/404.vue 组件 1234567891011121314151617&lt;template&gt; &lt;div class="notfound"&gt; &lt;img src="../assets/404.png" alt="页面没找到"&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.notfound&#123;width: 100%;height:100%;overflow: hidden;&#125;.notfound img&#123;width: 100%;height:100%;&#125;&lt;/style&gt; 在 router.js中设置路由 123456//router.js &#123; path: '*', name:'/404', component: NotFound &#125; 注册表单此后大量使用 element 的代码，为避免过长，仅提一些重要的点，其他请结合原文件阅读笔记 密码规则与验证加载动画和消息提示安装 axios 12//client目录下npm install axios 新建 /src/http.js 123456789101112131415161718192021222324252627282930313233343536373839import axios from 'axios';import &#123; Message,Loading &#125; from 'element-ui';let loading;function startLoading()&#123; loading = Loading.service(&#123; lock:true, text:"拼命加载中...", background:'rgba(0,0,0,0.7)' &#125;);&#125;function endLoading()&#123; loading.close();&#125;//请求拦截axios.interceptors.request.use(config =&gt; &#123; //加载动画 startLoading(); return config;&#125;,error =&gt; &#123; return Promise.reject(error);&#125;)//响应拦截axios.interceptors.response.use(response =&gt; &#123; //结束加载动画 endLoading(); return response;&#125;,error =&gt; &#123; //错误提醒 endLoading(); Message.error(error.response.data); return Promise.reject(error);&#125;)export default axios; 在main.js中引用 123import axios from './http'Vue.prototype.$axios = axios; http.js内容(后会变动) 123456789101112131415161718192021222324252627282930313233343536373839import axios from 'axios';import &#123; Message,Loading &#125; from 'element-ui';let loading;function startLoading()&#123; loading = Loading.service(&#123; lock:true, text:"拼命加载中...", background:'rgba(0,0,0,0.7)' &#125;);&#125;function endLoading()&#123; loading.close();&#125;//请求拦截axios.interceptors.request.use(config =&gt; &#123; //加载动画 startLoading(); return config;&#125;,error =&gt; &#123; return Promise.reject(error);&#125;)//响应拦截axios.interceptors.response.use(response =&gt; &#123; //结束加载动画 endLoading(); return response;&#125;,error =&gt; &#123; //错误提醒 endLoading(); Message.error(error.response.data); return Promise.reject(error);&#125;)export default axios; 配置前端跨域请求(使用vue-cli项目)新建 vue.config.js ，在client目录下,内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const path = require('path');const debug = process.env.NODE_ENV !== 'production';module.exports = &#123; baseUrl:'/', //根域上下文目录 outputDir:'dist', //构建输出目录 assetsDir: 'assets', //静态资源目录（js,css,img,fonts） lintOnSave:false, //是否开启eslint保存检测，有效值：true|false|'error' runtimeCompiler:true, //运行时版本是否需要编译 transpileDependencies:[], //默认babel-loader忽略node_modules,这里可增加例外的依赖包名 productionSourceMap:true, //是否在构建生产包时生产 sourceMap 文件，false将提高构建速度 configureWebpack:config =&gt; &#123; //webpack 配置，值为对象时会合并配置，为方法时会改写配置 if(debug)&#123; //开发环境配置 config.devtool = 'cheap-module-eval-source-map'; &#125;else&#123; //生产环境配置 &#125; // Object.assign(config,&#123; //开发生产共同配置 // resolve:&#123; // alias:&#123; // '@':path.resolve(__dirname,'./src'), // '@c':path.resolve(__dirname,'./src/components'), // 'vue$':'vue/dist/vue.esm.js' // &#125; // &#125; // &#125;) &#125;, chainWebpack:config =&gt; &#123; //webpack链接API，用于生成和修改webpack配置， // https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md if(debug)&#123; //本地开发配置 &#125;else&#123; //生产开发配置 &#125; &#125;, parallel:require('os').cpus().length &gt; 1, //构建时开启多进程处理babel编译 pluginOptions:&#123; //第三方插件配置 &#125;, pwa:&#123; //单页插件相关配置 // https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa &#125;, devServer:&#123; open:true, host:'localhost', port:8080, https:false, hotOnly:false, proxy:&#123;//配置跨域 '/api':&#123; target:'http://localhost:5000/api', ws:true, changOrigin:true, pathRewrite:&#123; '^/api':'' &#125; &#125; &#125;, before:app =&gt; &#123;&#125; &#125;&#125;; 这样就可以访问我们的后台了 在register.vue中配置跳转,这样就可以注册用户了 12345678910111213141516submitForm(formName) &#123; this.$refs[formName].validate(valid =&gt; &#123; if (valid) &#123; this.$axios .post("/api/users/register", this.registerUser) .then(res =&gt; &#123; //注册成功 this.$message(&#123; message: "账号注册成功！", type: "success" &#125;); &#125;); this.$router.push("/login"); &#125; &#125;); &#125; 登录逻辑新建组件和添加路由参考注册，这里讲下登录逻辑. Login.vue 1234567891011121314submitForm(formName) &#123; this.$refs[formName].validate(valid =&gt; &#123; if (valid) &#123; this.$axios.post("/api/users/login", this.loginUser).then(res =&gt; &#123; //拿到token const &#123; token &#125; = res.data; // 存储到localStorage localStorage.setItem("eleToken", token); this.$router.push('/index'); &#125;); this.$router.push("/login"); &#125; &#125;); &#125; 路由守卫router.js 1234567891011//路由守卫router.beforeEach((to, from, next) =&gt; &#123; //如果token存在返回boolean值true,否则false const isLogin = localStorage.eleToken ? true : false; if(to.path == "/login" || to.path == "/register")&#123; next(); &#125;else&#123; //如果有token,为true,就正常跳转;为false,就跳转到登录页 isLogin ? next() : next("login"); &#125;&#125;) 设置token和token 过期在请求拦截中,如果存在token,就把token设置到请求头中.在响应拦截里的error里,如果状态码是401未授权,表示token过期.就在error返回函数里清除token,并跳转到登录页. http.js 12345678910111213141516171819202122232425262728293031323334353637//请求拦截axios.interceptors.request.use(config =&gt; &#123; //加载动画 startLoading(); //如果有tokenif(localStorage.eleToken)&#123; //设置统一的请求头header config.headers.Authorization = localStorage.eleToken;&#125; return config;&#125;,error =&gt; &#123; return Promise.reject(error);&#125;)//响应拦截axios.interceptors.response.use(response =&gt; &#123; //结束加载动画 endLoading(); return response;&#125;,error =&gt; &#123; //错误提醒 endLoading(); Message.error(error.response.data); //获取错误状态码 const &#123; status &#125; = error.response; //401未授权,表示token过期 if (status == 401)&#123; Message.error('token失效，请重新登录！'); //清除token localStorage.removeItem("eleToken"); //跳转到登录页面 router.push('/login'); &#125; return Promise.reject(error);&#125;) 解析token存储到Vuex中安装解析token的模块 1npm install jwt-decode 1234567891011//Login.vue//引入解析模块import jwt_decode from 'jwt_decode';//解析tokenconst decoded = jwt_decode(token)//token存储到vuex中this.$store.dispatch("setAuthenticated", !this.isEmpty(decoded));this.$store.dispatch("setUser", decoded); 设置Vuex123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//store.js//登录成功后将数据存储到Vuex中//判断是否认证通过const types = &#123; SET_AUTHENTICATED: "SET_AUTHENTICATED", SET_USER: "SET_USER"&#125;;const state = &#123; isAuthenticated: false, user: &#123;&#125;&#125;;const getters = &#123; isAuthenticated: state =&gt; state.isAuthenticated, user: state =&gt; state.user&#125;;const mutations = &#123; [types.SET_AUTHENTICATED](state, isAuthenticated) &#123; if (isAuthenticated) state.isAuthenticated = isAuthenticated; else state.isAuthenticated = false; &#125;, [types.SET_USER](state, user) &#123; if (user) state.user = user; else state.user = &#123;&#125;; &#125;&#125;;const actions = &#123; setAuthenticated: (&#123; commit &#125;, isAuthenticated) =&gt; &#123; commit(types.SET_AUTHENTICATED, isAuthenticated); &#125;, setUser: (&#123; commit &#125;, user) =&gt; &#123; commit(types.SET_USER, user); &#125;, //清除当前的状态 clearCurrentState: (&#123; commit &#125;) =&gt; &#123; commit(types.SET_AUTHENTICATED, false); commit(types.SET_USER, null); &#125;&#125;;export default new Vuex.Store(&#123; state, getters, mutations, actions&#125;); 方法: 判断是否为空 1234567isEmpty(value)&#123; return ( value === undefined || value === null || (typeof value === "object" &amp;&amp; Object.keys(value).length === 0) || (typeof value === "string" &amp;&amp; value.trim().length === 0) ) 在根组件App.vue中判断token123456789created() &#123; if (localStorage.eleToken) &#123; //解析token const decoded = jwt_decode(localStorage.eleToken); //token存储到vuex中 this.$store.dispatch("setAuthenticated", !this.isEmpty(decoded)); this.$store.dispatch("setUser", decoded); &#125;&#125; 样式新建/component/HeadNav.vue 将HeadNav.vue引入到Index.vue,并注册,然后template中调用 在HeadNav.vue中布局 1//看代码 写向下箭头的方法 12345678910111213141516171819202122232425 methods: &#123; setDialogInfo(cmdItem) &#123; switch (cmdItem) &#123; case "info": this.showInfoList(); break; case "logout": this.logout(); break; &#125; &#125;, showInfoList() &#123; console.log("个人信息"); &#125;, logout() &#123; //清除token localStorage.removeItem("eleToken"); //设置Vuex store this.$store.dispatch("clearCurrentState"); //跳转到login this.$router.push("/login"); &#125; &#125;&#125;;//vuex中记得在actions中添加clearCurrentState 个人信息新建views/Home.vue 在router.js中设置二级路由 新建views/InfoShow.vue 侧面导航栏新建assets/component/LeftMenu.vue 编辑收支类型 创建资金列表新建views/FundList.vue 添加各个按钮,事件设置添加按钮,新增对话框component/Dialog.vue组件 编辑和添加编辑和添加功能雷同,把formData放到父级fundlist中,并用props传递修改父级中dialog的属性,新增title,options,方便切换弹窗的标题和选项 在handleEdit中修改dialog的title,当点击编辑时title就切换成’编辑’编辑时已经拿到数据了.this.formData的值也就是传入值了同样,添加的也可以新增this.formData.但是添加的数据默认是空的 在onSubmit中判断提交的类型 1const url = this.dialog.option == "add" ? "add" : `edit/$&#123;this.formData.id&#125;` 删除按钮12this.$axios.delete(`/api/profiles/delete/$&#123;row._id&#125;`)//之后可以then调用$message弹出删除成功的提示 分页elementUI布局整行分为24列.使用标准分页 123456789&lt;el-pagination @size-change="handleSizeChange" @current-change="handleCurrentChange" :current-page="currentPage4" :page-sizes="[100, 200, 300, 400]" :page-size="100" layout="total, sizes, prev, pager, next, jumper" :total="400"&gt;&lt;/el-pagination&gt; //修改绑定数据 //设置全部数据容器(数组) allTableData: [] //在获取数据时就开始设置分页数据 this.setPaginations() 在setPaginations中设置默认属性 筛选和权限定义筛选组件复制elementUI的时间选择器.添加筛选按钮,绑定筛选事件handleSearch()绑定开始时间,结束时间.在data中定义开始时间startTime,结束时间endTime 添加过滤容器filterTableData:{},在getProfile()时也存储一次. 权限使用计算属性computed获取此时用户的身份 1234computed: &#123; user()&#123; return this.$store.getters.user &#125; 使用v-if决定是否可以使用添加,编辑,删除操作. 12v-if="user.indentity == 'manager'"//将此判断加到添加事件之前和label='操作'后]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cNode社区项目]]></title>
    <url>%2F2019%2F11%2F27%2FcNode%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[实战项目: 高仿CNODE社区使用Vue-cli2搭建,包含webpack配置. 项目模块组件：Header模块PostList模块Article模块Slider侧边栏模块UserInfo用户个人中心模块Pagination分页组件的开发 主要用到的技术栈有：vue.js计算属性vue.js的内置指令和事件的绑定vue.js的自定义事件和触发vue-router路由的跳转和监听父子组件之间的数据传递]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多人博客项目]]></title>
    <url>%2F2019%2F11%2F27%2F%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[blog3说明使用Vue-cli3搭建,高度集成webpack,不暴露webpack配置,相应插件需要自行创建vue.config.js,在其中配置. 前后端接口约定后端接口规范 当前接口路径 当前接口提交数据类型,如: GET: 获取数据 POST: 提交或者创建 PUT: 修改数据 DELETE: 删除数据 PATCH: 修改数据,部分修改 参数类型格式: json或者application/x-www-form-urlencoded的数据 参数字段及限制条件 返回成功的数据格式 返回失败的数据格式 下面和后端做以下接口约定,开发阶段使用postman或者curl命令测试接口 认证相关 POST /auth/register功能: 用户注册 提交参数 参数类型: Content-type: application/x-www-form-urlencoded;chratset=utf-8 参数字段: username: 用户名,长度1-15个字符,只能是字母数字下划线 password: 密码,长度6-16位任意字符 返回数据 失败: 返回格式: {&quot;status&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;错误原因&quot;} 成功: 返回格式: 1234567891011&#123; "status": "ok", "msg": "注册成功", "data": &#123; "id" : 1, "username": "Tom", "avatar": "http://avatar.com/1.png", "createdAt": "2019-10-19T15:15:33.343Z", "updatedAt": "2019-10-19T15:15:33.343Z" &#125;&#125; 测试命令 # -d用来传递数据 # 对于POST和PUT可以: -X POST,对于GET,不加-X curl -d &quot;usernme=Tom&amp;password=123456&quot; -X POST &quot;http://localhost:3000/auth/regitster&quot; GET /auth/login功能: 用户登录 提交参数 参数类型: Content-type: application/x-www-form-urlencoded;chratset=utf-8 参数字段: username: 用户名,长度1-15个字符,只能是字母数字下划线 password: 密码,长度6-16位任意字符返回数据 失败: 返回格式: `{&quot;status&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;用户不存在&quot;}或者 {&quot;status&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;密码不正确&quot;}`成功: 返回格式: 1234567891011&#123; "status": "ok", "msg": "注册成功", "data": &#123; "id" : 1, "username": "Tom", "avatar": "http://avatar.com/1.png", "createdAt": "2019-10-19T15:15:33.343Z", "updatedAt": "2019-10-19T15:15:33.343Z" &#125;&#125; 测试命令 # -d用来传递数据 # -i 可以显示响应头 # 会发现响应头里有setCookie信息,得到cookie curl -d &quot;usernme=Tom&amp;password=123456&quot; &quot;http://localhost:3000/auth/login&quot; -i GET /auth功能: 判断用户是否登录 提交参数: 无 返回数据:已经登录的情况 返回格式: 12345678910&#123; "status": "ok", "isLogin": "true", "data": &#123; "id" : 1, "username": "Tom", "createdAt": "2019-10-19T15:15:33.343Z", "updatedAt": "2019-10-19T15:15:33.343Z" &#125;&#125; 没有登录的情况 1234&#123;"status": "ok""isLogin": false&#125; 测试命令 #先通过登录接口获取 cookie，带上 cookie 就能测试登录 curl &quot;http://localhost:3000/auth&quot; -b &quot;connect.sid=s%3AmeDbrn03UtTM8fqChaPQ20wmWlnKeHiu.e3uMtu7j1zQ1iNeaajCmxkYYGQ%2FyHV1ZsozMvZYWC6s&quot; GET /auth/logout功能: 注销登录 提交参数:无 返回数据: 失败: 返回格式: `{ &quot;status&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;用户尚未登录&quot;}` 成功: 返回格式: `{ &quot;status&quot;: &quot;success&quot;, &quot;msg&quot;: &quot;注销成功&quot;}`测试命令 curl &quot;http://localhost:3000/auth/logout&quot; -b &quot;connect.sid=s%3AmeDbrn03UtTM8fqChaPQ20wmWlnKeHiu.e3uMtu7j1zQ1iNeaajCmxkYYGQ%2FyHV11ZsozMvZYWC6s&quot; 博客相关GET /blog功能: 获取博客列表 提交参数: page: 页码,不传默认为1. userId: 用户ID,不传获取全部用户ID atIndex: 是否展示在首页.true只得到展示到首页的博客列表,false得到不展示到首页的列表,不传得到全部类型的博客列表如 /blog?page=2&amp;userId=1 获取属于用户1的第二页博客列表 返回数据: 失败: { &quot;status&quot;: &quot;系统异常&quot;}成功:返回格式: 12345678910111213141516171819&#123; "status": "ok", "msg": "获取成功", "total": 200,//全部博客总数 "page": 2,//当前页数 "totalPage": 10, //总页数 "data": &#123; "id": 1, "title": "博客标题", "description": "博客内容简要描述", "user": &#123; "id": 100, //博客所属用户id "username": "博客所属用户username", "avatar": "头像" &#125;, "createdAt": "2019-10-19T15:15:33.343Z", //创建时间 "updatedAt": "2019-10-19T15:15:33.343Z", //更新时间 &#125;&#125; 测试命令 curl &quot;http://localhost:3000/blog?page=1&amp;userId=1&quot; curl &quot;http://localhost:3000/blog?page=1&quot; curl &quot;http://localhost:3000/blog&quot; GET /blog/:blogId功能: 获取id为blogId的博客详情,如 /blog/1 提交参数: 无 返回数据: 失败: { &quot;status&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;系统异常&quot;} 成功: 返回格式: 1234567891011121314151617&#123;"status": "ok","msg": "获取成功","data": &#123; "id": 1, "title": "博客标题", "description": "博客内容简要描述", "content": "博客内容", "user": &#123; "id": 100, //博客所属用户id "username": "博客所属用户username", "avatar": "头像" &#125;, "createdAt": "2019-10-19T15:15:33.343Z", //创建时间 "updatedAt": "2019-10-19T15:15:33.343Z", //更新时间&#125;&#125; POST /blog功能: 创建博客 提交参数: 参数类型: Content-type: application/x-www-form-urlencoded; charset=utf-8; 参数字段: title : 博客标题, 博客标题不能为空，且不超过100个字符 content : 博客内容, 博客内容不能为空，且不超过10000个字符 description: 博客内容简要描述,可为空，如果为空则后台自动从content 中提取返回数据: 失败: { &quot;status&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;登录后才能操作&quot;}成功: 返回格式: 1234567891011121314151617&#123;&quot;status&quot;: &quot;ok&quot;,&quot;msg&quot;: 创建成功&quot;,&quot;data&quot;: &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;博客标题&quot;, &quot;description&quot;: &quot;博客内容简要描述&quot;, &quot;content&quot;: &quot;博客内容&quot;, &quot;user&quot;: &#123; &quot;id&quot;: 100, //博客所属用户id &quot;username&quot;: &quot;博客所属用户username&quot;, &quot;avatar&quot;: &quot;头像&quot; &#125;, &quot;createdAt&quot;: &quot;2019-10-19T15:15:33.343Z&quot;, //创建时间 &quot;updatedAt&quot;: &quot;2019-10-19T15:15:33.343Z&quot;, //更新时间&#125;&#125; 测试命令curl -d &quot;title=hello&amp;content=world&amp;description=jirengu&quot; -X POST &quot;http://localhost:3000/blog&quot; -b &quot;connect.sid=s%3AdyZh-z5fqPU_ThG9Qn8nGD6euI0UI75e.8uso0k4P6WzqWv02iQCUwxbUML2RdlOCnpKp7RSJpj0&quot; PATCH /blog/:blogid功能: 修改博客id为:blogid的博客 范例: /blog/1 提交参数 参数类型: Content-Type: application/x-www-form-urlencoded; charset=utf-8 参数字段: title: 博客标题 content : 博客内容, 博客内容不能为空，且不超过10000个字符 description: 博客内容简要描述,可为空，如果为空则后台自动从content 中提取 atIndex: true/false， 展示到首页/从首页异常, 可选返回数据 失败 返回格式: 123&#123;"status": "fail", "msg": "登录后才能操作"&#125;&#123;"status": "fail", "msg": "博客不存在"&#125;&#123;"status": "fail", "msg": "无法修改别人的博客"&#125; 成功 返回格式: 1234567891011121314151617&#123;"status": "ok","msg": 修改成功","data": &#123; "id": 1, "title": "博客标题", "description": "博客内容简要描述", "content": "博客内容", "user": &#123; "id": 100, //博客所属用户id "username": "博客所属用户username", "avatar": "头像" &#125;, "createdAt": "2019-10-19T15:15:33.343Z", //创建时间 "updatedAt": "2019-10-19T15:15:33.343Z", //更新时间&#125;&#125; 测试命令 curl -d &quot;title=hello100&amp;content=world1&amp;description=jirengu2234444444&amp;atIndex=true&quot; -X PATCH &quot;http://localhost:3000/blog/12&quot; -b &quot;connect.sid=s%3At_9V2bMXA7U9oSAmr1dhRXpdRPAsNM2B.jlpWgkwiWdpgTjexeTHGNydt8gvc%2F%2BEkJpQ9yaAmTg0&quot; DELETE /bog/:blogid功能: 删除id为:blogid的博客 提交参数：无 返回数据 失败 返回格式范例 123&#123;"status": "fail", "msg": "登录后才能操作"&#125;&#123;"status": "fail", "msg": "博客不存在"&#125;&#123;"status": "fail", "msg": "无法删除别人的博客"&#125; 成功 返回格式 1234&#123;"status": "ok","msg": "删除成功"&#125; 测试命令 curl -X DELETE &quot;http://localhost:3000/blog/12&quot; -b &quot;connect.sid=s%3AG_Chytg2F0RLWh2wTSCdLWVxpNg1MWWb.nPuMcgyMN6zxuxjSkyu8qSqM1boruol1Nce7egaXrPw&quot; 文件介绍main.js项目入口 1234567import Vue,app,router from ...new Vue(&#123; el:"#app", router, component: &#123; App &#125;, template: '&lt;App /&gt;&#125;) App.vue当前整个项目的模板 tempalte,js,style component/xxx.vue各个组件,也可以同名的文件夹,包含vue,css,js router.js路由组件 请求接口封装helpers/request.js请求组件 import axios //约定请求文件格式 axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39; //接口路径 axios.defaults.baseURL = &#39;http://blog-server.hunger-valley.com&#39; //前后端分离,即使异步请求也带上cookie axios.defaults.withCredentials = true //函数导出 export default function request(){ ... } api接口封装@/api/auth.js//引入请求接口 import request from &#39;@/helpers/request&#39; 把各个接口进行封装,便于后续调用 123456789101112131415161718192021const URL = &#123; REGISTER: '/auth/register', LOGIN: '/auth/login', LOGOUT: '/auth/logout', GET_INFO: '/auth'&#125;export default &#123; register(&#123;username, password&#125;)&#123; return request(URL.REGISTER, 'POST', &#123; username, password &#125;) &#125;, login(&#123; username, password&#125;)&#123; return request(URL.LOGIN, 'POST', &#123; username, password &#125;) &#125;, logout()&#123; return request(URL.LOGOUT) &#125;, getInfo()&#123; return request(URL.GET_INFO) &#125;&#125; 封装blog接口同样引入请求接口import request from &#39;@/helpers/request&#39; 封装blog的各个接口 123456789101112131415161718192021222324252627const URL = &#123; GET_LIST: '/blog', GET_DETAIL: '/blog/:blogId', CREATE: '/blog', UPDATE: '/blog/:blogId', DELETE: '/blog/:blogId'&#125;export default &#123; getBlogs(&#123; page=1, userId, atIndex &#125; = &#123; page:1 &#125;)&#123; return request(URL.GET_LIST, 'GET', &#123; page, userId, atIndex &#125;) &#125;, getIndexBlogs(&#123; page=1 &#125; = &#123; page: 1 &#125;)&#123; return this.getBlogs(&#123; userId, page, atIndex &#125;) &#125; getDetail(&#123; blogId &#125;)&#123; return reuqest(URL.GET_DETAIL, replace(':blogId', blogId)) &#125;, updateBlog(&#123; blogId &#125;, &#123; title, content, description, atIndex &#125;)&#123; return request(URL.UPDATE, replace(':blogId', blogId), 'PATCH', &#123; title, content, description, atIndex &#125;) &#125;, deleteBlog(&#123; blogId &#125;)&#123; return request(URL.DELETE, replace(':blogId',blogId), 'DELETE') &#125;, createBlog(&#123; title = '', content = '', description = '',atIndex = false &#125; = &#123; title = '', content = ''&#125;)&#123; return request(URL.CREATE, 'POST', &#123; title, content, description &#125;) &#125;&#125; 首页布局… 状态管理store.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// @/assets/moudles/auth.jsconst state = &#123; user: null, isLogin: false&#125;const getters = &#123; user:state =&gt; state.user, isLogin:state =&gt; state.isLogin&#125;const mutations = &#123; setUser(state, payload)&#123; state.user = payloag.user &#125;, setLogin(state, payload)&#123; state.isLogin = payload.isLogin &#125;&#125;const actions = &#123; async login(&#123; commit &#125;, &#123; username, password &#125;)&#123; let res = await auth.login(&#123; username, password &#125;) commit('setUser', &#123; user: res.data&#125;) commit('setLogin', &#123; isLogin: true &#125;) return res.data &#125;, async register(&#123; commit &#125;, &#123; username, password &#125;)&#123; let res = await auth.register(&#123; username, password&#125;) commit('setUser', &#123; user: res.data&#125;) commit('setLogin', &#123; isLogin: true &#125;) return res.data &#125;, async logout(&#123; commit &#125;)&#123; await auth.logout() commit('setUser', &#123; user: null &#125;) commit('setLogin', &#123; isLogin: false &#125;) &#125;, async checkLogin(&#123; commit, state &#125;)&#123; //判断state中是否有登录状态,有返回true if(state.isLogin) return true //如果state中没有,调用res let res = await auth.getInfo() //从res中获取isLogin状态设置Login commit('setLogin', &#123; isLogin: res.isLogin &#125;) //如果res中未登录,返回false if(!res.isLogin) return false //如果res中已登录,设置user并返回true commit('setUser', &#123; user: res.data &#125;) return true &#125;&#125;export default &#123; state, getters, mutations, actions&#125; 在header.vue中调用vuex中的参数12345678910111213141516171819202122232425//header.vueimport &#123; mapState, mapActions &#125; from 'vuex'export default &#123; data()&#123; return &#123;&#125; &#125;, computed()&#123; ...mapGetters([ 'isLogin', 'user' ]) &#125;, created()&#123; //在生命周期created调用methods的方法 this.checkLogin() &#125;, methods: &#123; //将state中的方法映射进来 ...mapActions(&#123; 'checkLogin' &#125;) &#125;&#125; 登录和注册1234567891011// Login/template.vue&lt;template&gt; &lt;div id="login"&gt; &lt;h4&gt;用户名&lt;/h4&gt; &lt;input v-model="username" placeholder="用户名"&gt; &lt;h4&gt;密码&lt;/h4&gt; &lt;input v-model="password" type="password" placeholder="密码" @key.enter="onLogin"&gt; &lt;el-button size="medium" @click="onLogin"&gt;立即登录&lt;/el-button&gt; &lt;p class="notice"&gt;没有账号?&lt;router-link to="/register"&gt;注册新用户&lt;/router-link&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920212223242526//Login/template.jsimport &#123; mapActions &#125; from 'vuex'export default &#123; data()&#123; return &#123; username: '', password: '' &#125; &#125;, methods: &#123; //把login从vuex中拿出来 ...mapActions(['login']) onLogin()&#123; //test console.log(this.username + this.password) //执行登录,把用户名密码传递 this.login(&#123;username: this.username, password: this.password&#125;) //调用then下一步操作,跳转到首页或者定向页面 .then(() =&gt; &#123; this.$router.push(&#123;path: this.$route.query.redirect || '/'&#125;) &#125;) &#125; &#125;&#125; 注册注册类似于登录将login换成register即可. 路由组件router.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import Vue from 'vue'import Router from 'vue-router'//引入store为了checkinimport store from './src/store.js'Vue.use(Router)//先声明,最后再导出const router = new Router(&#123; routes: [ &#123; path: '/', //使用匿名函数import方式实现异步懒加载 //当需要跳转该模块时才会引入相关路径 component: () =&gt; import('@/pages/Index/template.vue') &#125;, &#123; path: '/login', component: () =&gt; import('@/pages/Login/template.vue') &#125;, &#123; path: '/detail/:blogId', component: () =&gt; import('@/pages/Detail/template.vue') &#125;, &#123; path: '/edit/:blogId', component: () =&gt; import('@/pages/Edit/template.vue'), meta: &#123; requiresAuth: true &#125; &#125;, &#123; path: '/create', component: () =&gt; import('@/pages/Create/template.vue'), meta: &#123; requiresAuth: true &#125; &#125;, &#123; path: '/user/:userId', component: () =&gt; import('@/pages/User/template.vue') &#125;, &#123; path: '/my', component: () =&gt; import('@/pages/My/template.vue'), meta: &#123; requiresAuth: true &#125; &#125;, &#123; path: '/register', component: () =&gt; import('@/pages/Register/template.vue') &#125; ]&#125;)router.beforeEach((to,from,next) =&gt; &#123; //判断是否有元信息meta if(to.matched.some(record =&gt; record.meta.requiresAuth))&#123; //如果有就触发checkLogin检查登录状态 store.dispatch('checkLogin').then(isLogin =&gt; &#123; if(!isLogin)&#123; next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125;else&#123; next() &#125; &#125;) &#125;else&#123; next() &#125;&#125;)export default router 创建博客页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div id="edit"&gt; &lt;!-- 创建博客 --&gt; &lt;h1&gt;创建文章&lt;/h1&gt; &lt;h3&gt;文章标题&lt;/h3&gt; &lt;el-input v-model="title"&gt;&lt;/el-input&gt; &lt;p class="msg"&gt;限30个字&lt;/p&gt; &lt;h3&gt;内容简介&lt;/h3&gt; &lt;el-input type="textarea" v-model="description" :autosize="&#123; minRow: 2, maxRows: 4 &#125;"&gt;&lt;/el-input&gt; &lt;p class="msg"&gt;限30个字&lt;/p&gt; &lt;h3&gt;文章内容&lt;/h3&gt; &lt;el-input type="textarea" v-model="content" :autosize="&#123; minRow: 4, maxRows: 30 &#125;"&gt;&lt;/el-input&gt; &lt;p class="msg"&gt;限30个字&lt;/p&gt; &lt;p&gt; &lt;label&gt;是否展示到首页&lt;/label&gt; &lt;el-switch v-model="atIndex" active-color="#13ce66" inactive-color="#fff"&gt; &lt;/el-switch&gt; &lt;/p&gt; &lt;el-button @click="onCreate"&gt;确定&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import blog from '@/api/blog'export default &#123; data()&#123; return &#123; title: '', description: '', content: '', atIndex: false &#125; &#125;, methods: &#123; onCreate()&#123; blog.createBlog(&#123; title: this.title, content: this.content, description: this.description, atIndex: this.atIndex&#125;) .then(res =&gt; &#123; this.$message.success(res.msg) this.$router.push(&#123; path: `/detail/$&#123;res.data.id&#125;`&#125;) &#125;) &#125; &#125;&#125;&lt;/script&gt; 完善首页详情页时间插件12345678910111213141516171819202122232425262728function friendlyDate(datsStr)&#123; let dateObj = typeof datsStr === 'object' ? datsStr : new Date(datsStr) let time = dateObj.getTime() let now = Date.now() let space = now - time let str = '' switch(true)&#123; case space &lt; 60000: str = '刚刚' break case space &lt; 1000*3600: str = Math.floor(space/60000) + '分钟前' break case space &lt; 1000*3600*24: str = Math.floor(space/(1000*3600)) + '小时前' break default: str = Math.floor(space/(1000*3600*24)) + '天前' &#125; return str&#125;export default &#123; install(Vue, options) &#123; Vue.prototype.friendlyDate = friendlyDate &#125;&#125; 个人页面user有点东西 登陆者的个人页面my遇到过的问题 vuex中actions错误(原因: modules拼错了) 登录时enter无法使用.(解决方法: 加.native) 文章内容应有一定区域(原因: 没写palceholder) 编辑时少一个设置为首页的按钮(原因:按钮初始颜色透明) my页面无法显示(原因: 因为错误6) 过滤器getMouth错误,(原因: mouth单词拼错) my页面编辑删除两个按钮靠的太近 header布局错误(原因: h1标签没有把router-link包裹,如果包裹,less有设置h1下a标签的颜色为白色.没有包裹的时候,a标签的颜色是common.less设置的黑色,会覆盖)标题颜色错误,把标题文本和普通文本颜色算在一起了.]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他人面试题]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%85%B6%E4%BB%96%E4%BA%BA%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一份 1234567891011121314function Person()&#123;&#125;Person.prototype.name = "nick"Person.prototype.age = 20Person.prototype.job = "Engineer"Person.prototype.sayName = function()&#123; console.log(this.name)&#125;var person1 = new Person()var person2 = new Person()person1.name = "Greg"console.log(person1.name)console.log(person2.name)console.log(person1.hasOwnProperty("name")) 输出 123Gregnick //实例并没有改变对象的属性true 请列举js的数据类型 请写出dom事件流的三个阶段 js如何添加,移除,创建,复制,查找dom节点 jQuery的bind,live,delegate的区别 请写出至少4种vue的指令和用法 什么是闭包,什么时候使用闭包 如何编写响应式网页 简单描述一下微信小程序的文件类型 如何优化代码 请列举ES6的语法 第二份 this原型链new结合的题,问输出什么 css有什么选择器,优先级,什么属性,哪些可以继承,哪些不能继承,css3新增的伪类有哪些 vue组件通信 ajax返回三个状态码,成功失败未知,假如是未知就轮询,1到5秒延迟3秒发请求,6到10秒延迟1秒,10到20延迟0.5秒,轮询20次失败,手写可运行的代码 数组{城市,省份,代号}输出成{省份,城市[城市名,代号]} js有什么bug让你写代码出错,答类型判断.追问,怎么通过原型链判断一个对象是json, 平时写代码有什么逻辑上的错误 当前端有什么技巧?(不是优化).答:console二分法定位错误 第三份 将下列数据封装成json 数据名 值 类型 name kate string age 10 int phone 15455234376 string phone 15455234376 string date_time 2019-01-01 15:00:00 string 将如下json字符串转化成js对象并获取到name的值1var json_str = &#123;"name": "tiger"&#125; 输出 123var json_str = &#123;"name": "tiger"&#125;var str = JSON.parse('json_str')console.log(str.name) 获取如下变量中的月和日1var date_time = "2019-01-01 15:00:00" 输出 12new Date(date_time).getMonth() + 1new Date(date_time).getDate() 写出尽可能多的dom事件和js事件 写出尽可能多的伪类和伪元素 css3 2D转换,如右图效果(效果是第二个div方块向上位移一半,能够覆盖一点第一个div,然后顺时针旋转30度),代码如下,请填写div2的代码1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;style&gt;div &#123; width: 100px; height: 75px; background-color: lightgray; border: 1px solid black;&#125;div#div2&#123; /*请写代码 */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;1号div元素&lt;/div&gt;&lt;div id="div2"&gt;2号div元素&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 输出 12345div#div2&#123;transform: translateY(-20%);transform: rotate(30deg);&#125; css动画使用哪个属性,过渡使用哪个属性 写一种灰色的rgb值 尽可能多的vue的生命周期,并标注运行时间 控制元素是否显示的vue属性 下面代码的打印结果. 简述什么是变量的作用域,全局变量和局部变量的区别12345678910var a = 10;function test()&#123; a = 100 console.log(a) console.log(this.a) var a console.log(a)&#125;test()console.log(a) 输出 1234100 //声明前置,函数内部a=10010 //this指向window,a=10100 //继续输出函数内部的a10 //函数内部的a只在函数内有效,在外部看全局的a,a=10 简述cookie和session的区别 简述axios的作用和优势. 第四份 v-show和v-if的区别 let和const的区别 fetch和axios支持跨域请求吗?fetch第一次得到什么数据,怎么进行转换? 什么是MVC和MVVM,vue属于那一种?小程序是什么思想实现双向数据绑定的? async和await实现同步的好处 React/Vue中key会影响diff算法吗 Vue-router的路由原理 什么是虚拟dom 第五份 使用css让该节点不可见,方法越多越好1&lt;div class="hidden"&gt;Hi&lt;/div&gt; 输出 12 在哪些场景下用过position的哪些值,他们分别有什么特性. 什么是单进程?什么是单进程异步? 输出结果12345678910var fn = []for(var i = 0; i&lt;10;i++)&#123; fn[i] = function(param)&#123; console.log(i + param) &#125;&#125;fn[5](5)var data = &#123; a:10, b:20 &#125;console.log('第'+ i +'条数据:' + data) 输出 1215 //闭包,打印最后是10个闭包,且i=10,传入[5],打出来i也是10"第10条数据:[object Object]" //字符串+对象就会把对象打印成[object Object].这是+运算符的特点 输出结果12345678910111213141516console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;,0)console.log(3)new Promise((resolve,reject)=&gt;&#123; console.log(4) resolve()&#125;).then(()=&gt;&#123; console.log(5)&#125;, ()=&gt;&#123; console.log(6)&#125;)console.log(7) 输出 12345678//考察微任务和宏任务134 //此时并未执行异步,仍属于宏任务中script下同步代码7 //此时同步代码执行完毕,执行栈为空,5 //开始执行微任务,promise属于微任务 //不输出6是因为那是失败时的回调2 //开始下一轮event loop,执行宏任务中的异步代码.setTimeout开始执行. 输出结果12345678910const a = [1,1,1,1,1]for(let i=0;i&lt;5;i++)&#123; for(let j=0;j&lt;5;j++)&#123; a[i] = a[i] + a[j] &#125;&#125;for(let i=0; i&lt;5; i++)&#123; console.log(a[i])&#125; 输出 12345678910111213141516171819//双重遍历//可以假设外层的不变//当i=0时,内层开始遍历,得到a[0] = a[0] + a[0] //2a[0] = a[0] + a[1] //3a[0] = a[0] + a[2] //4a[0] = a[0] + a[3] //5a[0] = a[0] + a[4] //6,//此时a[0] = 6//当i=1时,内层再次遍历,得到a[1] = a[1] + a[0] //7a[1] = a[1] + a[1] //14a[1] = a[1] + a[2] //15a[1] = a[1] + a[3] //16a[1] = a[1] + a[4] //17,//此时a[1] = 17//以此类推,得到a = [6,17,50,149,446] 写出1所在的while循环的作用.补全2的代码1234567891011121314//isSymmetry用来判断正整数n是否是一个对称数.例如:12321是对称数,123不是.function isSymmetry(n)&#123; let i = n let j = 0 //位置1 while(i)&#123; j = j * 10 + i % 10 i = parseInt(i/10) &#125; return //位置2补充代码&#125;console.log(isSymmetry(12321)) //trueconsole.log(isSymmetry(12312)) //false 输出 12345678910111213141516171819假设: n = 11,i = 11,j = 0;i = 1,j = 1;i = 0 ,j = 11n = 111,i = 111,j = 0;i = 11,j = 1;i = 1,j = 11;i = 0,j = 111.n = 12,i = 12,j = 0;i = 1,j = 2;i = 0,j = 21.//结论return n == jwhile的作用: 循环判断是否将输入值的高低位置颠倒. 把数组倒序输出(不是排序,不能用内置方法)1const arr = ['name', 'first', '5', 7, 4, '2', 9] 输出 12345for(let key in arr)&#123; setTimeout(function()&#123; console.log(arr[key]) &#125;,100-key)&#125; (过一面必做题)数组中的重复项最多出现N次.(时间复杂度越低得分越高)1234//原题outputNth([1,1,1,1], 2) //return [1,1]outputNth([20, 37, 20, 20, 21], 2) //return [20,20,37,21]//预估时间复杂度 1234//附加题//如果要求outputNth([20, 37, 20, 20, 21], 2) //return [20,37,20,21] 按原数组的先后返回//预估时间复杂度 输出 12 第六份 假设有两个数组a和b,数组的内容都是从小到大排好序的数字.现在我们合并这两个数字.并且合并之后的数字也是从小到大排好序的.请写下你的实现.不要直接使用js的sort方法,并且确保只使用一次for循环.例如,a=[2,5,10],b=[4,7,9,11],那么合并的结果是c=[2,4,5,7,9,10,11]提示,你可以在一个for循环中同时控制两个数组下标i和j.比较a[i]和a[j].将小的数字加到c中,同时更新相应的下标.但是注意各种边界条件.输出 123//考察排序算法var arr = a.concat(b) //arr=[2,5,10,4,7,9,11]var c =[] 输入一个数字组成的字符串,请把它转化成整数并输出.例如,输入字符串’123’,输出整数123.不要使用库函数,函数原型为: function strToInt(str)输出 123var str = '123'console.log(+str)console.log(parseInt(str)) 合并数组中相邻且重复的元素说明: 请实现一个函数merge,传入一个数组,合并数组中相邻且重复的元素,示例: 123merge([3,2,2,4,5,5,6,2,1]) //[3,2,4,5,6,2,1]merge([3,2,3]) //[3,2,3]merge([2,2,3]) //[2,3] 输出 1 请按顺序取出下方log12345678910111213141516171819202122232425async function async1()&#123; console.log("async1 start") await async2() console.log("async1 end")&#125;async function async2()&#123; console.log("async2")&#125;console.log("script start")setTimeout(function()&#123; console.log("setTimeout")&#125;,0)async1()new Promise(function(resolve)&#123; console.log("promise1") resolve()&#125;).then(function()&#123; console.log("promise2")&#125;)console.log("script end") 输出 12345678script start async1 start //async 表达式定义的函数是立即执行的async2promise1script endasync1 end //promise2setTimeout 第七份 对MVC,MVVM的理解. vue对于jquery在开发上有什么优点 前后端分离的思想了解吗 你上一个项目都用了哪些方法优化js的性能 说一下你对vue和veux的使用方法,vue的组件复用机制 js怎样实现一个类,怎么实例化这个类 第八份 下面的函数执行后会输出什么12345678910111213const a = () =&gt; &#123; const b = new Promise((resolve,reject) =&gt; &#123; resolve("hello world") reject("error") &#125;) for(let i = 0; i &lt;10; ++i)&#123; b.then((data) =&gt; &#123; console.log(data + i) &#125;) &#125;&#125;a() //输出什么 输出 12345678910hello world0hello world1hello world2hello world3hello world4hello world5hello world6hello world7hello world8hello world9 下面的函数执行后会输出什么12345678910111213141516171819var a = async function()&#123; var b = function()&#123; return new Promise(function(resolve,reject)&#123; resolve("hello") reject("error") &#125;) .then(function(data)&#123; console.log(data + i) &#125;) .catch(function(err)&#123; console.log(err) &#125;) &#125; for(var i = 0;i&lt;10;++i)&#123; await b() &#125;&#125;a() //输出什么 输出 12345678910hello0hello1hello2hello3hello4hello5hello6hello7hello8hello9 第九份(半截) 什么是延迟加载? 请谈谈vue中的mvvm模式 vue中引入组件的步骤 什么是vuex?为什么要用vuex? 第十份 请说明值类型和引用类型的区别?那些是值类型,哪些是引用类型? 请简述private,protected,public,internal修饰符的访问权限. 简述session和cookie的作用和区别 请简述ajax工作原理和常用的ajax框架 css规范中, .后面跟一个名称代表什么?#代表什么? 字符串反转,给定字符串&quot;we;tonight;you;&quot;,编码实现输出&quot;ew;thginot;uoy;&quot; 第十一份12345678910var name = "The Window"var obj = &#123; name: "My Obj", getNameFunc: function()&#123; return function()&#123; return this.name &#125; &#125;&#125;console.log(obj.getNameFunc()()) //输出什么 输出 12obj.getNameFunc()的this是objobj.getNameFunc()()的this是window 1234567891011var name = "The Window"var obj = &#123; name: "My Obj", getNameFunc: function()&#123; var that = this; return function()&#123; return that.name &#125; &#125;&#125;console.log(obj.getNameFunc()()) //输出什么 输出 1My Obj 第十二份 vue-router原理 相关钩子函数 nexttick css3常用属性 keep-alive 屏幕滚动 箭头函数什么时候就已经绑定this 数组方法,map和forEach的区别 route和router的区别 中间件原理 第十三份 虚拟dom 生命周期,常用的那些,在这些阶段一般都做了什么 Vuex是干什么的?有哪些属性?怎么操作state中的属性 vue-router有哪些方法?怎么传递参数,获取参数,路由导航钩子有哪几种,全局钩子的移动端适配(媒体查询,flex,viewport,rem) 常用的ES6内容.const a ={b:1},改变b的值会不会报错.模板字符串,解构赋值,拓展运算符及使用场景. element-UI常用的插件,之前项目是怎么搭建的]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电话面试题]]></title>
    <url>%2F2019%2F11%2F16%2F%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[#CSS 重绘和回流(那些操作会引起重回和回流,如何减少回流) Css伪类有哪些? Position的几个属性,各个区别? Css3常用的属性 实现水平垂直居中的方法 Visible:none和display:none,hidden的区别 Css的预处理器,好处,优点作用. Css实现三角形. Css引入的方法与区别 JS 闭包的理解,作用,场景,缺点. 类如何创建和继承 深拷贝有哪些 微任务和宏任务 setInterval如何实现,用setTimeout实现. for循环里面有setTimeout,里面有console.log(i).不属于for循环最后面再有个console.log(i).17:40处. 如果把var改为let,结果如何 [] == ![]结果如何?为什么? Promise的理解 Async/Await与Promise的区别和联系.Await相对于Promise相当于Promise的什么? 随机生成一个100-200之间的数 Vue 虚拟DOM的理解 Vue如何实现双向绑定,底层 如何监听数组 异步组件在哪用,优点 计算属性和侦听器的区别(watch和computed) Slot插槽,用在哪里.独立配置webpack?有过修改吗? Vue面试题 向后台请求数据放在哪个生命周期,为什么? Vue的特性是数据驱动和组件化开发,有封装过自己的组件吗? 组件和v-model,如果组件内数据变动,页面会不会都变动? V-model的实现原理 路由菜单动态改变 请求菜单时,是每个请求都加上token还是加上其他东西? v-model绑定相同类目在不同页面,点击其中一个,另一个会变化吗?为什么? 腾讯面试1.ES6导入为什么是require？如何require模块？2.密码加密用什么插件？这个插件是对称加密还是什么？3.说下http状态码4.缓存有几个阶段？浏览器请求网页，发现没有缓存到，就去重新请求，请问这个过程是怎样的？5.如果遇到304，会用到缓存的哪些字段？6.前端工程化是什么？7.webpack插件和loader的区别8.webpack如何优化8.vue的底层原理9.说下虚拟dom js的异步机制，底层原理是什么？ node.js和js区别 计算机网络 #酒铺 API输出格式规范 单页和多页的区别 鉴权方式]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上海公司面试题]]></title>
    <url>%2F2019%2F11%2F16%2F%E4%B8%8A%E6%B5%B7%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[云印(以 vue 为主)1.页面初始化一般放在哪个生命周期里,为什么?2.vue 组件之间如何传递参数3.同步组件和异步组件之间的区别,优缺点4.vue-router 实现原理5.微信小程序的跳转方式有哪几种 ajax 的同步和异步有什么区别 css 那些属性是默认继承的? canvas和style怎么进行绑定? v-for中in和of的区别 watch如何使用 如何存储localstorage router如何传值,如何取值 vuex如何存储值 分页组件的实现 如何监听物理返回键 报关(以 http 为主) http 请求原理 http 请求的几种方式,有什么区别 如何进行登录验证,token 失效如何处理 如何调换数组中两个元素的位置.例如:[1,2,3,4,5]中调换3和4的位置,变成[1,2,4,3,5]. 向后端发送文件的格式? 外包公司 1 js 中如何检测一个变量是 String 类型.请写出函数具体实现 写出下面函数输出什么(tips:闭包) 1234567891011var count = 10;function add() &#123; var count = 0; return function() &#123; count += 1; console.log(count); &#125;;&#125;var s = add();s();s(); 输出 123//考察闭包12 如何阻止事件冒泡和默认事件 下面的问题打印什么 12345678var str = "我是MT";test();function test() &#123; console.log(str); var str = "哈哈哈"; console.log(str);&#125;console.log(str); 输出 12345//考察变量声明和作用域undefined //因为打印str时,首先从str所在的作用域找变量str,//因为有声明前置,var str,但是未赋值,是undefined.所以不再从外部找str哈哈哈我是MT 什么是盒子模型 sessionStorage,localStorage 和 cookie 的区别 px 和 em 的区别 列举不同的清除浮动的技巧 display: none和visibility: hidden的区别 组件中&lt;style scoped&gt;的scoped的作用. v-show 和 v-if 的共同点和区别 vue 注册组件使用什么关键字 vue 如何实现父子组件通信 vue 的双向数据绑定原理是什么? 外包公司 2 使用 js 将数组: [{ name: &quot;king&quot;, age: 18}, {name: &quot;bob&quot;, age: 22}]变成[18,22],并且筛选出大于 20 的值. 使用 js 获取页面一个 id 为 myP 的&lt;p&gt;标签,并为其增加点击事件,并说明一下 addEventLister 方法的第三个可选参数的冒泡和捕获. 控制台运行一下代码: 123456for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 0);&#125;console.log(i); 输出什么 1234563 //先执行for循环,i=1,有异步代码,封存数据,console.log(i).//i=2,console.log(i)//i=3,console.log(i)//此时i的最终形态是3,执行最后一行的console.log(i),是33个3 //同步代码执行完,看任务队列中排着3个console.log(i),i=3,连续输出3个3 大钱 写一个原生 ajax 请求 写几个常用的数组,字符串,对象的方法 npm install --save和npm install --save --dev的区别 IE 与火狐的事件机制有什么区别?如何阻止冒泡? 什么是闭包? 闭包的用途 css3 动画最后一帧如何恢复到原样? sessionStorage,localStorage 和 cookie 的区别?分别在什么时候用? HTML5 新特性?移除那些?如何处理 HTML5 新标签的浏览器兼容问题?做过的项目中,那些 CSS 样式需要单独写兼容样式? ES6 运算符…是用来做什么的?用 ES6 语法遍历一个数组. px,em,rem 的区别 prototype 是什么?什么时候用 js 添加,移除,替换,删除,创建,查找节点的方法是什么 如何优化网站性能(js) 编写一个方法,去掉以下数组的重复元素 vue 如何监听一个对象的变化,写个例子 setTimeout,promise,async/await 的区别 intercepter用在什么地方 路由拦截在什么地方 切换用户如何处理 用户不是提交验证进来而是输入url进来如何处理 组件里name的作用 外包公司 3 js 有哪些基本数据类型 var let const 的区别 数字计算: 在 js 中,0.1+0.2 的结果是? 下面代码有什么问题?(tips:闭包) 12345678910111213&lt;ul&gt; &lt;li&gt;test1&lt;/li&gt; &lt;li&gt;test2&lt;/li&gt; &lt;li&gt;test3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var lis = document.querySelectorAll('ul li'); for(var i = 0; i &lt;lis.length; i++)&#123; lis[i].addEventListener('click', function()&#123; console.log(i) &#125;,false) &#125;&lt;/script&gt; 无论点击哪个都会输出3解决方法:1.将var换成let for循环改造 12345for(var i = 0; i &lt;lis.length; i++)&#123; (function(i)&#123;lis[i].addEventListener('click', function()&#123; console.log(i) &#125;,false)&#125;)(i)&#125; 请写出下面输出结果, 123let obj = &#123;&#125;,arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;));console.log(obj, arr); 输出 1234&#123; prop: 123;&#125;[true]; promise 有几种状态,什么时候会进入 catch? 在 8*8 的国际象棋摆放八个皇后,使其不同相互攻击,即任意两个皇后不能处在同一行,同一列,同一对角线.总共有多少种摆法. git 命令有哪些? 外包公司 4 才匠 下面代码的输出是什么? 123456789const shape = &#123; radius: 10, diameter() &#123; return this.radius * 2; &#125;, perimeter: () =&gt; 2 * Math.PI * this.radius&#125;;shape.diameter();shape.perimeter(); 输出 1220NaN //考察箭头函数的this 2. 12345let c = &#123; greeting: "hey" &#125;;let d;d = c;c.greeting = "hello";console.log(d.greeting); 输出 1hello //考察引用类型的指针,或者说堆内存 3. 1234567891011class Chameleon &#123; static colorChange(newColor) &#123; this.newColor = newColor; &#125; constructor(&#123; newColor = "green" &#125; = &#123;&#125;) &#123; this.newColor = newColor; &#125;&#125;const freddie = new Chameleon(&#123; newColor: "purple" &#125;);freddie.colorChange("orange"); 输出 123//考察class中static的方法"freddie.colorChange is not a function"//static不能在类的实例上调用 4. 1234567function Person(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName;&#125;const member = new Person("Lydia", "Hallie");Person.getFullName = () =&gt; this.firstName + this.lastName;console.log(member.getFullName()); 输出 12345678910111213141516171819202122232425//考察ES6中的class"member.getFullName is not a function"//getFullName并没有写到Person的原型上,member并不能调用该函数解决办法:ES6:class Person&#123; constructor(firstName, lastName)&#123; this.firstName = firstName this.lastName = lastName &#125; getFullName = () =&gt; this.firstName + this.lastName;&#125;const member = new Person("Lydia","Hallie")console.log(member.getFullName())ES5原型法:function Person(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName;&#125;Person.prototype.getFullName = function()&#123; return this.firstName + this.lastName; &#125; //这里不能用箭头函数,否则this指向windowconst member = new Person("Lydia", "Hallie");console.log(member.getFullName()); 5. 12345678function checkAge(data) &#123; if (data === &#123; age: 18 &#125;) &#123; console.log("you are an adult!"); &#125; else &#123; console.log("hh"); &#125;&#125;checkAge(&#123; age: 18 &#125;); 输出 123//考察引用类型hh //考点在&#123;age: 18&#125; === &#123;age: 18&#125;是否相等,//两个不同的地址,所以不相等]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头条面试题]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%A4%B4%E6%9D%A1%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一套 替换元素与非替换元素,差异? offsetWidth,clientWidth,scrollwidth区别 Dom标准事件模型是什么?是否所有的事件都支持冒泡?如果不是,举例说明. css选择器的优先级 简述什么是IFC,作用 用CSS实现自适应正方形 Http://toutiao.com往http://mp.toutiao.com发ajax请求,跨域了吗?mp.toutiao.com的服务器可以收到请求吗,是怎样的请求? XSS和CRSF分别是什么?有什么联系?如何防御? 关于js Bridge 是什么? 实现原理 优化方案 TCP/UDP是什么?有什么区别?如何进行拥塞控制? 请用算法实现.从给定的无序,不重复的数组A中,取出N个数,使其相加和为M.并给出算法的时间空间复杂度.第二套 ES5和ES6的继承有什么区别? Web动画的几种常见方式 POST提交数据的几种常见content-type 如何定义一个方法,通过调用把视频的一帧生产预览图 什么是重放攻击,列举几个防御手段. 编程题 实现一个函数sum,运算结果满足如下预期结果: 12341. sum(1,2,3).valueof(); //62. sum(2,3)(2).valueof(); //73. sum(1)(2)(3)(4).valueof(); //104. sum(2)(4,1)(2).valueof(); //9 实现一个优先队列,使得可以这样使用. 1234567891. Const priorityQuene = new PriorityQuene()2. priorityQuene.enquene(‘优先级2-1’,2)’3. priorityQuene.enquene(‘优先级1-1’,1)’4. priorityQuene.enquene(‘优先级1-2’,1)’5. priorityQuene.enquene(‘优先级3-1’,3)’6. priorityQuene.enquene(‘优先级2-2’,2)’7. priorityQuene.enquene(‘优先级1-3’,1)’8. priorityQuene..print(); //按优先级顺序输出9. priorityQuene.dequene(); //出队 硬币找零问题:有面额为d1…dn的硬币,和要找零的钱数,找出所需最小硬币个数的方案,例如,美国有以下面额的硬币: d1=1,d2=5,d3=10,d4=25.如果要找36美分.,所需最少硬币是[1,10,25],即满足如下输出: 1234const miniCoinChange = new MinCoinChange(1,5,10,25));console.log(minCoinChange.makeChange(36)) //[1,10,25]const minCoinChange2 = new MinCoinChange([1,3,4]console.log(minCoinChange2.makeChange(6); //[3,3]]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[photoshop切图]]></title>
    <url>%2F2019%2F10%2F27%2Fphotoshop%E5%88%87%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[新建图层建议背景图层透明.移动工具: 快捷键V按住Ctrl,自动选择图层.放大缩小: Alt+滚轮 界面设置视图设置: 智能参考线 标尺(ctrl+R) ##窗口设置 信息 字符 历史记录 修改信息-面板选项 |-鼠标坐标单位-像素 |-第一颜色信息-RGB颜色 |-第二颜色信息-RGB颜色 |-状态信息-文档尺寸 编辑设置首选项-单位与标尺-标尺,文字改为像素 格局 图层和历史记录 信息和字符 保存为web切图窗口-工作区-新建工作区-web切图 基本操作套索工具L放大Ctrl+ +缩小Ctrl+ -按住空格键拖动按住shift键: 增加选区按住alt键: 删除选区 磁性套索工具L可以吸附到同颜色区域边界.多余地方可以按住shfit或者alt进行增删 快速选择工具W可以快速选择相同颜色区块画笔大小快捷键:[] 魔棒工具W类似于快速选择工具 裁剪工具C使用魔棒工具或快速选择工具选取一块区域,直接按裁剪工具,然后回车,可快速裁剪出所选区域.此时,按住Alt,点击当前图层的眼睛图标,可隐藏其他图层,只保留当前图层.即显影模式.裁剪工具时,按住Alt,点击所选图案,可以让图案成为中心. 吸管工具I选取当前颜色,前景色填充Alt+Delete背景色填充Ctrl+Delete 污点修复画笔工具J选取周围的颜色覆盖选取区域的颜色.比如照片中黑点会被抹除. 修复画笔工具按住Alt键单击左键选取要复制的区域,在其他区域就可以复制过去. 修补工具画出一个选取,将选取拖动到想要使用修补的地方进行替换修补. 仿制图章工具类似于修复画笔工具,双击选取要复制的点,在其他地方可以复制出来.与 修复画笔工具区别是,修复画笔工具复制出来的有羽化效果. 图案图章工具有可选择的备用图案,作用类似于打马赛克. 历史记录画笔工具Y作用类似于祛斑.先用高斯模糊将照片模糊到没有斑点.再将画笔圆记录到历史记录的高斯模糊这一步,再回到原图,使用该画笔圆进行处理. 渐变渐变颜色方向是顺时针 文字双击空白区域,即可写字.按住Ctrl可以拖动区域大小,Alt也可以拖动. 抓手工具H按住Alt缩小,按住shift放大. 图层奥运五环 新建文件,背景色为白色. 右下角新建图层. 使用椭圆选区工具M,按住shift(有的是alt),拉出一个标准圆. 使用吸管工具I,点击拾色器,选择颜色,确定.使用快捷键Alt+Delete填充圆形选区的颜色. 使用选区工具M,右键变化选区,按住Alt进行同心圆的缩小.右上角对号确定.按下delete删除内圆,得到圆环. Ctrl+ T自由变换,进行调整. 使用移动工具V,按住Alt进行拖动,即复制一张图层. 在右下角图层菜单中,双击图层名,进行重命名. 选取复制图层,按住Ctrl单击图层菜单中缩略图.选择颜色,Alt+Delete填充颜色. 按M使用选区后,单击空白就结束选区了. 删除覆盖在黄色上的蓝色,按住Ctrl,单击蓝色图层的缩略图,选中蓝色选区, 使用选区工具M,点击黄色图层,按住Alt选取要排除的区块(因为此时要删掉黄色图层上的两小块区域,而选区是蓝色选区,排除掉保留的蓝色,剩下的就是要真正删除的蓝色小块了),按Delete删除,就出现交叉效果了. 参考线 视图-新建参考线(按住Alt,依次按V+E) Ctrl+R调出标尺,切换到移动工具V,然后从标尺处拖出参考线. 参考线切换: 拉动参考线,按住Alt. 参考线初始化通用页面像素一般是1920*1080,页面内容一般占1200,两侧留白共720px起始左侧线可设置为360px,右侧线设置为1560px. 隐藏参考线快捷键: Ctrl+ ; 切图传统切图裁剪工具C-切片工具 参考线辅助切图先设置参考线,再点击切片工具C,上面菜单基于参考线切片.通过删除多余切片将零碎切片合并为一个切片.文件-存储为web所用格式,一般格式为PNG-24. 建议将大图裁剪成多份,然后使用参考线切片. 精准切图文件-脚本-将图层导出到文件-文件类型-PNG24-全部打√文件-导出-将图层导出导出到文件-文件类型-PNG24-全部打√(因为软件版本不同,可能命令不在上述中,上述是同一命令的两个位置)选择导出目录,运行 扩展知识将整个图层切成一个图编辑-首选项-增效工具-启动生成器打√文件-生成-图像资源 抠图先打开图片,图层-新建图层-新建图层背景图像-画布大小Ctrl+T选中图片,Alt进行比例放大Ctrl+ X可以把选取内不需要的内容删掉导出-快速导出PNG即可. 描白边使用魔棒选取大部分边缘,使用选区工具进行修补.编辑-描边-白色-5px左右,外部使用魔棒点击外部区域,选择反向,就选中了包含白边的区域.此时可以使用编辑-填充-黑色,就出现纯黑背景的白边图片了.]]></content>
  </entry>
  <entry>
    <title><![CDATA[滚动阅读]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%BB%9A%E5%8A%A8%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[初步构思 定时任务启动 滑到面板桌面(从常规桌面上滑) 点击礼盒图标(右上角,测量位置) 点击完成相关任务(位置) 自动唤醒京东读书app 点击图书(位置) 自动翻页(swipe) 完成后返回打卡页面 点击完成打卡(位置) 新增: 时间统计(共阅读了多久) 页数统计(共阅读了多少页) 防检测自动翻页位置 滑动翻页(swipe) Math.random 点击翻页(touch),时间和位置都随机 映射音量键翻页 该机分辨率为1440*720下一页触摸区域在x(480-720),y(0-1440) 规则:30分钟阅读300页,则每分钟阅读10页,至少6秒阅读完一页. 16000 * (Math.random() + 1) 每页最少6秒,最多12秒不到.每300页最少30分钟.最多60分钟不到. 随机时间123456789101112131415var initTime = 6000 * (Math.random() + 0.33333)if(initTime &lt; 6000)&#123; initTime += 4000&#125;//或者function iTime()&#123; var initTime = 6000 * ( Math.random()+ 0.33333)if(initTime &lt; 6000)&#123; return initTime += 4000&#125; return initTime&#125;iTime() 每页最少2秒,最多8秒不到.每300页最少不到16分钟.最多40分钟不到. 定时运行脚本点击脚本右边的菜单按钮-&gt;更多-&gt;定时任务设置定时运行脚本.注意必须保持Auto.js后台运行(自启动白名单、电源管理白名单等),不可加锁屏密码. 脚本的开头使用device.wakeUp()来唤醒屏幕 12345//# 启动appapp.launchApp("京东读书")//暂停运行5秒sleep(5000) 气泡信息toast(message)注意，信息的显示是”异步”执行的，并且，不会等待信息消失程序才继续执行。如果在循环中执行该命令，可能出现脚本停止运行后仍然有不断的气泡信息出现的情况 官方貌似说了会实时显示进度,那么下面的统计就不需要了.这里可以显示已经看了几页(估计得写个函数),看具体是怎么翻页了 12345如果触发一次,就次数`total += 1`if(total == 300)&#123; //toast('看完300页了,准备打卡去') //建议此时不停,不知道时间够不够,继续刷一会&#125; 12345678if(total &gt;=300 &amp;&amp; totalTime &gt;= 30*6000)&#123; //条件满足,停止刷页 stop() //跳转打卡页面&#125;else&#123; //继续刷页&#125; 立即停止exit()console.show()显示控制台。这会显示一个控制台的悬浮窗(需要悬浮窗权限)。 print(text)text {string} | {Object}要打印到控制台的信息,相当于log(text)。 基于坐标的触摸模拟要获取要点击的位置的坐标，可以在开发者选项中开启”指针位置”。 setScreenMetrics(width, height)设置脚本坐标点击所适合的屏幕宽高.如果脚本运行时，屏幕宽度不一致会自动放缩坐标. 安卓7.0以上的触摸和手势模拟click(x, y)模拟点击坐标(x, y)，并返回是否点击成功。只有在点击执行完成后脚本才继续执行。使用该函数模拟连续点击时可能有点击速度过慢的问题，这时可以用press()函数代替。 press(x, y, duration)duration: {number} 按住时长，单位毫秒模拟按住坐标(x, y), 并返回是否成功。只有按住操作执行完成时脚本才会继续执行。如果按住时间过短，那么会被系统认为是点击；如果时长超过500毫秒，则认为是长按。 swipe(x1, y1, x2, y2, duration)x1 {number} 滑动的起始坐标的x值y1 {number} 滑动的起始坐标的y值x2 {number} 滑动的结束坐标的x值y2 {number} 滑动的结束坐标的y值duration {number} 滑动时长，单位毫秒模拟从坐标(x1, y1)滑动到坐标(x2, y2)，并返回是否成功。只有滑动操作执行完成时脚本才会继续执行。 随机数randomrandom(min, max)min {number} 随机数产生的区间下界max {number} 随机数产生的区间上界返回 {number}返回一个在[min...max]之间的随机数(正整数)。例如random(0, 2)可能产生0, 1, 2。 random()返回 {number}返回在[0, 1)的随机浮点数。 device.wakeUp()唤醒设备。包括唤醒设备CPU、屏幕等。可以用来点亮屏幕。 device.wakeUpIfNeeded()如果屏幕没有点亮，则唤醒设备。 按键模拟实体按键模拟依赖root权限,故放弃. 基于控件的操作推荐使用auto()函数来确保无障碍服务已启用. auto([mode])检查无障碍服务是否已经启用，如果没有启用则抛出异常并跳转到无障碍服务启用界面；同时设置无障碍模式为mode。如果不加mode参数，则为正常模式。建议使用auto.waitFor()和auto.setMode()代替该函数，因为auto()函数如果无障碍服务未启动会停止脚本；而auto.waitFor()则会在在无障碍服务启动后继续运行。 auto.waitFor()检查无障碍服务是否已经启用，如果没有启用则跳转到无障碍服务启用界面，并等待无障碍服务启动；当无障碍服务启动后脚本会继续运行。 点击文本click(text[, i])text {string} 要点击的文本i {number} 如果相同的文本在屏幕中出现多次，则i表示要点击第几个文本, i从0开始计算该函数可以点击大部分包含文字的按钮。例如微信主界面下方的”微信”, “联系人”, “发现”, “我”的按钮。通常与while同时使用以便点击按钮直至成功。例如: 1while(!click("扫一扫")); UiSelector.exists()返回 {Boolean}判断屏幕上是否存在控件符合选择器所确定的条件。例如要判断某个文本出现就执行某个动作，可以用： 123if(text("某个文本").exists())&#123; //要支持的动作&#125; 暂停sleep()12//暂停1秒sleep(1000) 选取控件一般软件的界面是由一个个控件构成的，例如图片部分是一个图片控件(ImageView)，文字部分是一个文字控件(TextView)；同时，通过各种布局来决定各个控件的位置，例如，线性布局(LinearLayout)里面的控件都是按水平或垂直一次叠放的，列表布局(AbsListView)则是以列表的形式显示控件。控件有各种属性，包括文本(text), 描述(desc), 类名(className), id等等。我们通常用一个控件的属性来找到这个控件，例如，想要点击QQ聊天窗口的”发送”按钮，我们就可以通过他的文本属性为”发送”来找到这个控件并点击他，具体代码为: 12var sendButton = text("发送").findOne();sendButton.click(); 在这个例子中, text(“发送”)表示一个条件(文本属性为”发送”)，findOne()表示基于这个条件找到一个符合条件的控件，从而我们可以得到发送按钮sendButton，再执行sendButton.click()即可点击”发送”按钮。 果一个控件是图片控件.我们注意到这个图标的desc(描述)属性为”搜索”，那么我们就可以通过desc属性来定位这个控件，得到点击搜索图标的代码为: 1desc("搜索").findOne().click(); 另外，对于这个搜索图标而言，id属性也是唯一的，我们也可以用id(“action_search”).findOne().click()来点击这个控件。如果一个控件有id属性，那么这个属性很可能是唯一的. i_reader_folder 定时器TimerssetTimeout()与web端用法一致.但是使用了一个不同的内部实现，它是基于 Android Looper-Handler消息循环机制构建的。其实现机制与Node.js比较相似. setInterval(callback, delay[,…args])callback {Function} 当定时器到点时要调用的函数。delay {number} 调用 callback 之前要等待的毫秒数。…args {any} 当调用 callback 时要传入的可选参数。 因为定时器是异步执行,另外delay只能是number,那么不采用这种方案. 刷页函数123function turnPage()&#123; ...&#125; 准备工作先打开京东读书,登录账号点击书城-免费-点击一本书-加入书架-(多加几本) 方案一: 点击翻页1234567891011121314151617181920212223242526272829303132333435363738//检查无障碍服务开启情况auto.waitFor()//显示控制台console.show()//设置脚本适合的宽高setScreenMetrics(720, 1440)//打开京东读书appapp.launchApp("京东读书")toast("开始打卡")//等待启动sleep(2000)//跳过if(text("跳过").exists())&#123; //点击控件 text("跳过").findOne().click() sleep(2000)&#125;//检测升级if(text("下次再说").exists())&#123; //点击控件 text("下次再说").findOne().click() sleep(2000)&#125;//点击控件,跳转书架id("main_tab_bookshelf").findOne().click()sleep(1000)//准备开始图书//随机时间var initTime = 6000 * (Math.random() + 0.33333)if(initTime &lt; 6000)&#123; initTime += 4000&#125; 这里有问题应该阅读到末尾结束,出现关闭阅读.点击关闭阅读.删除第一本.重新打开一本,开始阅读. 123456789101112131415161718//已读完时,左上角出现关闭阅读if(text("关闭阅读").exists())&#123; //点击控件 text("关闭阅读").findOne().click() sleep(2000) //长按第一本书,左下角删除,弹出确认删除,点击第二个删除.sleep(2000),右上角完成,继续阅读() let index deleteBook() //继续阅读 //删掉之后,加上已阅读200页,重新开始,又会阅读300页. this.index = index readBook()&#125;else&#123; //执行自动阅读 readBook()&#125; 开始阅读-阅读完-跳出阅读-删除-重新开始阅读 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//执行阅读主步骤mianStep()function mianStep()&#123; readeBook() if(text("关闭阅读").exists())&#123; //点击控件 text("关闭阅读").findOne().click() sleep(2000) //长按第一本书,左下角删除,弹出确认删除,点击第二个删除.sleep(2000),右上角完成,继续阅读() let index deleteBook() //继续阅读 //删掉之后,加上已阅读200页,重新开始,又会阅读300页. this.index = i mianStep()&#125;//自动阅读function readBook()&#123; toast("开始阅读") //选择第一本 id("i_reader_folder").indexInParent(0).findOne().click() sleep(3000) //执行点击 clickPage()&#125;//点击阅读function clickPages()&#123; //点击300页 for(let &#123;i=0&#125;=index; i&lt;300; i++)&#123; randomClick() //间隔时间 sleep(initTime) &#125;&#125;//定时器版// for(var i=0; i&lt;5; i++)&#123;// setTimeout(randomClick(),initTime)// &#125;//随机点坐标function randomClick()&#123;//随机坐标,各缩减20px,防止误触x = random(500, 700)y = random(20, 1420)//点击随机坐标区域翻页click(x, y)&#125;//删除已读数目function deleteBook()&#123; //长按图书,坐标就是第一本书的位置 //press(x, y, 1500) id("i_reader_folder").indexInParent(0).findOne().longClick() //删除图书 text("删除").findOne().click() //要确认删除了 id("confirm").findOne().click() //右上角完成 text("完成").findOne().click()&#125;//点击打卡文本click(text["立即打卡"])//打印结束toast("打卡结束") 方案二: 滑动翻页]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-hackernews-2.0 源码解读(适合入门)(二)]]></title>
    <url>%2F2019%2F10%2F17%2Fvue-hackernews-2-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E9%80%82%E5%90%88%E5%85%A5%E9%97%A8-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[书接上回我们看下entry-server.js主要做了什么 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import &#123; createApp &#125; from './app'const isDev = process.env.NODE_ENV !== 'production'//此导出的函数将由`bundleRenderer`调用。//这是我们执行数据预取以确定//实际渲染应用程序之前的状态。//由于数据获取是异步的，因此该函数有望//返回解析为应用实例的Promise。// This exported function will be called by `bundleRenderer`.// This is where we perform data-prefetching to determine the// state of our application before actually rendering it.// Since data fetching is async, this function is expected to// return a Promise that resolves to the app instance.export default context =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const s = isDev &amp;&amp; Date.now() const &#123; app, router, store &#125; = createApp() const &#123; url &#125; = context const &#123; fullPath &#125; = router.resolve(url).route if (fullPath !== url) &#123; return reject(&#123; url: fullPath &#125;) &#125; //设置路由位置 // set router's location router.push(url) //等待路由可能的异步钩子 // wait until router has resolved possible async hooks router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents() // no matched routes if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;) &#125; //路由上匹配的组件唤醒fetchData钩子 //一个预置钩子匹配一个状态返回promise //当解析完成且状态更新 // Call fetchData hooks on components matched by the route. // A preFetch hook dispatches a store action and returns a Promise, // which is resolved when the action is complete and store state has been // updated. // 使用Promise.all执行匹配到的Component的asyncData方法，即预取数据 Promise.all(matchedComponents.map((&#123; asyncData &#125;) =&gt; asyncData &amp;&amp; asyncData(&#123; store, route: router.currentRoute &#125;))).then(() =&gt; &#123; isDev &amp;&amp; console.log(`data pre-fetch: $&#123;Date.now() - s&#125;ms`) //解析了所有prefetch钩子后,渲染app所需要的state充满了store, //在渲染上下文中公开状态，并让请求处理程序 //内联HTML响应中的状态。这允许客户端 //存储以获取服务器端状态，而不必重复 //在客户端上获取初始数据。 // After all preFetch hooks are resolved, our store is now // filled with the state needed to render the app. // Expose the state on the render context, and let the request handler // inline the state in the HTML response. This allows the client-side // store to pick-up the server-side state without having to duplicate // the initial data fetching on the client. // 把vuex的state设置到传入的context.initialState上 context.state = store.state // 返回state, router已经设置好的Vue实例app resolve(app) &#125;).catch(reject) &#125;, reject) &#125;)&#125; entry-server.js的主要工作：0.返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 Promise 返回。 context 一般包含 当前页面的url。1.手动路由切换到请求的url，即’/‘2.找到该路由对应要渲染的组件，并调用组件的asyncData方法来预取数据3.同步vuex的state数据至传入的context.initialState上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步，以避免客户端首屏重新加载数据（在客户端入口文件entry-client.js） 还记得index.template.html被设置到template属性中吗？此时Vue渲染器内部就会将Vue实例渲染进我们传入的这个html模板，那么Vue render内部是如何知道把Vue实例插入到模板的什么位置呢？ 123&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt; 就是这里，这个&lt;!--vue-ssr-outlet--&gt;Vue渲染器就是根据这个自动替换插入，所以这是个固定的placeholder。如果改动，服务端渲染时会有错误提示：Error: Content placeholder not found in template. 接下来，Vue渲染器会回调callback方法，我们回到server.js 12345678function render (req, res) &#123; ··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) ··· &#125;)&#125; 此时只需要将渲染好的html写入http响应体就结束了，浏览器客户端就可以看到页面了。 接下来我们看看服务端数据预取的实现 服务端渲染时的数据预取流程上文提到，服务端渲染时，会手动将路由导航到请求地址即’/‘下，然后调用该路由组件的asyncData方法来预取数据 那么我们看看路由配置 12345678910111213141516171819202122// /src/router/index.jsVue.use(Router)// route-level code splittingconst createListView = id =&gt; () =&gt; System.import('../views/CreateListView').then(m =&gt; m.default(id))const ItemView = () =&gt; System.import('../views/ItemView.vue')const UserView = () =&gt; System.import('../views/UserView.vue')export function createRouter () &#123; return new Router(&#123; mode: 'history', scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: [ &#123; path: '/top/:page(\\d+)?', component: createListView('top') &#125;, &#123; path: '/new/:page(\\d+)?', component: createListView('new') &#125;, &#123; path: '/show/:page(\\d+)?', component: createListView('show') &#125;, &#123; path: '/ask/:page(\\d+)?', component: createListView('ask') &#125;, &#123; path: '/job/:page(\\d+)?', component: createListView('job') &#125;, &#123; path: '/item/:id(\\d+)', component: ItemView &#125;, &#123; path: '/user/:id', component: UserView &#125;, &#123; path: '/', redirect: '/top' &#125; ] &#125;)&#125; 地址’/‘是做了redirect到’/top’,其实就是默认地址就是到top页面，在看第一条路由配置，’/top’路由对应的组件是createListView(‘top’) 1234567891011121314151617181920212223// /src/views/CreateListView.jsimport ItemList from './ItemList.vue'const camelize = str =&gt; str.charAt(0).toUpperCase() + str.slice(1)// This is a factory function for dynamically creating root-level list views,// since they share most of the logic except for the type of items to display.// They are essentially higher order components wrapping ItemList.vue.export default function createListView (type) &#123; return &#123; name: `$&#123;type&#125;-stories-view`, //从store中取值 asyncData (&#123; store &#125;) &#123; return store.dispatch('FETCH_LIST_DATA', &#123; type &#125;) &#125;, title: camelize(type), //创建itemlist的节点,渲染节点 render (h) &#123; return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; &#125;&#125; Vuex state状态变更流程asyncData方法被调用，通过store.dispatch分发了一个数据预取的事件，接下来我们可以看到通过FireBase的API获取到Top分类的数据，然后又做了一系列的内部事件分发，保存数据状态到Vuex store，获取Top页面的List子项数据，最后处理并保存数据到store. 最后数据就都保存在store这里了。 12345678910111213141516171819202122232425262728import Vue from 'vue'import Vuex from 'vuex'import actions from './actions'import mutations from './mutations'import getters from './getters'Vue.use(Vuex)export function createStore () &#123; return new Vuex.Store(&#123; state: &#123; activeType: null, itemsPerPage: 20, items: &#123;/* [id: number]: Item */&#125;, users: &#123;/* [id: string]: User */&#125;, lists: &#123; top: [/* number */], new: [], show: [], ask: [], job: [] &#125; &#125;, actions, mutations, getters &#125;)&#125; 然后将开始通过Render 函数创建HTML 12345// /src/views/CreateListView.jsrender (h) &#123; console.log(`createListView render`) return h(ItemList, &#123; props: &#123; type &#125;&#125;) &#125; 12345678910111213141516171819202122// /src/views/ItemList.vue···&lt;template&gt; &lt;div class="news-view"&gt; &lt;div class="news-list-nav"&gt; &lt;router-link v-if="page &gt; 1" :to="'/' + type + '/' + (page - 1)"&gt;&amp;lt; prev&lt;/router-link&gt; &lt;a v-else class="disabled"&gt;&amp;lt; prev&lt;/a&gt; &lt;span&gt;&#123;&#123; page &#125;&#125;/&#123;&#123; maxPage &#125;&#125;&lt;/span&gt; &lt;router-link v-if="hasMore" :to="'/' + type + '/' + (page + 1)"&gt;more &amp;gt;&lt;/router-link&gt; &lt;a v-else class="disabled"&gt;more &amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;transition :name="transition"&gt; &lt;div class="news-list" :key="displayedPage" v-if="displayedPage &gt; 0"&gt; &lt;transition-group tag="ul" name="item"&gt; &lt;item v-for="item in displayedItems" :key="item.id" :item="item"&gt; &lt;/item&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;··· 这样创建完HTML Body部分，前面提到的Vue渲染器会自动把这部分内容插入index.template.html中，替换对应的,然后就又回到前面的流程了，server.js将整个html写入http响应体，浏览器就得到了整个html页面，整个首次访问过程完成。暂时先这样]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue-SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-hackernews-2.0 源码解读(适合入门)(一)]]></title>
    <url>%2F2019%2F10%2F16%2Fvue-hackernews-2-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E9%80%82%E5%90%88%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HackerNews 是基于 HN 的官方 firebase API 、Vue 2.0 、vue-router 和 vuex 来构建的，使用服务器端渲染。vue-hackernews 项目，是尤大神在 Vue-SSR 官方文档所展示的范例 DEMO.涉及知识点及技术栈非常全面，对于初学者来说，直接阅读该项目，极具挑战。那么我就来一句一句的解析,看看到底都是啥.本文借鉴了 osan 的文章(https://wangfuda.github.io/2017/05/14/vue-hackernews-2.0-code-explain/),加上本人自己的理解,从菜鸡的角度来看,添加一些理解. 牢骚去了一家公司面试,问了半天技术,答基础不错(因为我没有工作经验).回复说我司非常依赖 SSR,对 SEO 要求很高,搜索引擎排名必须第一,要求我必须尽快做出一份 demo 出来满足他们的最低要求.那么问题来了,我对 SSR 基本只是一知半解,怎么用完全属于白板啊.当时周五,那么只剩周六日两天了,也就是说,两天从不知 SSR 为何物到搞出一个 demo.压力好大.回去路上就开始上网查文档.我一看,这是啥,这又是啥.完全不知所云啊.无奈看看有没有入门教程吧,一搜,好少啊,看看掘金,挺多的,挨个看一遍,为什么都在 copy 官方文档啊,把各个组件,方法讲讲都是干嘛的也行啊,根本没讲,copy 完官方文档,直接甩一个 demo.我:what?这真是应验了官方指南的话, 本指南将会非常深入，并且假设你已经熟悉 Vue.js 本身，并且具有 Node.js 和 webpack 的相当不错的应用经验。我这完全不熟悉 node 和 webpack 的人完全就是抓瞎啊.好吧,经过不断努(bao)力(gan),终于搞出了一个 demo,人家说技术不过关,期待下次合作.wtf?也在意料之中了,有老手为什么还要菜鸡呢?不过这技术不能扔了,我得记下来,以警示后人… 结构概览项目结构图上显示，有两个入口文件，entry-server.js 和 entry-client.js， 分别是服务端渲染和客户端渲染的实现入口，webpack 将两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 服务端：当 Node Server 收到来自 Browser 的请求后，会创建一个 Vue 渲染器 BundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件（即 entry-server.js），并且执行它，而 server bundle 实现了数据预取并返回已填充数据的 Vue 实例，接下来 Vue 渲染器内部就会将 Vue 实例渲染进 html 模板，最后把这个完整的 html 发送到浏览器。 客户端：Browser 收到 HTML 后，客户端加载了client bundle(即 entry-client.js) ，通过 app.$mount(‘#app’)挂载 Vue 实例到服务端渲染的 DOM 上,并会和服务端渲染的HTML进行 Hydration（合并）. 大体操作 目录概览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748│ manifest.json # progressive web apps配置文件│ package.json # 项目配置文件│ server.js # 服务端渲染│├─public # 静态资源│ logo-120.png│ logo-144.png│ logo-152.png│ logo-192.png│ logo-384.png│ logo-48.png│└─src │ app.js # 整合 router,filters,vuex 的入口文件 │ App.vue # 根 vue 组件 │ entry-client.js # client 的入口文件 │ entry-server.js # server 的入口文件 │ index.template.html # html 模板 │ ├─api │ create-api-client.js # Client数据源配置 │ create-api-server.js # server数据源配置 │ index.js # 数据请求API │ ├─components │ Comment.vue # 评论组件 │ Item.vue # │ ProgressBar.vue # 进度条组件 │ Spinner.vue # 加载提示组件 │ ├─router │ index.js # router配置 │ ├─store # Vue store模块 │ actions.js # 根级别的 action │ getters.js # 属性接口 │ index.js # 我们组装模块并导出 store 的地方 │ mutations.js # 根级别的 mutation │ ├─util │ filters.js # 过滤器 │ title.js # 工具类 │ └─views CreateListView.js # 动态生成列表界面的工厂方法 ItemList.vue # List界面组件 ItemView.vue # 单List项组件 UserView.vue # 用户界面组件 开发环境的服务端渲染流程12# serve in dev mode, with hot reload at localhost:8080$npm run dev 看看发生了什么上述执行 dev 属性对应的脚本：node server 即 node server.js，即执行 server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//server.jsconst fs = require("fs");const path = require("path");const LRU = require("lru-cache");const express = require("express");const favicon = require("serve-favicon");const compression = require("compression");const microcache = require("route-cache");const resolve = file =&gt; path.resolve(__dirname, file);const &#123; createBundleRenderer &#125; = require("vue-server-renderer");//设置生产环境const isProd = process.env.NODE_ENV === "production";//使用微缓存const useMicroCache = process.env.MICRO_CACHE !== "false";//服务端信息const serverInfo = `express/$&#123;require("express/package.json").version&#125; ` + `vue-server-renderer/$&#123;require("vue-server-renderer/package.json").version&#125;`;//调用expessconst app = express();//创建渲染器function createRenderer(bundle, options) &#123; // 调用vue-server-renderer的createBundleRenderer方法创建渲染器， //并设置HTML模板，以后后续将服务端预取的数据填充至模板中 return createBundleRenderer( bundle, Object.assign(options, &#123; // for component caching //设置一个缓存 cache: LRU(&#123; max: 1000, maxAge: 1000 * 60 * 15 &#125;), // this is only needed when vue-server-renderer is npm-linked basedir: resolve("./dist"), // recommended for performance runInNewContext: false &#125;) );&#125;let renderer;let readyPromise;//模板路径const templatePath = resolve("./src/index.template.html");if (isProd) &#123; //生产环境: //webpack结合vue-ssr-webpack-plugin插件生成的server bundle //服务端渲染的HTML模板 const template = fs.readFileSync(templatePath, "utf-8"); //生产环境的时候这里已经打包好了这个json文件可以直接调用 const bundle = require("./dist/vue-ssr-server-bundle.json"); //client manifests是可选项,允许渲染器自动预加载,渲染添加&lt;script&gt;标签 // The client manifests are optional, but it allows the renderer // to automatically infer preload/prefetch links and directly add &lt;script&gt; // tags for any async chunks used during render, avoiding waterfall requests. const clientManifest = require("./dist/vue-ssr-client-manifest.json"); //vue-server-renderer创建bundle渲染器并绑定server bundle renderer = createRenderer(bundle, &#123; template, clientManifest &#125;);&#125; else &#123; // 开发环境下，使用dev-server来通过回调把生成在内存中的bundle文件传回 // 通过dev server的webpack-dev-middleware和webpack-hot-middleware实现客户端代码的热更新 //以及通过webpack的watch功能实现服务端代码的热更新 // In development: setup the dev server with watch and hot-reload, // and create a new renderer on bundle / index template update. readyPromise = require("./build/setup-dev-server")( app, templatePath, (bundle, options) =&gt; &#123; // 基于热更新，回调生成最新的bundle渲染器 renderer = createRenderer(bundle, options); &#125; );&#125;//静态缓存时间const serve = (path, cache) =&gt; express.static(resolve(path), &#123; maxAge: cache &amp;&amp; isProd ? 1000 * 60 * 60 * 24 * 30 : 0 &#125;);//依次装载一系列Express中间件，用来处理静态资源，数据压缩等app.use(compression(&#123; threshold: 0 &#125;));app.use(favicon("./public/logo-48.png"));app.use("/dist", serve("./dist", true));app.use("/public", serve("./public", true));app.use("/manifest.json", serve("./manifest.json", true));app.use("/service-worker.js", serve("./dist/service-worker.js"));// since this app has no user-specific content, every page is micro-cacheable.// if your app involves user-specific content, you need to implement custom// logic to determine whether a request is cacheable based on its url and// headers.// 1-second microcache.// https://www.nginx.com/blog/benefits-of-microcaching-nginx///设置微缓存app.use(microcache.cacheSeconds(1, req =&gt; useMicroCache &amp;&amp; req.originalUrl));function render(req, res) &#123; const s = Date.now(); res.setHeader("Content-Type", "text/html"); res.setHeader("Server", serverInfo); const handleError = err =&gt; &#123; if (err.url) &#123; res.redirect(err.url); &#125; else if (err.code === 404) &#123; res.status(404).send("404 | Page Not Found"); &#125; else &#123; // Render Error Page or Redirect res.status(500).send("500 | Internal Server Error"); console.error(`error during render : $&#123;req.url&#125;`); console.error(err.stack); &#125; &#125;; // 设置请求的url const context = &#123; title: "Vue HN 2.0", // default title url: req.url &#125;; // 为渲染器绑定的server bundle（即entry-server.js）设置入参context renderer.renderToString(context, (err, html) =&gt; &#123; if (err) &#123; return handleError(err); &#125; res.send(html); if (!isProd) &#123; console.log(`whole request: $&#123;Date.now() - s&#125;ms`); &#125; &#125;);&#125;//启动一个服务并监听从 8080 端口进入的所有连接请求。app.get( "*", isProd ? render : (req, res) =&gt; &#123; readyPromise.then(() =&gt; render(req, res)); &#125;);const port = process.env.PORT || 8080;app.listen(port, () =&gt; &#123; console.log(`server started at localhost:$&#123;port&#125;`);&#125;); server.js 最终监听 8080 端口等待处理客户端请求，此时在浏览器访问 localhost:8080请求经由 express 路由接收后，执行处理逻辑:readyPromise.then(() =&gt; render(req, res))沿着 Promise 的调用链处理：开发环境下 1.调用 setup-dev-server.js 模块，根据上图中 webpack config 文件实现入口文件打包，热替换功能实现。最终通过回调把生成在内存中的 server bundle 传回。 2.创建渲染器，绑定 server bundle，设置渲染模板，缓存等 3.依次装载一系列 Express 中间件，用来处理静态资源，数据压缩等 4.最后将渲染好的 HTML 写入 http 响应体，传回浏览器。 setup-dev-serverserver.js 的模块依赖关系图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// setup-dev-server.jsconst fs = require("fs");const path = require("path");const MFS = require("memory-fs");const webpack = require("webpack");const chokidar = require("chokidar");const clientConfig = require("./webpack.client.config");const serverConfig = require("./webpack.server.config");//读取文件const readFile = (fs, file) =&gt; &#123; try &#123; //fs读取客户端输出路径 return fs.readFileSync(path.join(clientConfig.output.path, file), "utf-8"); &#125; catch (e) &#123;&#125;&#125;;//输出模块,创建开发服务module.exports = function setupDevServer(app, templatePath, cb) &#123; let bundle; let template; let clientManifest; let ready; const readyPromise = new Promise(r =&gt; &#123; ready = r; &#125;); //设定更新 const update = () =&gt; &#123; if (bundle &amp;&amp; clientManifest) &#123; ready(); cb(bundle, &#123; template, clientManifest &#125;); &#125; &#125;; //读取本地模板并观测 // read template from disk and watch template = fs.readFileSync(templatePath, "utf-8"); chokidar.watch(templatePath).on("change", () =&gt; &#123; template = fs.readFileSync(templatePath, "utf-8"); console.log("index.html template updated."); update(); &#125;); //客户端热加载服务 // modify client config to work with hot middleware clientConfig.entry.app = [ "webpack-hot-middleware/client", clientConfig.entry.app ]; clientConfig.output.filename = "[name].js"; clientConfig.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() ); //开发中间件 // dev middleware const clientCompiler = webpack(clientConfig); const devMiddleware = require("webpack-dev-middleware")(clientCompiler, &#123; publicPath: clientConfig.output.publicPath, noInfo: true &#125;); app.use(devMiddleware); // 在client webpack结合vue-ssr-webpack-plugin完成编译后，获取devMiddleware的fileSystem // 读取内存中的bundle 并通过传入的回调更新server.js中的bundle clientCompiler.plugin("done", stats =&gt; &#123; stats = stats.toJson(); stats.errors.forEach(err =&gt; console.error(err)); stats.warnings.forEach(err =&gt; console.warn(err)); if (stats.errors.length) return; clientManifest = JSON.parse( readFile(devMiddleware.fileSystem, "vue-ssr-client-manifest.json") ); update(); &#125;); //中间件热加载 // hot middleware app.use( require("webpack-hot-middleware")(clientCompiler, &#123; heartbeat: 5000 &#125;) ); //观测更新服务渲染 // watch and update server renderer const serverCompiler = webpack(serverConfig); // 获取基于memory-fs创建的内存文件系统对象 const mfs = new MFS(); serverCompiler.outputFileSystem = mfs; // 设置文件重新编译监听并通过传入的回调更新server.js中的bundle serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123; if (err) throw err; stats = stats.toJson(); if (stats.errors.length) return; //读取bundle文件 // read bundle generated by vue-ssr-webpack-plugin bundle = JSON.parse(readFile(mfs, "vue-ssr-server-bundle.json")); update(); &#125;); return readyPromise;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// build/webpack.base.config.jsconst path = require("path");const webpack = require("webpack");const ExtractTextPlugin = require("extract-text-webpack-plugin");const FriendlyErrorsPlugin = require("friendly-errors-webpack-plugin");const &#123; VueLoaderPlugin &#125; = require("vue-loader");//生产环境const isProd = process.env.NODE_ENV === "production";module.exports = &#123; //开发环境搞这些 // 开发环境下，开启代码调试map，方便调试断点时代码寻址，推荐模式选择：cheap-module-source-map devtool: isProd ? false : "#cheap-module-source-map", // 打包输出配置 output: &#123; path: path.resolve(__dirname, "../dist"), publicPath: "/dist/", filename: "[name].[chunkhash].js" &#125;, resolve: &#123; alias: &#123; public: path.resolve(__dirname, "../public") &#125; &#125;, //解析模块,各种加载器 module: &#123; noParse: /es6-promise\.js$/, // avoid webpack shimming process rules: [ &#123; test: /\.vue$/, loader: "vue-loader", options: &#123; compilerOptions: &#123; preserveWhitespace: false &#125; &#125; &#125;, &#123; test: /\.js$/, loader: "babel-loader", exclude: /node_modules/ &#125;, &#123; test: /\.(png|jpg|gif|svg)$/, loader: "url-loader", options: &#123; limit: 10000, name: "[name].[ext]?[hash]" &#125; &#125;, &#123; test: /\.styl(us)?$/, use: isProd ? ExtractTextPlugin.extract(&#123; use: [ &#123; loader: "css-loader", options: &#123; minimize: true &#125; &#125;, "stylus-loader" ], fallback: "vue-style-loader" &#125;) : ["vue-style-loader", "css-loader", "stylus-loader"] &#125; ] &#125;, performance: &#123; hints: false &#125;, //生产环境搞这些 plugins: isProd ? [ new VueLoaderPlugin(), // 压缩js的插件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), new webpack.optimize.ModuleConcatenationPlugin(), // 从bundle中提取出特定的text到一个文件中,可以把css从js中独立抽离出来 new ExtractTextPlugin(&#123; filename: "common.[chunkhash].css" &#125;) ] : [new VueLoaderPlugin(), new FriendlyErrorsPlugin()]&#125;; 创建渲染器就是server.js里这一步 123456789function createRenderer (bundle, options) &#123; // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer console.log(`createRenderer`) return createBundleRenderer(bundle, Object.assign(options, &#123; template, ··· &#125;))&#125; 创建渲染器时重点两件事：1.绑定渲染用的server bundle至渲染器，这个bundle是在setup-dev-server.js中将服务端入口文件entry-server.js打包生成的。当渲染器调用renderer.renderToString开始渲染时，会执行该入口文件的默认方法。2.传入了一个html模板index.template.html，这个模板稍后在服务端渲染时就会动态填充预取数据到模板中。 顺着readyPromise.then的调用链，接下来调用render方法 123456function render (req, res) &#123;··· renderer.renderToString(context, (err, html) =&gt; &#123; res.end(html) &#125;)&#125; renderer.renderToString方法内部会先调用入口模块entry-server.js的默认方法.下节再叙]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue-SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue可复用性&组合]]></title>
    <url>%2F2019%2F10%2F14%2Fvue%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%2F</url>
    <content type="text"><![CDATA[混入mixin一个混入对象可以包含任意组件选项.当组件使用混入对象时,所有混入对象的选项将被”混合”进组件本身的选项.例子: 123456789101112131415161718//定义一个混入对象var myMixin = &#123; created: function()&#123; this.hello() &#125;, methods: &#123; hello: function()&#123; console.log('hello from mixin") &#125; &#125;&#125;//定义一个使用混入对象的组件var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() //=&gt; 'hello from mixin' 选项合并当组件和混入对象含有同名选项时,这些选项将以恰当的方式进行”合并”.比如,数据对象在内部会进行递归合并,并在发生冲突时以组件数据优先. 123456789101112131415161718192021var mixin = &#123; data: function()&#123; return &#123; message: 'hello', foo: 'abc' &#125; &#125;&#125;new Vue(&#123; mixins: [mixin], data: function()&#123; return &#123; message: 'goodbye', bar: 'def' &#125; &#125;, created: function()&#123; console.log(this.$data) // =&gt; &#123; message: 'goodbye', foo:'abc', bar: 'def'&#125; &#125;&#125;) 同名钩子函数将合并成一个数组,因此都将被调用.另外,混入对象的钩子将在组件自身钩子之前调用. 123456789101112131415var mixin = &#123; created: function()&#123; console.log('混入对象钩子被调用') &#125;&#125;new Vue(&#123; mixins: [mixin], created: function()&#123; console.log('组件钩子被调用') &#125;&#125;)//=&gt; '混入对象钩子被调用'//=&gt; '组件钩子被调用' 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 1234567891011121314151617181920212223242526var mixin = &#123; methods: &#123; foo: function()&#123; console.log('foo') &#125;, conficting: function()&#123; console.log('from mixin') &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function()&#123; console.log('bar') &#125;, conficting: function()&#123; console.log('from self') &#125; &#125;&#125;)vm.foo() // =&gt; "foo"vm.bar() // =&gt; "bar"vm.conflicting() // =&gt; "from self" 注意：Vue.extend() 也使用同样的策略进行合并。 全局混入混入也可以进行全局注册,使用时需要小心.一但使用全局混入,他将影响每一个之后创建的Vue实例.使用恰当时还可以用来为自定义选项注入处理逻辑. 1234567891011121314// 为自定义的选项 'myOption' 注入一个处理器。Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello!'&#125;)// =&gt; "hello!" 请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。 自定义选项合并策略自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 Vue.config.optionMergeStrategies 添加一个函数： 123Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) &#123; // 返回合并后的值&#125; 对于多数值为对象的选项，可以使用与 methods 相同的合并策略： 12var strategies = Vue.config.optionMergeStrategiesstrategies.myOption = strategies.methods 可以在 Vuex 1.x 的混入策略里找到一个更高级的例子： 12345678910const merge = Vue.config.optionMergeStrategies.computedVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) &#123; if (!toVal) return fromVal if (!fromVal) return toVal return &#123; getters: merge(toVal.getters, fromVal.getters), state: merge(toVal.state, fromVal.state), actions: merge(toVal.actions, fromVal.actions) &#125;&#125; 自定义指令输入框聚焦当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能： 12345678//注册一个全局自定义指令v-focusVue.directive('focus', &#123;//当被绑定的元素插入到DOM中时...inserted: function(el)&#123; //聚焦元素 el.focus() &#125;&#125;) 局部指令注册,组件中接受directive: 12345678directives: &#123; focus: &#123; //指令的定义 inserted: function(el)&#123; el.focus() &#125; &#125;&#125; 然后在模板中任何元素上使用v-focus属性,例如: 1&lt;input v-focus&gt; 钩子函数一个指令对象可以提供以下几个钩子函数: bind: 只调用一次,指令第一次绑定到元素时调用.在这里进行一次性的初始化设置. inserted: 被绑定元素插入到父节点时调用. update: 所在组件的VNode更新时调用,但是可能发生在其子VNode更新之前.指令的值可能发生改变,也可能没有. componentUpdated: 指令所在组件的VNode及其子VNode全部更新后调用. unbind: 只调用一次,指令与元素解绑时调用. 钩子函数的参数指令钩子会被传入以下参数: el: 指令所绑定的元素,可以直接操作DOM. binding: 一个对象,包含以下属性: name: 指令名,不包括v-前缀. value: 指令的绑定值.例如：v-my-directive=&quot;1 + 1&quot;中，绑定值为2。 oldValue: 指令绑定的上一个值.仅在update和componentUpdated钩子中可用.无论值是否改变都可用. expression: 字符串形式的指令表达式.例如 v-my-directive=&quot;1 + 1&quot;中，表达式为 &quot;1 + 1&quot;。 arg: 传给指令的参数.可选.例如 v-my-directive:foo 中，参数为 “foo”。 modifiers: 一个包含修饰符的对象.例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode: Vue编译生成的虚拟节点. oldVNode: 上一个虚拟节点. 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 范例: 1234567891011121314151617181920212223//html&lt;div id="hook-arguments-example" v-demo:foo.a.b="message"&gt;&lt;/div&gt;//jsVue.directive('demo', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#hook-arguments-example', data: &#123; message: 'hello!' &#125;&#125;) 动态指令参数在 v-mydirective:[argument]=&quot;value&quot; 中，argument 参数可以根据组件实例数据进行更新！例如创建一个自定义指令,通过固定布局将元素固定在页面上. 1234&lt;div id="baseexample"&gt; &lt;p&gt;Scroll down this page&lt;/p&gt; &lt;p v-pin="200"&gt;Stick me 200px from the top of the page&lt;p&gt;&lt;/div&gt; 自定义事件 12345678910Vue.directive('pin', &#123; bind: function(el, bingding, vnode)&#123; el.style.position = 'fixed' el.style.top = binding.value + 'px' &#125;&#125;)new Vue(&#123; el: '#baseexample"&#125;) 这会把元素固定在距离页面顶部200px的位置.如果需要将元素固定在左侧呢? 1234&lt;div id="dynamicexample"&gt; &lt;p&gt;Scroll down this page&lt;/p&gt; &lt;p v-pin:[direction]="200"&gt;I am pinned onto the page at 200px to the left.&lt;p&gt;&lt;/div&gt; 12345678910111213141516Vue.directive('pin',&#123; bind: function(el, binding, vnode)&#123; el.style.position = 'fixed' var s = (binding.arg == 'left' ? 'left' : 'top') el.style[s] = binding.value + 'px' &#125;&#125;)new Vue(&#123; el: '#dynamicexample', data: function()&#123; return &#123; direction: 'left' &#125; &#125;&#125;) 函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: 123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。 1234567//html&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt;//jsVue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; "white" console.log(binding.value.text) // =&gt; "hello!"&#125;) 渲染函数&amp;JSX渲染函数在Vue.js进阶里有讲到,JSX先不看了. 插件插件用来为Vue添加全局功能.插件常用功能: 添加全局方法或属性. 添加全局资源: 指令,过滤器,过渡 通过全局混入来添加一些组件选项. 添加Vue实例方法,通过把他们添加到Vue.prototype上实现. 一个库,提供自己的API,同时提供上面提到的一个或多个功能.如Vue-router 使用插件通过全局方法Vue.use()使用插件.需要在new Vue()之前调用.也可以传入一个可选的对象. 1Vue.use(MyPlugin, &#123; someOption: true&#125;) Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 Vue.js 官方提供的一些插件 (例如 vue-router) 在检测到 Vue 是可访问的全局变量时会自动调用 Vue.use()。然而在像 CommonJS 这样的模块环境中，你应该始终显式地调用 Vue.use() 开发插件Vue.js的插件暴露一个install的方法.这个方法的第一个参数是Vue构造器,第二个参数是可选的选项对象: 123456789101112131415161718192021222324252627MyPlugin.install = function(Vue, options)&#123; //1. 添加全局方法或属性 Vue.myGlobalMethod = function()&#123; //逻辑.. &#125; //2.添加全局资源 Vue.directive('my-directive',&#123; bind(el, binding, vnode, oldVnode)&#123; //逻辑 &#125; //... &#125;) //3. 注入组件选项 Vue.mixin(&#123; created: function()&#123; //逻辑... &#125; //... &#125;) //4. 添加实例方法 Vue.prototype.$myMethod = function(methodOptions)&#123; //逻辑... &#125;&#125; 过滤器过滤器可以用在：双花括号插值和 v-bind 表达式 12345&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt; 在组件的选项中定义本地的过滤器 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; 或者在创建Vue实例之前全局定义过滤器: 123456789Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123; // ...&#125;) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。过滤器可以串联 1&#123;&#123; message | filterA | filterB &#125;&#125; 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器可以接收参数: 1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue过渡和动画]]></title>
    <url>%2F2019%2F10%2F14%2Fvue%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序入门]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[小程序的文件结构app.js: 设置一些项目的全局变量app.json: 每一个新页面都必须在这个页面注册app.wxss: 项目全局样式project.config.json: 项目配置文件 一个页面主要是包含以下四个文件，这四个文件的名字应该都是一样的，最好以页面所在的文件夹名字为标准：xxx.wxml: 页面结构xxx.wxss: 页面样式xxx.json: 页面配置文件xxx.js: 页面脚本文件 通过新建目录,新建component.可以快速建立上述同名称文件. 页面可以嵌套,但不能超过5个层级.app.json中tabBar可以设置导航栏颜色背景,下属的list中可以设置下标按钮的信息. 设备分辨率和RPXpt: 视觉单位.与屏幕的物理尺寸有关系,也叫做逻辑分辨率,与移动端的栅格渲染有关.px: 像素点,物理分辨率.随着屏幕变化不会变化.一般设计稿以px为单位.iphone6的分辨率是375,设计稿一般是750,那么 rpx : px = 2:1.rpx 是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx. 当需要的元素大小适应屏幕尺寸，就选择rpx作为单位，否则使用px作为单位。 小程序的事件冒泡事件: 当一个组件上的事件被触发,该事件会向父节点传递.非冒泡事件: 与之相反,不向父节点传递. 事件绑定key以bind或者catch开头,然后跟上事件的类型,如bindtap,catchtouchstart.value是一个字符串,需要在对应的page中定义同名的函数,不然当触发时会报错.区别: bind事件绑定不会阻止冒泡事件向上冒泡,catch事件绑定可以阻止. 下拉刷新监听用户下拉刷新事件 在app.json的window选项或者页面配置中开启enablePullDownRefresh. 可以通过wx.startPullDownRefresh触发下拉刷新,调用后触发下拉刷新动画. 当处理完数据刷新后,wx.stopPullDownRefresh可以停止当前页面的下拉刷新. 小程序更新数据的值函数用于将数据从逻辑层更新到视图层(异步) 1this.setData(object data, function callback) data: 传一个object,是这次要改变的数据callback: 传一个function,是setData引起页面更新渲染完毕后的回调函数 //赋值的方式 1this.setData(&#123; arr: this.data.arr&#125;) 小程序中push方法基本失效. 改变object中的值1this.setData(&#123; "obj.text": "message2" &#125;) 小程序的路由方式打开新页面: wx.navigateTo 或使用组件&lt;navigator open-type=&quot;navigateTo&quot; /&gt;页面重定向: wx.redirectTo 或使用组件&lt;navigator open-type=&quot;redirectTo&quot;/&gt;压面返回: wx.navigateBack 或使用组件&lt;navigator open-type=&quot;navigateBack&quot;/&gt;Tab切换: wx.switchTab或使用组件&lt;navigator open-type=&quot;switchTab&quot;/&gt;重启动: wx.reLauch或使用组件&lt;navigator open-type=&quot;reLauch&quot;/&gt; 小程序请求接口方式HTTPS请求: wx.request上传文件: wx.uploadFile下载文件: wx.downloadFilewebSocket通信: wx.connectSocket 小程序的生命周期onLoad: 页面加载时触发.一个页面只会调用一次.可以在onLoad的参数中获取打开当前页面路径中的参数onShow: 页面显示/切入前台时触发onReady: 页面初次渲染时触发.一个页面只调用一次.onHide: 页面隐藏/切入后台时触发.如navigateTo或底部tab切换到其他页面,小程序切入后台.onUnload: 页面卸载时触发.如navigateTo或navigateBack时触发. 组件通信父传子: properties子传父: triggerEvent(&#39;自定义事件名&#39;, {}) AppID(小程序ID)也是开发者ID,路径:微信公众平台-小程序-开发-开发设置 标签微信小程序采用自有的标签,但是基本和h5标签有对应 小程序标签 h5标签 view div text span scroll-view 可以滚动的div 数据绑定数据绑定采用双大括号语法. 1&lt;view&gt;&#123;&#123; message &#125;&#125;&lt;/view&gt; 数据来自对应Page的data中. 12345Page(&#123; data: &#123; message: 'hello world' &#125;&#125;) 组件属性(需要在双大括号内)1&lt;view id="item-&#123;&#123;id&#125;&#125;"&gt;&lt;/view&gt; 12345Page(&#123; data: &#123; id: 0 &#125;&#125;) 条件判断wx: if=&quot;&quot;wx: else=&quot;&quot; wx: if 和hidden类似于v-if和v-show,hidden是始终渲染的,wx: if只有为true才渲染. 列表渲染wx: for在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item 123&lt;view wx:for="&#123;&#123;array&#125;&#125;"&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 123456789Page(&#123; data: &#123; array: [&#123; message: 'foo' &#125;, &#123; message: 'bar' &#125;] &#125;&#125;) 使用 wx:for-item 可以指定数组当前元素的变量名，使用 wx:for-index 可以指定数组当前下标的变量名： 123&lt;view wx:for="&#123;&#123;array&#125;&#125;" wx:for-index="idx" wx:for-item="itemName"&gt; &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;&lt;/view&gt; 注意: 当 wx:for 的值为字符串时，会将字符串解析成字符串数组.花括号和引号之间如果有空格，将最终被解析成为字符串. wx:keywx:key 的值以两种形式提供 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 key是字符串,所以不用双大括号.item是默认值,可以不加. 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 组件中的样式组件对应 wxss 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点： 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。子元素选择器（.a&gt;.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。继承样式，如 font 、 color ，会从组件外继承到组件内。除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。 1234#a &#123; &#125; /* 在组件中不能使用 */[a] &#123; &#125; /* 在组件中不能使用 */button &#123; &#125; /* 在组件中不能使用 */.a &gt; .b &#123; &#125; /* 除非 .a 是 view 组件节点，否则不一定会生效 */ 除此以外，组件可以指定它所在节点的默认样式，使用 :host 选择器（需要包含基础库 1.7.2 或更高版本的开发者工具支持）。 1234/* 组件 custom-component.wxss */:host &#123; color: yellow;&#125; 12&lt;!-- 页面的 WXML --&gt;&lt;custom-component&gt;这段文本是黄色的&lt;/custom-component&gt; 模板WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。 ##定义模板使用 name属性，作为模板的名字。然后在&lt;template/&gt;内定义代码片段，如： 123456&lt;template name="msgItem"&gt; &lt;view&gt; &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt; &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt; 使用模板使用is属性,声明需要的使用模板,然后将模板所需要的data传入, 1&lt;template is="msgItem" data="&#123;&#123;..item&#125;&#125;"&gt; 123456789Page(&#123; data: &#123; item: &#123; index: 0, msg: "this is a template", time: '2019-11-11' &#125; &#125;&#125;) is属性可以用双大括号,来动态决定渲染哪个模板. 12345678910&lt;template name="odd"&gt; &lt;view&gt; odd&lt;/view&gt;&lt;/template&gt;&lt;template name="even"&gt; &lt;view&gt; even &lt;/view&gt;&lt;/template&gt;&lt;block wx:for="&#123;&#123;[1,2,3,4,5]&#125;&#125;"&gt; &lt;template is="&#123;&#123;item % 2 == 0 ? 'even' : 'odd'&#125;&#125;"/&gt;&lt;/block&gt; 模板的作用域模板拥有自己的作用域，只能使用 data 传入的数据以及模板定义文件中定义的 &lt;wxs /&gt; 模块。 WXS语法(WeiXin Script) WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。 WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。 WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。 WXS 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异 封装小程序wx.request1234567891011121314// 官方例子wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 data: &#123; x: '' , y: '' &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) Promsie封装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const baseUrl = 'https://api.it120.cc';const http = (&#123; url = '', param = &#123;&#125;, ...other &#125; = &#123;&#125;) =&gt; &#123; wx.showLoading(&#123; title: '请求中，请耐心等待..' &#125;); let timeStart = Date.now(); return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: getUrl(url), data: param, header: &#123; 'content-type': 'application/json' // 默认值 ,另一种是 "content-type": "application/x-www-form-urlencoded" &#125;, ...other, complete: (res) =&gt; &#123; wx.hideLoading(); console.log(`耗时$&#123;Date.now() - timeStart&#125;`); if (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300) &#123; resolve(res.data) &#125; else &#123; reject(res) &#125; &#125; &#125;) &#125;)&#125;const getUrl = (url) =&gt; &#123; if (url.indexOf('://') == -1) &#123; url = baseUrl + url; &#125; return url&#125;// get方法const _get = (url, param = &#123;&#125;) =&gt; &#123; return http(&#123; url, param &#125;)&#125;const _post = (url, param = &#123;&#125;) =&gt; &#123; return http(&#123; url, param, method: 'post' &#125;)&#125;const _put = (url, param = &#123;&#125;) =&gt; &#123; return http(&#123; url, param, method: 'put' &#125;)&#125;const _delete = (url, param = &#123;&#125;) =&gt; &#123; return http(&#123; url, param, method: 'put' &#125;)&#125;module.exports = &#123; baseUrl, _get, _post, _put, _delete&#125; 使用 123456789101112131415161718const api = require('../../utils/api.js')// 单个请求api.get('list').then(res =&gt; &#123; console.log(res)&#125;).catch(e =&gt; &#123; console.log(e)&#125;)// 一个页面多个请求Promise.all([ api.get('list'), api.get(`detail/$&#123;id&#125;`)]).then(result =&gt; &#123; console.log(result)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//app.jsApp(&#123; onLaunch: function () &#123; console.log('App onLaunch'); var that = this; // 获取商城名称 wx.request(&#123; url: 'https://api.it120.cc/'+ that.globalData.subDomain +'/config/get-value', data: &#123; key: 'mallName' &#125;, success: function(res) &#123; wx.setStorageSync('mallName', res.data.data.value); &#125; &#125;) this.login(); this.getUserInfo(); &#125;, login : function () &#123; var that = this; var token = that.globalData.token; // 如果有token if (token) &#123; // 检查token是否有效 wx.request(&#123; url: 'https://api.it120.cc/' + that.globalData.subDomain + '/user/check-token', data: &#123; token: token &#125;, success: function (res) &#123; // 如果token失效了 if (res.data.code != 0) &#123; that.globalData.token = null; that.login(); // 重新登陆 &#125; &#125; &#125;) return; &#125; // 【1】调用微信自带登陆 wx.login(&#123; success: function (res) &#123; // 【2】 拿到code去访问我们的后台换取其他信息 wx.request(&#123; url: 'https://api.it120.cc/'+ that.globalData.subDomain +'/user/wxapp/login', data: &#123; code: res.code &#125;, success: function(res) &#123; // 如果说这个code失效的 if (res.data.code == 10000) &#123; // 去注册 that.registerUser(); return; &#125; // 如果返回失败了 if (res.data.code != 0) &#123; // 登录错误 wx.hideLoading(); // 提示无法登陆 wx.showModal(&#123; title: '提示', content: '无法登录，请重试', showCancel:false &#125;) return; &#125; // 【3】 如果成功后设置token到本地 that.globalData.token = res.data.data.token; // 保存用户信息 wx.setStorage(&#123; key: 'token', data: res.data.data.token &#125;) &#125; &#125;) &#125; &#125;) &#125;, // 注册？？ [这个看需求] registerUser: function () &#123; var that = this; wx.login(&#123; success: function (res) &#123; var code = res.code; // 微信登录接口返回的 code 参数，下面注册接口需要用到 wx.getUserInfo(&#123; success: function (res) &#123; var iv = res.iv; var encryptedData = res.encryptedData; // 下面开始调用注册接口 wx.request(&#123; url: 'https://api.it120.cc/' + that.globalData.subDomain +'/user/wxapp/register/complex', data: &#123;code:code,encryptedData:encryptedData,iv:iv&#125;, // 设置请求的 参数 success: (res) =&gt;&#123; wx.hideLoading(); that.login(); &#125; &#125;) &#125; &#125;) &#125; &#125;) &#125;, // 获取用户信息 getUserInfo:function() &#123; wx.getUserInfo(&#123; success:(data) =&gt;&#123; this.globalData.userInfo = data.userInfo; wx.setStorage(&#123; key: 'userInfo', data: data.userInfo &#125;) return this.globalData.userInfo; &#125; &#125;) &#125;, globalData:&#123; userInfo:null, subDomain:"34vu54u7vuiuvc546d", token: null &#125;&#125;) 授权 1234567891011121314151617181920212223242526272829getUserInfo: function () &#123; // 先调用wx.getSetting 获取用户权限设置 wx.getSetting(&#123; success(res) &#123; console.log('1'); if (!res.authSetting['scope.userInfo']) &#123; wx.authorize(&#123; scope: 'scope.userInfo', success() &#123; // 用户已经同意小程序使用录音功能，后续调用 wx.getUserInfo接口不会弹窗询问 wx.getUserInfo(&#123; success: (data) =&gt; &#123; this.globalData.userInfo = data.userInfo; wx.setStorage(&#123; key: 'userInfo', data: data.userInfo &#125;) return this.globalData.userInfo; &#125; &#125;) &#125; &#125;) &#125; else &#123; console.log(2); &#125; &#125; &#125;)&#125;, 小程序的双向绑定和vue哪里不一样小程序直接this.data的属性不可以直接同步到视图,必须调用this.data data和params的区别哪些方法可以用来提高微信小程序的应用速度 提高页面加载速度 用户行为预测 减少默认 data 的大小 组件化方案 番茄闹钟的问题 组件内css选择器不能有id,target,attr选择器,一律使用class选择器. wx:key后跟字符串,不能是双大括号. 页面wxss样式名不要和app.wxss重复,容易使设置样式失效. 没有出现登录页的情况是需要在app.json中将pages/login/login放在最前面. 登录页面中跳转时,使用wx.reLaunch并未跳转,使用wx.switchTab可以. 1234//原因:reLaunch必须写相对路径才能正确跳转wx.reLaunch(&#123; url: '../../pages/home/home' &#125;)//wx.switchTab可以直接跳转绝对路径wx.switchTab(&#123; url: '/pages/home/home' &#125;) 登录验证中的encrypted_data,event返回的是encryptedData.注意 请求头里的设置&#39;t-app-id&#39;: t_app_id,注意横线. 登录存储storage时,wx.setStorageSync(&#39;me&#39;, response.res.data.resource),注意是response.res 创建任务时,第一个按照后端api文档写的报错,第二个正确 12345req.post('/todos',&#123; todo: &#123; completed: false, description &#125;&#125;) 123req.post('/todos',&#123; completed: false, description&#125;) 创建时多一个空白,并且没有id和index.原因:将resource写成resources.有些有s,有些没有. 登录时显示500报错,解决方法: 清缓存,全部清除,编译.即可.]]></content>
      <tags>
        <tag>小程序</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F2019%2F10%2F09%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[媒体查询media-query当媒体查询为true时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回false， 标签上带有媒体查询的样式表仍将被下载 （只不过不会被应用）。 包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 1234567&lt;style&gt; @media (min-width: 700px) and (orientation: landscape)&#123; .sidebar &#123; display: none; &#125; &#125; &lt;/style&gt; 视口iewport 为什么要设置 viewportviewport 的设置不会对 PC 页面产生影响，但对于移动页面却很重要。下面我们举例来说明： 媒体查询 @media响应式布局中，会根据媒体查询功能来适配多端布局，必须对 viewport 进行设置，否则根据查询到的尺寸无法正确匹配视觉宽度而导致布局混乱。如不设置 viewport 参数，多说移动端媒体查询的结果将是 980px 这个节点布局的参数，而非我们通常设置的 768px 范围内的这个布局参数 由于目前多数手机的 dpr 都不再是 1，为了产出高保真页面，我们一般会给出 750px 的设计稿，那么就需要通过设置 viewport 的参数来进行整体换算，而不是在每次设置尺寸时进行长度的换算。 viewport 详解在移动端有三种类型的 viewport: layoutviewport、visualviewport、idealviewport。具体解释如下： layoutviewport: 大于实际屏幕， 元素的宽度继承于 layoutviewport，用于保证网站的外观特性与桌面浏览器一样。layoutviewport 到底多宽，每个浏览器不同。iPhone 的 safari 为 980px，通过 document.documentElement.clientWidth 获取。visualviewport: 当前显示在屏幕上的页面，即浏览器可视区域的宽度。idealviewport: 为浏览器定义的可完美适配移动端的理想 viewport，固定不变，可以认为是设备视口宽度。比如 iphone 7 为 375px, iphone 7p 为 414px。 viewport设置&lt;meta name=&#39;viewport&#39; content=&#39;width=device-width,initial-scale=1,user-scalable=no&#39;/&gt;通过对meta标签三个viewport的设置，最终使页面完美展示。 width 设置的是 layoutviewport 的宽度 initial-scale 设置页面的初始缩放值，并且这个初始缩放值是相对于 idealviewport 缩放的，最终得到的结果不仅会决定 visualviewport，还会影响到 layoutviewport user-scalable 是否允许用户进行缩放的设置 只要 layoutviewport === visualviewport，页面下面不会出现滚动条，默认只是把页面放大或缩小。 设备像素比 dpr 与 1px 物理像素物理像素（physical pixel）手机屏幕上显示的最小单元，该最小单元具有颜色及亮度的属性可供设置，iphone6、7、8 为：750 * 1334，iphone6+、7+、8+ 为 1242 * 2208 设备独立像素（density-indenpendent pixel）此为逻辑像素，计算机设备中的一个点，css 中设置的像素指的就是该像素。老早在没有 retina 屏之前，设备独立像素与物理像素是相等的。 设备像素比（device pixel ratio）设备像素比(dpr) = 物理像素/设备独立像素。如 iphone 6、7、8 的 dpr 为 2，那么一个设备独立像素便为 4 个物理像素，因此在 css 上设置的 1px 在其屏幕上占据的是 2个物理像素，0.5px 对应的才是其所能展示的最小单位。这就是 1px 在 retina 屏上变粗的原因，目前有很多办法来解决这一问题。 1px的物理像素的解决方案从第一部分的讨论可知 viewport 的 initial-scale 具有缩放页面的效果。对于 dpr=2 的屏幕，1px压缩一半便可与1px的设备像素比匹配，这就可以通过将缩放比 initial-scale 设置为 0.5=1/2 而实现。以此类推 dpr=3的屏幕可以将 initial-scale设置为 0.33=1/3 来实现。 设备像素比 dpr 与 rem 的适配方案rem 是相对于根元素 html 的 font-size 来做计算。通常在页面初始化时加载时通过对document.documentElement.style.fontSize 设置来实现。 rem适配规则通过对 initial-scale = 1/dpr 的设置，已将对屏幕的描述从物理像素转化到了物理像素上了，这将是后续推导的基础，且设计稿为 750px。 物理像素为 750 = 375 * 2，若屏幕等分为 10 份，那么 1rem = 75px，10rem = 750px;物理像素为 1125 = 375 * 3，若屏幕等分为 10 份，那么 1rem = 112.5px, 10rem = 1125px;物理像素为 1242 = 414 * 3, 若屏幕等分为 10 份，那么 1rem = 124.2px, 10rem = 1242px; 同时为了书写方便可以直接通过 px 布局，然后在打包时利用 pxtorem 库转化为基于 rem 的布局。 视口单位(vw,vh)适配方案将视口宽度 window.innerWidth 和视口高度 window.innerHeight 等分为 100 份，且将这里的视口理解成 idealviewport 更为贴切，并不会随着 viewport 的不同设置而改变。 vw : 1vw 为视口宽度的 1%vh : 1vh 为视口高度的 1%vmin : vw 和 vh 中的较小值vmax : 选取 vw 和 vh 中的较大值 如果设计稿为 750px，那么 1vw = 7.5px，100vw = 750px。其实设计稿按照设么都没多大关系，最终转化过来的都是相对单位，上面讲的 rem 也是对它的模拟。这里的比例关系也推荐不要自己换算，使用 pxtoviewport 的库就可以帮我们转换。当然每种方案都会有其弊端，这里就不展开讨论。]]></content>
      <tags>
        <tag>css</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts]]></title>
    <url>%2F2019%2F10%2F06%2FEcharts%2F</url>
    <content type="text"><![CDATA[浏览器画图原理 canvas基于像素单个 html,类似于画笔在画布上画画Echarts 基于 canvas 画图 svg基于对象模型多个图形元素高保真 使用 canvas 画图基础操作 123456789101112131415161718192021&lt;script&gt;//获取canvas对象var canvas = document.getElementById("myCanvas")var ctx = canvas.getContext("2d")//开始一个新的绘制路径ctx.beginPath()//设置弧线颜色ctx.strokeStyle = "blue"var circle = &#123; x: 100, //圆心的x轴 y: 100, //圆心的y轴 r: 50 //圆的半径&#125;//沿着坐标点(100,100)为圆心,半径为50px的圆顺时针方向绘制弧线ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2, false)//按照指定的路径绘制弧线ctr.stroke()&lt;/script&gt; 使用 svg 画图12345678910111213141516&lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; // circle是圆形标签 &lt;circle cx="70" cy="50" r="40" stroke="black" stroke-width="2" fill="red" /&gt; //rect是长方形标签 &lt;rect x="120" width="100" height="100" style="fill:rgb(0,0,255);stroke-width:1; stroke:rgb(0,0,0)" /&gt;&lt;/svg&gt; Echarts 条形图(直方图)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;//基于DOM,初始化Echarts实例var myChart = echarts.init(document.getElementById("main"))//指定图表的配置项和数据var option = &#123; //标题组件 title: &#123; text: "直方图(条形图)", //主标题 subtext: "学习Echarts", //副标题 left: 150, //数字是像素值,距离左侧.也可以是left,center borderColor: "red", //边框颜色 borderWidth: 5 //边框粗细 &#125;, //工具箱组件 toolbox: &#123; show: true, //是否显示toolbox //具体显示功能 feature: &#123; //保存图片 saveAsImage: &#123; show: true &#125;, //数据视图 dataView: &#123; show: true &#125;, //缩放视图 dataZoom: &#123; show: true &#125;, //还原 Restore: &#123; show: true &#125;, //动态类型切换 magicType: &#123; type: ['line', 'bar'] &#125; &#125;, //弹窗(当鼠标滑过图表显示) tooltip: &#123; //触发方式 trigger: 'axis' //x轴触发 &#125; //图例 legend: &#123; data: ['销量'] &#125;, //x轴 xAxis: &#123; data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'] &#125;, yAxis: &#123;&#125;, //数据 series: [&#123; name: '销量', type: 'bar', //bar表示条形图.line表示折线图 data: [5, 20, 36, 10, 10, 20], //标记点(数据点) markPoint: &#123; data: [ &#123;type: 'max', name: '最大值'&#125;, //最大值的点会默认方块显示 &#123;type: 'min', name: '最小值', symbol: 'arrow'&#125; //最小值的点会变成箭头 ] &#125;, //标记线 markLine: &#123; data: [ &#123;type: 'average', name: '平均值'&#125; //设置平均值线 ] &#125; &#125;] //使用配置数据显示图表 myChart.setOption(option)&#125;&lt;/script&gt;&lt;/html&gt; 饼图特点: 展示百分比 type: pie center 圆心坐标radius 半径name 图例名字selectedMode 是否支持多选 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt;&lt;div id="main" style="width=900px;height=600px"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;myChart = echarts.init(document.getElementById("main"))var option = &#123; title: &#123; text: "站点访问来源", subtext: "副标题", x: center &#125;, tooltip: &#123; trigger: "item", formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, legend: &#123; orient: "vertical", left: "left", data: ['直接访问','邮件营销','联盟广告','视频广告','搜索引擎'] &#125;, series: [&#123; name: '访问来源', //图例名字 type: 'pie', radius: '55%', //半径 center: ['50%', '60%'], //圆心坐标 data: [ &#123;value: 335, name: '直接访问'&#125;, &#123;value: 210, name: '邮件营销'&#125;, &#123;value: 445, name: '联盟广告'&#125;, &#123;value: 135, name: '视频广告'&#125;, &#123;value: 2453, name: '搜索引擎'&#125; ] &#125;] &#125;&#125;&lt;/script&gt; 仪表盘type: gauge 123456789101112131415161718192021222324252627&lt;body&gt;&lt;div id=&quot;main&quot; style=&quot;width=900px;height=600px&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;myChart = echarts.init(document.getElementById(&quot;main&quot;))var option = &#123; tooltip: &#123; formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125;%&quot; &#125;, toolbox: &#123; feature: &#123; restore: &#123;&#125;, saveAsImage: &#123;&#125; &#125; &#125;, series: [&#123; name: &apos;业务指标&apos;, //图例名字 type: &apos;gauge&apos;, detail: &#123;formatter: &apos;&#123;value&#125;%&apos;&#125;, data: [ &#123;value: 33, name: &apos;完成率&apos;&#125; ] &#125;] &#125;&#125;&lt;/script&gt; 地图需要配合地图坐标,可以下载china.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src="../echarts.min.js"&gt;&lt;/script&gt; &lt;script src="../china.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;&lt;div id="main" style="width: 900px;height:600px;"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例var myChart = echarts.init(document.getElementById('main'));var geoCoordMap = &#123; '上海': [121.4648,31.2891], '东莞': [113.8953,22.901], '东营': [118.7073,37.5513], '中山': [113.4229,22.478], '临汾': [111.4783,36.1615], '临沂': [118.3118,35.2936], '丹东': [124.541,40.4242], '丽水': [119.5642,28.1854], '乌鲁木齐': [87.9236,43.5883], '佛山': [112.8955,23.1097], '保定': [115.0488,39.0948], '兰州': [103.5901,36.3043], '包头': [110.3467,41.4899], '北京': [116.4551,40.2539], '北海': [109.314,21.6211], '南京': [118.8062,31.9208], '南宁': [108.479,23.1152], '南昌': [116.0046,28.6633], '南通': [121.1023,32.1625], '厦门': [118.1689,24.6478], '台州': [121.1353,28.6688], '合肥': [117.29,32.0581], '呼和浩特': [111.4124,40.4901], '咸阳': [108.4131,34.8706], '哈尔滨': [127.9688,45.368], '唐山': [118.4766,39.6826], '嘉兴': [120.9155,30.6354], '大同': [113.7854,39.8035], '大连': [122.2229,39.4409], '天津': [117.4219,39.4189], '太原': [112.3352,37.9413], '威海': [121.9482,37.1393], '宁波': [121.5967,29.6466], '宝鸡': [107.1826,34.3433], '宿迁': [118.5535,33.7775], '常州': [119.4543,31.5582], '广州': [113.5107,23.2196], '廊坊': [116.521,39.0509], '延安': [109.1052,36.4252], '张家口': [115.1477,40.8527], '徐州': [117.5208,34.3268], '德州': [116.6858,37.2107], '惠州': [114.6204,23.1647], '成都': [103.9526,30.7617], '扬州': [119.4653,32.8162], '承德': [117.5757,41.4075], '拉萨': [91.1865,30.1465], '无锡': [120.3442,31.5527], '日照': [119.2786,35.5023], '昆明': [102.9199,25.4663], '杭州': [119.5313,29.8773], '枣庄': [117.323,34.8926], '柳州': [109.3799,24.9774], '株洲': [113.5327,27.0319], '武汉': [114.3896,30.6628], '汕头': [117.1692,23.3405], '江门': [112.6318,22.1484], '沈阳': [123.1238,42.1216], '沧州': [116.8286,38.2104], '河源': [114.917,23.9722], '泉州': [118.3228,25.1147], '泰安': [117.0264,36.0516], '泰州': [120.0586,32.5525], '济南': [117.1582,36.8701], '济宁': [116.8286,35.3375], '海口': [110.3893,19.8516], '淄博': [118.0371,36.6064], '淮安': [118.927,33.4039], '深圳': [114.5435,22.5439], '清远': [112.9175,24.3292], '温州': [120.498,27.8119], '渭南': [109.7864,35.0299], '湖州': [119.8608,30.7782], '湘潭': [112.5439,27.7075], '滨州': [117.8174,37.4963], '潍坊': [119.0918,36.524], '烟台': [120.7397,37.5128], '玉溪': [101.9312,23.8898], '珠海': [113.7305,22.1155], '盐城': [120.2234,33.5577], '盘锦': [121.9482,41.0449], '石家庄': [114.4995,38.1006], '福州': [119.4543,25.9222], '秦皇岛': [119.2126,40.0232], '绍兴': [120.564,29.7565], '聊城': [115.9167,36.4032], '肇庆': [112.1265,23.5822], '舟山': [122.2559,30.2234], '苏州': [120.6519,31.3989], '莱芜': [117.6526,36.2714], '菏泽': [115.6201,35.2057], '营口': [122.4316,40.4297], '葫芦岛': [120.1575,40.578], '衡水': [115.8838,37.7161], '衢州': [118.6853,28.8666], '西宁': [101.4038,36.8207], '西安': [109.1162,34.2004], '贵阳': [106.6992,26.7682], '连云港': [119.1248,34.552], '邢台': [114.8071,37.2821], '邯郸': [114.4775,36.535], '郑州': [113.4668,34.6234], '鄂尔多斯': [108.9734,39.2487], '重庆': [107.7539,30.1904], '金华': [120.0037,29.1028], '铜川': [109.0393,35.1947], '银川': [106.3586,38.1775], '镇江': [119.4763,31.9702], '长春': [125.8154,44.2584], '长沙': [113.0823,28.2568], '长治': [112.8625,36.4746], '阳泉': [113.4778,38.0951], '青岛': [120.4651,36.3373], '韶关': [113.7964,24.7028]&#125;;var BJData = [ [&#123;name:'北京'&#125;, &#123;name:'上海',value:95&#125;], [&#123;name:'北京'&#125;, &#123;name:'广州',value:90&#125;], [&#123;name:'北京'&#125;, &#123;name:'大连',value:80&#125;], [&#123;name:'北京'&#125;, &#123;name:'南宁',value:70&#125;], [&#123;name:'北京'&#125;, &#123;name:'南昌',value:60&#125;], [&#123;name:'北京'&#125;, &#123;name:'拉萨',value:50&#125;], [&#123;name:'北京'&#125;, &#123;name:'长春',value:40&#125;], [&#123;name:'北京'&#125;, &#123;name:'包头',value:30&#125;], [&#123;name:'北京'&#125;, &#123;name:'重庆',value:20&#125;], [&#123;name:'北京'&#125;, &#123;name:'常州',value:10&#125;]];var SHData = [ [&#123;name:'上海'&#125;,&#123;name:'包头',value:95&#125;], [&#123;name:'上海'&#125;,&#123;name:'昆明',value:90&#125;], [&#123;name:'上海'&#125;,&#123;name:'广州',value:80&#125;], [&#123;name:'上海'&#125;,&#123;name:'郑州',value:70&#125;], [&#123;name:'上海'&#125;,&#123;name:'长春',value:60&#125;], [&#123;name:'上海'&#125;,&#123;name:'重庆',value:50&#125;], [&#123;name:'上海'&#125;,&#123;name:'长沙',value:40&#125;], [&#123;name:'上海'&#125;,&#123;name:'北京',value:30&#125;], [&#123;name:'上海'&#125;,&#123;name:'丹东',value:20&#125;], [&#123;name:'上海'&#125;,&#123;name:'大连',value:10&#125;]];var GZData = [ [&#123;name:'广州'&#125;,&#123;name:'福州',value:95&#125;], [&#123;name:'广州'&#125;,&#123;name:'太原',value:90&#125;], [&#123;name:'广州'&#125;,&#123;name:'长春',value:80&#125;], [&#123;name:'广州'&#125;,&#123;name:'重庆',value:70&#125;], [&#123;name:'广州'&#125;,&#123;name:'西安',value:60&#125;], [&#123;name:'广州'&#125;,&#123;name:'成都',value:50&#125;], [&#123;name:'广州'&#125;,&#123;name:'常州',value:40&#125;], [&#123;name:'广州'&#125;,&#123;name:'北京',value:30&#125;], [&#123;name:'广州'&#125;,&#123;name:'北海',value:20&#125;], [&#123;name:'广州'&#125;,&#123;name:'海口',value:10&#125;]];var planePath = 'path://M1705.06,1318.313v-89.254l-319.9-221.799l0.073-208.063c0.521-84.662-26.629-121.796-63.961-121.491c-37.332-0.305-64.482,36.829-63.961,121.491l0.073,208.063l-319.9,221.799v89.254l330.343-157.288l12.238,241.308l-134.449,92.931l0.531,42.034l175.125-42.917l175.125,42.917l0.531-42.034l-134.449-92.931l12.238-241.308L1705.06,1318.313z';var convertData = function (data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var dataItem = data[i]; var fromCoord = geoCoordMap[dataItem[0].name]; var toCoord = geoCoordMap[dataItem[1].name]; if (fromCoord &amp;&amp; toCoord) &#123; res.push([&#123; name: dataItem[0].name, coord: fromCoord &#125;, &#123; name: dataItem[1].name, coord: toCoord &#125;]); &#125; &#125; return res;&#125;;var color = ['#a6c84c', '#ffa022', '#46bee9'];var series = [];[['北京', BJData], ['上海', SHData], ['广州', GZData]].forEach(function (item, i) &#123; series.push(&#123; name: item[0] + ' Top10', type: 'lines', zlevel: 1, effect: &#123; show: true, period: 6, trailLength: 0.7, color: '#fff', symbolSize: 3 &#125;, lineStyle: &#123; normal: &#123; color: color[i], width: 0, curveness: 0.2 &#125; &#125;, data: convertData(item[1]) &#125;, &#123; name: item[0] + ' Top10', type: 'lines', zlevel: 2, effect: &#123; show: true, period: 6, trailLength: 0, symbol: planePath, symbolSize: 15 &#125;, lineStyle: &#123; normal: &#123; color: color[i], width: 1, opacity: 0.4, curveness: 0.2 &#125; &#125;, data: convertData(item[1]) &#125;, &#123; name: item[0] + ' Top10', type: 'effectScatter', coordinateSystem: 'geo', zlevel: 2, rippleEffect: &#123; brushType: 'stroke' &#125;, label: &#123; normal: &#123; show: true, position: 'right', formatter: '&#123;b&#125;' &#125; &#125;, symbolSize: function (val) &#123; return val[2] / 8; &#125;, itemStyle: &#123; normal: &#123; color: color[i] &#125; &#125;, data: item[1].map(function (dataItem) &#123; return &#123; name: dataItem[1].name, value: geoCoordMap[dataItem[1].name].concat([dataItem[1].value]) &#125;; &#125;) &#125;);&#125;);option = &#123; backgroundColor: '#404a59', title : &#123; text: '城市航线', subtext: '数据纯属虚构', left: 'center', textStyle : &#123; color: '#fff' &#125; &#125;, tooltip : &#123; trigger: 'item' &#125;, legend: &#123; orient: 'vertical', top: 'bottom', left: 'right', data:['北京 Top10', '上海 Top10', '广州 Top10'], textStyle: &#123; color: '#fff' &#125;, selectedMode: 'single' &#125;, geo: &#123; map: 'china', label: &#123; emphasis: &#123; show: false &#125; &#125;, roam: true, itemStyle: &#123; normal: &#123; areaColor: '#323c48', borderColor: '#404a59' &#125;, emphasis: &#123; areaColor: '#2a333d' &#125; &#125; &#125;, series: series&#125;;// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript入门]]></title>
    <url>%2F2019%2F10%2F03%2FTypeScript%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介TypeScript具有类型系统，且是JavaScript的超集。 它可以编译成普通的JavaScript代码。 TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。 安装123456789npm install -g typescript//查看版本号tsc -v//查看安装目录npm bin -g//代码编译tsc helloworld.ts//会出现一个helloworld.js 编译输出文件夹 12//将文件编译到dist文件夹下tsc --outDir dist helloworld.ts tsconfig.json12345678//使用代码初始化,生成tsconfig.jsontsc --init//修改文件内属性//设置输出文件夹dist"outDir": "./dist"//设置源代码文件夹"rootDir": "./src" 动态监视发现代码变动,自动编译 1tsc -w 变量使用 变量使用前要定义 变量类型 any类型 变量使用前要定义let/var 变量名:变量类型 = 默认值 变量类型number,string,boolean,symbol,any,object 123let name:string = "Tom"console.log("My name is" + name)name = 100 //编译错误,类型不匹配 any类型12345//any类型让编译器忽略检测let name:any = "Tom"console.log("My name is" + name)name = 100console.log("My name is" + name) 常量保存常量定义方法12345678910111213141516171819202122//常量的定义语法const name:type = initial_value//数据库连接串const dbstr:string = "ip=192.168.2.1;port=5433;uid=ayin;pwd=123123;"console.log(dbstr)//数组常量const DATA:number[] = [100,200,300]console.log(DATA)// DATA = [10,20,30]; //编译错误//数组地址并未改变,值可以改变//正常赋值DATA[0] = 10DATA[1] = 20DATA[2] = 30console.log(DATA) //[10,20,30]//数组元素增加DATA[3] = 40 数组的使用定义方法let name:type[] = initial 12345678910//定义数组let data:string[] = ['金','木','水','火']console.log(data) //['金','木','水','火']console.log(data[0]) //金//追加赋值data[4] = '土'//越界赋值data[10] = '风' 多维数组的定义let name:type[][] = [[],[],[],...] 123456789101112//定义三行五列的数组let data:number[][] = [ [1,2,3,4,5], [10,20,30,40,50], [100,200,300,400,500]]//打印第一行数组console.log(data[0]) // [1,2,3,4,5]//打印第一行第一个元素console.log(data[0][0]) // 1 枚举类型定义方法enum name = {name1, name2, name3, ...}注意定义的是常量,后期不会变化. 12345678910111213141516171819202122232425262728293031323334353637383940//使用枚举enum Sex &#123; MALE, FEMALE, UNKNOWN&#125;let member_sex: Sex = Sex.FEMALE //默认为FEMALEconsole.log(member_sex) //输出1console.log(Sex[member_sex]) //输出FEMALE//判断中枚举需要在传入对象前加字符+switch (+member_sex)&#123; case Sex.MALE: console.log("男") break case Sex.FEMALE: console.log("女") break case Sex.UNKNOWN: console.log("未知") break&#125;//或者将判断套入函数中function checkSex(sex: Sex)&#123; let result:string = '' switch (sex)&#123; case Sex.MALE: console.log("男") break case Sex.FEMALE: console.log("女") break case Sex.UNKNOWN: console.log("未知") break&#125; return result&#125; 联合类型指包含多种类型的变量类型,在实际项目中不常用. 1234567891011//联合类型的定义let data: type1 | type2 | type3 | ...//联合类型的使用let mydata: string | booleanmydata = "hello TS"console.log(mydata) //hello TSmydata = trueconsole.log(mydata) //true,没有报错 null空检查空检查用于代码编译时对程序中的变量做null空值检查,避免业务级别的错误. 123456789let data1: string = undefinedlet data2: string = nulllet data3: string = ""data3 = null//在tsconfig.json中开启"strickNullChecks": false//输入tsc进行检查 第三方库的使用node-request库 123456789101112131415import request = require('request')request('http://api.komavideo.com/news/list', function(error, response, body)&#123; if(error)&#123; console.error(error) &#125;else&#123; console.log(body) var body = JSON.parse(body) for(var i = 0; i &lt; body.length; i++)&#123; var item = body[i] console.log(item.title) &#125; &#125;&#125;)//直接使用是会报错的 需要添加tsd文件 如何找tsd文件网站: http://microsoft.github.io/TypeSearch直接搜索 导入tsd文件1npm install --save @types/request 函数的使用1234//格式function fname(param1:type, param2:type,...) : return_type &#123; //函数内容&#125; 范例 12345678function add(x:number, y:number) : number &#123; return x + y&#125;console.log(add(10, 5))//利用变量let func_add = addconsole.log(func_add(1, 2)) 箭头函数范例 1234add(x:number, y:number) : number =&gt; &#123; return x + y&#125;console.log(add(10, 5)) 可省略参数定义符号: ? 12345678910111213sayHello(name?: string): string =&gt; &#123; if(name == undefined) &#123; return "Hello ayin" &#125;else&#123; return "Hello " + name &#125;&#125;console.log(sayHello("Tom")) //Hello Tomconsole.log(sayHello()) //Hello ayin//默认值形式sayHello(name: string = "ayin"): string =&gt; &#123; return "Hello " + name 扩展运算符定义符号: ... 12345678add(...vals: number[]): number =&gt; &#123; let result = 0 for(let val of vals)&#123; result += val &#125; return result&#125;console.log(add(1,2,3)) //6 类的定义类似于ES6 12345678910111213141516171819class Person&#123; name: sting sex: number //0:女,1:男 constructor(name: string, sex: number)&#123; this.name = name this.sex = sex &#125; sayHello()&#123; console.log(`$&#123;this.name&#125;,你好$&#123;this.sex&#125;`) &#125;&#125;let qq = new Person('花藤',1)qq.sayHello()console.log(qq.name)console.log(qq.sex) 类的访问限制类的访问修饰符 public: 共有访问 protected: 本类和子类访问 private: 本类访问 1234567891011121314151617181920212223242526272829303132333435363738class Datebase&#123; dbname: string constructor(bdname: string)&#123; this.dbname = name &#125;&#125;//外部调用public showDB()&#123; console.log(`数据库:$&#123;this.dbname&#125;`)&#125;//本类和子类调用protected connect()&#123; console.log(`$&#123;this.name&#125;`,"连接中...")&#125;//本类调用private disconnect()&#123; console.log(`$&#123;this.name&#125;`,"关闭")&#125;let oracle = new Database("甲骨文")oracle.showDB()//oracle.connect()//oracle.disconnect()class PostgreSql extends Database&#123; public doIt()&#123; super.connect() //super.disconnect() &#125;&#125;let postgres = new PostregSql("小象")postgres.showDB()postgres.doIt() getter和setter书接上回,由于private属于私有,无法直接访问.可以使用get进行访问. 1234567891011121314151617181920212223class Datebase&#123; private dbname: string constructor(bdname: string)&#123; this.dbname = name &#125; get name(): string &#123; return this.dbname &#125; set name(val: string)&#123; this.dbname = val &#125;&#125;//通过name属性访问到let db = new Database('oracle is good')console.log(db.name) //修改name属性db.name = "mysql is better'console.log(db.name)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Chart.js]]></title>
    <url>%2F2019%2F10%2F03%2FChart-js%2F</url>
    <content type="text"><![CDATA[安装而另一个版本 Chart.bundle.js 和 Chart.bundle.min.js 早就包含了 Moment.js 。 1npm install chart.js --save CDN 引入1&lt;script src="https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.bundle.min.js"&gt;&lt;/script&gt; 模块化引入12import Chart from 'chart.js';var myChart = new Chart(ctx, &#123;...&#125;); 简单上手1234567891011121314151617&lt;body&gt;&lt;canvas id="myChart" width="400" height="400"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt;// 获取我们要选择的canvas元素的上下文var ctx = document.getElementById("myChart").getContext("2d");var myNewChart = new Chart(ctx, &#123;...&#125;);// 使用jQuery获取上下文-使用jQuery的.get（）方法。var ctx = $("#myChart").get(0).getContext("2d");// 这将获取jQuery集合中第一个返回的节点。var myNewChart = new Chart(ctx);&lt;/script&gt; 如果您希望所有创建的图表都具有响应性，并在浏览器窗口打开时调整大小，则可以更改以下设置： 1Chart.defaults.global.responsive = true; 折线图折线图是在一条线上绘制数据点的方法. 12345var myLineChart = new Chart(ctx, &#123; type: "line", data: data, options: options&#125;); 数据结构 1234567891011121314151617var data = &#123; //横坐标显示的值 labels: [2014, 2015, 2016, 2017, 2018, 2019], datasets: [ &#123; //第一条线表示优酷 label: "优酷", //设定data数值,表示每年用户总量 data: [100, 200, 400, 800, 1600] &#125;, &#123; //第二条线表示YouTube label: "YouTube", data: [50, 100, 200, 400, 600] &#125; ]&#125;; 设置坐标轴Y 轴options.yAxes 12345678910111213141516171819202122232425262728var options = &#123; //设置缩放 scales: &#123; //设置Y轴 yAxes: [ &#123; //刻度 ticks: &#123; //固定最大最小 min: 0, max: 2000, //建议最大最小 suggestedMin: 0, suggestedMax: 2000, //跨度 stepSize: 400, //用回调函数设置单位 callback: function(value, index, values) &#123; return value + "人"; &#125; &#125; &#125; ] &#125;&#125;; 标题和图例12345678910111213141516171819var options = &#123; //设置标题 title: &#123; display: true, text: '阿银', fontColor: 'black', fontSize: '24', position: 'top' &#125;, legend: &#123; //设置图例 position: 'left', display: true &#125;, animation: &#123; //动态效果,为0时禁用动画 duration: 1000, easing: 'easeOutQuart' &#125; 线型变换data.datasets 123456789101112131415161718192021222324var data = &#123; labels: [2014,2015,2016,2017,2018,2019], datasets: [ &#123; label: '优酷', data: [100,200,400,800,1600], //线段颜色 borderColor: 'red', //线宽 borderWidth: 3, //背景色是否填充 fill: true, //背景色 backgroundColor: 'rgba(128,0,0,0.5), //线段曲率,为0显示折线 lineTension: 0, //折点的造型,默认是圆点.可选三角,方块,星星 pointStyle: 'rect' &#125;,&#123; label: 'YouTube', data: [50,100,200,400,600] &#125; ]&#125; 条形图(柱状图)垂直条形图: type: bar水平条形图: type: horizontalBar 大部分属性类似于折线图 123456789101112131415var data = &#123; labels: [2014, 2015, 2016, 2017, 2018], datasets: [ &#123; label: "优酷", data: [100, 200, 400, 800, 1600], //为每个条形单独设置颜色 backgroundColor: ["red", "orange", "yellow", "green", "blue"] &#125;, &#123; label: "YouTube", data: [50, 100, 200, 400, 600] &#125; ]&#125;; 还可以设置条形重叠(覆盖) 123456789101112options: &#123; scales: &#123; xAxes: [&#123; //设置覆盖 stacked: true &#125;], yAxes: [&#123; //设置覆盖 stacked: true &#125;] &#125; &#125; 混合图线形图和条形图的混合 123456789101112131415161718192021var mixedChart = new Chart(ctx, &#123; type: "bar", data: &#123; datasets: [ &#123; label: "优酷", data: [100, 200, 400, 800, 1600] &#125;, &#123; label: "YouTube", data: [50, 100, 200, 400, 600], //再改成线图 type: "line", //防止填充遮盖到条形图 fill: false &#125; ], labels: [2014, 2015, 2016, 2017, 2018] &#125;, options: options&#125;); 雷达图(六边形图)type = &#39;radar&#39; 12345678910111213141516171819202122232425262728293031type = "radar";var data = &#123; labels: ["力量", "速度", "经验", "防守", "技术", "发球"], datasets: [ &#123; label: "帝国の破坏龙-马龙", data: [5, 5, 5, 5, 5, 5], backgroundColor: "rgba(247,247,9,0.2)" &#125;, &#123; label: "帝国の绝凶虎-张继科", data: [4, 5, 5, 5, 5, 5], backgroundColor: "rgba(238,61,17,0.2)" &#125; ]&#125;;var options = &#123; scale: &#123; ticks: &#123; suggestedMin: 0, suggestedMax: 5, stepSize: 1 &#125; &#125;, title: &#123; display: true, text: "桌球帝国战力值", fontSize: "24" &#125;&#125;; 饼图和甜甜圈饼图: type: &#39;pie&#39;甜甜圈: type: &#39;doughnut&#39; 1234567891011121314151617181920data = &#123; datasets: [ &#123; data: [30, 20, 30], backgroundColor: ['green','red','yellow'] &#125; ], labels: ["马龙", "张继科", "王浩"]&#125;;var options = &#123; //50-用于甜甜圈，0-用于饼图 cutoutPercentage: 80, title: &#123; display: true, text: "桌球帝国战力值", fontSize: "24" &#125;&#125;; 极区图type: &#39;polarArea&#39;极区图类似于饼图，但是每个线段具有相同的角度-线段的半径根据值而不同。]]></content>
      <categories>
        <category>HTML5</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git版本管理工具]]></title>
    <url>%2F2019%2F10%2F01%2FGit%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[下载安装去官网下载吧建立Git库12345//先新建一个空文件夹mkdir newBash//在git bash中cd newBash //切换到newBash文件夹下git init //初始化仓库 设置基础信息配置相关信息 1234567//在git bash中git initgit config -l //查看当前配置git config --global user.name "你的用户名"git config --global user.email "邮箱地址"git config --global color.ui true //代码颜色高亮显示git config -l //再查看一下对不对 提交commit基本步骤: 建立文件(本地工作文件夹) 追加文件(索引区stage) 提交文件(本地库local,远程库remote) 123456789101112131415161718192021222324252627//新建一个文件touch a.md//在文件中写字符echo "helloworld" &gt; a.md//查看此时状态git status (未提交文件名颜色为红色)//提交到索引区(也叫暂存区)git add a.md (或者直接git add . 表示提交修改文件)//再看看状态git status (提交了颜色变绿了)//将暂存区的文件提交到本地库(需要附带说明)git commit -m "add file" //add file 就是说明,会显示在github的文件名后面//再看看状态git status (提交到本地库后,暂存区里就空了)//看看提交历史git log //(会显示提交者的名字,时间,提交记录)//提交到远程仓库git push origin master 远程仓库一般远程仓库有一个master主分支,多个其他分支.现在展示如何从远端dev分支下载并修改,再推送. 1234567891011121314151617181920212223242526//切换到一个文件夹下cd newclone//从远端仓库clonegit clone git@xxx.com//查看当前分支git branch (发现远端仓库只有master被clone下来,其他没有)//查看所有分支(包括远端分支)git branch -a (此时出现远端dev分支)//创建dev分支,映射远端dev分支git branch dev remotes/origin/dev //上面几步不执行也可以,直接执行切换分支就可以clone数据//切换到dev分支git checkout dev (此时dev下所有文件都会clone下来)//修改其中的文件...//推送素质三连git add .git commit -m "修改情况"git push origin dev 分支branch新建分支123456789101112131415161718192021222324//查看当前分支状态git branch//新建一个分支devgit branch dev//切换到dev分支git checkout dev//修改文件nano style.css...//提交dev分支中内容到索引区git add .//提交dev分支到本地库git commit -m "added style.css"//查看记录git log//切换到主分支mastergit checkout master 合并分支书接上回 1234567891011121314//查看分支状态git branch//在主分支master下,合并dev分支git merge dev//查看记录git log//查看后没有问题,删除开发分支git branch -d dev//最后查看分支状态git branch 分支冲突案例分析:在dev分支创建index文件并修改.在主分支创建index文件并修改.合并分支,必有冲突代码重现: 12345678910111213141516171819202122232425262728293031323334353637//创建dev分支并切换到devgit checkout -b dev//创建文件.修改文件nano index.html...//提交操作git add .git commit -m "modified by dev"//切换到主分支git checkout master//重复上述操作nano index.html...git add .git commit -m "modified by master"//查看分支状态git branch//合并分支(必有冲突)git merge dev//报错,在冲突文件中出现提示//由leader决定以哪个分支的信息为准//编辑文件,去掉冲突提示,选择以哪个分支的修改为准nano index.html...//重新提交,并将git add .git commit -m "meraged by leader." 查看提交历史书接上回 1234567891011//提交之后,查看提交历史git log//查看最近几次历史,接一个数字git log -3 (查看最近3次的)//把历史记录缩成一行.简略显示git log --oneline//详细显示git log -p (非常详细) 提交回退12345//把刚修改的文件退到未修改状态git checkout -- a.md (取消修改,恢复到初始状态)//查看状态git status (文件已恢复) 提交到索引区,想回退 12345//把文件从索引区头部退出git reset HEAD a.md //把刚修改的文件退到未修改状态git checkout -- a.md 版本回退回退到远程库最后提交的版本,覆盖本地工作区 123456789101112131415//回退到最后一次git reset --hard HEAD//回退到倒数第二次git reset --hard HEAD~//回退到倒数第三次git reset --hard HEAD~2//回退到指定版本git reset --hard 5d79467(后面的数字是提交时的ID)//如果没记住ID,通过reflog找到现在位置的id,再从过去返回来.git reflog (会出现所有最近的记录,可以加-3,显示最近3条记录) 比较修改内容修改文件后 12345678//和修改前进行比较git diff//把修改后的文件加到索引区git add .//和索引区的进行比较git diff --cached 文件操作123456789101112//将文件添加到索引区git add [file1 file2 ...]//将工作文件夹下所有文件添加到索引区git add .//删除git rm//删除索引区文件git rm --cached a.md//更名git mv a.md b.md Git忽略管理设置Git忽略文件,这些文件不参与Git库提交. 12//新建.gitignore文件在该文件中写入要忽略的文件名 更新最后的提交最后一条提交代码里有bug,想更改,又不想新增一条提交.把更改追加到最后一条提交里. 12345678git commit -m "最后一次提交"//发现bug,修改bug后//此时文件已修改git add .//提交到最后一次修改里git commit --amend 使用Tag标签系统版本号管理例如: 1.1.3 格式: NNN.abc.xxx NNN: 大版本号 abc: 每次做出小的更新时发布的版本号 xxx: 每次bug修正时发布的版本号 12345678//查看当前版本号git tag//设置当前版本号git tag v1.0.0//查询该版本号时文件状态git show v1.0.0]]></content>
  </entry>
  <entry>
    <title><![CDATA[Axios]]></title>
    <url>%2F2019%2F09%2F24%2FAxios%2F</url>
    <content type="text"><![CDATA[Axiosaxios是一个基于Promise用于浏览器和nodejs的HTTP客户端，它本身具有以下特征： 从浏览器中创建XMLHttpRequest 从node.js发出http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 步骤: 安装$ npm install axios或者CDN引入 引入 一般是把axios挂载到原型上,便于全局使用 1Vue.prototype.$http = axios Axios之get请求12345678910111213141516methods: &#123; getData()&#123; this.$http.get('https://cnode.js.org/api/v1/topic',&#123; params: &#123; page: 1, limit: 10 &#125; &#125;) .then(res=&gt;&#123; this.items = res.data.data &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) &#125;&#125; 123456789101112//上面get请求的其他写法axios.get('/user',&#123; params: &#123; ID: 12345 &#125;&#125;)//如果只有一个选项axios.get('/user',&#123; ID: 12345&#125;)//将数据写到url里axios.get('/user?page=1&amp;limit=10') Axios之post请求12345678910axios.post('/user',&#123; firstName: 'tom', lastName: 'green'&#125;).then(res=&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;) POST传递参数有两种格式: form­-data 格式: ?page=1&amp;limit=48.但是不能写在url里 x-­www-­form-­urlencoded格式: { page: 1,limit: 10 } 在axios中，post请求接收的参数必须是form-­data可以使用qs插件—­qs.stringify 执行多个并发请求123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 1234567891011121314postData()&#123; //先要安装qs插件,然后引入 //使用qs插件将对象格式转化为form-data格式 this.$http.post(url,qs.stringify(&#123; page: 1, limit: 10 &#125;)) .then(res=&gt;&#123; console.log(res) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;)&#125; 拦截器interceptors在请求或响应被 then 或 catch 处理前拦截它们。 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如果你想在稍后移除拦截器，可以这样： 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;);]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>HTTP进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS深入]]></title>
    <url>%2F2019%2F09%2F20%2FJS%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[JavaScript 自动垃圾收集机制垃圾回收又称为 GC(Garbage Collecation)。编写 JavaScript 程序时，开发者不需要手工跟踪内存的使用情况，只要按照标准写 JavaScript 代码，JavaScript 程序运行所需内存的分配以及无用内存的回收完全是自动管理。JavaScript 中自动垃圾回收机制的原理为： 找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。 局部变量的正常生命周期局部变量只在函数执行的过程中存在。在函数执行过程中，会为局部变量在栈内存(或 堆内存)上分配相应的空间来存储它们的值。在函数中使用这些变量，直至函数执行结束，此时可以释放局部变量的内存供将来需要时使用。以上情况下，较容易判断变量是否有存在的必要，更复杂的情况需要更精细的变量追踪策略。JavaScript 中的垃圾收集器必须跟踪每个变量是否有用，需要为不再有用的变量打上标记，用于将来回收其占用的内存。标识无用变量的策略通常有两个：标记清除 和 引用计数 。 JavaScript 中的栈内存与堆内存上述过程中，JavaScript 中变量分为 基本类型值 和 引用类型值： 基本类型值 在内存中占固定大小的空间，因此被保存在 栈内存 中； 引用类型值 是对象，保存在 堆内存 中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。 标记清除标记清除(mark-and-sweep) 是 JavaScript 中最常用的垃圾回收方式。其执行机制如下： 当变量进入环境时，就将其标记为“进入环境” 当变量离开环境时将其标记为“离开环境” 逻辑上，永远不能释放进入环境的变量所占用的内存，因为执行流进入相应的环境时，可能会用到它们。标记变量的方式有很多种，可以使用标记位的形式记录变量进入环境，也可单独为“进入环境”和“离开环境”添加变量列表来记录变化。 标记清除采用的收集策略为： JavaScript中的垃圾收集器运行时会给存储在内存中的所有变量都加上标记； 然后去掉环境中的变量以及被环境中的变量引用的变量的标记； 此后，再被加上标记的变量被视为准备删除的变量； 最后，垃圾收集器完成内存清除，销毁那些带标记的值并回收其占用的内存空间。 2008年之前，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript实现使用的均为 标记清除式的垃圾回收策略，区别可能在垃圾收集的时间间隔。 引用计数引用计数(reference counting) 是另一种垃圾收集策略。引用计数的本质是 跟踪记录每个值被引用的次数。其执行机制如下： 当声明一个变量并将一个引用类型值赋值给该变量时，这个值的引用次数为1； 若同一个值(变量)又被赋值给另一个变量，则该值的引用次数加1； 但是如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1； 当这个值的引用次数为0时，则无法再访问这个值，就可回收其占用的内存空间。 垃圾收集器下次运行时，会释放那些引用次数为零的值所占用的内存。引用计数存在一个致命的问题： 循环引用。循环引用是指，对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。下面的代码就是标准的循环引用的例子： 1234567function cycleRefernce() &#123; var objectA = new Object(); var objectB = new Object(); objectA.someOtherObject = objectB; objectB.anotherObject = objectA;&#125; 上述例子中 objectA 和 objectB 通过各自属性相互引用。按照引用计数的策略，两个对象的引用次数均为 2。若采用标记清除策略，函数执行完毕，对象离开作用域就不存在相互引用。但采用引用计数后，函数执行完，两个对象的引用次数永不为0，会一直存尊内存中，若多次调用，导致大量内存得不到回收。 IE8浏览器 之前中有一部分对象并不是原生的 JavaScript 对象，可能是使用 C++ 以 COM 对象的形式实现的(BOM, DOM)。而 COM 对象的垃圾收集机制采用的是 引用计数策略。即使 IE 的 JavaScript 引擎是使用标记清除策略实现的，但 JavaScript 访问 COM 对象仍然是基于 引用计数策略的。在这种情况下，只要在 IE 中涉及 COM 对象，就可能存在循环引用的问题。 为避免出现循环引用，最好在不使用这些对象时，手动断开 原生 JavaScript 对象 与 DOM 元素之间的连接。IE中的循环引用与手动断开的操作如下所示： 123456789var element = document.getElementById("some_element");var myObject = new Object();myObject.element = element;element.someObject = myObject;// 以上 存在循环引用// ...... // 以下 手工断开连接myObject.element = null;element.someObject =null; 将变量设置成 null 即可切断变量与它之前引用的值之间的连接。下次垃圾收集器运行时，会删除这些值并回收它们占用的内存。为解决上述问题，IE9及以上版本把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象，避免了两种垃圾回收算法并存引起的问题。 垃圾回收的性能问题垃圾收集器是周期运行的，确定垃圾收集的时间间隔是个重要的问题。 IE7之前的垃圾收集器是根据内存分配量运行的，即 256 个变量、4096 个对象(数组)字面量或 64 KB 的字符串。达到这些临界值的任何一个，垃圾收集器就会运行。所以就导致如果一个脚本含有很多变量，在整个生命周期中一直保有前面临界值大小的变量，就会频繁触发垃圾回收，会存在严重的性能问题。 IE7 重写了垃圾收集例程。新的工作方式为：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为 动态修正。初始值与之前版本相同，但如果垃圾收集例程回收的内存低于 15%，则临界值加倍。若回收内存分配量超过 85%，则临界值重置回默认值。 JavaScript V8 引擎的垃圾回收机制在JavaScript脚本中，绝大多数对象的生存期很短，只有部分对象的生存期较长。所以，V8 中的垃圾回收主要使用的是 分代回收 (Generational collection)机制。 分代回收机制V8 引擎将保存对象的 堆 (heap) 进行了分代: 对象最初会被分在 新生区(New Space) (1~8M)，新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理(小周期)，清理掉新生区中不再活跃的死对象。 对于超过 2 个小周期的对象，则需要将其移动至 老生区(Old Space)。老生区在 标记-清除 或 标记-紧缩 的过程(大周期) 中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。 Scavenge 算法由于垃圾清理发生的比较频繁，清理的过程必须很快。V8 中的清理过程使用的是 Scavenge 算法，按照 经典的 Cheney 算法 实现的。Scavenge 算法的主要过程是： 新生区被分为两个等大小的子区(semi-spaces)：to-space 和 from-space； 大多数的内存分配都是在 to-space 发生 (某些特定对象是在老生区)； 当 to-space 耗尽时，交换 to-space 和 from-space, 此时所有的对象都在 from-space； 然后将 from-space 中活跃的对象复制到 to-space 或者老生区中; 这些对象被直接压到 to-space，提升了 Cache 的内存局部性，可使内存分配简洁快速。 算法的伪代码描述如下： 12345678910111213141516171819202122232425262728293031def scavenge(): swap(fromSpace, toSpace) allocationPtr = toSpace.bottom scanPtr = toSpace.bottom for i = 0..len(roots): root = roots[i] if inFromSpace(root): rootCopy = copyObject(&amp;allocationPtr, root) setForwardingAddress(root, rootCopy) roots[i] = rootCopy while scanPtr &lt; allocationPtr: obj = object at scanPtr scanPtr += size(obj) n = sizeInWords(obj) for i = 0..n: if isPointer(obj[i]) and not inOldSpace(obj[i]): fromNeighbor = obj[i] if hasForwardingAddress(fromNeighbor): toNeighbor = getForwardingAddress(fromNeighbor) else: toNeighbor = copyObject(&amp;allocationPtr, fromNeighbor) setForwardingAddress(fromNeighbor, toNeighbor) obj[i] = toNeighbordef copyObject(*allocationPtr, object): copy = *allocationPtr *allocationPtr += size(object) memcpy(copy, object, size(object)) return copy 不能被忽视的写屏障 Write barriers如果新生区有某个对象，只有一个指向它的指针，恰好该指针在老生区的对象中，在垃圾回收之前我们如何得知新生区的该对象是活跃的呢？为解决此问题，V8 在写缓冲区有一个列表，其中记录了所有老生区对象指向新生区的情况。新生区对象诞生时不会有指向它的指针，当老生区的对象出现指向新生区对象的指针时，便记录跨区指向，记录行为总是发生在写操作中。 标记-清除算法 与 标记-紧缩算法因为新生区的内存一般都不大，所以使用 Scavenge 算法进行垃圾回收效果比较好。老生区一般占用内存较大，因此采用的是 标记-清除(Mark-Sweep)算法 与 标记-紧缩(Mark-Compact)算法。 两种算法都包括两个阶段：标记阶段，清除或紧缩阶段。 标记阶段在标记阶段，堆上所有的活跃对象都会被发现并且标记。 每一页都包含用来标记的位图位图都要占据空间 (3.1% on 32-bit, 1.6% on 64-bit systems)使用两位二进制标记对象的状态状态为白(white), 它尚未被垃圾回收器发现状态为灰(gray), 它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕状态为黑(black), 它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕 标记算法的核心是 深度优先搜索，具体过程为： 在标记的初期，位图是空的，所有对象也都是白的。 从根可达的对象会被染色为灰色，并被放入标记用的一个单独分配的双端队列。 标记阶段的每次循环，GC会将一个对象从双端队列中取出，染色为黑，然后将它的邻接对象染色为灰，并把邻接对象放入双端队列。 这一过程在双端队列为空且所有对象都变黑时结束。 特别大的对象，如长数组，可能会在处理时分片，以防溢出双端队列。如果双端队列溢出了，则对象仍然会被染为灰色，但不会再被放入队列（这样他们的邻接对象就没有机会再染色了）。 因此当双端队列为空时，GC仍然需要扫描一次，确保所有的灰对象都成为了黑对象。对于未被染黑的灰对象，GC会将其再次放入队列，再度处理。 标记算法结束后，所有的活跃对象都被染成黑色，所有的死对象仍是白的。下一步就可以清除或者紧缩了。 清除 或 紧缩 算法标记算法执行后，可以选择清除 或是紧缩，这两个算法都可以收回内存，而且两者都作用于页级(V8 中的内存页是 1MB 的连续内存块) 清除算法扫描连续存放的死对象，将其变为空闲空间，并将其添加到空闲内存链表中。清除算法只需要遍历页的位图，搜索连续的白对象。[每一页都包含数个空闲内存链表，其分别代表小内存区（&lt;256字）、中内存区（&lt;2048字）、大内存区（&lt;16384字）和超大内存区（其它更大的内存）] 紧缩算法会尝试将对象从碎片页(包含大量小空闲内存的页)中迁移整合在一起，来释放内存。这些对象会被迁移到另外的页上，因此也可能会新分配一些页。而迁出后的碎片页就返还给操作系统。 对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块其它页的区域，将该对象复制至新页，并在碎片页中的该对象上写上转发地址。迁出过程中，对象中的旧地址会被记录下来，这样在迁出结束后V8会遍历它所记录的地址，将其更新为新的地址。由于标记过程中也记录了不同页之间的指针，此时也会更新这些指针的指向。 增量标记 与 惰性清除对于一个堆很大，活跃对象有很多的脚本时，标记-清除 与 标记-紧缩 的效率可能会很慢，为减少垃圾回收引起的停顿，引入了 增量标记(Incremental marking) 和 惰性清理(lazy sweeping)。 增量标记允许堆的标记(前面的标记阶段)发生在几次5-10毫秒的小停顿中。增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。就像普通的标记一样，增量标记也是一个深度优先搜索，并同样采用白灰黑机制来分类对象。增量标记与普通标记的区别是，添加了从黑对象到白对象的指针，为此需要再次启用写屏障中，在记录 老-&gt;新 的同时，记录 黑-&gt;白。在进行清除时，一旦在写屏障中发现这样的指针，黑对象会被重新染色为灰对象，重新放回到双端队列中。 惰性清理是指在标记完成后，并不急着释放空间，无需一次清理所有的页，垃圾回收器会视情况逐一清理，直到所有页都清理完成。 余下的涉及垃圾回收原理的部分留着后面继续整理。(平行标记 与 并发标记) Event Loop众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。 JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 1234567console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)console.log('script end') 以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。 微任务和宏任务不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 12345678910111213141516171819console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)new Promise(resolve =&gt; &#123; console.log('Promise') resolve()&#125;) .then(function() &#123; console.log('promise1') &#125;) .then(function() &#123; console.log('promise2') &#125;)console.log('script end')// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了script，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>JS深入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全防范]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83%2F</url>
    <content type="text"><![CDATA[XSS攻击 什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？ XSS 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导 致大量正常访问页面的用户都受到攻击。举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容&lt;script&gt;alert(2)&lt;/script&gt;.这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行. 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt; &lt;div&gt;&lt;/div&gt; 但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我 们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器. 防御对于 XSS 攻击来说，通常有两种方式可以用来防御。 转义字符首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进 行转义 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\//g, '&amp;#x2F;') return str &#125; 123//通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt; escape('&lt;script&gt;alert(1)&lt;/script&gt;') 但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 CSP(白名单)CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何 拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置meta标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 这里以设置 HTTP Header 来举例 123456//只允许加载本站资源Content-Security-Policy: default-src ‘self’//只允许加载 HTTPS 协议图片Content-Security-Policy: img-src https://*//允许加载任何来源框架Content-Security-Policy: child-src 'none' CSRF攻击 什么是CSRF攻击？如何防范CSRF攻击？ CSRF中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。举个例子，假设网站中有一个通过GET请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src="http://www.domain.com/xxx?comment='attack'"/&gt; 那么你是否会想到使用POST方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交POST请求 如何防御防范CSRF攻击可以遵循以下几种规则： GET请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token SameSite可以对Cookie设置SameSite属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。验证Referer对于需要防范CSRF的请求，我们可以通过验证Referer来判断该请求是否为第三方网站发起的。Token服务器下发一个随机Token，每次发起请求时将Token携带上，服务器验证Token是否有效。 点击劫持 什么是点击劫持？如何防范点击劫持？ 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击。 如何防御X-FRAME-OPTIONSX-FRAME-OPTIONS是一个HTTP响应头，在现代浏览器有一个很好的支持。这个HTTP响应头就是为了防御用iframe嵌套的点击劫持攻击。该响应头有三个值可选，分别是DENY，表示页面不允许通过iframe的方式展示SAMEORIGIN，表示页面可以在相同域名下通过iframe的方式展示ALLOW-FROM，表示页面可以在指定来源的iframe中展示JS防御对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过JS的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id="click-jack"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById('click-jack') document.body.removeChild(style) &#125; else &#123; top.location = self.location &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过iframe的方式加载页面时，攻击者的网页直接不显示所有内容了。 中间人攻击 什么是中间人攻击？如何防范中间人攻击？ 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。通常来说不建议使用公共的Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS就可以用来防御中间人攻击，但是并不是说使用了HTTPS就可以高枕无忧了，因为如果你没有完全关闭HTTP访问的话，攻击方可以通过某些方式将HTTPS降级为HTTP从而实现中间人攻击。 网页验证码是干嘛的，是为了解决什么安全问题。区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>HTTP安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue服务端渲染]]></title>
    <url>%2F2019%2F09%2F15%2FVue%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[介绍 Vue.js是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出Vue组件，进行生成DOM和操作DOM。然而，也可以将同一个组件渲染为服务器端的HTML字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 服务器渲染的Vue.js应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。 优缺点优点: 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。 缺点: 开发条件所限。 涉及构建设置和部署的更多要求。 更多的服务器端负载。 基本用法安装npm install vue vue-server-renderer --save 渲染实例12345678910111213141516171819202122// 第 1 步：创建一个 Vue 实例const Vue = require('vue')const app = new Vue(&#123; template: `&lt;div&gt;Hello World&lt;/div&gt;`&#125;)// 第 2 步：创建一个 rendererconst renderer = require('vue-server-renderer').createRenderer()// 第 3 步：将 Vue 实例渲染为 HTMLrenderer.renderToString(app, (err, html) =&gt; &#123; if (err) throw err console.log(html) // =&gt; &lt;div data-server-rendered="true"&gt;Hello World&lt;/div&gt;&#125;)// 在 2.5.0+，如果没有传入回调函数，则会返回 Promise：renderer.renderToString(app).then(html =&gt; &#123; console.log(html)&#125;).catch(err =&gt; &#123; console.error(err)&#125;) 与服务端集成12345678910111213141516171819202122232425262728293031//安装npm install express --save//操作expressconst Vue = require('vue')const server = require('express')()const renderer = require('vue-server-renderer').createRenderer()server.get('*', (req, res) =&gt; &#123; const app = new Vue(&#123; data: &#123; url: req.url &#125;, template: `&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;` &#125;) renderer.renderToString(app, (err, html) =&gt; &#123; if (err) &#123; res.status(500).end('Internal Server Error') return &#125; res.end(` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt; &lt;body&gt;$&#123;html&#125;&lt;/body&gt; &lt;/html&gt; `) &#125;)&#125;)server.listen(8080) 使用页面模板123456789//index.template.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;!--这里将是应用程序 HTML 标记注入的地方--&gt; &lt;/body&gt;&lt;/html&gt; 读取和传输文件到 Vue renderer 中： 1234567const renderer = createRenderer(&#123; template: require('fs').readFileSync('./index.template.html', 'utf-8')&#125;)renderer.renderToString(app, (err, html) =&gt; &#123; console.log(html) // html 将是注入应用程序内容的完整页面&#125;) vue-srr范例详解]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue-SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex]]></title>
    <url>%2F2019%2F09%2F14%2FVueX%2F</url>
    <content type="text"><![CDATA[Vuex 介绍每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态(state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。我的理解: Vuex 相当于一个扩展板的bus中介.起步虽相似,但功能更丰富. Vuex 之 store起步: 安装,引入,use,创建状态仓库.在Vue实例中注入(把store写进去).一条龙服务. 1234567891011121314151617181920212223//创建仓库格式var store = new Vuex.Store(&#123; state: &#123; //定义你的状态 XXX: xxx &#125;, mutations: &#123; //在此处定义状态改变的方法 increase(state)&#123; state.num ++ &#125; decrease(state)&#123; state.num -- &#125; &#125;, actions: &#123; //actions中传递的不再是state,而是context increaseAction(context)&#123; //actions中只能对mutations中的方法进行操作 context.commit('increase') &#125; &#125;&#125;) mutations 改变状态:直接通过this.$store.state.XXX拿到状态在 methods 中.定义一个函数通过this.$store.commit(&#39;xxx&#39;)方法触发状态变更 actions 改变状态:通过this.$store.dispatch(xxx)调用 二者区别: 传入参数不同,mutations 传入state.actions 传入context 调用方式不同,前者this.$store.commit(&#39;xxx&#39;).后者this.$store.dispatch(xxx) 函数要求不同.mutations 中只能有同步操作,actions 中可以有异步操作. getters有时需要对 mutations 处理后的 state 进行处理.可以当做 vuex 的计算属性(computed). 1234567getters: &#123; getNum(state)&#123; //因为要处理state,自然传入state return state.num &gt; 0 ? state.num : 0 //这里是防止一直减出现负数进行的处理 &#125;&#125; 获取状态也就改为 1234567//在组件中computed: &#123; getCount()&#123; //return this.$store.state.num return this.$store.getters.getNum &#125;&#125; Vuex 状态管理流程view–&gt;actions–&gt;mutations–&gt;state–&gt;view 新增VueX 中state相当于datagetter相当于computedmutation相当于methodsaction是异步的mutationmodule模块将上述进行封装分块 mapState 和 mapGettersmapState辅助函数仅仅是将 store 中的getter映射到局部计算属性 1234567891011121314...Vuex.mapState(['firstName', 'lastName'])//相当于firstName()&#123; return this.$store.state.firstName&#125;,lastName()&#123; return this.$store.state.lastName&#125;..Vuex.mapGetters(['fullName'])//相当于fullName()&#123; return this.$store.getters.fullName&#125; store.commit(&#39;xxFirstName&#39;, &#39;jirengu&#39;)提交 mutation 中 xxFirstName 的方法。第一个参数是 state 中有的，后添加的 jirengu 是载荷payload。 提交载荷（payload）向store.commit传入额外参数，即mutation的载荷 12345678mutations:&#123;increment (state, payload)&#123;state.count += payload.amount&#125;&#125;store.commit('increment', &#123;amount: 10&#125;) actions 中传入第一个参数是context，第二个是payload触发 action 1store.dispatch("increment"); moudle(模块化)12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter]]></title>
    <url>%2F2019%2F09%2F14%2FVueRouter%2F</url>
    <content type="text"><![CDATA[前端路由原理监听url的变化，然后匹配路由规则，显示相应页面，无需刷新。目前前端路由只有两种实现方式 hash模式 监听hash值变化(url后的,从#号开始)window.addEventListener(&#39;hashchange&#39;,()=&gt;{}) 123456//监听hash变化window.onhashchange = function(event) &#123; console.log(event.oldURL, event.newURL); let hash = loaction.hash //通过location对象来获取hash地址 console.log(hash) // "#/notebooks/260827/list" 从#号开始&#125; 因为hash发生变化的url都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用.特点: hash 虽然出现在URL中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。 history模式 通过此模式改变url同样不会引起页面刷新，只会更新浏览器的历史记录’修改为history模式:在router中添加mode: &#39;history&#39;. history.pushState替换当前历史记录history.replaceState点击后退触发popState事件window.addEventListener(&#39;popState&#39;,e=&gt;{}) 切换历史状态包括back,forward,go三个方法，对应浏览器的前进，后退，跳转操作. 1234history.go(-2);//后退两次history.go(2);//前进两次history.back(); //后退hsitory.forward(); //前进 修改历史状态包括了pushState,replaceState两个方法,这两个方法接收三个参数:stateObj,title,url. 123history.pushState(&#123;color:'red'&#125;, 'red', 'red'&#125;)history.back();history.forward(); 通过pushstate把页面的状态保存在state对象中，当页面的url再变回这个url时，可以通过event.state取到这个state对象. history模式缺点通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的,不玩虚的。 在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题.但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会请求失败. 所以，如果你想在github.io上搭一个单页博客，就应该选择hash模式 vue-router路由 安装vue-routernpm install --save vue-router 引用 12import router from 'vue-router'Vue.use(router) 配置路由文件,并在Vue实例中注入 123456789101112131415161718192021import Vue from 'vue'import App from './App'import router from 'vue-router'import HelloWorld from './components/HelloWorld'Vue.use(router) //引入并且使用var rt = new VueRouter(&#123; //下面这个routes是数组,用[] routes: [&#123; path: '/hello', //指定要跳转的路径 component: HelloWorld //指定要跳转的组件 &#125;]&#125;)new Vue(&#123; el: "#app", router: rt, //把路由实例rt写到Vue实例中就注入了 components: &#123; App &#125;, //组件直接注入.分开写便于模块化 template: '&lt;App/&gt;' //同上&#125;) 确定视图加载的位置 123456789101112131415161718192021222324&lt;router-view&gt;&lt;/router-view&gt;//把这个写到想注入的位置就可以了``` ## 路由跳转在路由文件中,一般是`router/index.js`.就是把路由单独写一个文件```javascriptimport Vue from 'vue'import router from 'vue-router'import HelloWorld from './components/HelloWorld'import HelloEarth from './components/Helloearth'Vue.use(router) //引入并且使用export default new router(&#123; routes: [&#123; path: '/helloworld', //指定要跳转的路径 component: HelloWorld //指定要跳转的组件 &#125;, &#123; path: '/helloearth', //指定要跳转的路径 component: HelloEarth //指定要跳转的组件 &#125;, ]&#125;) 然后在页面组件中 12345678910&lt;template&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to="/helloworld"&gt;HelloWorld&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to="/helloearth"&gt;HelloEarth&lt;/router-link&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/template&gt; vue-router路由参数传递(传参) 必须在路由内加入路由的name 必须在path后加/:加传递的参数 传递参数(传值)和接收参数(具体看下面两种方法) 传递参数方法: 12345678910111213141516171819//params: this.$router.push(&#123; name: 'xxx', params: &#123; id: id &#125;&#125;)//params读取参数: this.$route.params.id//querythis.$router.push(&#123; path: '/xxx', query: &#123; id: id &#125;&#125;)//query读取参数: this.$route.query.id 注意: params传参,push里只能是name:’xxx’,不能是path:’/xxx’,因为params只能用name来引入路由,如果这个写成path,接收参数页面会是undefined. 12345678910111213141516171819//两种方式: &lt;router-link :to="&#123;name: helloworld,params:&#123;worldmsg: '你好世界' &#125;&#125;"&gt; helloworld&lt;/router-link&gt; //接收参数:$route.params.xxx //这种方式等同于./helloworld/你好世界export default new router(&#123; routes: [&#123; name: 'helloworld', path: '/helloworld/:id', //动态绑定,各个不同id就都使用HelloWorld组件了 component: HelloWorld //指定要跳转的组件 &#125;, &#123; name: 'helloearth', path: '/helloearth/:earthmsg', //指定要跳转的路径 component: HelloEarth //指定要跳转的组件 &#125;, ]&#125;) 123456789101112131415 &lt;router-link :to="&#123;path: '/helloearth',query:&#123;msg: 只有一个地球&#125;&#125;"&gt; &lt;/router-link&gt; //方式等同于./helloworld?name=xxx&amp;count=xxx //接收参数this.$route.query.xxx coust couter = new VueRouter(&#123; routes:[&#123; path: '/search', component: SearchUser, props: (route) =&gt;(&#123; query: route.query.q &#125;) &#125; ] &#125;) 导航守卫导航守卫就是路由跳转过程中的一些钩子函数. 1234567891011//钩子函数执行后输出的顺序全局前置守卫: beforeEach路由独享守卫: beforeEnter组件路由守卫: beforeRouteEnter,此时this并不指向该组件实例全局解析守卫: beforeResolve全局后置守卫: aferEach组件生命周期: beforeCreate组件生命周期: created组件生命周期: borforeMount组件生命周期: mounted组件路由守卫: beforeRouteEnter的next回调 导航守卫分为：全局的、单个路由独享的、组件内的三种. 全局的分别是beforeEach,beforeResolve,afterEach 12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) beforeEach: 全局前置守卫.在路由跳转前触发,参数:to,from,next.这个钩子函数主要用于登录验证.beforeResolve: 全局解析守卫.和beforeEach类似.区别是在beforeEach和组件内beforeRouteEnter之后，afterEach之前调用.afterEach: 全局后置钩子.和beforeEach相反,在路由跳转完成后触发,参数: to,from.他发生在beforeEach和beforeResolve之后. 三个参数(to,from,next) to: Route: 即将要进入的目标路由对象 from: Route: 当前导航正要离开的路由 next: Function: 必须调用该方法来resolve这个钩子.否则不能进入路由.执行效果依赖next方法的调用函数. next(false): 中断当前导航.如果浏览器的URL改变,那么URL会重置到from路由对应的地址. next(&#39;/&#39;): 跳转到一个不同的地址. next(error): 如果传入的next的参数是一个Error实例.则导航会被终止且该错误会被传递给router.onerror()注册过的回调. 确保要调用next方法,否则钩子就不会被resolved. 路由独享的守卫beforeEnter可以在路由配置上直接定义beforeEnter守卫: 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, brforeEnter: (to, from, next) =&gt; &#123; //参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 //... &#125; &#125; ]&#125;) 组件内的守卫beforeRouteEnter 进入路由前beforeRouteUpdate 路由复用同一个组件时beforeRouteLeave 离开当前路由时 123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter(to, from, next)&#123; //在渲染该组件的对应路由被confirm前调用 //不能!!获取组件实例this //因为当守卫执行前,组件实例还未创建 &#125;, beforeRouteUpdate(to, from, next)&#123; //在当前路由改变,但是该组件被复用时调用 //举例来说,对于一个带有动态参数的路径 /foo/:id,在/foo/1和/foo/2之间跳转的时候, //由于会渲染同样的Foo组件,因此组件实例会被复用.而这个钩子就会在这个情况下被调用. //可以访问组件实例this &#125;, beforeRouteLeave(to, from, next)&#123; //导航离开该组件的对应路由时调用 //可以访问组件实例this &#125;&#125; beforeRouteEnter守卫不能访问this因为钩子在组件实例还没被创建的时候调用,可以通过传一个回调给next来访问组件实例 。不过,可以通过传一个回调给next来访问组件实例.在导航被确认的时候执行回调,并且把组件实例作为回调方法的参数.但是回调的执行时机在mounted后面,所以在我看来这里对this的访问意义不太大，可以放在created或者mounted里面。 12345beforeRouteEnter(to, from, next)&#123; next(vm =&gt; &#123; //通过`vm`访问组件实例 &#125;)&#125; beforeRouteLeave导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。 1234567beforeRouteLeave (to, from , next) &#123; if (文章保存) &#123; next(); // 允许离开或者可以跳到别的路由 上面讲过了 &#125; else &#123; next(false); // 取消离开 &#125;&#125; 路由钩子函数的错误捕获如果在导航守卫的钩子函数中有错误,可以这样捕获: 123router.onError(callback =&gt; &#123; console.log(callback, 'callback')&#125;) 假设是从a组件离开，第一次进入b组件 完整的路由导航解析流程: 触发进入其他路由。 调用要离开路由的组件守卫beforeRouteLeave 调用全局前置守卫: beforeEach 在重用的组件里调用beforeRouteUpdate 调用路由独享守卫beforeEnter 解析异步路由组件 在将要进入的路由组件中调用beforeRouteEnter 调用全局解析守卫beforeResolve 导航被确认 调用全局后置钩子afterEach 触发DOM更新(mounted) 执行beforeRouteEnter守卫中传给next的回调函数 疑难杂症监听物理返回键或页面返回123456789//unit.js//存储当前历史记录点,实现控制手机物理返回键的按钮事件export const pushHistory = ()=&gt;&#123; let state = &#123; title: '', url: '' &#125; window.history.pushState(state, state.title, state.url)&#125; 12345678910111213141516//index.vueimport &#123; pushHistory &#125; from '@/misc/utils' //引入工具export default &#123; mounted()&#123; pushHistory() //监听历史记录点,添加返回事件监听 window.onpopstate = ()=&gt;&#123; this.$router.push(...) //输入要返回的上一级路由地址 &#125; &#125;, destroyed()&#123; window.removeEventListener('popstate', this.fun, false);//false阻止默认事件 &#125;//页面销毁时，取消监听。否则其他vue路由页面也会被监听&#125;]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js进阶]]></title>
    <url>%2F2019%2F09%2F13%2FVuejs%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[关于h将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例. 响应式原理官网解释当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。 官方解释总结: 任何一个Vue组件都有一个与之对应的Watcher实例。 Vue的data上的属性会被添加getter和setter属性。 当Vue组件的render函数被执行的时候,data上会被触碰(touch),即被读,getter方法会被调用,此时Vue会去记录此Vue组件所依赖的所有data。(这一过程被称为依赖收集) data被改动时（主要是用户操作）,即被写,setter方法会被调用,此时Vue会去通知所有依赖于此data的组件去调用他们的render函数进行更新。 其他说法:mvvm用来初始化数据observer用来对初始数据通过Object.defineProperty添加setter和getter，当取数据（即调用get）的时候添加订阅对象（watcher）到数组里， 当给数据赋值（即调用set）的时候就能知道数据的变化，此时调用发布订阅中心的notify，从而遍历当前这个数据的订阅数组，执行里面所有的watcher，通知变化update。compiler是用来把data编译到dom中。分三步：1.先把真实的dom移入到内存中fragment，2.编译：提取想要的元素节点v-model和文本节点；3.把编译好的fragment塞回到页面去。第二步骤中会对编译到dom中的data添加watcher,当data变化时，这里的watcher回调也能收到通知得到执行。watcher是oberver和compiler之间通信的桥梁。 Object.defineProperty 的缺陷 无法监听数组变化。 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 使用Proxy实现Vue数据劫持proxy定义: Proxy对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）. Proxy第一个参数是目标对象，第二个参数是一个对象，其属性是当执行一个操作时定义代理的行为的函数。这时可以在第二个参数中加入一个set方法，这时可以监听到是哪个key做了改变。并且通过Reflect的set方法去模拟真实的set方法。 为什么说Proxy的性能比Object.defineProperty更好呢？Object.defineProperty只能监听属性，而Proxy能监听整个对象，省去对非对象或数组类型的劫持，也能做到监听。 vue是对对象每一个属性进行Object.defineProperty。第二点，Object.defineProperty不能监测到数组变化 总结Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改；Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利当然,Proxy的劣势就是兼容性问题,而且无法用polyfill实现 Proxy基本语法const obj = new Proxy(target, handler);参数说明如下：target: 被代理对象。handler: 是一个对象，声明了代理target的一些操作。obj: 是被代理完成之后返回的对象。 但是当外界每次对obj进行操作时，就会执行handler对象上的一些方法。handler中常用的对象方法如下： 123451. get(target, propKey, receiver)2. set(target, propKey, value, receiver)3. has(target, propKey)4. construct(target, args):5. apply(target, object, args) 常用(考)组件之keep-alive作用: 缓存组件内部状态，避免重新渲染注意: 和&lt;transition&gt;相似,&lt;keep-alive&gt;是一个抽象组件:自身不会渲染一个DOM元素,也不会出现在父组件链中. 用法:缓存动态组件:&lt;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，此种方式并无太大的实用意义。 12345678910&lt;!-- 基本 --&gt; &lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 多个条件判断的子组件 --&gt; &lt;keep-alive&gt; &lt;comp-a v-if="a &gt; 1"&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt; &lt;/keep-alive&gt; 使用keep-alive可以将所有路径匹配到的路由组件都缓存起来，包括路由组件里面的组件，keep-alive大多数使用场景就是这种。 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 常用(考)API之nextTick作用: $nextTick是将回调推迟到下次DOM更新循环之后再执行，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM，Vue实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新。 123456789101112// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick() .then(function () &#123; // DOM 更新了 &#125;) 为了在数据变化之后等待Vue完成更新DOM，可以在数据变化之后立即使用Vue.nextTick(callback)。这样回调函数将在DOM更新完成后被调用。在组件内使用vm.$nextTick()实例方法特别方便，因为它不需要全局Vue，并且回调函数中的this将自动绑定到当前的Vue实例上.因为 $nextTick()返回一个Promise对象，所以可以使用ES6语法. 常用(考)API之set返回: 设置的值.用法: 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 . 注意对象不能是Vue实例，或者Vue实例的根数据对象。 常用(考)API之watch一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id="app"&gt; &lt;input type="text" v-model:value="childrens.name" /&gt; &lt;input type="text" v-model:value="lastName" /&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue( &#123; el: '#app', data: &#123; children: &#123; name: '小强', age: 20, sex: '男' &#125;, tdArray:["1","2"], lastName:"张三" &#125;, watch:&#123; children:&#123; //如果childrens发生变化,函数就会执行 handler:function(val,oldval)&#123; console.log(val.name) &#125;, deep:true//对象内部的属性监听，也叫深度监听 &#125;, 'children.name':function(val,oldval)&#123; console.log(val+"aaa") &#125;,//键路径必须加上引号 lastName:&#123;function(val,oldval)&#123; console.log(this.lastName) &#125;, immediate:true //立即以'childern.name'触发回调 &#125; &#125;,//以V-model绑定数据时使用的数据变化监测 &#125; ); vm.$watch("lastName",function(val,oldval)&#123; console.log(val) &#125;)//主动调用$watch方法来进行数据监测&lt;/script&gt;&lt;/body&gt; 取消观察vm.$watch 返回一个取消观察函数，用来停止触发回调： 123var unwatch = vm.$watch('a', cb)// 之后取消观察unwatch() 注意，不应该使用箭头函数来定义watcher函数 (例如searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以this将不会按照期望指向Vue实例，this.updateAutocomplete将是undefined。 其他APIVue.extend(options)用法: 使用基础Vue构造器创建一个子类.参数是一个包含组件选项的对象.data在Vue.extend中是函数 12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point') Vue.set(target,propertyName/index,value)返回值: 设置的值用法: 向响应式添加新属性,并确保这个新属性同样是响应式的.且触发识图更新.它必须用于响应式对象上添加新属性,因为Vue无法探测新增的属性.如果我们在创建实例以后，再在实例上绑定新属性，vue是无法进行双向绑定的。 注意: 对象不能是Vue实例,或者Vue实例的根数据对象. Vue.mixin用法: 全局注册一个混入,影响注册之后所有创建的每个Vue实例.插件作者可以使用混入,向组件注入自定义行为.不推荐在应用代码中使用. 123456Vue.mixin(&#123; beforeCreate()&#123; //..逻辑 //这种方法会影响到每个组件的beforeCreate钩子函数 &#125;&#125;) 虽然文档不建议我们在应用中直接使用mixin ，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的ajax或者一些工具函数等等。 mixins应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是mixins混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并. Vue页面优化(spa首屏单页面) 压缩代码 框架和插件按需加载 框架和插件从CDN中引入 路由懒加载 SSR服务端渲染 函数化组件先设置functional: true,表示该组件无状态无实例,不能使用this使用上下文context进行替换替换规律: 12this.text-----context.props.textthis.$slots.default------context.children 123456789101112131415161718192021222324252627282930&lt;div id="app"&gt;&lt;my-component value="haha"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; functional: true, //开启函数化,无实例,无状态.this失效 render: function(createElement,context)&#123; //添加context参数 return createElement('button',&#123; on: &#123; click: function()&#123; console.log(context) console.log(context.parent) //父组件 console.log(context.parent.msg) console.log(context.props.value) &#125; &#125; &#125;,'点击我') //第三个参数 &#125;, props:['value'] )var app = new Vue(&#123; el: "#app", data: &#123; msg: "我是父组件内容" &#125;&#125;)&lt;/script&gt; 虚拟dom虚拟DOM到底是什么，说简单点，就是一个普通的 JavaScript 对象，包含了 tag、props、children 三个属性。 虚拟dom优点用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。 123&lt;div id="app"&gt; &lt;p class="text"&gt;hello world!!!&lt;/p&gt;&lt;/div&gt; 上面的 HTML 转换为虚拟 DOM 如下： 1234567891011121314151617&#123; tag: 'div', props: &#123; id: 'app' &#125;, chidren: [ &#123; tag: 'p', props: &#123; className: 'text' &#125;, chidren: [ 'hello world!!!' ] &#125; ]&#125; 该对象就是我们常说的虚拟 DOM 了，因为 DOM 是树形结构，所以使用 JavaScript 对象就能很简单的表示。而原生 DOM 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 div 也要付出昂贵的代价。虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图. diff算法diff 算法用来比较两棵 Virtual DOM 树的差异，如果需要两棵树的完全比较，那么 diff 算法的时间复杂度为O(n^3)。但是在前端当中，你很少会跨越层级地移动 DOM 元素，所以 Virtual DOM 只会对同一个层级的元素进行对比，如下图所示， div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 O(n)。 Vue中的虚拟domVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码： 1return createElement('h1', this.blogTitle) createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 render函数(渲染函数)12345678910111213141516171819202122232425262728293031&lt;template id="hdom"&gt;//template下只允许有一个子节点,所以用div包裹三个标题 &lt;div&gt; &lt;h1 v-if="level==1"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-if="level==2"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-if="level==3"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; Vue.component('child', &#123; //使用template命名的方法将大段代码写在html里 props: ['level'], template: '#hdom' &#125;) Vue.component('child', &#123; //使用render函数替代template,节省大量代码 render: function (createElement) &#123; return createElement('h' + this.level, this.$slots.default); &#125;, props: ['level'] &#125;)&lt;/script&gt; render函数的第一个参数在render函数的方法中,参数必须是createElement,它的类型是functioncreateElement的第一个参数必选.类型可以是String|Object|Function 1234567891011121314151617Vue.component('child',&#123; render: function(createElement)&#123; return createELement('h1') //参数是字符串.返回&lt;h1&gt;&lt;/h1&gt; return createElement(&#123; template: `&lt;div&gt;鹅鹅鹅&lt;/div&gt;` &#125;) //参数是对象.返回&lt;div&gt;鹅鹅鹅&lt;/div&gt; var domFun = function()&#123; return &#123; template: `&lt;div&gt;鹅鹅鹅&lt;/div&gt;` &#125; &#125; return createELement(domFun()) //参数是函数.返回&lt;div&gt;鹅鹅鹅&lt;/div&gt; &#125;&#125;) render函数的第二个参数createElement的第二个参数可选.参数是数据对象,只能是Object 1234567891011121314151617181920212223242526272829Vue.component('child',&#123; render: function(createElement)&#123; return CreateElement(&#123; template: `&lt;div&gt;鹅鹅鹅&lt;/div&gt;` &#125;,&#123; //添加class选项,其中为true的会添加到模板&lt;div&gt;中 'class':&#123; foo: true baz: false &#125;, //添加style属性 style: &#123; color: 'red', fontSize: '18px' &#125;, //正常的html属性 attrs: &#123; id: 'foo', src: 'xxxx' &#125;, //原生DOM属性 domProps: &#123; innerHTML: '&lt;span style="color:blue"&gt;我是蓝色&lt;/span&gt;' &#125; &#125; ) &#125;&#125;) render函数的第三个参数createElement的第三个参数可选.参数可以是String|Array,代表子节点 1234567Vue.component('child', &#123; render: function (createElement) &#123; return createElement('div', [ createElement('h1', '我是h1标题'), createElement('h6', '我是h6标题') ]) &#125;&#125;); 在render函数中使用this.$slots第三个参数存的是VNode,也就是虚拟节点.组件树中的所有 VNode 必须是唯一的. 12345678910111213Vue.component('my-component',&#123; render: function(createElement)&#123; var header = this.$slots.header //返回的就是含有VNode的数组 var main = this.$slots.default var footer = this.$slots.footer return createElement('div',[ createElement('header',header), createElement('main',main), createElement('footer',footer) ]) &#125;&#125;) 在render函数中使用props传数据1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;button @click="switchShow"&gt;点击切换&lt;/button&gt; &lt;my-component :show="show"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; props: ['show'], render: function(createElement)&#123; var imgsrc if(this.show)&#123; imgsrc = 'img/001.jpg' &#125;else&#123; imgsrc = 'img/002.jpg' &#125; return createElement('img',&#123; attrs: &#123; scr: imgsrc &#125; &#125;) &#125;&#125;)var app = new Vue(&#123; el: "#app", data: &#123; show: true &#125;, methods: &#123; switchShow: function()&#123; this.show = !this.show &#125; &#125;&#125;)&lt;/script&gt; 在render函数中使用v-modelv-model作用: 接收input的内容并绑定到后面的值上. 1234567891011121314151617181920212223242526272829303132&lt;div id="app"&gt;&lt;my-component v-bind:name="name" v-model="name"&gt;&lt;/my-component&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; render: function(createElement)&#123; props:['name'], var self = this //指的是当前的Vue实例 return createElement('input',&#123; domProps: &#123; //原生DOM value: self.name &#125;, on: &#123; //这里添加事件 input: function(event)&#123; //此处的this是window,所以需要声明self指代vue实例 self.$emit('input',event.target.value) &#125; &#125; &#125;) &#125;&#125;)var app = new Vue(&#123; el: "#app", data: &#123; name: "Tom" &#125;&#125;)&lt;/script&gt; render函数中使用作用域插槽123456789101112131415161718192021222324&lt;div id="app"&gt;&lt;my-component&gt; &lt;template scoped="prop"&gt; &#123;&#123; prop.text &#125;&#125; &#123;&#123; prop.msg &#125;&#125; &lt;/template&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; render: function(createElement)&#123; return createElement('div',this.$scopedSlots.default(&#123; text: '我是子组件传递的数据', msg: 'scopetext' &#125;))&#125;)var app = new Vue(&#123; el: "#app", data: &#123; &#125;&#125;)&lt;/script&gt;]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件]]></title>
    <url>%2F2019%2F09%2F09%2FVue%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[作用提高代码复用性组件使用方法全局注册 全局注册时,Vue.component需要在new Vue实例之前注册.否则报错. 123456789Vue.component('button-counter',&#123; data: function()&#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;)&#125;) 优点：所有的vue实例都可以用缺点：权限太大，容错率降低 局部注册12345678var app = new Vue(&#123; el: '#app', components: &#123; 'my-component': &#123; template: '&lt;div&gt;我是组件的内容&lt;/div&gt;' &#125; &#125;&#125;) 注意局部注册的组件在其子组件相互之间是不可用的。如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写： 12345678var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; components: &#123; 'component-a': ComponentA &#125;, // ...&#125; 或者采用import方法: 12345678import ComponentA from './ComponentA.vue'export default &#123; components: &#123; ComponentA &#125;, // ...&#125; 组件的复用1234567891011121314151617&lt;div id="components-demo"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;&lt;script&gt;Vue.component('button-counter',&#123; data: function()&#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;)&#125;)&lt;/script&gt; 问题: 点击按钮时,三个按键的数字都会变化吗?为什么? 注意当点击按钮时，每个组件都会各自独立维护它的count。因为你每用一次组件，就会有一个它的新实例被创建。 特殊情况vue组件的模板在某些情况下会受到html标签的限制，比如 &lt;table&gt; 中只能还 有 &lt;tr&gt; , &lt;td&gt;这些元素，所以直接在table中使用组件是无效的，此时可以使用is属性来挂载组件 123&lt;table&gt; &lt;tbody is="my-component"&gt;&lt;/tbody&gt; &lt;/table&gt; 组件使用技巧 必须使用小写字母加­进行命名child,my­component命名组件 template中的内容必须被一个DOM元素包括,也可以嵌套 在组件的定义中，除了template之外还可以使用其他选项,比如data,computed,methods 一个组件的 data 选项必须是一个函数,否则就会出现点一个其他按钮也跟着变化的情况 组件中data什么时候可以用对象因为组件内data会复用。一个组件修改，就都会改解决办法:new Vue()，生成一个根实例。该组件不会复用，也就不会共享。 组件通信通过prop父传子通信123456789101112131415161718192021222324252627282930&lt;div id="blog-post-demo"&gt; &lt;h5&gt;我是父组件&lt;/h5&gt; &lt;child-post msg="我是来自父组件的内容" v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title" &gt; &lt;/child-post&gt; &lt;/div&gt;&lt;script&gt;Vue.component('child-post',&#123; props: ['title','msg'], template: '&lt;h3&gt;&#123;&#123; title &#125;&#125; + &#123;&#123;msg&#125;&#125;&lt;/h3&gt;'&#125;)new Vue(&#123; el: "#blog-post-demo", data: &#123; posts: [ &#123;id: 1, title: 'aaa' &#125;, &#123;id: 2, title: 'bbb' &#125;, &#123;id: 3, title: 'ccc' &#125; ] &#125; &#125; )&lt;/script&gt; 一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问data中的值一样。如上所示，你会发现我们可以使用v-bind来动态传递prop。这在你一开始不清楚要渲染的具体内容，比如从一个 API 获取博文列表的时候，是非常有用的。总结 在组件中使用props来从父亲组件接收参数，注意，在props中定义的属性，都可以在组件中直接使用 props来自父级，而组件中data return的数据就是组件自己的数据，两种情况作用域就是 组件本身，可以在template，computed，methods中直接使用 props的值有两种，一种是字符串数组，一种是对象，本节先只讲数组 可以使用v-­bind动态绑定父组件来的内容 单向数据流 解释: 通过props传递数据是单向的了,也就是父组件数据变化时会传递给子组件,但是反过来不行。 目的: 是尽可能将父子组件解耦，避免子组件无意中修改了父组件的状态。 应用场景: 业务中会经常遇到两种需要改变prop的情况 一种是父组件传递初始值进来，子组件将它作为初始值保存起来，在自己的作用域下可以随意使用和修改。这种情况可以在组件data内再声明一个数据，引用父组件的prop步骤一：注册组件步骤二：将父组件的数据传递进来，并在子组件中用props接收步骤三：将传递进来的数据通过初始值保存起来 1234567891011121314151617181920&lt;div id="app"&gt; &lt;my-comp init-count="666"&gt;&lt;/my-comp&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', components: &#123; 'my-comp': &#123; props: ['init-count'], template: '&lt;div&gt;&#123;&#123;init-count&#125;&#125;&lt;/div&gt;', data: function() &#123; return &#123; //初始值count.props中的值通过this.XXX获取 count: this.initCount &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 另一种情况就是prop作为需要被转变的原始值传入。这种情况用计算属性就可以了步骤一：注册组件步骤二：将父组件的数据传递进来，并在子组件中用props接收步骤三：将传递进来的数据通过计算属性进行重新计算 123456789101112131415161718192021222324252627&lt;div&gt; &lt;input type="text" v-model="width"&gt; &lt;my-comp :width="width"&gt;&lt;/my-comp&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: "#app", data: &#123; width: '' &#125;, components: &#123; 'my-comp': &#123; props: ['init-count', 'width'], template: '&lt;div :style="style"&gt;&#123;&#123; init-count &#125;&#125;&lt;/div&gt;', computed: &#123; style: function()&#123; return &#123; width: this.width + 'px', background: 'red' &#125; &#125; &#125; &#125; &#125;&#125;)&lt;/script&gt; 驼峰命名与短横线命名 在html中,myMessage和mymessage是一样的.因此在组件中的html中必须使用短横线命名. 在组件中,父组件给子组件传数据必须用短横线(属于HTML范围内),因为html不识别驼峰,在props中无所谓.在template中必须使用驼峰命名. 在组件中的data中,用this.XXX引用时,必须使用驼峰命名. 数据验证验证的 type 类型可以是：• String• Number• Boolean• Object• Array• Function 在props中设定数据类型时,必须使用对象格式,即 123456789101112props: &#123; //msg必须是数字 msg: Number, //total既可以是数字又可以是字符串 total: [Number,String] //ach是布尔值,默认是true,required是必传项. ach: &#123; type: Boolean, default: true, required: true &#125;&#125; 组件通信组件通信分为父子通信,兄弟通信,跨级通信. 子传父通信使用v­-on除了监听DOM事件外，还可以用于组件之间的自定义事件.JavaScript的设计模式 一一观察者模式， dispatchEvent和addEventListener这两个方法.Vue组件也有与之类似的一套模式，子组件用$emit()来触发事件,父组件用$on()来监听子组件的事件. 自定义事件change 在子组件中用$emit触发change,即this.$emit(&#39;change&#39;,this.count).括号里前面是用户名,后面是传递参数. 在自定义事件中用一个参数来接受 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id="app"&gt; &lt;p&gt;您的余额为&#123;&#123; total &#125;&#125;&lt;/p&gt; //父组件内用v-on监听change事件 &lt;btn-component @change="handleTotal"&gt;&lt;/btn-component&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: "#app", data: &#123; total: 0 &#125;, methods: &#123; handleTotal: function(value)&#123; this.total = value &#125; &#125;, components: &#123; 'btn-component': &#123; template: '&lt;div&gt;\ &lt;button @click="handleIncrease"&gt;+1&lt;/button&gt;\ &lt;button @click="handleReduce"&gt;-1&lt;/button&gt;\ &lt;/div&gt;', data: function()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; handleIncrease: function()&#123; this.count++; this.$emit('change', this.count) &#125;, handleReduce: function()&#123; this.count-- this.$emit('change', this.count) &#125; &#125; &#125; &#125;&#125;)&lt;/script&gt; 在组件中使用v-model$emit的代码实际上会触发一个input事件,input后的参数就是传递给v-model绑定的属性的值.v-model其实是一个语法糖,其实绑定了两层操作: v-bind绑定一个value值 v-on指令给当前元素绑定input事件 123456&lt;input v-model="total"&gt;//等价于&lt;input v-bind:value="total" v-on:input="total = $event.target.value"&gt; 要使用v-model,要做到: 接收一个value属性 在有新的value时触发input事件 修改上面的实例: 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="app"&gt; &lt;p&gt;您的余额为&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;btn-component v-model="total"&gt;&lt;/btn-component&gt; //如果又添加一个相同的组件,点击也会变化,只不过显示的值属于各自的结果,不冲突 &lt;btn-component v-model="total"&gt;&lt;/btn-component&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: "#app", data: &#123; total: 0 &#125;, components: &#123; 'btn-component': &#123; template: `&lt;div&gt; &lt;button @click="handleincrease"&gt;+1&lt;/button&gt; &lt;button @click="handlereduce"&gt;-1&lt;/button&gt; &lt;/div&gt;`, data: function()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; handleincrease: function()&#123; this.count++ this.$emit('input',this.count) &#125;, handlereduce: function()&#123; this.count-- this.$emit('input',this.count) &#125; &#125; &#125; &#125;&#125;)&lt;/script&gt; V-model简单实例12345678910111213141516171819202122&lt;div id="app"&gt; &lt;h5&gt;我是父组件&lt;/h5&gt; &lt;input type="text" v-model="parentmsg"&gt; // 下面的是子组件,通过v-bind绑定msg到父组件中v-model所绑定的parentmsg,通过props传递到模板中渲染到页面 &lt;child :msg="parentmsg"&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt;Vue.component('child',&#123; props: ['msg'], template: '&lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;'&#125;)new Vue(&#123; el: "#app", data: &#123; parentmsg:'' &#125; &#125; )&lt;/script&gt; 非父子组件通信(兄弟通信)方法: 使用bus中介使用一个空的Vue实例作为中央事件总线(bus):var bus = new Vue()触发组件A中的事件bus.$emit(&#39;id-selected&#39;,1)在组件B创建的钩子中监听事件bus.$on(&#39;id-selected&#39;,function(id){//....}) 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt;&lt;my-acomponent&gt;&lt;/my-acomponent&gt;&lt;my-bcomponent&gt;&lt;/my-bcomponent&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-acomponent',&#123; template: `&lt;div&gt;&lt;button @click="handle"&gt;点击我向B组件传数据&lt;/button&gt;&lt;/div&gt;`, data: function()&#123; return &#123; aaa: '我来自a组件' &#125; &#125;, methods: &#123; handle: function()&#123; this.$root.bus.$emit('lala', this.aaa) &#125; &#125;&#125;)Vue.component('my-bcomponent',&#123; template: `&lt;div&gt;我是B组件&lt;/div&gt;`, created: function()&#123; //A组件在实例创建的时候就监听事件--lala事件 this.$root.bus.$on('lala',function(value)&#123; alert(value) &#125;) &#125;&#125;)var app = new Vue(&#123; el:"#app", data: &#123; //bus中介 bus: new Vue() &#125;&#125;)&lt;/script&gt; 父链和子链this.$parent(从父组件里拿内容)12345678Vue.component('child-component',&#123; template:`&lt;button @click="setFatherData"&gt;通过我修改父亲的数据&lt;/button&gt;`, methods: &#123; setFatherData: function()&#123; this.$parent.msg = "数据已修改" &#125; &#125;&#125;) this$refs(从子组件里拿内容 )为子组件提供索引的方法,用特殊的属性ref为其增加一个索引如果用$children会把所有子组件都拿到 12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;my-acomponent ref="A"&gt;&lt;/my-acomponent&gt; &lt;my-bcomponent ref="B"&gt;&lt;/my-bcomponent&gt; &lt;button @click="getChildData"&gt;我是父组件,我要拿到子组件的数据&lt;/button&gt;---&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: "#app", data: &#123; bus: new Vue() msg: '数据未拿到', formchild: '还未拿到' &#125;, methods: &#123; getChildData: function()&#123; //用来拿子组件中的内容---$refs this.fromChild = this.$refs.b.msg &#125; &#125; &#125;)Vue.component('my-acomponent',&#123; template: `&lt;div&gt;&lt;/div&gt;`, data: function()&#123; return &#123; msg: '我来自a组件' &#125; &#125;&#125;)&lt;/script&gt; 使用slot插槽分发内容什么是插槽为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为内容分发.Vue.js 实现了一个内容分发API，使用特殊的slot元素作为原始内容的插槽. 编译的作用域父组件的作用域在父组件内,即&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;内部(便于理解).子组件的作用域在子组件的template里. 插槽的用法 混合父组件的内容和子组件的模板 单个插槽 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;my-component&gt; &lt;p&gt;父组件&lt;/p&gt; //虽然是父组件的作用域,但没有slot插槽,父组件的信息是无法显示 //插槽的作用是把父组件的内容插入到下面的子组件中,最后会显示出来 &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; template: `&lt;div&gt; &lt;slot&gt; 如果父组件没有插入内容,那么我就作为默认出现 &lt;/slot&gt; &lt;/div&gt;`&#125;)var app = new Vue(&#123; el:"#app", data: &#123; &#125;&#125;)&lt;/script&gt; 具名插槽 123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;my-component&gt; &lt;h3 slot="header"&gt;我是标题&lt;/h3&gt; //给父组件的插槽命名,可以和子组件模板的slot一一对应 &lt;p&gt;父组件&lt;/p&gt; //这个不命名的自然就对应那个没有命名的slot &lt;p slot="footer"&gt;我是底部信息&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; template: `&lt;div&gt; &lt;div class="header"&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;`&#125;)var app = new Vue(&#123; el:"#app", data: &#123; &#125;&#125;)&lt;/script&gt; 作用域插槽 作用域插槽是一种特殊的插槽,使用一个可复用的模板来替换已渲染的元素 从子组件获取数据 &lt;template&gt;标签是不会渲染出来的,Vue版本更新后,也可以写在其他标签上 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;my-component&gt; &lt;template slot="abc" slot-scope="prop"&gt; //写一个临时变量prop,用临时变量拿子组件的信息 &#123;&#123; prop.text &#125;&#125; &lt;/template&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; template: `&lt;div&gt; &lt;slot name="abc" text="我是子组件的内容"&gt; &lt;/slot&gt; &lt;/div&gt;`&#125;)var app = new Vue(&#123; el:"#app", data: &#123; &#125;&#125;)&lt;/script&gt; 访问slot通过this.$slots.(name) 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;my-component&gt; &lt;h3 slot="header"&gt;我是标题&lt;/h3&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;p slot="footer"&gt;我是底部信息&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; template: `&lt;div&gt; &lt;div class="header"&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;`, mounted: function()&#123; //访问插槽 var header = this.$slots.header var text = header[0].elm.innerText console.log(header) //打印一个虚拟节点 console.log(text) &#125;&#125;)var app = new Vue(&#123; el:"#app", data: &#123; &#125;&#125;)&lt;/script&gt; 组件高级用法-动态组件实现需求: 点击不同按钮切换不同页面使用is动态绑定组件,调用方法切换不同页面 123456789101112131415161718192021222324252627282930313233&lt;div id="app"&gt; &lt;component :is="thisView"&gt;&lt;/component&gt; &lt;button @click="handleView('A')"&gt;第一句&lt;/button&gt; &lt;button @click="handleView('B')"&gt;第二句&lt;/button&gt; &lt;button @click="handleView('C')"&gt;第三句&lt;/button&gt; &lt;button @click="handleView('D')"&gt;第四句&lt;/button&gt;&lt;/div&gt;&lt;script&gt;Vue.component('comA',&#123; template:`&lt;div&gt;鹅鹅鹅&lt;/div&gt;`&#125;)Vue.component('comB',&#123; template:`&lt;div&gt;曲项向天歌&lt;/div&gt;`&#125;)Vue.component('comC',&#123; template:`&lt;div&gt;白毛浮绿水&lt;/div&gt;`&#125;)Vue.component('comD',&#123; template:`&lt;div&gt;红掌拨清波&lt;/div&gt;`&#125;)var app = new Vue(&#123; el: "#app", data: &#123; thisView: 'comA' &#125;, methods: &#123; handleView: function(tag)&#123; this.thisView = 'com' + tag &#125; &#125;&#125;)&lt;/script&gt; 解析 DOM 模板时的注意事项有些 HTML 元素，诸如&lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部。 123&lt;table&gt; &lt;blog-post-row&gt;&lt;/blog-post-row&gt;&lt;/table&gt; 这个自定义组件 &lt;blog-post-row&gt; 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的is特性给了我们一个变通的办法： 123&lt;table&gt; &lt;tr is="blog-post-row"&gt;&lt;/tr&gt;&lt;/table&gt; 需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的： 字符串 (例如：template: ‘…’) 单文件组件 (.vue) &lt;script type=&quot;text/x-template&quot;&gt; 模块系统在模块系统中局部注册推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 ComponentB.js 或 ComponentB.vue 文件中： 12345678910import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default &#123; components: &#123; ComponentA, ComponentC &#125;, // ...&#125; 现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了 基础组件的自动化全局注册可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。所以会导致很多组件里都会有一个包含基础组件的长列表： 1234567891011import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export default &#123; components: &#123; BaseButton, BaseIcon, BaseInput &#125;&#125; 如果你使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码： 12345678910111213141516171819202122232425262728293031323334353637import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\w+\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = upperFirst( camelCase( // 获取和目录深度无关的文件名 fileName .split('/') .pop() .replace(/\.\w+$/, '') ) ) // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;) 记住全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生. PropProp 的大小写HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符.当使用dom中的模板时,驼峰命名的prop需要使用其等价的短横线命名替换: 12345678910//jsVue.component('blog-post', &#123; // 在 JavaScript 中是 驼峰 的 props: ['postTitle'], template: '&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'&#125;)//html&lt;!-- 在 HTML 中是短横线的 --&gt;&lt;blog-post post-title="hello!"&gt;&lt;/blog-post&gt; prop的类型字符串和对象字符串:props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]对象: 123456789props: &#123; title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor&#125; 传递静态或动态 Prop传静态值: 1&lt;blog-post title="My journey with Vue"&gt;&lt;/blog-post&gt; 动态赋值: 1&lt;blog-post v-bind:title="post.title"&gt;&lt;/blog-post&gt; 布尔值: 123456789&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt;&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:is-published="false"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:is-published="post.isPublished"&gt;&lt;/blog-post&gt; 数组 123456&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:comment-ids="[234, 266, 273]"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:comment-ids="post.commentIds"&gt;&lt;/blog-post&gt; 对象 1234567891011&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:author="&#123; name: 'Veronica', company: 'Veridian Dynamics' &#125;"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:author="post.author"&gt;&lt;/blog-post&gt; 禁用特性继承如果你不希望组件的根元素继承特性，你可以在组件的选项中设置 inheritAttrs: false。例如： 1234Vue.component('my-component', &#123; inheritAttrs: false, // ...&#125;) 这尤其适合配合实例的$attrs属性 1234&#123; required: true, placeholder: 'Enter your username'&#125; 1234567891011121314Vue.component('base-input', &#123; inheritAttrs: false, props: ['label', 'value'], template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind="$attrs" v-bind:value="value" v-on:input="$emit('input', $event.target.value)" &gt; &lt;/label&gt; `&#125;) 123456//html&lt;base-input v-model="username" required placeholder="Enter your username"&gt;&lt;/base-input&gt; 注意 inheritAttrs: false 选项不会影响 style 和 class 的绑定。 自定义事件事件名不同于组件和 prop，事件名不会被用作一个js变量名或属性名，所以就没有理由使用驼峰命名了。并且v-on事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以推荐始终使用短横线命名. 自定义组件的v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突： 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type="checkbox" v-bind:checked="checked" v-on:change="$emit('change', $event.target.checked)" &gt; `&#125;) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model="lovingVue"&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 &lt;base-checkbox&gt;触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新。 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。 将原生事件绑定到组件使用v-on的修饰符.native直接监听一个组件根元素上的原生事件 1&lt;base-input v-on:focus.native="onFocus"&gt;&lt;/base-input&gt; 但当上述 &lt;base-input&gt; 组件做了如下重构，那么根元素实际上是一个 &lt;label&gt; 元素: 12345678&lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind="$attrs" v-bind:value="value" v-on:input="$emit('input', $event.target.value)" &gt;&lt;/label&gt; 这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。 为了解决这个问题，Vue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如： 1234&#123; focus: function (event) &#123; /* ... */ &#125; input: function (value) &#123; /* ... */ &#125;,&#125; $listeners有了这个 $listeners 属性，你就可以配合 v-on=”$listeners” 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 &lt;input&gt; 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的： 1234567891011121314151617181920212223242526272829303132Vue.component('base-input', &#123; inheritAttrs: false, props: ['label', 'value'], computed: &#123; inputListeners: function () &#123; var vm = this // `Object.assign` 将所有的对象合并为一个新对象 return Object.assign(&#123;&#125;, // 我们从父级添加所有的监听器 this.$listeners, // 然后我们添加自定义监听器， // 或覆写一些监听器的行为 &#123; // 这里确保组件配合 `v-model` 的工作 input: function (event) &#123; vm.$emit('input', event.target.value) &#125; &#125; ) &#125; &#125;, template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind="$attrs" v-bind:value="value" v-on="inputListeners" &gt; &lt;/label&gt; `&#125;) 现在&lt;base-input&gt;组件是一个完全透明的包裹器了，也就是说它可以完全像一个普通的 &lt;input&gt;元素一样使用了：所有跟它相同的特性和监听器的都可以工作。 .sync 修饰符在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图： 1this.$emit('update:title', newTitle) 然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如： 1234&lt;text-document v-bind:title="doc.title" v-on:update:title="doc.title = $event"&gt;&lt;/text-document&gt; 为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符： 1&lt;text-document v-bind:title.sync="doc.title"&gt;&lt;/text-document&gt; 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。 当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用： 1&lt;text-document v-bind.sync="doc"&gt;&lt;/text-document&gt; 这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=&quot;{ title: doc.title }&quot;，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。 动态组件和异步组件动态组件is使用is特性切换不同的组件,如果想在标签的组件实例被在它们第一次被创建的时候缓存下来,避免重复渲染.可以使用&lt;keep-alive&gt; 元素将其动态组件包裹起来. 1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 异步组件的3种实现方式—工厂函数、Promise、高级函数 异步组件实现的本质是2次渲染，先渲染成注释节点，当组件加载成功后，在通过forceRender重新渲染 高级异步组件可以通过简单的配置实现loading resolve reject timeout 4种状态. 例如： 12345678Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) 函数有2个参数，resolve和reject，它们是两个函数，由javascript引擎提供，不用自己定义。resolve会在你从服务器得到组件定义的时候被调用。 如你所见，这个工厂函数会收到一个 resolve回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 reject(reason) 来表示加载失败。这里的 setTimeout 是为了演示用的，如何获取组件取决于你自己.一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用： 12345678Vue.component('async-webpack-example', function (resolve) &#123; // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require(['./my-async-component'], resolve)&#125;)//这里使用的是webpack模块方法require(AMD版本)，将其对应的文件拆分到一个单独的 bundle 中，//此 bundle 会被异步加载，然后调用resolve回调函数 你也可以在工厂函数中返回一个 Promise，所以把 webpack 2 和 ES2015 语法加在一起，我们可以写成这样： 123456Vue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component'))//这里使用的webpack模块方法import()，可以通过注释的方法定义新chunk的名称 处理加载状态这里的异步组件工厂函数也可以返回一个如下格式的对象： 12345678910111213const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;) 当使用局部注册的时候，也可以直接提供一个返回promise的函数，比如在使用vue的路由懒加载时： 1234//懒加载方式,当路由被访问时才加载对应组件const Login = () =&gt; import('@/components/Login')const Home = resolve =&gt; require(['@/components/Home'], resolve)const UserList = resolve =&gt; require(['@/components/user/list'], resolve) 这样只有当要访问路由时，才会加载指定路由下的组件. 处理边界情况访问元素和组件访问根实例在每个new Vue实例的子组件中,其根实例可以通过$root属性进行访问. 123456789101112131415161718192021222324// Vue 根实例new Vue(&#123; data: &#123; foo: 1 &#125;, computed: &#123; bar: function () &#123; /* ... */ &#125; &#125;, methods: &#123; baz: function () &#123; /* ... */ &#125; &#125;&#125;)// 获取根组件的数据this.$root.foo// 写入根组件的数据this.$root.foo = 2// 访问根组件的计算属性this.$root.bar// 调用根组件的方法this.$root.baz() 访问父组件实例和 $root类似，$parent 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。 访问子组件实例通过$ref 依赖注入依赖注入用到了两个新的实例选项：provide 和 inject。provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 &lt;google-map&gt; 内部的 getMap 方法 12345provide: function () &#123; return &#123; getMap: this.getMap &#125;&#125; 然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的属性： 1inject: ['getMap'] 相比$parent来说，这个用法可以让我们在任意后代组件中访问 getMap，而不需要暴露整个 &lt;google-map&gt; 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 props 一样。 实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了： 祖先组件不需要知道哪些后代组件使用它提供的属性 后代组件不需要知道被注入的属性来自哪里 然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。 程序化的事件侦听器现在，你已经知道了 $emit 的用法，它可以被 v-on 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以： 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件 让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己： 12345678910111213141516mounted: function () &#123; this.attachDatepicker('startDateInput') this.attachDatepicker('endDateInput')&#125;,methods: &#123; attachDatepicker: function (refName) &#123; var picker = new Pikaday(&#123; field: this.$refs[refName], format: 'YYYY-MM-DD' &#125;) this.$once('hook:beforeDestroy', function () &#123; picker.destroy() &#125;) &#125;&#125; 循环引用递归组件组件是可以在它们自己的模板中调用自身的。不过它们只能通过 name 选项来做这件事： 1name: 'unique-name-of-my-component' 稍有不慎，递归组件就可能导致无限循环： 12name: 'stack-overflow',template: '&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;' 类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 false 的 v-if)。 组件之间的循环引用解决方法:把 &lt;tree-folder&gt; 组件设为了那个点。我们知道那个产生悖论的子组件是 &lt;tree-folder-contents&gt; 组件，所以我们会等到生命周期钩子 beforeCreate 时去注册它： 123beforeCreate: function () &#123; this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default&#125; 或者，在本地注册组件的时候，你可以使用 webpack 的异步 import： 123components: &#123; TreeFolderContents: () =&gt; import('./tree-folder-contents.vue')&#125; 模板定义的替代品内联模板(inline-template)当子组件中出现inline-template时,这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。 123456&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;These are compiled as the component's own template.&lt;/p&gt; &lt;p&gt;Not parent's transclusion content.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; 内联模板需要定义在 Vue 所属的 DOM 元素内。不过，inline-template 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 template 选项或 .vue 文件里的一个 &lt;template&gt; 元素来定义模板。 X-template另一个定义模板的方式是在一个 &lt;script&gt; 元素中，并为其带上 text/x-template 的类型，然后通过一个 id 将模板引用过去。例如： 123456789//html&lt;script type="text/x-template" id="hello-world-template"&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;//jsVue.component('hello-world', &#123; template: '#hello-world-template'&#125;) x-template 需要定义在 Vue 所属的 DOM 元素外。 这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。 控制更新强制更新 如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。 然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 $forceUpdate 来做这件事。 通过 v-once 创建低开销的静态组件渲染包含大量静态内容的组件,你可以在根元素上添加 v-once 特性以确保这些内容只计算一次然后缓存起来; 12345678Vue.component('terms-of-service', &#123; template: ` &lt;div v-once&gt; &lt;h1&gt;Terms of Service&lt;/h1&gt; ... a lot of static content ... &lt;/div&gt; `&#125;) 注意事项: 不要过度使用这个模式。当需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 v-once 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2019%2F09%2F07%2FVue-js%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[介绍Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。vue和react都不是mvvm框架，只是借鉴 什么是MVVMMVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。viewmodel是组件的实例.ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 Vue.js的优点： 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 易用灵活高效 引入在html内引入:&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;工程化时最好使用vue/cli构建. 实例和数据绑定通过构造函数Vue就可以创建一个Vue的实例.并启动Vue应用. 1234let app = new Vue(&#123; el: '#app', data: &#123;msg: 'hello world' &#125;&#125;) el用于指定页面中的DOM元素来挂载Vue实例.可以是标签,可以是css语法.通过Vue实例的data选项,可以声明应用内可以双向绑定的数据.建议所有会用到的数据都预先在data内声明,也可以指向一个已有的变量.值可以先设置默认值.挂载成功后,可以通过app.$el来访问该元素,Vue实例本身也代理了data对象里的所有属性,所以可以这样访问:访问Vue实例的属性: app.$el, app.$data.访问data元素的属性: app.msg 生命周期钩子钩子(hook),可以理解为挂载点.在整个Vue实例创建过程中,有一些挂载点. 生命周期流程: 所有的生命周期钩子自动绑定this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 生命周期钩子 类型 详细 beforeCreate Function 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created Function 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el属性目前不可见。 beforeMoute Function 在挂载开始之前被调用：相关的render函数首次被调用。 mounted Function el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当mounted被调用时vm.$el也在文档内。 beforeUpdate Function 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。 updated Function 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或watcher取而代之 actived Function keep-alive 组件激活时调用。 deactivated Function keep-alive 组件停用时调用。 beforeDestroy Function 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Function Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 errorCaptured (err: Error, vm: Component, info: string) =&gt; ?boolean 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回false以阻止该错误继续向上传播。 不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。注意mounted不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用vm.$nextTick替换掉mounted： 123456mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 注意updated不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用vm.$nextTick替换掉updated： 123456updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been re-rendered &#125;)&#125; 文本插值和表达式使用双大括号(Mustache语法)的方法是最基本的文本插值的语法,它会自动将双向绑定的数据实时显示出来. 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt; 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 v-bindv-bind可缩写成:.双大括号语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令： 1&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt; 对于布尔特性 (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中： 1&lt;button v-bind:disabled="isButtonDisabled"&gt;Button&lt;/button&gt; 如果isButtonDisabled的值是null、undefined或false，则disabled特性甚至不会被包含在渲染出来的 &lt;button&gt; 元素中。 js表达式 Vue .js 只支持单个表达式，不支持语句和流控制。 1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt;//文本插值的形式，其中不能书写表达式,支持单个表达式 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 1234&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。 计算属性123&lt;div id="example"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 这里是想要显示变量 message 的翻转字符串,但是更复杂的就需要计算属性.所有的计算属性都以函数的形式写在 Vue 实例内的computed选项内，最终返回计算后的结果。范例: 1234&lt;div id="example"&gt;&lt;p&gt;message: "&#123;&#123; message &#125;&#125;"&lt;/p&gt;&lt;p&gt;reversed message: "&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516var vm = new Vue(&#123; el: '#example', data: &#123; message: 'hello' &#125;, computed: &#123; //计算属性的getter reversedMessage: function()&#123; //this指向vm实例 return this.message.split('').reverse.().join('') &#125; &#125;&#125;)//结果：//message: "hello"//reversed message: "olleh" 计算属性缓存123456// 在组件中methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125; 使用methods方法也可以起到和计算属性同样效果区别:methods: 如果调用方法,只要页面重新渲染.方法就会重新执行,不需要渲染就不需要重新执行计算属性: 不管渲不渲染,只要计算属性依赖的数据不变,就不会变何时使用: 取决于是否需要缓存,当遍历大量数组或大量计算,应该使用计算属性. 计算属性缓存 vs 方法methods我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖： 12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 相比之下，每当触发重新渲染时，调用方法methods将总会再次执行函数。计算属性 vs 侦听属性watchwatch:主要用来监听数据变化.可以监听:props,data,computed内的数据.属于我的变化影响别人.计算属性computed: 依赖data中的数据,只有该依赖的数据发生变化才会变化.属于别人的变化影响我.Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。例子: 1234567891011121314151617&lt;div id="demo"&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 计算属性版本: 123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 计算属性的setter计算属性默认只有getter，不过在需要时你也可以提供一个setter： 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 侦听器watch当需要在数据变化时执行异步或开销较大的操作时,更适合用watch. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id="watch-example"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model="question"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() &#125; &#125;, created: function () &#123; // `_.debounce` 是一个通过 Lodash 创建的函数防抖. this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) &#125;, methods: &#123; getAnswer: function () &#123; //如果要检索的字符串值没有出现，则indexOf返回 -1。 if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125; &#125;&#125;)&lt;/script&gt; 在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 v-bind与class和style的绑定应用场景: dom元素经常绑定一些class类名或style样式 对象语法可以给v-bind:class传一个对象,动态切换class: 1&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 也可以传入多个属性来动态切换class.v-bind:class指令也可以与普通class属性共存.绑定的数据对象也可以写在data里. 12345678910&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;&lt;script&gt;data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125;&lt;/script&gt; 当class的表达式过长或者逻辑复杂,可以绑定一个计算属性.一般当条件多于两个时,就可以使用data或computed 123456789101112131415&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;&lt;script&gt;data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125;&#125;&lt;/script&gt; 数组语法当应用多个class时,可以使用数组语法,给v-bind:class绑定一个数组.数组成员直接对应类名. 1234567&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;&lt;script&gt;data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125;&lt;/script&gt; 渲染为 1&lt;div class="active text-danger"&gt;&lt;/div&gt; 根据条件切换,也可以使用三元表达式: 1&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt; 也可以数组语法,对象语法混用: 1&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;&lt;/div&gt; 绑定内联样式对象语法v-bind:style的对象语法十分直观——看着非常像CSS，但其实是一个JavaScript对象.CSS属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名： 1234567&lt;div v-bind:style="&#123;color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt;&lt;script&gt;data: &#123; color: 'red', fontSize: 30&#125;&lt;/script&gt; 同样的，对象语法常常结合返回对象的计算属性使用。 数组语法数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 应用多个样式对象时,可以使用数组语法.在实际业务中,style的数组语法并不常用,因为往往可以写在一个对象里面.而较为常用的应当是计算属性.使用:style时,Vue会自动给特殊的css属性名称增加前缀,比如transform,无需再加前缀属性. 基本指令v-cloak解决因为初始化慢,导致页面闪动的情况.这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕.一般和CSS规则如 [v-cloak] { display: none }配合使用(需要写到css里). v-once只渲染元素和组件一次.之后的重新渲染被当做静态内容跳过,用于优化性能.写在标签里. v-pre跳过这个元素和他子元素的编译过程.可以加快编译. 其他的单独写v-text, v-html, v-show, v-if, v-else, v-else-if, v-for, v-on, v-bind, v-model, v-slot. 条件渲染v-if,v-else,v-else-if用法: 根据表达式值的真假条件渲染元素.在切换时元素及它的数据绑定/组件被销毁并重建.如果元素是&lt;template&gt;,将提出他的内容作为条件块.当条件变化时,该指令触发过渡效果. 当和v-for一起使用时,v-for的优先级更高. 也可以用 v-else 添加一个“else 块”： 12&lt;h1 v-if="awesome"&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt; 在&lt;template&gt;上使用v-if因为v-if是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个&lt;template&gt;元素当做不可见的包裹元素，并在上面使用v-if。最终的渲染结果将不包含&lt;template&gt;元素。 12345&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 用key管理可复用元素Vue会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染.&lt;input&gt;不会被替换掉——仅仅是替换了它的 placeholder。如果要表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的key属性即可. 12345678&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt; v-show1&lt;h1 v-show="ok"&gt;Hello!&lt;/h1&gt; v-show只是切换css属性display.v-show不支持&lt;template&gt;元素,也不支持v-else. v-if和v-show相比v-if: 真正的条件渲染,条件为真就渲染,为false就移除.v-show: 不管初始条件是什么,都会渲染.只是切换css的display属性.总结: 如果需要非常频繁地切换，则使用v-show较好；如果在运行时条件很少改变，则使用v-if较好 v-for列表渲染两种使用场景: 遍历多个对象 遍历一个对象的多个属性 遍历数组语法: v-for=&quot;(item, index) in items&quot;第一个是数组元素名,第二个是索引.遍历对象的多个属性语法: v-for=&quot;(value, name, index) in object&quot;第一个是属性值,第二个是属性名,第三个是索引. 在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性： 123&lt;div v-for="item in items" v-bind:key="item.id"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。 Vue 中的 key 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 这里的就地复用的策略复用的是没有发生改变的元素，其他的还要依次重排。 所以我们需要使用key来给每个节点做一个唯一标识，Vue的Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点，所以一句话，key的作用主要是为了高效的更新虚拟DOM. v-for和v-if当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下: 123&lt;li v-for="todo in todos" v-if="!todo.isComplete"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 上面的代码将只渲染未完成的 todo。 而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 )上。如： 123456&lt;ul v-if="todos.length"&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; 在组件上使用 v-for当在组件上使用 v-for 时，key 现在是必须的.然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop,不自动将 item 注入到组件里的原因是，这会使得组件与 v-for的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。 123456789101112131415161718192021//html&lt;div id="todo-list-example"&gt; &lt;form v-on:submit.prevent="addNewTodo"&gt; &lt;label for="new-todo"&gt;Add a todo&lt;/label&gt; &lt;input v-model="newTodoText" id="new-todo" placeholder="E.g. Feed the cat" &gt; &lt;button&gt;Add&lt;/button&gt; &lt;/form&gt; &lt;ul&gt; &lt;li is="todo-item" v-for="(todo, index) in todos" v-bind:key="todo.id" v-bind:title="todo.title" v-on:remove="todos.splice(index, 1)" &gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 注意这里的 is=&quot;todo-item&quot;属性。这种做法在使用 DOM 模板时是十分必要的，因为在 &lt;ul&gt; 元素内只有&lt;li&gt; 元素会被看作有效内容。这样做实现的效果与 &lt;todo-item&gt; 相同，但是可以避开一些潜在的浏览器解析错误。 1234567891011121314151617181920212223242526272829303132333435363738394041//jsVue.component('todo-item', &#123; template: '\ &lt;li&gt;\ &#123;&#123; title &#125;&#125;\ &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;\ &lt;/li&gt;\ ', props: ['title']&#125;)new Vue(&#123; el: '#todo-list-example', data: &#123; newTodoText: '', todos: [ &#123; id: 1, title: 'Do the dishes', &#125;, &#123; id: 2, title: 'Take out the trash', &#125;, &#123; id: 3, title: 'Mow the lawn' &#125; ], nextTodoId: 4 &#125;, methods: &#123; addNewTodo: function () &#123; this.todos.push(&#123; id: this.nextTodoId++, title: this.newTodoText &#125;) this.newTodoText = '' &#125; &#125;&#125;) 数组更新过滤排序改变数组的一系列方法： push() pop() shift() unshift() splice() sort() reverse() 两个数组变动Vue检测不到: 改变数组指定项,vm.items[indexOfItem] = newValue 改变数组长度,vm.items.length = newLength 解决办法:改变指定项: Vue.set(app.arr, 1, ‘car’)改变数组长度: app.arr.splice(1) 显示过滤/排序后的结果有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。计算属性 12345678910&lt;li v-for="n in evenNumbers"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125; 使用methods 1234567891011&lt;li v-for="n in even(numbers)"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; v-onv-on用来绑定事件监听器.v-on可以缩写成@.在普通元素上,v­-on可以监听原生的DOM事件，除了click外，还有dblclick、keyup,mousemove等。表达式可以是一个方法名，这些方法都写在Vue实例的methods属性内，并且是函数的形式，函数内的this指向的是当前Vue实例本身，因此可以直接使用this.xxx的形式来访问或修改数据. 如果方法中带有参数，但是没有加括号，默认传原生事件对象event 动态参数从2.6.0开始，可以用方括号括起来的JavaScript表达式作为一个指令的参数：&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;方括号里的属性可以被替换.可以使用动态参数为一个动态的事件名绑定处理函数：&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;当 eventName的值为 “focus” 时,v-on:[eventName]将等价于 v-on:focus。 动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在HTML特性名里是无效的。同样，在DOM中使用模板时你需要回避大写键名。 修饰符在Vue中传入event对象用$event修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。.stop 阻止单击事件冒泡 &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;.prevent 提交事件不再重载页面.capture 添加事件侦听器时使用时间捕获模式.self 只当事件在该元素本身（而不是子元素）触发时触发回调.once只执行一次的方法.passiveVue 还对应 addEventListener 中的 passive 选项提供了 .passive修饰符。 1234&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive="onScroll"&gt;...&lt;/div&gt; 这个 .passive 修饰符尤其能够提升移动端的性能。 不要把 .passive 和 .prevent 一起使用，因为 .prevent将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 按键修饰符12&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter="submit"&gt; 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 1&lt;input v-on:keyup.page-down="onPageDown"&gt; 在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。 系统修饰键.ctrl.alt.shift.meta.exact .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl="onClick"&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact="onClick"&gt;A&lt;/button&gt; v-model用于在表单类元素上双向绑定可以用于input框，以及textarea等注意:所显示的值只依赖于所绑定的数据，不再关心初始化时的插入的value v-model的实际v-model其实是一个语法糖,其实绑定了两层操作: v-bind绑定一个value值 v-on指令给当前元素绑定input事件 123456&lt;input v-model="total"&gt;//等价于&lt;input v-bind:value="total" v-on:input="total = $event.target.value"&gt; 要使用v-model,要做到: 接收一个value属性 在有新的value时触发input事件 文本12&lt;input v-model="message" placeholder="edit me"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 多行文本将v-model绑定到textarea上 1234&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style="white-space: pre-line;"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model="message" placeholder="add multiple lines"&gt;&lt;/textarea&gt; 单选按钮 单个单选按钮，直接用v-­bind绑定一个布尔值，用v-­model是不可以的 如果是组合使用，就需要v-­model来配合value使用，绑定选中的单选框的value值. 1234567891011121314151617&lt;div id="example-4"&gt; &lt;input type="radio" id="one" value="One" v-model="picked"&gt; &lt;label for="one"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type="radio" id="two" value="Two" v-model="picked"&gt; &lt;label for="two"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#example-4', data: &#123; picked: '' &#125;&#125;)&lt;/script&gt; 复选框单个复选框,绑定到布尔值: 12&lt;input type="checkbox" id="checkbox" v-model="checked"&gt;&lt;label for="checkbox"&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt; 多个复选框,绑定到同一个数组: 123456789101112131415161718&lt;div id='example-3'&gt; &lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt; &lt;label for="jack"&gt;Jack&lt;/label&gt; &lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt; &lt;label for="john"&gt;John&lt;/label&gt; &lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt; &lt;label for="mike"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: "#example-3", data: &#123; checkedNames: [] &#125;&#125;)&lt;/script&gt; 下拉框单选下拉:12345678910111213141516171819&lt;div id="example-5"&gt; &lt;select v-model="selected"&gt; // 将v-model绑定到select上,data中selected使用空字符串 &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: "#example-5", data: &#123; selected: '' &#125; &#125;)&lt;/script&gt; 多选下拉:123456789101112131415161718&lt;div id="example-6"&gt; &lt;select v-model="selected" multiple style="width: 50px"&gt; // 将v-model绑定到select上,data中selected使用空数组 &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;)&lt;/script&gt; 使用v-for配合1234567891011121314151617181920&lt;select v-model="selected"&gt; &lt;option v-for="option in options" v-bind:value="option.value"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;script&gt;new Vue(&#123; el: "...", data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;)&lt;/script&gt; 绑定值 单选按钮只需要用v-­bind给单个单选框绑定一个value值，此时,v­-model绑定的就是他的value值 复选框 下拉框在select标签上绑定value值对option并没有影响修饰符 修饰符 解释 lazy v-­model默认是在input输入时实时同步输入框的数据，而lazy修饰符，可以使其在失去焦点或者敲回车键之后再更新 number 将输入的字符串转化为number类型 trim trim自动过滤输入过程中首尾输入的空格]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express]]></title>
    <url>%2F2019%2F09%2F06%2FExpress%2F</url>
    <content type="text"><![CDATA[介绍Express是基于Node.js平台的web开发框架. 快速创建使用以下命令安装express 12//express脚手架npm install express-generator -g 使用-h选项显示命令选项 1234567891011121314151617express -h Usage: express [options][dir] //用法 Options: -h, --help output usage information --version output the version number -e, --ejs add ejs engine support --hbs add handlebars engine support --pug add pug engine support -H, --hogan add hogan.js engine support --no-view generate without view engine -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade) -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory 例如，以下语句在当前工作目录中创建名为 myapp 的 Express 应用程序： 12345678910111213141516171819$ express --view=pug myapp create : myapp create : myapp/package.json create : myapp/app.js create : myapp/public create : myapp/public/javascripts create : myapp/public/images create : myapp/routes create : myapp/routes/index.js create : myapp/routes/users.js create : myapp/public/stylesheets create : myapp/public/stylesheets/style.css create : myapp/views create : myapp/views/index.pug create : myapp/views/layout.pug create : myapp/views/error.pug create : myapp/bin create : myapp/bin/www 然后安装依赖项: 12cd myappnpm install 在Mac或Linux下采用以下命令运行此程序 1DEBUG=myapp:* npm start 在windows上 1set DEBUG=myapp:* &amp; npm start 然后在浏览器输入`http://localhost:3000 访问 基本路由中间件: 处理请求的函数.模板引擎: &lt;%= 写入的变量名 %&gt;,其中变量名可以在其他地方赋值,这样就可以批量改变变量了. 后台基本页面: 创建,列表,展示 静态文件提供图像,css和js之类的静态文件,请使用express.static内置中间件函数.使用以下代码在名为public的目录中提供图像,css和js之类的静态文件 1app.use(express.static('public')) 现在，可以访问位于 public 目录中的文件： 12345http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/app.jshttp://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html 要使用多个静态资源目录，请多次调用 express.static 中间件函数： 12app.use(express.static('public'));app.use(express.static('files')); Express 以您使用 express.static 中间件函数设置静态目录的顺序来查找文件。 要为 express.static 函数提供的文件创建虚拟路径前缀（路径并不实际存在于文件系统中），请为静态目录指定安装路径，如下所示： 1app.use('/static', express.static('public')); 向 express.static 函数提供的路径相对于您在其中启动 node 进程的目录。如果从另一个目录运行 Express 应用程序，那么对于提供资源的目录使用绝对路径会更安全： 1app.use('/static', express.static(__dirname + '/public')); 路由基本路由示例: 123456var express = require('express')var app = express() //在`myapp/bin/www`里创建了app的服务器app.get('/', function(req, res)&#123; red.send('hello world')//给浏览器发一个hello world&#125;) 路由方法GET和POST的示例 123456789//GETapp.get('/', function(req, res)&#123; res.send('GET request to the homepage')&#125;)//POSTapp.post('/', function(req, res)&#123; res.send('POST request to the homepage')&#125;) 有一种特殊路由方法：app.all()，它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数。 在以下示例中，无论您使用 GET、POST、PUT、DELETE 还是在 http 模块中支持的其他任何 HTTP 请求方法，都将为针对“/secret”的请求执行处理程序。 1234app.all('/secret', function (req, res, next) &#123; console.log('Accessing the secret section ...'); next(); // pass control to the next handler&#125;); 路由路径‘/‘表示根路径 123app.get('/', function(req, res)&#123; res.send('root')&#125;) 和’/about’路径匹配 123app.get('/about', function(req, res)&#123; res.send('random.txt')&#125;) 基于字符串模式的匹配12345678910111213141516171819202122232425//此路由路径将匹配 abcd、abbcd、abbbcd 等。app.get('/ab+cd', function(req, res) &#123; res.send('ab+cd');&#125;);//此路由路径将匹配 abcd、abbcd、abbbcd 等。app.get('/ab+cd', function(req, res) &#123; res.send('ab+cd');&#125;);//此路由路径将匹配 abcd、abxcd、abRABDOMcd、ab123cd 等。app.get('/ab*cd', function(req, res) &#123; res.send('ab*cd');&#125;);//此路由路径将匹配 /abe 和 /abcde。app.get('/ab(cd)?e', function(req, res) &#123; res.send('ab(cd)?e');&#125;); 字符 ?、+、* 和 () 是其正则表达式同应项的子集。基于字符串的路径按字面理解连字符 (-) 和点 (.)。 路由处理程序可以提供多个回调函数，以类似于中间件的行为方式来处理请求。唯一例外是这些回调函数可能调用 next(‘route’) 来绕过剩余的路由回调。可以使用此机制对路由施加先决条件，在没有理由继续执行当前路由的情况下，可将控制权传递给后续路由。 路由处理程序的形式可以是一个函数、一组函数或者两者的结合，如以下示例中所示。 单个回调函数可以处理一个路由。例如： 123app.get('/example/a', function (req, res) &#123; res.send('Hello from A!');&#125;); 多个回调函数可以处理一个路由（确保您指定 next 对象）。例如： 123456app.get('/example/b', function (req, res, next) &#123; console.log('the response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from B!');&#125;); 一组回调函数可以处理一个路由。例如： 123456789101112131415var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/example/c', [cb0, cb1, cb2]); 独立函数与一组函数的组合可以处理一个路由。例如： 12345678910111213141516var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;app.get('/example/d', [cb0, cb1], function (req, res, next) &#123; console.log('the response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from D!');&#125;); 响应方法响应对象 (res) 的方法可以向客户端发送响应，并终止请求/响应循环。如果没有从路由处理程序调用其中任何方法，客户端请求将保持挂起状态。 方法 描述 res.download() 提示将要下载文件。 res.end() 结束响应进程。 res.json() 发送 JSON 响应。 res.jsonp() 在 JSONP 的支持下发送 JSON 响应。 res.redirect() 重定向请求。 res.render() 呈现视图模板。 res.send() 发送各种类型的响应。 res.sendFile 以八位元流形式发送文件。 res.sendStatus() 设置响应状态码并以响应主体形式发送其字符串表示。 app.route()可以使用app.route()为路由路径创建可连接的路由处理程序因为在单一位置指定路径,可以减少冗杂和输入错误. 12345678910app.route('/book') .get(function(req, res)&#123; res.send('get a book') &#125;) .post(function(req, res)&#123; res.send('add a book') &#125;) .put(function(req, res)&#123; res.send('update a book') &#125;) express.Router使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。 以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。 在应用程序目录中创建名为 birds.js 的路由器文件，其中包含以下内容： 12345678910111213141516171819var express = require('express');var router = express.Router();// middleware that is specific to this router//use是不管get还是post都可以匹配router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// define the home page routerouter.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// define the about routerouter.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 接着，在应用程序中装入路由器模块： 123var birds = require('./birds');...app.use('/birds', birds); 此应用程序现在可处理针对 /birds 和 /birds/about 的请求，调用特定于此路由的 timeLog 中间件函数。]]></content>
      <categories>
        <category>后端</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2019%2F09%2F05%2FES6%2F</url>
    <content type="text"><![CDATA[ES6常见语法let和constlet定义局部变量var定义全局变量.用var定义的全部变量，有时候会污染整个js的作用域。const定义常量在全局作用域下使用let和const声明变量，变量并不会挂载到window var可声明前置(变量提升)变量会提升，函数也会提升，并且函数优先于变量提升，函数提升会把整个函数提到作用域顶部，变量提升只会把声明提上去. 123a = 3var avar a = 4 let不可声明前置 暂时性死区：不能在变量声明之前使用变量 12a = 3 //报错let a let不可重复声明 123let a = 3let a = 4 //报错var a = 5 //报错 存在块级作用域 1234for(let i=0; i&lt;3; i++)&#123; console.log(i) //块级作用域只在大括号内,出了大括号,i并没有声明,会报错&#125;console.log(i) //报错 暂时性死区: 在let声明变量之前都是该变量的死区,在死区内该变量不可使用.不能被声明也不能被获取. const声明的常量不可改变 123456const a = 1a = 2//报错const obj = &#123;a: 1&#125;obj.a = 2 //正常obj = &#123;a: 2&#125; //报错 const 对象等于引用类型,obj存的是{a: 1}的地址,里面的东西改变并不影响地址.而obj = {a: 2}是赋给一个新的地址,发生了改变,会报错. 适用于let同样适用于const let和const作用基本一致，const声明的变量不能再次赋值ES6可以大量使用let,如果认定模块不改变,可以使用const 解构赋值关于数组的解构赋值123456789let [a,b,c] = [1,2,3]console.log(a, b, c) let [a, [b], c] = [2, [3], 4]a //2b //3c //4let [a] = 1 //报错,因为[a]是一个数组,把值赋值给数组就报错了 默认值 123456789101112131415let [a, b = 2] = [3]a // 3b // 2,因为b没有对应值,所以是undefined,使用默认值let [a, b = 2] = [3, 4]a //3b //4数组对应对值有没有？如果没有（数组对没有指undefined）就使用默认值，如果有就使用对应值let [a=2, b=3] = [undefined, null]a //2b //nulllet [a=1, b=a] = [2]a //2b //2,因为b没有对应值,所以是undefined,使用默认值,此时a的默认值为2 对象的解构赋值 前置知识 1234567891011121314let [name, age] = ['hunger', 3]let p1 = &#123;name, age&#125;//等同于let p2 = &#123;name: name, age: age&#125;解构范例let &#123;name, age&#125; = &#123;name: 'jirengu', age: 4&#125;name //‘jirengu’age //4以上代码等同于let namelet age(&#123;name: name, age: age&#125; = &#123;name: 'jirengu', age: 4&#125;) 默认值 123let &#123;x, y=5&#125; = &#123;x: 1&#125;x //1y //5 函数解构 1234567891011function add([x=1, y=2])&#123; return x+y&#125;add() //Erroradd([2]) //4add([3,4]) //7function sum(&#123;x, y&#125;=&#123;x:0, y:0&#125;, &#123;a=1, b=1&#125;)&#123; return [x+a, y+b]&#125;sum(&#123;x:1, y:2&#125;, &#123;a:2&#125;) //[3, 3] 作用 1234567let [x, y] = [1, 2];[x, y] = [y, x]x //2y // 1function ajax(&#123;url, type=‘GET’&#125;)&#123;&#125;ajax(&#123;url: ‘http://localhost:3000/getData’&#125;) 字符串,数组,对象字符串 多行字符串 12345let str =`Hi,This is jirengu.com.You can study frontend here.` 字符串模板 1234567let website = 'jirengucom'let who = 'You'let str = `HiThis is $&#123;website&#125;.$&#123;who&#125; can study frontend here`//$&#123;&#125;,可以替换变量 12345var data= [1,2,3,4]var liArr = data.map(v=&gt;`&lt;li&gt;$&#123;v&#125;&lt;/li&gt;`).join('')var html = `&lt;ul&gt;$&#123;liArr&#125;&lt;/ul&gt;`console.log(html)//"&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;" 数组 扩展运算符... 主要作用是将数组或对象进行展开. 对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中 1234567var a = [1, 2]console.log(...a) // 1, 2,这三个点相当于脱壳,把数组的壳拿掉var b = [...a, 3]b // [1, 2, 3]var c = b.concat([4, 5]) //b拼接[4,5]变成[1,2,3,4,5]var d = [...b, 4, 5] //直接把脱壳后的1,2,3放入数组中 函数参数的扩展 12345678function sort(...arr)&#123; console.log(arr.sort())&#125;sort(3, 1, 5) //[1, 3, 5]function max(arr)&#123; return Math.max(...arr)&#125;max([3, 4, 1]) // 4 类数组对象转数组 12345let ps = document.querySelectorAll('p');Array.from(ps).forEach(p=&gt; &#123; console.log(p.innerText);&#125;);[...ps].forEach(p=&gt;&#123;console.log(p.innerText)&#125;); 函数 默认值 12345function sayHi(name='jirengu') &#123; console.log(`hi, $&#123;name&#125;`)&#125;sayHi()sayHi('ruoyu') 1234function fetch(url, &#123; body='', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com')//如果没有定义那么就是undefined,使用默认值,如果传入了参数,那就使用传入值 以下两种写法的区别? 12345678910111213141516171819202122232425262728//ex1function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;//ex2 function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];把&#123;&#125;赋给(x = 0,y = 0)m2(&#123;&#125;) // [undefined, undefined];把&#123;&#125;赋给&#123;x,y&#125;,也就是把undefined, undefined赋给&#123;x,y&#125;m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] ex1：调用函数需要你传递一个对象，如果你没传对象就用默认值对象{}，默认值对象里面都是 undefined， 所以属性使用初始值 ex2：参数需要是一个对象，如果没传对象，就用默认值对象{ x: 0, y: 0 }如果传了对象，就使用你传递的对象 箭头函数 箭头后面的内容，就相当于return的内容。 12345678910111213var f = v =&gt; v+1//等价于var f = function(v)&#123;return v+1&#125;var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;//适用于立刻返回,即把代码写成一行的情况// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 1234//数组的平方var arr = [1, 2, 3]var arr2 = arr.map(v=&gt;v*v)arr2 //[1, 4, 9] 箭头函数里面的 this 1.箭头函数会捕获其所在上下文的this值作为自己的this值,自己本身并没有this值.2.箭头函数的this永远指向其上下文的this,任何方法都改变不了其指向,如call,bind,apply. 1234567891011121314// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// 等同于如下ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 对象123var name = 'jirengu'var age = 3var people = &#123;name, age&#125; //&#123;name:'jirengu', age:3&#125; 123456789let app = &#123;selector: '#app',//函数简写init() &#123;&#125;,bind() &#123;&#125;&#125;app.init() 类和继承 构造函数 12345678910111213141516171819202122class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHello() &#123; console.log( `hello, $&#123;this.name&#125;, i am $&#123;this.age&#125; years old`); &#125;&#125;等价于function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.sayHello = function () &#123; console.log( `hello, $&#123;this.name&#125;, i am $&#123;this.age&#125; years old`);&#125;;var p = new Person('hunger', 2); 静态方法静态方法调用直接在类上进行，不能在类的实例上调用。 下面的例子说明了这几点:静态方法如何在类上实现。具有静态成员的类，可以被子类化 。什么情况下静态方法可以调用，什么情况下不能调用。 1234567891011121314151617181920class Tripple &#123; static tripple(n = 1) &#123; return n * 3; &#125;&#125;class BiggerTripple extends Tripple &#123; static tripple(n) &#123; return super.tripple(n) * super.tripple(n); &#125;&#125;console.log(Tripple.tripple());// 3console.log(Tripple.tripple(6));// 18let tp = new Tripple();console.log(BiggerTripple.tripple(3));// 81（不会受父类实例化的影响）//super继承父类的方法super.tripple(n) = 3n,BiggerTripple.tripple(n) = (3n)^2.当n=3,输出81console.log(tp.tripple());// 'tp.tripple 不是一个函数'.说明只能在类上实现. 继承 js中并不存在类，class只是语法糖，本质是函数class继承的核心在于使用extends表明继承自哪个父类，并在子类构造函数中必须调用super 123456789101112131415161718192021class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHello() &#123; //写的函数会直接放到原型上 console.log( `hello, $&#123;this.name&#125;, i am $&#123;this.age&#125; years old`); &#125;&#125;class Student extends Person &#123; constructor(name, age, score) &#123; super(name, age); this.score = score; &#125; sayScore() &#123; console.log( `hello, $&#123;this.name&#125;, i am $&#123;this.age&#125; years old, i get $&#123;this.score&#125;`); &#125;&#125; 模块化为什么使用模块化? 解决命名冲突 提供复用性 提高代码可维护性 写法1 1234567// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;//useage.jsimport &#123;firstName, lastName, year&#125; from './profile';console.log(firstName) 写法2 12345678var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;;//useage.jsimport &#123;firstName, lastName, year&#125; from './profile';console.log(firstName) 写法3 123456//helper.jsexport function getName()&#123;&#125;export function getYear()&#123;&#125;//main.jsimport &#123;getName, getYear&#125; from './helper';getName() 写法4 1234567//helper.jsfunction getName()&#123;&#125;function getYear()&#123;&#125;export &#123;getName, getYear&#125;//main.jsimport &#123;getName, getYear&#125; from './helper';getName() 写法5 1234567// export-default.jsexport default function () &#123; console.log('foo');&#125;// import-default.jsimport getName from './export-default'getName()]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2F2019%2F09%2F01%2FNode-js%2F</url>
    <content type="text"><![CDATA[node.js基础简易版node-server12345678910111213//index.js文件中引入http模块var http = require("http") //引入http模块var server = http.createServer(function(request,response)&#123; response.setHeader("Content-Type", "text/plain; chartset=gbk") //内容渲染形式:字符串.解码方式gbk //设置响应头 response.writeHead(200,"ok") //设置状态码 response.write("hello") response.end() //结束&#125;)//创建服务器server.listen(9000) //启动服务器，监听9000端口console.log("open http://localhost:9000") 在终端中输入node index.js就启动服务器. 简单版服务器1234567891011121314151617var http = require('http')//http模块var fs = require('fs')//fs模块读写文件//创建服务器var server = http.createServer(function(req,res)&#123; console.log(__dirname + '/static' + req.url) //fs同步读取,路径由文件绝对路径+static+请求url拼接.使用二进制格式 var fileContent = fs.readFileSync(__dirname + '/static' + req.url, 'binary') res.write(fileContent, 'binary') res.end()&#125;)//监听8080端口server.listen(8080)console.log('visit localhost:8080') 进阶静态服务器. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var http = require("http") //引入http模块var path = require("path") //自动处理路径问题var fs = require("fs") //读写文件var url = require("url") //解析url//function staticRoot(staticPath, req, res)&#123; var pathObj = url.parse(req.url, true) //url.parse是node.js方法，将一个URL字符串转换成对象并返回 console.log(pathObj) if(pathObj.pathname === "/")&#123; pathObj.pathname += "index.html" &#125; //不加后缀可以默认加后缀//请求文件的具体路径var filePath = path.join(staticPath, pathObj.pathname)//拼接文件地址//同步读取文件// var fileContent = fs.readFlieSync(filePath,'binary')// res.write(fileContent, 'binary')// res.end()//异步读取文件fs.readFile(filePath, "binary", function(err, fileContent)&#123; //'binary'表示二进制格式 if(err)&#123; res.writeHead(404, "not found") res.end("&lt;h1&gt;404 Not Found&lt;/h1&gt;")&#125;else&#123; res.writeHead(200, "ok") res.write(fileContent, "binary") res.end() &#125;&#125;)console.log("path.join(_dirname, "static")var server = http.createServer(function(res,req)&#123; staticRoot(path.join(__dirname, "static"), req, res) //__dirname代表当前文件路径,join拼接上static路径&#125;)server.listen(8080)console.log("visit http://localhost:8080") mock数据1234567891011121314151617181920//服务器配置var http = require('http')var fs = require('fs')var url = require('url')http.createServer(function(req,res)&#123; //解析请求url var pathObj = url.parse(req.url, true) switch(pathObj.pathname)&#123; case '/getWeather': res.end(JSON.stringify(&#123; a: 1, b: 2&#125;)) break; case 'user/123': res.end(fs.readFileSync(__dirname + '/static/user.tpl' )) break; default: res.end(fs.readFileSync(__dirname + 'static' + req.url)) &#125;&#125;).listen(8080) 问题 __dirname是什么 __dirname总是指向被执行文件的绝对路径.如/d1/d2/my.js中的__dirname,他的值就是/d1/d2. 常用APIfs.readFile(path[,options],callback)/fs.writeFile(file,data[,options],callback)12345678910111213141516171819let fs = require('fs') //引入fs模块fs.readFile('flie.txt', 'utf-8', function(err, str)&#123; if(err)&#123; console.log('error') &#125;else&#123; console.log(str) //要去掉字符串里的数字空格 const strAfter = str.replace(/\d/gm, '') console.log(strAfter) //去掉数字后把strAfter写出来 fs.writeFile('fileAfter.txt', strAfter, (err)=&gt;&#123; if(err) throw err; //如果报错直接使用throw抛出 console.log('the file has been save!'); &#125;) &#125;&#125;) 模块将上面的去数字的方法封装成函数,单独写一个文件,并调用创建stringApi.js 123456function replaceDigit(str)&#123; return str.replace(/\d/gm, '')&#125;module.exports.replaceDigit = replaceDigit //把这个封装好的函数暴露出来可以使用了 123456//封装好后在上面的代码里就可以使用了//先引入let strApi = require('./stringApi') //如果在同级目录下,直接使用相对路径引入//然后将上面的代码const strAfter = str.replace(/\d/gm, '')替换成const strAfter = strApi.replaceDigit(str) NPM如果需要一些功能,node.js自带的没有,可以去npm官网上找一些其他人发布的npm包.找到之后,首先进行安装 package.json记录保存模块依赖,当没有依赖时,比如下载其他人的项目里没有依赖,可以使用npm.init初始化,将package.json中记录的模块依赖全都下载下来,方便. npm切换源工具1234npm install -g nrm //安装nrm工具nrm ls //查看nrm支持的源的列表nrm use taobao //使用淘宝的源nrm use npm //切换回npm源 NPM Script在package.json文件里有一个scripts对象,写入里面的命令可以比较方便快捷的执行.直接npm xxx就可以执行.而且会自动搜索路径,不用写相对路径. 123456789101112&#123; "scripts": &#123; "css:autoprefixer": "postcss -u autoprefixer -r dist/css/*", "css:compress": "csso in.css --output out.css", "js:lint": "eslint src/js", "js:uglify": "mkdir -p dist/js &amp;&amp; uglifyjs src/js/*.js -m -o dist/js/app.js", "image:imagemin": "app=imagemin-cli npm run check; imagemin src/images dist/images -p", "server": "browser-sync start --server --files 'dist/css/*.css, dist/js/*.js'", "watch": "onchange 'src/js/*.js' -- npm run css:compress", "start": "npm run server" &#125;&#125; 12npm run css:autoprefixernpm start]]></content>
      <categories>
        <category>后端</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程化]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[模块化初探模块化系统的风格模块化的价值 最主要的目的： 解决命名冲突 依赖管理其他价值: 提高代码可读性 代码解耦,提高复用性 &lt;script&gt;标签风格123&lt;script src="module1.js"&gt;&lt;/script&gt;&lt;script src="module2.js"&gt;&lt;/script&gt;&lt;script src="module3.js"&gt;&lt;/script&gt; 各个模块把接口暴露给全局对象,比如window.各个模块通过全局对象进行相互访问出现的问题: 全局对象的冲突 加载的顺序很重要 开发者需要解决模块的依赖问题 在大项目中模块非常多难以维护CommonJs: 同步的requireCommonJs 是 Node 独有的规范，浏览器中使用就需要用到 Browserify 解析了。 使用同步的require方法来加载依赖和返回暴露的接口.一个模块可以通过exports对象添加属性,或者设置module.exports的值来描述暴露对象. 1234require('moudle')require('../file.js')exports.doStuff = function()&#123;&#125;moudle.exports = someValue 优点: 服务端代码可以被复用. npm有大量的代码 使用方便 缺点: 阻塞调用无法在网络环境应用,网络请求是异步的 不能并行require多个模块 CommonJS规范 在一个模块中,存在一个自由的变量”require”,它是一个函数。这个”require”函数接收一个模块标识符。“require”返回外部模块所输出的API。 在一个模块中,会存在一个名为”exports”的自由变量,它是一个对象,模块可以在执行的时候把自身的API加入到其中。 模块必须使用”exports”对象来做为输出的唯一表示。 AMD规范: 异步的requireAMD主要解决两个问题: 多个js文件可能有依赖关系,被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染,加载文件越多,页面失去响应时间越长 requireJS语法RequireJS 遵循 AMD 规范,用于解决命名冲突和文件依赖的问题.requireJS定义了一个函数 define,它是全局变量,用来定义模块define(id?, dependencies?, factory); id：可选参数,用来定义模块的标识,如果没有提供该参数,脚本文件名(去掉拓展名) dependencies：是一个当前模块依赖的模块名称数组 factory：工厂方法,模块初始化要执行的函数或对象。如果为函数,它应该只被执行一次。如果是对象,此对象应该为模块的输出值 在页面上使用require函数加载模块require([dependencies], function(){});require()函数接受两个参数: 第一个参数是一个数组,表示所依赖的模块 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用。加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块. require()函数在加载依赖的函数的时候是异步加载的,这样浏览器不会失去响应,它指定的回调函数,只有前面的模块都加载成功后,才会运行,解决了依赖性的问题。 1234require(['moudle', '../file'], function(moudle, file)&#123; /* ... */&#125;)define('moudle',['dep1', 'dep2'], function(d1, d2)&#123; return someExportedValue&#125;) import和export的区别以前:CommonJS（服务器） 和 AMD（浏览器）规范各自实现了运行时加载模块的方法（没办法在编译时做“静态优化”）。 1234567// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 现在：ES6：一个模块就是一个文件，export/import命令可以出现在模块的任何位置，只要处于模块顶层就可以。通过import和export实现静态加载（编译时加载），服务端和浏览器通用。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; export：如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 12345// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 还可以输出函数和class类： 123export function multiply(x, y) &#123; return x * y;&#125;; 还可以改个名字输出： 1234567function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。CommonJS 模块输出的是值的缓存，不存在动态更新。 import：加载模块 12345// main.jsimport &#123;firstName, lastName, year&#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 可以改名字： 1import &#123; lastName as surname &#125; from './profile'; 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。import命令是编译阶段执行的，在代码运行之前。由于import是静态执行，所以不能使用表达式和变量。 会执行加载的模块： 1import 'lodash';//仅仅执行lodash模块，但是不输入任何值。多次引入同一个模块仅执行一次。 整体加载所有的模块： 1import * as circle from './circle'; export default：为模块指定默认输出，引用的时候不用知道输出的到底是什么，可以指定任意名字。需要注意的是，这时import命令后面，不使用大括号。一个模块只能有一个默认输出。 1234567// export-default.jsexport default function () &#123; console.log('foo');&#125;// import-default.jsimport customName from './export-default';customName(); // 'foo' 同时引用默认模块和其他模块： 12345678910//输出export default function (obj) &#123; // ···&#125;export function each(obj, iterator, context) &#123; // ···&#125;export &#123; each as forEach &#125;;//对应的加载import _, &#123; each, each as forEach &#125; from 'lodash'; ES6模块加载CommonJS模块： 1234567891011//commonjs模块：// a.jsmodule.exports = &#123; foo: 'hello', bar: 'world'&#125;;// 等同于export default &#123; foo: 'hello', bar: 'world'&#125;; 1234567891011121314//es6加载上面的模块：// 写法一import baz from './a';// baz = &#123;foo: 'hello', bar: 'world'&#125;;// 写法二import &#123;default as baz&#125; from './a';// baz = &#123;foo: 'hello', bar: 'world'&#125;;// 写法三import * as baz from './a';// baz = &#123;// get default() &#123;return module.exports;&#125;,// get foo() &#123;return this.default.foo&#125;.bind(baz),// get bar() &#123;return this.default.bar&#125;.bind(baz)// &#125; CommonJS加载ES6模块：通过import()函数 1234// es6.mjslet foo = &#123; bar: 'my-default' &#125;;export default foo;foo = null; 123456789// commonjs.jsconst es_namespace = await import('./es');// es_namespace = &#123;// get default() &#123;// ...// &#125;// &#125;console.log(es_namespace.default);// &#123; bar:'my-default' &#125; import和require的区别#module.exports和export default的区别 webpackwebpack是收把项目当作一个整体,通过一个给定的的主文件,webpack将从这个文件开始找到你的项目的所有依赖文件,使用loaders处理它们,最后打包成一个或多个浏览器可识别的js文件. 初始化 新建一个文件夹,cd到它的目录下.执行npm init -y命令 执行npm install --save--dev webpack命令安装(也可以全局安装) 12345678910111213141516171819/配置touch webpack.config.jsvi webpack.config.js//在里面写以下内容/*const path = require('path');module.exports = &#123; entry: './src/index.js', //入口 output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;;*///创建文件touch src/index.js//运行webpacknpx webpack //这时会多出dist目录,里面有bundle.js文件 2.使用1.在index.js里写123456console.log(1)//再运行webpack:npx webpack//再看bundle.js,这时会多出来一行console.log(1) 2.安装babel-loader自动转换es612345678910111213141516171819202122232425262728293031323334353637383940414243//安装v6,命令行npm install babel-loader babel-core babel-preset-env webpack//将这个复制到webpack的配置文件webpack.config.js里,加在output的下面module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ]&#125;//加在output的下面,复制完后成这样const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ]&#125;&#125;; 运行npx webpack若出现can’t find ‘…’或can’t resolve ‘…’的报错,则安装省略号里的东西npm i ‘省略号’注意：若是Couldn’t find preset “env”,不要安装env,而是npm i babel-preset-env 3.使用babel123//当你在写index.js里写let a=1//它就会帮你自动转换成es5了 NPM 脚本(NPM Scripts)在package.json文件中写入npm脚本,就可以使用npm run build替代npx命令. 123456789101112131415161718 &#123; "name": "webpack-demo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",+ "build": "webpack" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.0.1", "webpack-cli": "^2.0.9", "lodash": "^4.17.5" &#125; &#125; 管理资源(css,图片之类)加载CSS 需要先安装style-laoder和css-loader npm install --save-dev style-loader css-loader 然后在webpack.config.js文件里添加规则 1234567891011121314151617181920 const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,+ module: &#123;+ rules: [+ &#123;+ test: /\.css$/,+ use: [+ 'style-loader',+ 'css-loader'+ ]+ &#125;+ ]+ &#125; &#125;; webpack 根据正则表达式,来确定应该查找哪些文件,并将其提供给指定的 loader。在这种情况下,以 .css 结尾的全部文件,都将被提供给 style-loader 和 css-loader。 这使你可以在依赖于此样式的文件中import &#39;./style.css&#39;。现在,当该模块运行时,含有 CSS 字符串的&lt;style&gt;标签,将被插入到 html 文件的 &lt;head&gt;中。 加载图片 安装npm install --save-dev file-loader插件 配置webpack.config.js文件 现在,当你 import MyImage from &#39;./my-image.png&#39;,该图像将被处理并添加到 output 目录,并且 MyImage 变量将包含该图像在处理后的最终 url。当使用 css-loader 时,如上所示,你的 CSS 中的url(&#39;./my-image.png&#39;) 会使用类似的过程去处理。loader 会识别这是一个本地文件,并将 &#39;./my-image.png&#39;路径,替换为输出目录中图像的最终路径。html-loader 以相同的方式处理 &lt;img src=&quot;./my-image.png&quot; /&gt;。 在src文件夹下创建icon.png. 修改src/index.js文件 123456789101112131415161718192021 import _ from 'lodash'; import './style.css';+ import Icon from './icon.png'; function component() &#123; var element = document.createElement('div'); // Lodash,现在由此脚本导入 element.innerHTML = _.join(['Hello', 'webpack'], ' '); element.classList.add('hello');+ // 将图像添加到我们现有的 div。+ var myIcon = new Image();+ myIcon.src = Icon;++ element.appendChild(myIcon); return element; &#125; document.body.appendChild(component()); src/style.css中引入图片 1234 .hello &#123; color: red;+ background: url('./icon.png'); &#125; 重新构建npm run build Glup简介它是一款nodejs应用。它是打造前端工作流的利器,打包、压缩、合并、git、远程操作…,简单易用无快不破高质量的插件 安装 安装gulpnpm install -g gulp如果报Error: EACCES, open &#39;/Users/xxx/xxx.lock错误。先执行：sudo chown -R $(whoami) $HOME/.npm 如果使用npm安装插件太慢(被墙),可执行 npm install -g cnpm --registry=https://registry.npm.taobao.org先安装cnpm, 之后再安装插件时用cnpm安装cnpm install gulp 安装各种插件123456789101112131415npm install --save gulp //本地使用gulpnpm install --save gulp-imagemin //压缩图片npm install --save gulp-minify-css //压缩cssnpm install --save gulp-ruby-sass //sassnpm install --save gulp-jshint //js代码检测npm install --save gulp-uglify //js压缩npm install --save gulp-concat //文件合并npm install --save gulp-rename //文件重命名npm install --save png-sprite //png合并npm install --save gulp-htmlmin //压缩htmlnpm install --save gulp-clean //清空文件夹npm install --save browser-sync //文件修改浏览器自动刷新npm install --save gulp-shell //执行shell命令npm install --save gulp-ssh //操作远程机器npm install --save run-sequence //task顺序执行 或者根据package.json 自动安装。把package.json拷贝到自己的工程目录下,进入目录,执行:npm install 语法gulp APIgulp.src(globs[,options])1234gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) //压缩文件 .pipe(gulp.dest('build/minified_templates')); 作用: 输出符合所提供的匹配模式或数组的文件.globs 类型: string或Array所要读取的glob或者包含globs的数组.可以是地址options 类型:object额外的选项参数 gulp.dest(path[,options])12345gulp.src('./client/templates/*.jade') .pipe(jade()) .pipe(gulp.dest('./build/templates')) .pipe(minify()) .pipe(gulp.dest('./build/minified_templates')); 文件被pipe进来,dest生成或者写入一个文件.path文件将被写入的路径(输出目录)。 gulp.task(name[,deps],fn)定义一个实现任务 123gulp.task('somename', function()&#123; //任务&#125;) name任务名字deps 类型: array一个包含任务列表的数组,这些任务会在你当前运行任务之前完成. 123gulp.task('mytask', ['array', 'of', 'task', 'names'], function()&#123; //任务&#125;) fn该函数定义任务所要执行的一些操作。通常来说,它会是这种形式：gulp.src().pipe(someplugin())。 gulp.watch(glob[, opts], tasks)监视文件,并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射(emit) change 事件。 1234var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); gulp使用实例范例1. 压缩合并demo1目录结构如下。把demo1中的 index.html压缩,把src里面的less编译、合并、压缩、重命名、存储到dist。src里面的图片压缩、合并存储到dist。src里面的js做代码检查,压缩,合并,存储到dist。 123456789101112131415161718192021+ demo1 + dist + css - merge.min.css + js - merge.min.js + imgs - 1.png - 2.png - index.html + src + css - a.css - b.css + js - a.js - b.js + imgs - 1.png - 2.png - index.html 创建gulpfile.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var gulp = require('gulp');// 引入组件var minifycss = require('gulp-minify-css'), // CSS压缩 uglify = require('gulp-uglify'), // js压缩 concat = require('gulp-concat'), // 合并文件 rename = require('gulp-rename'), // 重命名 clean = require('gulp-clean'), //清空文件夹 minhtml = require('gulp-htmlmin'), //html压缩 jshint = require('gulp-jshint'), //js代码规范性检查 imagemin = require('gulp-imagemin'); //图片压缩gulp.task('html', function() &#123; return gulp.src('src/*.html') .pipe(minhtml(&#123;collapseWhitespace: true&#125;)) //html压缩 .pipe(gulp.dest('dist'));&#125;);gulp.task('css', function(argument) &#123; gulp.src('src/css/*.css') .pipe(concat('merge.css')) // CSS压缩 .pipe(rename(&#123; suffix: '.min' // 重命名 &#125;)) .pipe(minifycss()) // CSS压缩 .pipe(gulp.dest('dist/css/'));&#125;);gulp.task('js', function(argument) &#123; gulp.src('src/js/*.js') .pipe(jshint()) //js代码规范性检查 .pipe(jshint.reporter('default')) .pipe(concat('merge.js')) // 合并文件 .pipe(rename(&#123; suffix: '.min' // 重命名 &#125;)) .pipe(uglify()) // js压缩 .pipe(gulp.dest('dist/js/'));&#125;);gulp.task('img', function(argument)&#123; gulp.src('src/imgs/*') .pipe(imagemin()) //图片压缩 .pipe(gulp.dest('dist/imgs'));&#125;);gulp.task('clear', function()&#123; gulp.src('dist/*',&#123;read: false&#125;) .pipe(clean()); //清空文件夹&#125;);gulp.task('build', ['html', 'css', 'js', 'img']); 最后命令行gulp build;可实现src目录下的html压缩,css、js合并压缩,图片压缩,最后放入 dist目录下 范例2. 监控变动自动同步1234567891011121314151617181920212223242526272829303132333435363738394041var gulp = require('gulp');// 引入组件var browserSync = require('browser-sync').create(); //用于浏览器自动刷新var scp = require('gulp-scp2'); //用于scp到远程机器var fs = require('fs'); gulp.task('reload', function()&#123; browserSync.reload();&#125;);gulp.task('server', function() &#123; browserSync.init(&#123; server: &#123; baseDir: "./src" &#125; &#125;); gulp.watch(['**/*.css', '**/*.js', '**/*.html'], ['reload', 'scp']);&#125;);gulp.task('scp', function() &#123; return gulp.src('src/**/*') .pipe(scp(&#123; host: '121.40.201.213', username: 'root', privateKey: fs.readFileSync('/Users/wingo/.ssh/id_rsa'), dest: '/var/www/fe.jirengu.com', watch: function(client) &#123; client.on('write', function(o) &#123; console.log('write %s', o.destination); &#125;); &#125; &#125;)) .on('error', function(err) &#123; console.log(err); &#125;);&#125;); 命令行执行: 12gulp scp; // 可把本地开发环境代码拷贝到服务器gulp server; //可在本地创建服务器,本地开发浏览器立刻刷新 范例3. 监控项目文件变动,自动压缩、合并、打包、添加版本号12345678910111213141516171819202122html&lt;/html&gt;&lt;head&gt;&lt;!-- build:css css/merge.css --&gt; &lt;link href="css/a.css" rel="stylesheet"&gt; &lt;link href="css/b.css" rel="stylesheet"&gt;&lt;!-- endbuild --&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;demo1-工程化手动版&lt;/p&gt;&lt;!-- build:js js/merge.js --&gt; &lt;script type="text/javascript" src="js/a.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/b.js"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt;&lt;/body&gt;&lt;/html&gt; 设置gulpfile.js文件 1234567891011121314151617181920212223242526272829303132333435var gulp = require('gulp'); var rev = require('gulp-rev'); //添加版本号var revReplace = require('gulp-rev-replace'); //版本号替换var useref = require('gulp-useref'); //解析html资源定位var filter = require('gulp-filter'); //过滤数据var uglify = require('gulp-uglify'); var csso = require('gulp-csso'); //css优化压缩var clean = require('gulp-clean');gulp.task("index", ['clear'], function() &#123; var jsFilter = filter("**/*.js", &#123;restore: true&#125;); var cssFilter = filter("**/*.css", &#123;restore: true&#125;); var userefAssets = useref.assets(); return gulp.src("src/index.html") .pipe(userefAssets) // Concatenate with gulp-useref .pipe(jsFilter) .pipe(uglify()) // Minify any javascript sources .pipe(jsFilter.restore) .pipe(cssFilter) .pipe(csso()) // Minify any CSS sources .pipe(cssFilter.restore) .pipe(rev()) // Rename the concatenated files .pipe(userefAssets.restore()) .pipe(useref()) .pipe(revReplace()) // Substitute in new filenames .pipe(gulp.dest('dist'));&#125;);gulp.task('clear', function()&#123; gulp.src('dist/*',&#123;read: false&#125;) .pipe(clean());&#125;); 范例4. 本地shell命令, 远程shell, 任务顺序执行…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var gulp = require('gulp');var shell = require('gulp-shell');var runSequence = require('run-sequence');var fs = require('fs');var GulpSSH = require('gulp-ssh');//shell操作, gulp.task('git', shell.task(['git add .', 'git commit -am "dd"', 'git push -u origin dev']));gulp.task('clear', shell.task(['find . -name ".DS_Store" -depth -exec rm &#123;&#125; \\;']));//操作远程主机var gulpSSH = new GulpSSH(&#123; ignoreErrors: false, sshConfig: &#123; host: '121.40.201.213', port: 22, username: 'root', privateKey: fs.readFileSync('/Users/wingo/.ssh/id_rsa') &#125;&#125;);gulp.task('remote', function() &#123; return gulpSSH .shell(['cd /var/www/fe.jirengu.com', 'git pull origin dev', 'rm -rf _runtime']);&#125;);gulp.task('build', function(callback) &#123; runSequence( 'git', 'clear', 'remote', callback );&#125;);gulp.task('watch', function() &#123; gulp.watch(['**/*.css', '**/*.js', '**/*.html', '**/*.php'], ['build']);&#125;); webpack相关问题 webpack与grunt、gulp的不同？ 三者都是前端构建工具,grunt和gulp在早期比较流行,现在webpack相对来说比较主流,不过一些轻量化的任务还是会用gulp来处理,比如单独打包CSS文件等。 grunt和gulp是基于任务和流(Task、Stream)的。类似jQuery,找到一个(或一类)文件,对其做一系列链式操作,更新流上的数据, 整条链式操作构成了一个任务,多个任务就构成了整个web的构建流程。 webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件,然后用不同的Loader来处理不同的文件,用Plugin来扩展webpack功能。 所以总结一下： 从构建思路来说gulp和grunt需要开发者将整个前端构建过程拆分成多个Task,并合理控制所有Task的调用关系webpack需要开发者找到入口,并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工 对于知识背景来说gulp更像后端开发者的思路,需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路 与webpack类似的工具还有哪些？谈谈你为什么最终选择(或放弃)使用webpack？ 同样是基于入口的打包工具还有以下几个主流的：webpackrollupparcel从应用场景上来看： webpack适用于大型复杂的前端站点构建rollup适用于基础库的打包,如vue、reactparcel适用于简单的实验性项目,他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限,所以一旦打包出错难以调试,所以不建议复杂的项目使用parcel 有哪些常见的Loader？他们是解决什么问题的？ file-loader：把文件输出到一个文件夹中,在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似,但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件,以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS,支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中,通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码 有哪些常见的Plugin？他们是解决什么问题的？ define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 Loader和Plugin的不同？ 不同的作用Loader直译为”加载器”。Webpack将一切文件视为模块,但是webpack原生是只能解析js文件,如果想将其他文件也打包的话,就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。Plugin直译为”插件”。Plugin可以扩展webpack的功能,让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件,Plugin 可以监听这些事件,在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法Loader在module.rules中配置,也就是它作为模块的解析规则而存在。 类型为数组,每一项都是一个Object,里面描述了对于什么类型的文件(test),使用什么加载(loader)和使用的参数(options)Plugin在plugins中单独配置。 类型为数组,每一项是一个plugin的实例,参数都通过构造函数传入。 webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全 Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数;开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译;确定入口：根据配置中的 entry 找出所有的入口文件;编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理;完成模块编译：在经过第4步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系;输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会;输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？ Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容,并且每个Loader通过链式操作,将源文件一步步翻译成想要的样子。 编写Loader时要遵循单一原则,每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容(source),可以通过返回值的方式将处理后的内容输出,也可以调用this.callback()方法,将内容返回给webpack。 还可以通过 this.async()生成一个callback函数,再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。 相对于Loader而言,Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件,Plugin 可以监听这些事件,在合适的时机通过 Webpack 提供的 API 改变输出结果。 webpack的热更新是如何做到的？说明其原理？ webpack的热更新又称热替换(Hot Module Replacement),缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理：首先要知道server端和client端都做了处理工作 第一步,在 webpack 的 watch 模式下,文件系统中某一个文件发生修改,webpack 监听到文件变化,根据配置文件对模块重新编译打包,并将打包后的代码通过简单的 JavaScript 对象保存在内存中。第二步是 webpack-dev-server 和 webpack 之间的接口交互,而在这一步,主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互,webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控,并且告诉 webpack,将代码打包到内存中。第三步是 webpack-dev-server 对文件变化的一个监控,这一步不同于第一步,并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候,Server 会监听这些配置文件夹中静态文件的变化,变化后会通知浏览器端对应用进行 live reload。注意,这儿是浏览器刷新,和 HMR 是两个概念。第四步也是 webpack-dev-server 代码的工作,该步骤主要是通过 sockjs(webpack-dev-server 的依赖)在浏览器端和服务端之间建立一个 websocket 长连接,将 webpack 编译打包的各个阶段的状态信息告知浏览器端,同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值,后面的步骤根据这一 hash 值来进行模块热替换。webpack-dev-server/client 端并不能够请求更新的代码,也不会执行热更模块操作,而把这些工作又交回给了 webpack,webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器,也就没有后面那些步骤了。HotModuleReplacement.runtime 是客户端 HMR 的中枢,它接收到上一步传递给他的新模块的 hash 值,它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求,服务端返回一个 json,该 json 包含了所有要更新的模块的 hash 值,获取到更新列表后,该模块再次通过 jsonp 请求,获取到最新的模块代码。这就是上图中 7、8、9 步骤。而第 10 步是决定 HMR 成功与否的关键步骤,在该步骤中,HotModulePlugin 将会对新旧模块进行对比,决定是否更新模块,在决定更新模块后,检查模块之间的依赖关系,更新模块的同时更新模块间的依赖引用。最后一步,当 HMR 失败后,回退到 live reload 操作,也就是进行浏览器刷新来获取最新打包代码。 如何利用webpack来优化前端性能？(提高性能和体验) 用webpack优化前端性能是指优化webpack的输出结果,让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件, 利用cssnano(css-loader?minimize)来压缩css利用CDN加速。在构建过程中,将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码(Tree Shaking)。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现提取公共代码。 如何提高webpack的构建速度？ 多入口情况下,使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译,再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码 怎么配置单页应用？怎么配置多页应用? 单页应用可以理解为webpack的标准模式,直接在entry中指定单页应用的入口即可,这里不再赘述 多页应用的话,可以使用webpack的 AutoWebPlugin来完成简单自动化的构建,但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码,可以将这些代码抽离出来,避免重复的加载。比如,每个页面都引用了同一套css样式表随着业务的不断扩展,页面可能会不断的追加,所以一定要让入口的配置足够灵活,避免每次添加新页面还需要修改构建配置 npm打包时需要注意哪些？如何利用webpack来更好的构建？ Npm是目前最大的 JavaScript 模块仓库,里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者,但是有些情况你也会去选择上传自己开发的模块。 关于NPM模块上传的方法可以去官网上进行学习,这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题： 要支持CommonJS模块化规范,所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的,很有可能并不支持ES6,所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的,请最好连同SourceMap一同上传。Npm包大小应该是尽量小(有些仓库会限制包大小)发布的模块不能将依赖的模块也一同打包,应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件,例如.css文件也需要包含在发布的模块里。基于以上需要注意的问题,我们可以对于webpack配置做以下扩展和优化： CommonJS模块化规范的解决方案：设置output.libraryTarget=&#39;commonjs2&#39;使输出的代码符合CommonJS2 模块化规范,以供给其它模块导入使用输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: &#39;source-map&#39;输出SourceMap以发布调试。Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数,最终导致每个输出的文件中都包含这段辅助函数的代码,造成了代码的冗余。解决方法是修改.babelrc文件,为其加入transform-runtime插件不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现,配置如下： 12345678910111213141516171819202122const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; module: &#123; rules: [ &#123; //增加对CSS文件的支持 test: /\.css/, //提取出 Chunk 中的CSS代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: ['css-loader'] &#125;), &#125;, ] &#125;, plugins: [ new ExtractTextPlugin( &#123; //输出的CSS文件名称 filename: 'index.css', &#125;), ], &#125;; 如何在vue项目中实现按需加载？ Vue UI组件库的按需加载: 为了快速开发前端项目,经常会引入现成的UI组件库如ElementUI、iView等,但是他们的体积和他们所提供的功能一样,是很庞大的。 而通常情况下,我们仅仅需要少量的几个组件就足够了,但是我们却将庞大的组件库打包到我们的源码中,造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案,如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后,在.babelrc配置中或babel-loader的参数中进行设置,即可实现组件按需加载了。 单页应用的按需加载现在很多前端项目都是通过单页应用的方式开发的,但是随着业务的不断扩展,会面临一个严峻的问题——首次加载的代码量会越来越多,影响用户的体验。 通过import(*)语句来控制加载时机,webpack内置了对于import(*)的解析,会将import(*)中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import(*)语句时,会去加载Chunk对应生成的文件。import()会返回一个Promise对象,所以为了让浏览器支持,需要事先注入Promise polyfill. Nginxnginx是一个反向代理服务器.客户端向服务端发送请求,可以配置一个nginx代理服务器. 反向代理代理服务器负责接收请求,转发给内部的服务器.从颞部服务器得到响应返回给客户端.反向代理服务器为服务端工作.对服务端是透明的,对客户端不透明. nginx的作用解决跨域请求过滤负载均衡配置gzip静态资源服务器 解决跨域在server中配置一个server-name,和客户端同域名在Location中拦截向客户端域名发送的请求,并且请求代理回服务器. 请求过滤在Location中过滤相应的状态码或者url,或者请求类型 负载均衡通过配置upstream指定后端服务器的地址列表在server中拦截请求,并将请求转发到upstream的后端服务器列表里. 策略默认采用轮训的策略,缺点是一台服务器压力过大时,会影响其他服务器. 最小连接数策略,优先分配给连接数最少的服务器least_connt最快响应时间策略,优先分配给响应时间最短的服务器fair 静态资源服务器在Location中配置,匹配比如说图片为结尾的请求,转发到本地路径.设置root指定路径.]]></content>
      <categories>
        <category>JS</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶]]></title>
    <url>%2F2019%2F08%2F27%2FJS%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[构造对象newnew 运算符接受一个函数 F 及其参数: new F(arguments…).这个一过程分为: 创建类的实例.这步是把一个空的对象的 proto 属性设置为 F.prototype. 初始化实例.函数 F 被传入参数并调用.关键字 this 被设定为该实例. 返回实例. 对于实例对象来说，都是通过 new 产生的，无论是function Foo()还是let a = { b : 1 } 。 123456789function person(name, age) &#123; this.name = name; this.age = age; this.sayName = function() &#123; console.log(this.name); &#125;;&#125;p1 = new person("tom", 12); instanceofinstanceof 是一个操作符,可以判断对象是否为某个类型的实例 123p1 instanceof person; //true,说明p1是由person创造的p1 instanceof Object; //true,1 instanceof Number; //false,instanceof判断的是对象 原型与原型链 当new一个函数的时候会创建一个对象,函数.prototype等于被创建对象.__proto__ 一切函数都是由 Function 这个函数创建的,所以Function.prototye === 被创建函数.__proto__ 一切函数的原型对象都是由Object这个函数创建的,所以Object.prototype === 一切函数.prototype.__proto__ __proto__把对象和原型连接起来，形成原型链 this在函数被直接调用时this绑定到全局对象.即 window 12345console.log(this); //指向windowfunction fn1() &#123; console.log(this); //指向window&#125;fn1(); //相当于window.fn1() 内部函数函数嵌套产生的内部函数的this不是他的父函数,仍然是全局,window 12345678function fn0() &#123; function fn() &#123; console.log(this); &#125; fn();&#125;fn0(); setTimeOut()和 setInterval()这两个函数执行的函数 this 也是全局 12345678910document.addEventListener( "click", function(e) &#123; console.log(this); setTimeout(function() &#123; console.log(this); &#125;, 200); &#125;, false); DOM 对象绑定事件在事件处理程序中 this 代表事件源 DOM 对象 123456789101112document.addEventListener( "click", function(e) &#123; console.log(this); //指向dom对象 var _document = this; setTimeout(function() &#123; console.log(this); //指向window console.log(_document); &#125;, 200); &#125;, false); Function.prototype.bind()bind 改变 this 的指向.返回一个新函数,并使函数内部的 this 为传入的第一个参数,并不执行 12var fn3 = obj1.fn.bind(obj1);fn3(); 使用 call 和 apply 设置 thiscall,apply 调用一个函数,传入函数执行上下文及其参数,并立即执行 12fn.call(context,param1,param2...)//接受参数列表fn.apply(context,paramArray)//接收参数数组 第一个参数都是希望设置的 this 对象举例 12345678//实现一个函数可以遍历传入的参数function sum() &#123; //arguments.forEach无法执行,因为arguments不是数组,使用call将forEach的this指向arguments,使之可以遍历 Array.prototype.forEach.call(arguments, function(value) &#123; console.log(value); &#125;);&#125;sum(3, 4, 1, 6); //函数就可以遍历了 12345678910function sum() &#123; var result = 0; //arguments.forEach无法执行,因为arguments不是数组,使用call将forEach的this指向arguments,使之可以遍历 Array.prototype.forEach.call(arguments, function(value) &#123; console.log(value); return (result += value); &#125;); console.log(result);&#125;sum(3, 4, 1, 6); //函数就可以将传入值相加了 arguments 在函数调用时，会自动在该函数内部生成一个名为 arguments 的隐藏对象 该对象类似于数组，可以使用[]运算符获取函数调用时传递的实参 只有函数被调用时，arguments 对象才会创建，未调用时其值为 null 12345678function fn5(name, age) &#123; console.log(arguments); name = "XXX"; console.log(arguments); arguments[1] = 30; console.log(arguments);&#125;fn5("Byron", 20); 研究 this123456789var obj = &#123; foo: function() &#123; console.log(this); &#125;&#125;;var bar = obj.foo;obj.foo(); // 打印出的 this 是 objbar(); // 打印出的 this 是 window 实际上的正常调用方式func.call(context, p1, p2)其他简化方式都可以转化 12345func(p1, p2) 等价于func.call(undefined, p1, p2)obj.child.method(p1, p2) 等价于obj.child.method.call(obj.child, p1, p2) this，就是上面代码中的 context。就这么简单。 this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。 浏览器规则:如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） 上面的代码就解释的通了 12345678910111213var obj = &#123; foo: function() &#123; console.log(this); &#125;&#125;;var bar = obj.foo;obj.foo(); // 转换为 obj.foo.call(obj)，this 就是 objbar();// 转换为 bar.call()// 由于没有传 context// 所以 this 就是 undefined// 最后浏览器给你一个默认的 this —— window 对象 Event Handler 中的 this123btn.addEventListener("click", function handler() &#123; console.log(this); // 请问这里的 this 是什么&#125;); 当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样。 jQuery Event Handler 中的 this那么下面代码中的 this 是什么呢： 123$ul.on("click", "li", function() &#123; console.log(this);&#125;); 当 jQuery 的调用处理程序时，this 关键字指向的是当前正在执行事件的元素。对于直接事件而言，this 代表绑定事件的元素。对于代理事件而言，this 则代表了与 selector 相匹配的元素。(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)若要使用 jQuery 的相关方法，可以根据当前元素创建一个 jQuery 对象，即使用 $(this)。 []语法12345function fn() &#123; console.log(this);&#125;var arr = [fn, fn2];arr[0](); // 这里面的 this 又是什么呢？ 我们可以把 arr0 想象为 arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了： 1234 arr[0]()假想为 arr.0()然后转换为 arr.0.call(arr)那么里面的 this 就是 arr 了 call、apply 、函数执行的本质当我们执行一个函数，以下几种调用方式等价 12345678"use strict";function fn(a, b) &#123; console.log(this);&#125;fn(1, 2);//等价于fn.call(undefined, 1, 2);fn.apply(undefined, [1, 2]); 在严格模式下， fn 里的 this 就是 call 的第一个参数，也就是 undefined。在非严格模式下(不加”use strict”)， call 传递的第一个参数如果是 undefined 或者 null， 那 this 会自动替换为 Window 对象 123456789101112131415161718var obj = &#123; fn: function(a, b) &#123; console.log(this); &#125;, child: &#123; fn2: function() &#123; console.log(this); &#125; &#125;&#125;;obj.fn(1, 2);//等价于obj.fn.call(obj, 1, 2); // 所以 this 是 objobj.fn.apply(obj, [1, 2]);obj.child.fn2();//等价于obj.child.fn2.call(obj.chid); // 所以 this 是 obj.child 箭头函数中的 this 箭头函数会捕获其所在上下文的this值作为自己的this值,自己本身并没有this值. 箭头函数的this永远指向其上下文的this,任何方法都改变不了其指向,如call,bind,apply. 1234567891011121314let app = &#123; fn1: function(a) &#123; console.log(this); //app &#125;, fn2(a) &#123; console.log(this); //app &#125;, fn3: a =&gt; &#123; console.log(this); //window &#125;&#125;;app.fn2.call(app);app.fn3.call(它上下文的this); 箭头函数的复杂情况示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var app = &#123; fn1() &#123; setTimeout(function() &#123; console.log(this); &#125;, 10); &#125;, fn2() &#123; setTimeout(() =&gt; &#123; console.log(this); &#125;, 20); &#125;, fn3() &#123; setTimeout( function() &#123; console.log(this); &#125;.bind(this), 30 ); &#125;, fn4: () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(this); &#125;, 40); &#125;&#125;;app.fn1();app.fn2();app.fn3();app.fn4();以上代码相当于;var app = &#123; fn1() &#123; function fn() &#123; console.log(this); &#125; //过10ms后执行 //fn.call(undefined),所以输出window &#125;, fn2() &#123; //过20ms执行箭头函数 //箭头函数里没有资格有自己的this,借用setTimeout外面的this,也就是app &#125;, fn3() &#123; //创建了一个新函数,这个新函数绑定了外面的this,也就是app //20ms后执行新函数,输出this,也就是刚刚绑定的app &#125;, fn4: () =&gt; &#123; //过40ms执行箭头函数 //箭头函数里没有资格有自己的this,借用setTimeout外面的this //setTimeout所在的fn4也是箭头函数,没资格拥有自己的this,借用外面的this,也就是window &#125;&#125;; 函数的执行环境JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因 一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建 arguments 变量，其中包含调用函数时传入的参数 接下来创建作用域链，然后初始化变量。首先初始化函数的形参表，值为 arguments 变量中对应的值，如果 arguments 变量中没有对应值，则该形参初始化为 undefined。 如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，最后为 this 变量赋值，会根据函数调用方式的不同，赋给 this 全局对象，当前对象等 至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取. 每个执行上下文中都有三个重要的属性 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链（JS采用词法作用域，也就是说变量的作用域是在定义时就决定了） this 三种变量实例变量：（this）类的实例才能访问到的变量静态变量：（属性）直接类型对象能访问到的变量私有变量：（局部变量）当前作用域内有效的变量 123456789101112131415function ClassA() &#123; var a = 1; //私有变量，只有函数内部可以访问 this.b = 2; //实例变量，只有实例可以访问&#125;ClassA.c = 3; // 静态变量，也就是属性，类型访问console.log(a); // errorconsole.log(ClassA.b); // undefinedconsole.log(ClassA.c); //3var classa = new ClassA();console.log(classa.a); //undefinedconsole.log(classa.b); // 2console.log(classa.c); //undefined 继承继承是指一个对象直接使用另一个对象的属性和方法.如果实现以下两点就实现了继承 得到一个类的属性 得到一个类的方法 原型继承，核心在于在子类的构造函数中通过parent.call(this)继承父亲的属性，然后改变子类的原型为new parent()来继承父类的函数. 属性的获取对象属性的获取是通过构造函数的执行.在一个类中执行另外一个类的构造函数,就可以把属性赋值到自己内部,但是需要把环境改到自己的作用域内,用call修改 this 的指向即可. 123456789101112131415161718192021222324252627function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function() &#123; console.log(this.name);&#125;;function Male(age) &#123; this.age = age;&#125;Male.prototype.printAge = function() &#123; console.log(this.age);&#125;;function Male(name, sex, age) &#123; Person.call(this, name, sex); this.age = age;&#125;Male.prototype.printAge = function() &#123; console.log(this.age);&#125;;var m = new Male("Tom", "male", 10);console.log(m.sex); //'male' 继承的范例12345678910function Male(name, sex, age) &#123; Person.call(this, name, sex); this.age = age;&#125;Male.prototype = Object.create(Person.prototype);Male.prototype.printAge = function() &#123; console.log(this.age);&#125;; 123456789101112131415161718192021222324function Person(name, sex) &#123; this.name = name; this.age = age;&#125;Person.prototype.printName = function() &#123; console.log(this.name);&#125;;function Male(name, sex, age) &#123; Person.call(this, name, age); this.sex = sex;&#125;Male.prototype = new Person();Male.prototype.constuctor = Male;Male.prototype.printAge = function() &#123; console.log(this.age);&#125;;var man = new Male("Tom", "Male", 10);man.printName(); //'Tom' hasOwnProperty判断属性是自己的还是继承的 12m.hasOwnProperty("name"); //truem.hasOwnProperty("printName"); //false Promise 对象回调地狱下列代码实现按顺序执行,1 秒后执行 fn1,再过 1 秒执行 fn2,再过 1 秒执行 fn3 12345678910111213141516171819202122232425function fn1(callback) &#123; setTimeout(() =&gt; &#123; console.log("fn1"); callback(); &#125;, 1000);&#125;function fn2(callback) &#123; setTimeout(() =&gt; &#123; console.log("fn2"); callback(); &#125;, 1000);&#125;function fn3() &#123; setTimeout(() =&gt; &#123; console.log("fn3"); &#125;, 1000);&#125;fn1(function() &#123; fn2(function() &#123; fn3(); &#125;);&#125;); 由于层层嵌套,形成回调地狱.(如果套个十几二十个,真的要崩溃) 什么是 PromisePromise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.(MDN解释)Promise 是一个对象,对象里存储着状态.分别是 pending(等待态),fulfilled(完成态),rejected(拒绝态)Promise 启动之后，当满足成功的条件时我们让状态从 pending 变成 fullfilled （执行 resolve）；当满足失败的条件，我们让状态从 pending 变成 rejected（执行 reject）面试官想听的版本:所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理，让开发者不用再关注于时序和底层的结果。Promise 的状态具有不受外界影响和不可逆两个特点。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了. then的参数有两个,也是一个成功函数,一个失败函数. 1const promise2 = doSomething().then(successCallback, failureCallback); Promise+ajax 范例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//获取IPfunction getIp()&#123; return new Promise(function(resolve,reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET','https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getIp',true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson.ip) &#125; xhr.onerror = function()&#123; reject('获取IP失败') &#125; xhr.send() &#125;)&#125;//从IP获取城市function getCityFromIp(ip)&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET', 'https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip='+ip, true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson.city) &#125; xhr.onerror = function()&#123; reject('获取city失败') &#125; xhr.send() &#125;)&#125;//通过城市获取天气function getWeatherFromCity(city&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET', 'https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getWeatherFromCity?city='+city, true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson) &#125; xhr.onerror = function()&#123; reject('获取天气失败') &#125; xhr.send() &#125;)&#125;)getIp().then(function(ip)&#123; return getCityFromIp(ip)&#125;).then(function(city)&#123; return getWeatherFromCity(city)&#125;).then(function(data)&#123; console.log(data)&#125;).catch(function(e)&#123; console.log('出现了错误',e)&#125;)//getIP()得到一个promise对象,传入ip,返回另一个promise对象,依次往下//中途报错直接执行catch() Promise.all1234567891011121314151617181920212223function getCityFromIp(ip)&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET','https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip='+ip',true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson) &#125; xhr.onerror = function()&#123; reject('获取city失败') &#125; xhr.send() &#125;)&#125;var p1 = getCityFromIp('10.10.10.1')var p2 = getCityFromIp('10.10.10.2')var p3 = getCityFromIp('10.10.10.3')//Promise.all, 当所有的 Promise 对象都完成后再执行Promise.all([p1,p2,p3]).then(data =&gt; &#123; console.log(data)&#125;) Promise.race12345678910111213141516171819202122232425262728293031function getCityFromIp(ip) &#123; var promise = new Promise(function(resolve, reject) &#123; var xhr = new XMLHttpRequest(); xhr.open( "GET", "https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip=" + ip, true ); xhr.onload = function() &#123; var retJson = JSON.parse(xhr.responseText); // &#123;"city": "hangzhou","ip": "23.45.12.34"&#125; resolve(retJson); &#125;; xhr.onerror = function() &#123; reject("获取city失败"); &#125;; setTimeout(() =&gt; &#123; xhr.send(); &#125;, Math.random() * 1000); &#125;); return promise;&#125;var p1 = getCityFromIp("10.10.10.1");var p2 = getCityFromIp("10.10.10.2");var p3 = getCityFromIp("10.10.10.3");//Promise.race, 谁的先输出就先执行谁Promise.race([p1, p2, p3]).then(data =&gt; &#123; console.log(data);&#125;); callback&amp;Promise&amp;async/await把一个需求不断简化需求如下: 读取 a.md 文件，得到内容 把内容转换成 HTML 字符串 把 HTML 字符串写入 b.html callback()处理1234567891011121314var fs = require("fs");var markdown = require("markdown").markdown;fs.readFile("a.md", "UTF-8", function(err, str) &#123; if (err) &#123; return console.log(err); &#125; var html = markown.toHTML(str); fs.writeFile("b.html", html, function(err) &#123; if (err) &#123; return console.log(err); &#125; console.log("write.success"); &#125;);&#125;); ES6 语法简化处理1234567891011121314let fs = require("fs");let markdown = require("markdown").markdown;fs.readFile("a.md", "UTF-8", (err, str) =&gt; &#123; if (err) &#123; return console.log(err); &#125; let html = markdown.toHTML(str); fs.writeFile("b.html", html, err =&gt; &#123; if (err) &#123; return console.log(err); &#125; console.log("write.success"); &#125;);&#125;); Promise 处理123456789101112131415161718192021222324252627282930313233343536373839const fs = require("fs");const markdown = require("markdown").markdown;readFile("a.md") .then(mdStr =&gt; &#123; return markdown.toHTML(mdStr); //返回结果作为下个回调函数 &#125;) .then(html =&gt; &#123; writeFile("b.html", html); &#125;) .catch(e =&gt; &#123; console.log(e); &#125;);//对读取文件进行包装function readFile(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFlie(url, "UTF-8", (err, str) =&gt; &#123; if (err) &#123; reject(new Error("readFlie error")); &#125; else &#123; resolve(str); &#125; &#125;); &#125;);&#125;//对写入文件进行包装function writeFile(url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.writeFile(url, data, (err, str) =&gt; &#123; if (err) &#123; reject(new Error("write error")); &#125; else &#123; resolve(); &#125; &#125;); &#125;);&#125; 使用模块改装上面代码123456789101112131415const markdown = require("markdown").markdown;const fsp = require("fs-promise"); //用于把fs变promise化let onerror = err =&gt; &#123; console.error("something wrong");&#125;;fsp .readFile("a.md", "UTF-8") .then(mdStr =&gt; &#123; return markdown.toHTML(mdStr); &#125;) .then(html =&gt; &#123; fsp.writeFile("b.html", html); &#125;) .catch(onerror); async/await 处理12345678910111213const markdown = require("markdown").markdown;const fsp = require("fs-promise");let onerror = err =&gt; &#123; console.error("sonething wrong");&#125;;async function start() &#123; let mdStr = await fsp.readFile("a.md", "UTF-8"); let html = markdown.toHTML(mdStr); await fsp.writeFile("b.html", html);&#125;start().catch(onerror); 方法Promise.prototype.then(onFulfilled, onRejected)接收成功或失败的结果回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来 resolve. Promise.prototype.catch(onRejected)接受一个失败的结果回调到当前 promise, 返回一个新的 promise。当这个回调函数被调用，新 promise 将以它的返回值来 resolve，否则如果当前 promise 进入 fulfilled 状态，则以当前 promise 的完成结果作为新 promise 的完成结果. Promise.prototype.finally(onFinally)添加一个事件处理回调于当前 promise 对象，并且在原 promise 对象解析完毕后，返回一个新的 promise 对象。回调会在当前 promise 运行完毕后被调用，无论当前 promise 的状态是完成(fulfilled)还是失败(rejected) async/awaitasync 函数的创建时通过在函数声明语句之前加上 async 关键字，这是异步函数的特征之一 ––它将任何函数转换为 promise。示例如下： 1234567const asyncFunction = async () =&gt; &#123; // Code&#125;;//或者async function asyncFunction() &#123; //code&#125; awaitasync 异步函数可通过await来暂停，该关键字只能用在 async 函数内部。每当函数执行完毕，await返回的是任何 async 函数会返回的东西。 阮一峰老师的解释: async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句 只能放在 async 函数内部使用，不能放在普通函数里面，否则会报错。后面放 Promise 对象，在Pending状态时，相应的协程会交出控制权，进入等待状态。等等党永不为奴!这个是本质。await是 async wait 的意思，wait 的是resolve(data)消息，并把数据data返回。await后面也可以跟同步代码，不过系统会自动转化成一个 Promise 对象。await只关心异步过程成功的消息resolve(data)，拿到相应的数据data。至于失败消息reject(error)，不关心，不处理。 await的特点1.建立在 promise 之上。所以，不能把它和回调函数搭配使用。但它会声明一个异步函数，并隐式地返回一个Promise。因此可以直接return变量，无需使用 Promise.resolve 进行转换。2.和 promise 一样，是非阻塞的。但不用写 then 及其回调函数，这减少代码行数，也避免了代码嵌套。而且，所有异步调用，可以写在同一个代码块中，无需定义多余的中间变量。3.它的最大价值在于，可以使异步代码，在形式上，更接近于同步代码。4.它总是与 await 一起使用的。并且，await 只能在 async 函数体内。5.await 是个运算符，用于组成表达式，它会阻塞后面的代码。如果等到的是 Promise 对象，则得到其 resolve 值。否则，会得到一个表达式的运算结果。 MDN 例子: 123456async function hello() &#123; return (greeting = await Promise.resolve("Hello"));&#125;hello().then(alert);//先等返回了hello再打印 简单案例: 123456789101112function timeout(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint("hello world", 50);// 上面代码指定50毫秒以后，输出"hello world"。]]></content>
      <categories>
        <category>JS</category>
        <category>JS进阶</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas画板]]></title>
    <url>%2F2019%2F08%2F27%2Fcanvas%2F</url>
    <content type="text"><![CDATA[简介canvas本身没有绘图能力，只是定义了一个容器，都是由canvas内部的CanvasRenderingContext2D对象来做，需要我们用 JavaScript脚本完成绘制工作。 基础 html引入&lt;canvas&gt;标签 &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; js获取&lt;canvas&gt;属性,使用2d绘制上下文. 123var canvas = getElementById("canvas")var context = canvas.getContext("2d")//使用context进行绘制 设置宽高 使用canvas.width设置宽度.canvas.height设置高度. 12345678910111213141516&lt;body&gt;&lt;canvas id="canvas" sytle="border: 1px solid #aaa;display: block;margin: 50px auto;"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function()&#123; var canvas = document.getElementById("canvas") canvas.width: 1024; canvas.height: 768; if(canvas.getContext("2d"))&#123; //如果浏览器支持canvas,可以使用 var context = canvas.getContext("2d") &#125;else&#123; alert('当前浏览器不支持,请使用谷歌浏览器') &#125; &#125;&lt;/script&gt;&lt;/body&gt; 设置全屏 12345let pageWidth = document.documentElement.clientWidth;let pageHeight = document.documentElement.clientHeight;canvas.width = pageWidth;canvas.height = pageHeight; 绘制线段1234567891011121314151617181920212223var context = canvas.getContext("2d")conext.beginPath()//开始第一段绘制,与其他绘制可以区别开context.moveTo(100,100)//以画布左上角为原点,从坐标(100,100)开始context.lineTO(700,700)//把线画到(700,700)位置context.lineTO(100,700)//折到(100,700)位置context.lineTO(100,100)//线段完成封闭,形成三角形context.closePath()//结束本段状态context.fillStyle="rgab(168,168,168)"//设置三角形填充颜色context.fill()//执行填充颜色context.lineWidth = 5 //设置线段宽度context.strokeStyle = "red" //设置线段颜色context.stroke//执行绘图conext.beginPath()//开始第二段绘制,与其他绘制可以区别开context.moveTo(200,100)//以画布左上角为原点,从坐标(200,100)开始context.lineTO(700,600)//把线画到(700,600)位置context.closePath()//结束本段状态context.strokeStyle = "blue" //设置线段颜色context.stroke//执行第二段绘图 标签属性 标签 描述 height 设置 canvas 的高度 width 设置 canvas 的宽度 fill() 可以填充 fillRect(x,y,width,height) 绘制一个矩形边框 fillRect(x,y,width,height) 绘制一个填充的矩形 clearRect(x,y,width,height) 清除指定矩形区域，让清除部分完全透明 ctx.strokeStyle 可以改变画笔颜色 ctx.beginPath() 设置开始路径 ctx.moveTo(x,y) 设置起点 ctx.lineTo(x,y) 设置终点 ctx.stroke() 绘制 ctx.closePath() 结束路径 ctx.arc(弧形圆心x坐标，y坐标，半径，起始角(以3点钟的位置开始)，结束角、方向(true表示逆时针，false表示顺时针)) 绘制一个弧形 ctx.quadraticCurveTo(cpx,cpy,x,y)参数是控制点x坐标，控制点y坐标，结束点x坐标，结束点y坐标 绘制二次贝塞尔曲线 ctx.quadraticCurveTo(cpx1,cpy1,cpx2,cpy2,x,y)参数是控制点1的x坐标，控制点1的y坐标，控制点2的x坐标，控制点2的y坐标，结束点x坐标，结束点y坐标 绘制三次贝塞尔曲线 canvas画板代码实现 html1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;div id="actions"class="actions x"&gt; &lt;svg id="pen"class="icon"&gt; &lt;use xlink:href="#icon-pencil"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="eraser"class="icon"&gt; &lt;use xlink:href="#icon-eraser"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="clear"class="icon"&gt; &lt;use xlink:href="#icon-delete"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="download"class="icon"&gt; &lt;use xlink:href="#icon-download"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;ul class='colorCir'&gt; &lt;li id="black"class="black"&gt;&lt;/li&gt; &lt;li id="red"class="red"&gt;&lt;/li&gt; &lt;li id="yellow"class="yellow"&gt;&lt;/li&gt; &lt;li id="blue"class="blue"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class='lineWidth'&gt; &lt;li id="thin" class="thin"&gt;&lt;/li&gt; &lt;li id="thick" class="thick"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117*&#123; margin:0; padding:0;&#125;body&#123; background:#eee&#125;ul,ol&#123; list-style: none; &#125;.colorCir&#123; top:60px; left:20px; position: fixed; &#125;.colorCir li&#123; border: 1px solid grey; height:20px; width: 20px; border-radius: 50%; margin-bottom:10px;&#125;.colorCir .red&#123; background:red;&#125; .colorCir .yellow&#123; background:yellow;&#125; .colorCir .blue&#123; background:blue;&#125; .colorCir .black&#123; background:black;&#125; .colorCir .red.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .yellow.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .blue.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .black.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; &#125;body&#123; overflow: hidden;&#125;#canvas&#123; display: block; position: fixed; top:0px; left:0px;&#125;.actions&#123; position: fixed; top:0px; left:0px; padding-top:20px; padding-left:15px;&#125;.actions svg&#123; width:1.5em; height:1.5em; transition: all 0.3s; margin:0 5px;&#125;.actions svg.active&#123; fill:red; transform: scale(1.2);&#125;.lineWidth&#123; position: relative; left:-10px; top:140px;&#125;.lineWidth .thin&#123; height:0px; width:40px; border-top:2px solid black; margin:15px;&#125;.lineWidth .thick&#123; height:0px; width:40px; border-top:6px solid black; margin:15px;&#125;.lineWidth .thin.active&#123; transform: scale(1.2); &#125;.lineWidth .thick.active&#123; transform: scale(1.2);&#125; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197var canvas=document.getElementById('canvas');var context=canvas.getContext('2d');var using=false;var lastPoint=&#123; x:undefined, y:undefined&#125;/*画板逻辑 */autoSetSize(canvas);listenToUser(canvas);/********///画笔、橡皮擦按钮替换var eraserEnabled=false;pen.onclick=function()&#123; eraserEnabled=false; pen.classList.add('active'); eraser.classList.remove('active'); &#125;eraser.onclick=function()&#123; eraserEnabled=true; eraser.classList.add('active'); pen.classList.remove('active');&#125; //颜色替换并高亮red.onclick=function()&#123; context.fillStyle ="red"; context.strokeStyle="red"; red.classList.add('active'); yellow.classList.remove('active'); blue.classList.remove('active'); black.classList.remove('active');&#125;yellow.onclick=function()&#123; context.fillStyle ="yellow"; context.strokeStyle="yellow"; yellow.classList.add('active'); red.classList.remove('active'); blue.classList.remove('active'); black.classList.remove('active');&#125;blue.onclick=function()&#123; context.fillStyle ="blue"; context.strokeStyle="blue"; blue.classList.add('active'); yellow.classList.remove('active'); red.classList.remove('active'); black.classList.remove('active');&#125;black.onclick=function()&#123; context.fillStyle ="black"; context.strokeStyle="black"; black.classList.add('active'); yellow.classList.remove('active'); blue.classList.remove('active'); red.classList.remove('active');&#125;/********/thin.onclick=function()&#123; thin.classList.add('active'); thick.classList.remove('active'); context.lineWidth=2;&#125;thick.onclick=function()&#123; thick.classList.add('active'); thin.classList.remove('active'); context.lineWidth=4;&#125;clear.onclick=function()&#123; context.clearRect(0,0,canvas.clientWidth,canvas.clientHeight); &#125;download.onclick = function()&#123; var url = canvas.toDataURL('image/png'); var a = document.createElement('a'); document.body.appendChild(a); a.href=url; a.download='my drawing'; a.click();&#125;//drawLinefunction drawLine(x1,y1,x2,y2)&#123; context.beginPath(); context.moveTo(x1,y1); context.lineTo(x2,y2); context.stroke(); context.closePath(); &#125;//drawCirfunction drawCir(x,y)&#123;context.beginPath()context.arc(x,y,0.1,0,Math.PI*2);context.fill();&#125;//重置canvas画板宽高function setCanvasSize()&#123; var pageWidth=document.documentElement.clientWidth; var pageHeight=document.documentElement.clientHeight; canvas.width = pageWidth; canvas.height = pageHeight; &#125;//自动设置canvas画板宽高function autoSetSize()&#123; setCanvasSize(); window.onresize =function()&#123; setCanvasSize(); &#125; &#125;function preventBehavior(e) &#123; e.preventDefault()&#125; document.addEventListener("touchmove", preventBehavior, false) function listenToUser()&#123; //特性检测 if(document.body.ontouchstart!== undefined )&#123; //是触屏设备 canvas.ontouchstart =function(aaa)&#123; var x=aaa.touches[0].clientX; var y=aaa.touches[0].clientY; using=true; lastPoint=&#123;x:x,y:y&#125;; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); &#125; &#125; // canvas.ontouchmove = function(aaa)&#123; var x=aaa.touches[0].clientX; var y=aaa.touches[0].clientY; var newPoint=&#123;x:x,y:y&#125; if(using)&#123; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); drawLine(lastPoint.x,lastPoint.y,newPoint.x,newPoint.y) lastPoint=newPoint; &#125; &#125; &#125; canvas.ontouchend = function(aaa)&#123; using=false; &#125; &#125;else&#123; //不是触屏设备 canvas.onmousedown=function(aaa)&#123; var x=aaa.clientX; var y=aaa.clientY; using=true; lastPoint=&#123;x:x,y:y&#125;; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); &#125; &#125; //鼠标移动监听 canvas.onmousemove=function(aaa)&#123; var x=aaa.clientX; var y=aaa.clientY; var newPoint=&#123;x:x,y:y&#125; if(using)&#123; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); drawLine(lastPoint.x,lastPoint.y,newPoint.x,newPoint.y) lastPoint=newPoint; &#125; &#125; &#125; //鼠标松开监听 canvas.onmouseup=function(aaa)&#123; using=false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>HTML5</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局]]></title>
    <url>%2F2019%2F08%2F23%2FCSS3%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[单栏布局方式: 定宽+水平居中123456&lt;style&gt;.layout&#123;max-width: 100px;margin: 0 auto;&#125;&lt;/style&gt; 通栏的话再加一层div,单独给div设置背景色即可 双列布局固定margin+浮动元素先设置浮动,再设置普通元素,最后清除浮动 flex布局(弹性盒子)display:flex一个容器 设置了display:flex属性,就定义了一个flex容器.它的直接子元素会接受这个flex环境.常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做居中，能对不同屏幕大小自适应。在布局上有了比以前更加灵活的空间。这个是ms图床 这个是路过图床 flex-direction123.container&#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 设置子元素在父容器中的位置 row默认值,水平从左到右 row-reverse,从右到左 column,垂直从上到下 column-reverse,垂直从下到上 flex-wrap设置换行 1234.container&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125;依次为:不换行,换行,换行且颠倒顺序 flex-flowflex-direction和flex-wrap的缩写,默认值row nowrapflex-flow: &lt;&#39;flex-direction&#39;&gt; || &lt;&#39;flex-wrap&#39;&gt; justify-content设置子元素在水平方向上的对齐方式 1234.container&#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125;分别是水平靠左,水平靠右,水平居中,均匀分布,均匀分布且两端保留子元素间距一半(空间包裹) align-items设置子元素在垂直方向上的对齐方式 1234.container&#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125;分别是垂直靠上,垂直靠下,垂直居中,垂直基线对齐,垂直方向拉伸 align-content设置子元素整体内容的在垂直方向上的对齐方式 1234.container&#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125;分别是整体靠上,整体靠下,整体居中,整体垂直均匀排列,整体均匀分布且垂直两端保留间距一半空间,整体垂直拉伸占用剩余空间 用在子元素上的属性order默认情况下flex order会按照书写顺序排列,可以通过order属性改变,数值小的在前面,也可以是负数. 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow.item {flex-grow: 1}按比例瓜分父元素剩余的空间,1即分一份.不写默认是0 flex-basis基准宽度 flex-shrink按比例吸收超出的空间.不写默认是1 flex flex-grow,flex-shrink,flex-basis的缩写 123.item&#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt; || &lt;''flex-basis'&gt;]&#125; aglin-self单独修改自身的属性 Grid布局父元素Grid container的属性display将元素定义为gird container,并为其建立新的网格格式化上下文 1234.container&#123; display: grid | inline-grid | subgrid;&#125;分别是生成一个块级网格;一行网格;如果本身是gird-item,可从父元素获取行列大小 gird-template-columns和gird-template-rows设置网格的列和行 1234.container&#123; gird-template-columns: 40px 50px auto 50px 40px; grid-template-rows: 25% 100px auto;&#125; 简化写法: 1234567.container&#123; gird-template-columns: repeat(3, 20px [col-start]) 5%;&#125;等价于.container&#123; gird-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;&#125; “fr”单位允许将轨道大小设置为网格容器自由空间的一部分.如下代码会将每个gird item设置为gird container宽度的三分之一 123.container&#123; .grid-template-columns: 1fr 1fr 1fr;&#125; gird-template-areas — 使用gird-area属性设置的网络区域的名称 . — 点号代表一个空网格单元 none — 没有定义网格单元 1234567891011121314151617181920.item-a &#123; grid-area: header;&#125;.item-b &#123; grid-area: main;&#125;.item-c &#123; grid-area: sidebar;&#125;.item-d &#123; grid-area: footer;&#125;.container &#123; grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: "header header header header" "main main . sidebar" "footer footer footer footer";&#125; 这将创建一个四列宽三行高的网格。 整个第一行将由 header 区域组成。 中间一行将由两个 main 区域、一个空单元格和一个 sidebar 区域组成。 最后一行是footer区域组成。 媒体查询(响应式)12345678910111213141516&lt;style&gt; /* 屏幕宽度为300px-325px时的css样式 */ @media(min-width: 300px) and (max-width: 325px)&#123; body&#123; background: red; &#125; &#125; /* 屏幕宽度小于450px时的css样式 */ @media(max-width: 450px)&#123; body&#123; background: black; &#125; &#125; /* 这样前面那个就没用了，被覆盖了 */&lt;/style&gt; 一般不用第一个方法，直接引用一个手机版的css即可 &lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width:768px)&quot; href=&quot;mobile.css&quot;&gt;在屏幕宽度小于768px时，就会渲染这个css，要把这个引用写在main.css之后，把main.css覆盖。并加上meta:vp&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;让视口等于理想视口,禁止用户缩放.]]></content>
      <tags>
        <tag>css</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F08%2F23%2Fcss%2F</url>
    <content type="text"><![CDATA[介绍css,即层叠样式表,可以为网页添加样式.stylesheet 应用方式外部样式表 通过&lt;link&gt;引入&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; 通过@import引入,注意末尾加;号,CSS语法,只能在CSS内使用. 1234&lt;style&gt;@import url("index.css");@import "index.css";&lt;/style&gt; 媒体查询(响应式) 12345678&lt;style&gt;@media (min-width: 801px) &#123; body &#123; margin: 0 auto; width: 800px; &#125;&#125;&lt;/style&gt; 内部样式表将css放到&lt;style&gt;元素中,一般放到文档的&lt;head&gt;中. 12345678910111213141516&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;style&gt;h1 &#123; background: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;AMD yes!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 内联样式&lt;p style=&quot;background: red; font-size: 20px;&quot;&gt;AMD yes!&lt;p&gt; CSS选择器 基本选择器 名称 含义 * 通用选择器 匹配任何元素 E 标签选择器 匹配所有使用E标签的元素 .info class选择器 匹配所有class属性中包含info的元素 #footer id选择器 匹配所有id属性等于footer的元素 组合选择器 名称 含义 E,F 多元素选择器 同时匹配所有E元素或F元素 E F 后代选择器 匹配所有属于E元素后代的F元素 E&gt;F 子元素选择器 匹配所有E元素的直接子元素 E+F 直接相邻元素选择器 匹配E元素后的直接相邻元素 E~F 兄弟元素选择器 匹配E元素后的所有兄弟元素 属性选择器 含义 E[attr] 匹配所有具有attr属性的E元素 E[attr=val] 匹配所有attr属性等于val的E元素 E[attr~=val] 匹配所有attr属性具有多个空格分隔的值,其中一个等于val的E元素 E[attr =val] E[attr*=val] 匹配所有attr属性中包含val的E元素 E[attr^=val] 匹配所有attr属性中以val开头的E元素 E[attr$=val] 匹配所有attr属性中以val结尾的E元素 伪类 含义 E:first-child 匹配父元素的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经按下没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得焦点的E元素 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio或者checkbox元素 E:root 匹配文档的根元素,对于html文档,就是html元素 E:nth-child(n) 匹配其父元素的第n个子元素,第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素,第一个编号为1 E:nth-of-type 与nth-child类似,但仅匹配使用同种标签的元素 E:nth-last-child 与nth-last-child类似,但仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个元素 E:first-of-type 匹配父元素下使用同种标签的第一个子元素 E:last-of-type 匹配父元素下使用同种标签的最后一个子元素 E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素,注意,文本节点也被看做子元素 E:not(s) 匹配不符合当前选择器的任何元素 E:target 代表一个唯一的页面元素(目标元素)，其id 与当前URL片段匹配 伪元素 含义 E::first-line 匹配E元素的第一行 E::first-letter 匹配E元素的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 E::selection 匹配用户当前选中的元素 伪元素必须要有content 伪元素和伪类的区别 伪元素使用两个冒号,伪类使用一个冒号 伪元素添加了一个页面中没有的元素(只是从视觉效果上添加了,不是在文档树中添加),伪类是给页面中已经存在的的元素添加一个类. CSS选择器有哪些？哪些属性可以继承？1.id选择器（ # myid）2.类选择器（.myclassname）3.标签选择器（div, h1, p）4.相邻选择器（h1 + p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（ * ）8.属性选择器（a[rel = “external”]）9.伪类选择器（a:hover, li:nth-child） 可继承的样式： font-size font-family color, ul li dl dd dt; 不可继承的样式：border padding margin width height; 选择器优先级!important优先级最高(由于IE不支持!important，所以也可以利用它区分不同的浏览器。)同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）行内样式(写在style标签里的样式) &gt; id样式 &gt; class样式 &gt; 标签名样式 CSS基本样式div（块级元素）：高度是由内部文档流元素高度的总和决定的。文档流：文档内元素的流动方向，内联元素是从左往右，块级元素是从上往下span（内联元素）：高度是由其中文字高度决定的，内联元素设置width和height是无效的，上下的margin和padding也无效，要将它们设为display:inline-block才有效。 常见块级元素: div h1~h6 p hr form ul ol li table td tr th dl dt dd pre 常见内联元素: em strong span a br img button input label select textarea code script 尽量不写height和width，这两个属性会引出很多bug，要宽高的时候可以用padding，但img最好先写width，因为可以先占位，因为引用图片时浏览器不知道图片大小，所有等图片下载完成，它后面的元素又要重新排位置，若先写好width，则不用重排，知道height也可以先写好height。另外span元素设置padding的时候要将它设为display:inline-block，因为内联元素不能设置宽高，inline-block具有inline的同行特性，也具有block的高度特性。对于display:inline(内联元素)的元素，设置width/height/上下margin和padding都是无效的 inline-block inline-block 之间空隙 inline-block 之间有空格、Tab、换行符。 给父元素设置 font-size: 0，在 inline-block 元素上重新设置 font-size。 inline-block 导致父元素增高若干像素 给 inline-block 元素设置 vertical-align: top 通用解决办法 不要设置 inline-block，使用 float 或 flex。 浏览器默认样式浏览器对某些元素设置有默认样式，如 h1, ul, li 等。 常见处理方式 Normalize.css CSS Reset 简单去除 1234* &#123; margin: 0; padding: 0;&#125; CSS常见样式边框border1234567891011.box &#123; border-width: 1px; border-color: red; border-style: solid; border-bottom: none;//下边框消失 border-radius: 50%;//圆角&#125;//简写.box2 &#123; border: 1px red solid;&#125; 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt; 内边距paddingpadding: 10px 20px 30px;//按照上右下左,即顺时针,缺哪个补哪个,缺左边,按20px补上. 外边距marginmargin可以合写,可以分开.可以是数值,可以是百分比(相对于父元素).还可以是负值.有外边距合并问题 display 块级: block,list-item,table 行内: inline,inline-table,inline-block inherit: 规定应该从父元素继承display属性的值 display:inline-block 什么时候会显示间隙移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing font123456789body&#123; font: 12px/1.5 Arial;&#125;p&#123; line-height: 1.5;//行高是字体的1.5倍 font-size: 14px;//字体大小 font-family: Arial;//字体 font-weight: bold;//文字粗度,粗体&#125; Chrome默认字体是16px,最小字体是12px. 文本 text-aglin: 文本对齐方式,left,right,center,justify text-ident: 文案第一行缩进距离 text-decoration: 划线,none,underline,line-through,overline text-transform: 改变文字大小写,none,uppercase,lowercase,captialize word-spacing: 可以改变字(单词)之间的标准间距 letter-spacing: 字母之间的间隔单行文本溢出加…12345.box&gt;h3 &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 颜色 单词: red,blue,black,pink,yellow 十六进制: #000000(黑),#fff(白),#eee(淡灰),#ccc(灰色),#666(深灰) rgb:rgb(255,255,255)白色,rgba(0,0,0,0.5)透明度为0.5的黑色 单位px rpx em rem的区别 px是像素pixel，相对于屏幕分辨率的单位 em是相对单位，相对于当前对象内的文本尺寸。如果没有设置，则相对浏览器默认尺寸16px，1em=16px。为了简化，可以将body里font-size=62.5%，那么em就是16px*62%=10px。1em=10px em特点：em值不固定，会继承父元素字体大小 rem是root em。只相对于html根元素 rpx是微信小程序的方案,是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕为750rpx.物理像素1px=2rpx vh vw: 相对单位,1vw为屏幕宽度的1% background background-color: transparent 透明背景;颜色值;半透明浮层的背景颜色建议使用 rgba() 而不是 opacity 设置透明度。 background-image: url(../images/bg.png);// 属性用于给元素设置一张或多张背景图。 background-repeat 控制背景图片的重复方式。no-repeat不重复;repeat-x水平方向重复;repeat-y 垂直方向重复; background-position 设置背景图的位置。x y;x% y%;[top|center|bottom][left|center|right] background-size 设定背景图片的大小。IE9 以下不支持;cover缩放背景图片以完全覆盖背景区，可能背景图片部分看不见;contain缩放背景图片以完全装入背景区，可能背景区部分空白。 background-clip: 设置元素背景区域覆盖的范围.border-box 覆盖至边框的最外围;padding-box 覆盖至内边距的最外围;content-box 仅覆盖元素内容区域 缩写: 123.avatar &#123; background: #fff url(avatar.svg) no-repeat left center;&#125; 隐藏or透明 opacity: 0;//透明度为0,整体 visibility: hidden;//和opacity: 0;类似 display: none;//消失,不占用位置 background-color: rgba(0,0,0,0.2);//只是背景色透明 display:none和visibility:hidden的区别display:none:不占据任何空间，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中）.会触发reflow（回流）,进行渲染.不是继承属性，元素及其子元素都会消失visibility:该元素空间依旧存在.只会触发repaint（重绘），因为没有发现位置变化，不进行渲染.是继承属性，若子元素使用了visibility:visible，则不继承，这个子孙元素又会显现出 box-shadowbox-shadow: -16px 0 16px 1px rgba(102,102,102,0.4);第一个值代表阴影左右偏移，正数往右，负数往左第二个值代表上下偏移，正往下，负往上第三个值越大，模糊面积越大越淡第四个值取正值时，阴影扩大，取负值时，阴影收缩 line-height line-height: 2;//本身字体高度的2倍 line-height: 200%;//父元素高度的2倍,父元素没写行高就是默认16px*2=32px height=line-height;//垂直居中单行文本 盒模型 标准盒模型: border-box,即padding,border不在width,height范围内 IE盒模型: content-box,即width=content尺寸+padding+border css3可以设置box-sizing: content-box;//标准盒模型 positionCSS position属性用于指定一个元素在文档中的定位方式。语法: static | relative | absolute | sticky | fixed static: 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 relative: 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table元素无效. absolute: 不为元素预留空间，通过指定元素相对于最近的非 static 定位父元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 fixed: 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 sticky: 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。 相对定位(relative)相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。 绝对定位(absolute,fixed)相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）。 固定定位(fixed)固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。 粘性定位(sticky)粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。#one { position: sticky; top: 10px; }在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。(理解为大于10px时,属于相对定位,可以在页面滚动时随之滚动,当距视口10px时,固定了,就像粘在那里了) 浮动float: left;//向左浮动 浮动元素并不是完全意义上的脱离文档流,至少普通元素里的文本可以发现,行内元素也可以发现 设置浮动会让块级元素从左到右或从右到左排列. 块级元素设置浮动呈现inline-block特性,不再撑开父元素,宽度也会收缩 行内元素设置浮动呈现inline-block特性,可以设置宽高. 清除浮动问题: 对后续元素位置产生影响 父容器高度计算出现问题 清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。通用解决方案 12345678910父元素加clearfix.clearfix::after&#123; content:''; display: block; clear: both;&#125;.clearfix&#123; *zoom: 1 //兼容IE6,7&#125; BFC(块级格式化上下文)决定了其子元素将如何定位,以及其他元素的关系和相互作用在正常流中的盒子要么属于块级格式化上下文,要么属于内联格式化上下文 BFC的产生 根元素 float不为none; position: absolute/fixed; display: inline-block/flex/inline-flex/table-cell; overflow不为visible; 特性 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠.每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。(如果有多个浮动盒,因为是浮动盒,所以后面的有新的BFC,会挨着前面的从左到右排列) BFC的区域不会与float box重叠。(不跟外面的浮动盒重叠,会把浮动盒挤到一边) BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算(包裹浮动元素). 作用 阻止margin合并,因为BFC与外界隔离,自己的margin也就不再合并. contain float(包裹浮动元素). 边距合并合并场景 相邻元素合并,间距为二者中较大值 父子合并 自己合并 取消合并 加border,padding BFC 居中水平居中 块级元素水平居中 12margin-left:auto;margin-right:auto; 内联元素水平居中，给它们的父元素加上 1text-align:center; 若不是内联元素想让它居中，可加display:inline-block，加了之后一般还要加下面这句，不然可能会有bug（下面可能会空出一行） 1vertical-align: top; 让导航栏横过来，并在同一行里均匀分布 给ul加css 1234ul&#123; display:flex; justyfy-content:space-between;&#125; 去掉li的float:left去掉ul的clearfix 垂直居中 若父元素没有写height，则直接在父元素写 1padding: 10px 0; 子元素就可以居中，所以尽量避免父亲高度确定 以下是宽高确定(注意写宽高) 让一个元素在父级元素中绝对居中 方法一：给父级元素加: 12position:relative; //若父级元素是body可以不用加//注意父元素需要宽高 再给自己加： 123456789div&#123; //注意子元素也需要宽高 position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: auto;&#125; 方法二：（若不兼容IE，工作中只要用这一种方法即可，最简单，Chrome，移动端都可以用）给父元素加： 123display: flex; //让它变成一个弹性盒justify-content: center; //水平居中align-items: center; //垂直居中 table自带居中（兼容IE） 1234567891011121314151617181920&lt;html&gt;&lt;style&gt;.parent&#123; border: 1px solid red; height: 600px;&#125;.child&#123; border: 1px solid green;&#125;&lt;/style&gt;&lt;body&gt;&lt;table class="parent"&gt; &lt;tr&gt; &lt;td class="child"&gt; 文字 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 文字会居中 用div假扮table（兼容IE） 123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;style&gt;div.table&#123; display: table; border: 1px solid red; height: 600px;&#125;div.tr&#123; display: table-row; border: 1px solid green;&#125;div.td&#123; display: table-cell; border: 1px solid blue; vertical-align: middle;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="table"&gt; &lt;div class="tr"&gt; &lt;div class="td"&gt; 文字 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用100%高度的before和after 12345678910111213141516171819202122232425.parent&#123; border: 3px solid red; height: 600px; text-align: center;&#125;.child&#123; border: 3px solid black; display: inline-block; width: 300px; vertical-align: middle;&#125;.parent:before&#123; content:''; display: inline-block; height: 100%; vertical-align: middle;&#125;.parent:after&#123; content:''; display: inline-block; height: 100%; vertical-align: middle;&#125; 绝对定位加上margin-top: -自身height的50% 123456789101112131415161718192021222324252627&lt;html&gt;&lt;style&gt;.parent&#123; height: 600px; border: 1px solid red; position: relative;&#125;.child&#123; border: 1px solid green; width: 300px; position: absolute; top: 50%; left: 50%; margin-left: -150px; height: 20px; margin-top: -10px; text-align: center;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="parent"&gt; &lt;div class="child"&gt; 文字 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用transform 子元素加{top:50%,transform:translate(-50%)} CSS3有哪些新特性？新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）圆角 （border-radius:8px）多列布局 （multi-column layout）阴影和反射 （box-shadow\reflect）文字特效 （text-shadow）文字渲染 （Text-decoration）线性渐变 （gradient）旋转 transform:rotate(90deg)缩放 transform:scale(0.85,0.90)位移 transform:translate(0px,-30px)倾斜 transform:skew(-9deg,0deg)动画 Animation CSS动画transition(过渡)transition的作用在于指定状态变化所需要的时间. 123div&#123; transition: 1s;&#125; 指定属性可以指定transition使用的属性,比如只适用于heighttransition: 1s height; delay(延迟)transition: 1s height,1s 1s width;width在一秒之后在开始变化,也就是延迟一秒.delay可以指定动画发生的顺序,使得不同transition可以连在一起,形成不同效果. transition-timing-function(缓动函数)transition的状态变化速度,默认不是匀速的,而是逐渐放慢的,这叫做ease.transition: 1s ease;除了ease,其他模式还有: linear: 匀速 ease-in: 加速 ease-out: 减速 cubic-bezier: 自定义速度模式(可以在cubic-bezier.com里设置) 语法简写:transition: 1s 1s height ease;完整写法: 1234transition-property: height;transition-duration: 1s;transition-delay: 1s;transition-timing-function: ease; 注意 transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态，什么none到block之类的是不行的 transition是一次性的，不能重复发生，除非一再触发 animation(动画)使用animation首先需要定义动画过程,即关键帧 12345@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 写动画帧里的css记得加;号.定义关键帧后可以给DOM元素绑定动画,和事件比较像.加infinite代表无限次,改成数字就是循环多少次. 123div:hover &#123; animation: 1s rainbow infinite;&#125; animation-fill-mode动画结束后,会立即跳到结束状态,如果想让动画保持在结束状态,需要使用animation-fill-mode属性. 123div:hover&#123; animation: 1s rainbow forwards;&#125; animation-fill-mode的属性: none: 默认值,回到动画未开始的状态. forwards: 让动画停留在结束状态 backwards: 让动画回到第一帧的状态 both: animation-direction轮流应用forwards和backwards规则 animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变顺序默认情况是，animation-direction等于normal.此外，还可以等于取alternate(先从前往后再从后往前)、reverse(从后往前)、alternate-reverse等值. 123div:hover &#123; animation: 1s rainbow 3 normal;&#125; animation-play-state有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态，如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。 12345678div &#123; animation: spin 1s linear infinite; animation-play-state: paused;&#125;div:hover &#123; animation-play-state: running;&#125; 语法简写: 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 完整: 123456789div:hover &#123; animation-name: rainbow; animation-duration: 1s; animation-timing-function: linear; animation-delay: 1s; animation-fill-mode:forwards; animation-direction: normal; animation-iteration-count: 3;&#125; 0%可以用from代表，100%可以用to代表，因此上面的代码等同于下面的形式 12345@keyframes rainbow &#123; from &#123; background: #c00 &#125; 50% &#123; background: orange &#125; to &#123; background: yellowgreen &#125;&#125; steps(分步过渡)浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡。 123div:hover &#123; animation: 1s rainbow infinite steps(10);&#125; 歌词效果12345678910111213141516171819202122232425262728293031323334&lt;style&gt;@keyframes moving &#123; from &#123; width: 0; &#125;&#125;.line &#123; position: relative;&#125;p &#123; width: 600px; font-size: 40px; white-space: nowrap; overflow: hidden; position: absolute; top: 0; z-index: 2;&#125;p:nth-child(1) &#123; color: red; animation: moving 20s&#125;p:nth-child(2) &#123; z-index: -1; color: #666;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="line"&gt; &lt;p&gt;To my days change my ways为生活我试着不断改变&lt;/p&gt; &lt;p&gt;This sudden end to my days这生命的终点突如其来&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 打字机效果12345678910111213141516171819202122&lt;style&gt;@keyframes typing &#123;from &#123; width: 0 &#125; &#125;@keyframes blink-caret &#123; 50% &#123; border-clolr: transparent &#125; &#125;h1 &#123; border-right: 0.1em solid; color: #fff; width: 352px; height: 30px; white-space: nowrap; overflow: hidden; animation: typing 5s steps(11, end),//变11次变成最终状态 blink-caret .5s infinite alternate;&#125;body &#123; background: #000; height: 100vh;&#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;躺在你的学校操场看星空&lt;/h1&gt;&lt;/body&gt; 如果需要手动写动画，你认为最小时间间隔是多久，为什么多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms transform(变形)transform属性主要包括rotate(旋转),skew(扭曲),scale(缩放),translate(移动),matrix(矩阵变形)transform ： none | [ ]*transform中使用多个属性时却需要有空格隔开，可用于内联(inline)元素和块级(block)元素 rotate(旋转)可以通过rotate使元素旋转一定的度数transform: rotate(30deg)//顺时针旋转30度 旋转之后元素仍占据原来位置，实际上所有的transform都是这样，缩放、位移等都不会改变元素占据的位置 元素旋转的的基点默认是中心，可以通过transform-origin属性改变transform:rotate(30deg); transform-origin: 0% 0%; transform-origin的取值可以是: top, bottom, left, right, center 百分数 translate(位移)transform: translateY(100px)//Y轴位移100px; scale(缩放)scale(x,y): 使元素水平方向和垂直方向同时缩放transform: translate(3)//相同的比例缩放两个方向 skew(扭曲)通过skew使元素扭曲一定的度数transform:skew(10deg, 20deg);//x轴扭曲10度,y轴扭曲20度 3D元素需要设置需要设置perspective来激活3D效果 transform: perspective( 600px ); perspective: 600px; perspective属性的值决定了3D效果的强烈程度，可以认为是观察者到页面的距离。越大距离越远，视觉上的3D效果就会相应的减弱。 3D变形方法rotateX( angle )rotateY( angle )rotateZ( angle )translateZ( tz )scaleZ( sz )translateX()方法使元素延X轴移动，translateZ()使元素延Z轴（在3D空间中方向从前到后）移动。正值使元素离观察者更近，负值使元素变远。 渐进增强和优雅降级渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。 二者区别优雅降级观点认为:应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 渐进增强观点则认为:应关注于内容本身。请注意其中的差别：我甚至连“浏览器”三个字都没提。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得渐进增强成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 案例分析123456789101112.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125;.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的： 很久以前：浏览器前缀CSS3和正常CSS3都不支持； 不久之前：浏览器只支持前缀CSS3，不支持正常CSS3； 现在：浏览器既支持前缀CSS3，又支持正常CSS3； 未来：浏览器不支持前缀CSS3，仅支持正常CSS3. 渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。 重绘和回流前提 浏览器使用流式布局模型 (Flow Based Layout)。 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。 回流必将引起重绘，重绘不一定会引起回流。 重绘定义: 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 回流定义: 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 导致回流的操作页面首次渲染浏览器窗口大小发生改变元素尺寸或位置发生改变元素内容变化（文字数量或图片大小等等）元素字体大小变化添加或者删除可见的DOM元素激活CSS伪类（例如：:hover）查询某些属性或调用某些方法 导致回流的属性clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftscrollIntoView()、scrollIntoViewIfNeeded()getComputedStyle()getBoundingClientRect()scrollTo() 性能影响回流比重绘的代价要更高。有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。当你访问以下属性或方法时，浏览器会立刻清空队列： 123456clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftwidth、heightgetComputedStyle()getBoundingClientRect() 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免CSS避免使用table布局。尽可能在DOM树的最末端改变class。避免设置多层内联样式。将动画效果应用到position属性为absolute或fixed的元素上。避免使用CSS表达式（例如：calc()）。 JavaScript避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 浏览器兼容性问题样式兼容性（css）方面 因为历史原因，不同的浏览器样式存在差异，可以通过 Normalize.css 抹平差异，也可以定制自己的 reset.css，例如通过通配符选择器，全局重置样式. 123* &#123; margin: 0; padding: 0;&#125; 在CSS3还没有成为真正的标准时，浏览器厂商就开始支持这些属性的使用了。CSS3样式语法还存在波动时，浏览器厂商提供了针对浏览器的前缀，直到现在还是有部分的属性需要加上浏览器前缀。在开发过程中我们一般通过IDE开发插件、css 预处理器以及前端自动化构建工程帮我们处理。如css-loader. 在还原设计稿的时候我们常常会需要用到透明属性，所以解决 IE9 以下浏览器不能使用 opacit。 123opacity: 0.5;filter: alpha(opacity = 50); //IE6-IE8我们习惯使用filter滤镜属性来进行实现filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); //IE4-IE9都支持滤镜写法progid:DXImageTransform.Microsoft.Alpha(Opacity=xx) 浏览器 hack1.快速判断 IE 浏览器版本 123&lt;!--[if IE 8]&gt; ie8 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; ie9 浏览器 &lt;![endif]--&gt; 2.判断是否是 Safari 浏览器 12/* Safari */var isSafari = /a/.__proto__=='//'; 3.判断是否是 Chrome 浏览器 12/* Chrome */var isChrome = Boolean(window.chrome); js兼容1.事件兼容的问题，我们通常需要会封装一个适配器的方法，过滤事件句柄绑定、移除、冒泡阻止以及默认事件行为处理 12345678910111213141516171819202122232425var helper = &#123;&#125;//绑定事件helper.on = function(target, type, handler) &#123;if(target.addEventListener) &#123; target.addEventListener(type, handler, false);&#125; else &#123; target.attachEvent("on" + type, function(event) &#123; return handler.call(target, event); &#125;, false);&#125;&#125;;//取消事件监听helper.remove = function(target, type, handler) &#123;if(target.removeEventListener) &#123; target.removeEventListener(type, handler);&#125; else &#123; target.detachEvent("on" + type, function(event) &#123; return handler.call(target, event); &#125;, true); &#125;&#125;; 2.new Date()构造函数使用，’2018-07-05’是无法被各个浏览器中，使用new Date(str)来正确生成日期对象的。 正确的用法是’2018/07/05’.3.获取 scrollTop 通过 document.documentElement.scrollTop 兼容非chrome浏览器 1var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;]]></content>
      <categories>
        <category>css</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F08%2F22%2FjQuery%2F</url>
    <content type="text"><![CDATA[选择器 jQuery基本选择器 解释 $(‘*‘) 匹配所有元素 $(‘#id’) id选择器 $(‘.class’) 类选择器 $(‘element’) 标签选择器 组合选择器 解释 $(‘E,F’) 多元素选择器，同时匹配E和F $(‘E F’) 后代选择器,用空格分隔,匹配E元素所有后代 $(‘E&gt;F’) 子元素选择器,匹配E元素所有直接子元素 $(‘E+F’) 直接相邻元素,匹配E元素之后的相邻的同级元素F $(‘E~F’) 普通相邻元素(弟弟选择器),匹配E元素之后的同级元素F(无论是否直接相邻) $(‘class1.class2’) 匹配类名中既含有class1又含有class2的元素 基本过滤选择器 解释 $(‘E:first’) 所有E中的第一个 $(‘E:last’) 所有E中的最后一个 $(‘E:not(selector)’) 按照selector过滤E $(‘E:even’) 所有E中index是偶数 $(‘E:odd’) 所有E中index是奇数 $(‘E:eq(n)’) 所有E中index为n的元素 $(‘E:gt(n)’) 所有E中index大于n的元素 $(‘E:lt(n)’) 所有E中index小于n的元素 $(‘header’) 选择h1~h6元素 $(‘div:animated’) 选择正在执行动画效果的元素 内容过滤器 解释 $(‘E:contains(value)’) 内容包含value的元素 $(‘E:empty’) 内容为空的元素 $(‘E:has(F)’) 子元素中有F的元素,$(‘div:has(a)’):包含a标签的div $(‘E:parent’) 父元素是E的元素 可视化选择器 解释 $(‘E:hidden’) 所有被隐藏的E $(‘E:visible’) 所有可见的E 属性过滤选择器 解释 $(‘E[attr]’) 含有属性attr的E $(‘E[attr=value]’) 属性attr=value的E $(‘E[attr !=value]’) 属性attr！=value的E $(‘E[attr ^=value]’) 属性attr以value开头的E $(‘E[attr $=value]’) 属性attr以value结尾的E $(‘E[attr *=value]’) 属性attr包含value的E $(‘E[attr][attr*value]’) 可以连用 子元素过滤器 解释 $(‘E:nth-child(n)’) E的第n个子节点 $(‘E:nth-child(3n+1)’) E的第3n+1个子节点 $(‘E:nth-child(even)’) E的index为偶数的子节点 $(‘E:nth-child(odd)’) E的index为奇数的子节点 $(‘E:first-child’) 所有E的第一个子节点 $(‘E:last-child’) 所有E的最后一个子节点 $(‘E:only-child’) 只有唯一子节点的E的子节点 表单元素选择器 解释 $(‘E:type’) 特定类型的input $(‘:checked’) 被选中的checkbox或者radio $(‘option:selected’) 被选中的option 其他查找相关元素的方法.eq(index), .get([index])$(&#39;div&#39;).eq(3) //获取所有div中第4个jQuery对象$(&#39;div&#39;)[2] 或者 $(&#39;div&#39;).get(2) //获取第三个的DOM对象get()不写参数把所有对象转为DOM对象返回 兄弟元素获取 选择器 解释 .next([selector]) 没有写selcetor,返回所有后面的兄弟元素.写了就返回满足条件的 .prev([selector]) 和上面相反,获取前面的兄弟元素 .nextAll([selector]) 获取所有后面的兄弟元素 .prevAll([selector]) 获取所有前面的兄弟元素 .siblings([selector]) 获取所有前后邻居的元素 父子元素获取 选择器 解释 .parent([selector]) 获取父元素,可选筛选器 .parents([selector]) 获取祖先元素,可选筛选器 .children([selector]) 获取子元素,可选筛选器 .find([selector]) 查找符合选择器的后代 筛选当前结果集 选择器 解释 .first() 获取当前结果集第一个对象 .last() 获取当前结果集最后一个对象 .filter(slector), .filter(function(index)) 筛选当前结果集符合条件的对象 .not(selector), .not(function(index)) 从当前结果集中移除指定元素 .is(selector), is(function(index)), is(dom/jqObj) 判断结果集中的元素，是否为一个选择器，DOM元素，或者jQuery对象，如果这些元素至少一个匹配给定的参数，那么返回true .has(seletor), has(dom) 筛选匹配结果集中符合条件的后代元素 jQueryDOM操作创建元素将DOM传入$方法即可返回一个jQuery对象var obj = $(&#39;&lt;div class=&quot;test&quot;&gt;&lt;p&gt;&lt;span&gt;Done&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&#39;) 添加元素 方法 解释 示例 .append(content[,content]) / .append(function(index,html)) 可以添加多个内容,DOM对象,字符串,jQuery对象 $(‘p’).append($newdiv); $(‘p’).append($(‘strong’)); $(‘p’).append(document.createTextNode(‘hello’)) .appendTo(target) 把对象插入到目标target尾部,可以是selector,DOM对象,字符串,元素集合,jQuery对象(最后一个孩子) $(‘h2’).appendTo($(‘.container’)); $(‘&lt;p&gt;Test&lt;/p&gt;’).appendTo(‘.inner’) .prepend(content[,content]) / .prepend(function(index, html)) 向头部追加内容,内容添加到最前面(第一个孩子) $(‘.inner’).prepend(‘&lt;p&gt;Test&lt;/p&gt;’) .prependTo(Target) 把对象插入到目标头部 $(‘&lt;p&gt;Test&lt;/p&gt;’).prependTo(‘.inner’) .before([content][,content]) / .before(function) 在对象前面(不是头部,而是外面,和对象并列同级)插入内容(放到前面做邻居) $(‘.inner’).before(‘&lt;p&gt;Test&lt;/p&gt;’); $(‘.container’).before($(‘h2’)); $( “p” ).before( document.createTextNode( “Hello” ) ) .insertBefore(target) 把对象插入到target之前(不是头部,是同级)(做邻居) $(‘h2’).insertBefore($(‘.container)) .after([content][,content]) / .after(function（index）) 和before相反，在对象后面(不是尾部，而是外面，和对象并列同级)插入内容，参数和append类似 $( “.inner” ).after( “&lt;p&gt;Test&lt;/p&gt;” ); $( “p” ).after( document.createTextNode( “Hello” ) ); .insertAfter(target) 和insertBefore相反，把对象插入到target之后（同样不是尾部，是同级） $( “&lt;p&gt;Test&lt;/p&gt;” ).insertAfter( “.inner” ); $( “p” ).insertAfter( “#foo” ); 删除元素 方法 解释 示例 .remove([selector]) 删除被选元素及其子元素 $(‘.div’).remove() .empty() 清空被选元素内所有子元素 $(‘body’).empty() .detach() .detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。 $(‘.div’).detach() 包裹元素 方法 解释 示例 .wrap(wrapElement) / .wrap(function(index)) 为每个对象包裹一层HTML结构，可以是selector, element, HTML string, jQuery object $( “.inner” ).wrap( “&lt;div class=’new’&gt;&lt;/div&gt;” ) .wrapAll(wrappingElement) 把所有匹配对象包裹在同一个html结构里 $(‘.inner’).wrapAll(‘&lt;div class=”new”&gt;&lt;/div&gt;) .wrapInner(wrapingElement) 为每个匹配的对象包裹一层HTML结构 $(‘.inner’).wrapInner(‘&lt;div class=”new”&gt;&lt;/div&gt;) .unwrap 把DOM元素外的壳去掉 $(‘p’).unwrap() html([string])$(&#39;div&#39;).html()$(&#39;div&#39;).html(&#39;123&#39;)这是一个读写两用的方法,用于获取修改元素的innerHTML 没有传递参数的时候,返回元素的innerHTML 当传递一个string参数时,修改元素的innerHTML为参数值 text()和html方法类似，操作的是DOM的innerText值 jQuery属性操作属性相关.val([value])这是一个读写双用的方法,用来处理input的value值,当方法没有参数时返回input的value值.当传递一个参数时,方法修改input的value值为参数值. 12$('.input').val()$('.input').val('newValue') .attr().attr(attributeName)获取元素特定属性的值var title = $(&#39;em&#39;).attr(&#39;title&#39;) .attr(attributeName,value)/.attr(attributesJson)/.attr(attributeName,funtion(index,attr))为元素属性赋值$( &quot;#greatphoto&quot; ).attr( &quot;alt&quot;, &quot;Beijing&quot; ) .removeAttr()为匹配的元素集合中的每个元素移除一个属性$(&#39;div&#39;).removeAttr(&#39;id&#39;) .prop()/.removeProp()这两个方法是用来操作元素的property的 CSS相关.css().css(propertyName) / .css(propertyNames)获取元素style特定property的值 12345678var color = $( this ).css( "background-color" )var styleProps = $( this ).css([ "width", "height", "color", "background-color"]) .css(propertyName,value)/.css(propertyName,function(index,value))/ .css(propertiesJson)设置元素style特定property的值 123456789101112$( "div.example" ).css( "width", function( index ) &#123; return index * 50;&#125;)$( this ).css( "width", "+=200" )$( this ).css( "background-color", "yellow" )$( this ).css(&#123; "background-color": "yellow", "font-weight": "bolder"&#125;) .addClass(className) / .addClass(function(index,currentClass))为元素添加class，不是覆盖原class，是追加，也不会检查重复 12345$( "p" ).addClass( "myClass yourClass" )$( "ul li" ).addClass(function( index ) &#123; return "item-" + index;&#125;) .removeClass([className])/.removeClass(function(index,class))移除元素单个/多个/所有class 12345$( "p" ).removeClass( "myClass yourClass" );$( "li:last" ).removeClass(function() &#123; return $( this ).prev().attr( "class" );&#125;) .hasClass(className)检查元素是否包含某个class，返回true/false 1$( "#mydiv" ).hasClass( "foo" ) .toggleClass(className)toggle是切换的意思，方法用于切换，switch是个bool类型值 123456789&lt;div class="tumble"&gt;Some text.&lt;/div&gt;//第一次执行 $( "div.tumble" ).toggleClass( "bounce" )&lt;div class="tumble bounce"&gt;Some text.&lt;/div&gt;//第二次执行$( "div.tumble" ).toggleClass( "bounce" )&lt;div class="tumble"&gt;Some text.&lt;/div&gt; jQuery常用方法.each(fnction(index, Element))遍历一个jQuery对象,为每个匹配元素执行一个函数 12345$('li').each(function(index)&#123; console.log(index + ':' + $(this).text())&#125;)//回调函数返回的是DOM对象,所以this需要加$变成jQuery对象才能使用.text()方法//否则使用this.innerText方法 jQuery.each(collection, callback(indexInArray, valueOfElement))一个通用迭代函数,可以迭代对象和数组.数组和类数组对象通过长度属性来迭代数字索引,从0到length-1.其他对象通过其属性名进行迭代.上面jQuery可以用$替代,即$.each(). 1234567var obj = &#123; "fla" : "infla", "duh" : " no duh"&#125;$.each(obj, function(key, value)&#123; console.log(key + ":" + value)&#125; .map(callback(index, domElement))通过一个函数匹配当前集合中的每个元素,返回一个包含新的jQuery对象 123$('.div').map(function(i, ele)&#123; return this.id&#125;) jQuery.extend([deep,]target[,ovject1][,objectN]) 当提供两个或多个对象给$.extend(),对象的所有属性都添加到目标对象(target参数). 如果只有一个参数提供给$.extend(),这意味着目标参数被省略,在这种情况下,jQuery对象本身默认为目标对象.这样我们可以在jQuery的命名空间下添加新功能.var obj = $.extend({}, object1, object2)object1,object2会被添加到{}中 如果第一个对象的属性本身是一个数组或对象,那它将完全用第二个对象相同的key重写一个属性.这些值不会被合并.如果true作为第一个参数,那么会在对象上进行递归的合并. .clone([withDataAndEvents]).clone()方法深度复制所有匹配的元素集合,包括所有匹配元素,匹配元素的下级,文字节点.$(&#39;.hello&#39;).clone().appendTo(&#39;.Goodbye&#39;) .index()/.index(selector)/.index(element)从给定集合中查找特定元素index 没参数返回第一个元素index 如果参数是DOM对象或jQuery对象,则返回参数在集合中的index 如果参数是选择器,返回第一个匹配元素的index,没有找到返回-1 12var listItem = $('.bar')console.log('Index:' + $('li').index( listItem )) .ready(handler)当DOM加载完毕,执行.下面两种等价 $(document).ready(handler) $(handler) jQuery事件.on(events[,selector][,data],handler(eventObject)) events: 一个或多个空格分隔的事件类型和可选空间 selector: 一个选择器字符串,用于过滤被选中的元素中能触发事件的后代元素.如果选择器是null或者忽略,那么被选中的元素总能触发事件 data: 当一个事件被触发,要传递给事件处理函数的event.data handler(eventObject): 事件被触发时,执行的函数. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class="box"&gt;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;input id="ipt" type="text"&gt;&lt;button id="btn"&gt;添加&lt;/button&gt;&lt;div id="wrap"&gt;&lt;/div&gt;&lt;script&gt;$('.box li').on('click',function()&#123; console.log(1) var str = $(this).text() $('#wrap').text(str)&#125;)//等同于$('.box&gt;ul&gt;li').click(function()&#123; console.log(2) var str = $(this).text() $('#wrap').text(str)&#125;)//下面新增的元素是没有绑定事件的$('btn').on('click',function()&#123; var value = $('#ipt').val() $('.box&gt;li').append('&lt;li&gt;' + value + '&lt;/li&gt;')&#125;)//可以用事件代理$('.box ul').on('click','li',function()&#123; var str = $(this).text() $('#wrap').text(Str)&#125;)//上面代码换成原生js代码document.querySelector('.box ul').addEventListener('click',function(e)&#123; if(e.target.tagName.toLowerCase() === 'li')&#123; //do something &#125;&#125;)&lt;/script&gt; .one(events[,selector][,data],handler(eventObject))同on，绑定事件，但只执行一次 .off(events[,selector][,handler])移除一个事件处理函数$(&#39;.box li&#39;).off(&#39;click&#39;) .trigger(eventType[,extraParameters])根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为 1234$('#foo').on('click', function() &#123; console.log($(this).text())&#125;);$('#foo').trigger('click') 其他事件blur([[data],fn])change([[data],fn])click([[data],fn])dblclick([[data],fn])error([[data],fn])focus([[data],fn])focusin([data],fn)focusout([data],fn)keydown([[data],fn])keypress([[data],fn])keyup([[data],fn])mousedown([[data],fn])mouseenter([[data],fn])mouseleave([[data],fn])mousemove([[data],fn])mouseout([[data],fn])mouseover([[data],fn])mouseup([[data],fn])resize([[data],fn])scroll([[data],fn])select([[data],fn])submit([[data],fn]) 事件对象eve.currentTargeteve.dataeve.delegateTargeteve.isDefaultPrevented()eve.isImmediatePropag…()eve.isPropagationStopped()eve.namespaceeve.pageXeve.pageYeve.preventDefault()eve.relatedTargeteve.resulteve.stopImmediatePro…()eve.stopPropagation()eve.targeteve.timeStampeve.typeeve.which jQuery动画基础.hide([duration][,easting][,fn]) duration: 三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) easing: 用来指定切换效果，默认是”swing”，可用参数”linear” fn: 在动画完成时执行的函数，每个元素执行一次。用于隐藏元素,没有参数等同于直接设置display属性 12$('.target').hide()//等同于$('.target').css('display','none') 123$('#book').hide(300, 'linear', function() &#123; console.log('Animation complete.') &#125;) .show([duration][,easing][,fn])显示元素,用法类似hide .toggle([duration][,easing][,fn])事件处理套件也有一个名为.toggle()方法。哪一个被调用取决于传递的参数的设置用来切换元素的隐藏、显示，类似于toggleClass，用法和show、hide类似 渐变.fadeIn( [duration ] [, easing ] [, complete ] )渐入效果 .fadeOut( [duration ] [, easing ] [, complete ] )渐出效果 .fadeTo( duration, opacity [, easing ] [, complete ] )调整匹配元素的透明度，方法通过匹配元素的不透明度做动画效果 123$('#book').fadeTo('slow', 0.5, function() &#123; // Animation complete.&#125;) fadeToggle([speed,[easing],[fn]])通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数。这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。 1234$("p").fadeToggle("fast",function()&#123; alert("Animation Done.") &#125;) //用200毫秒快速将段落淡入，之后弹出一个对话框 slideDown([speed],[easing],[fn]) 下拉动画.这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式显示出来。 slideUp([speed,[easing],[fn]]) 上浮动画,向上隐藏,在隐藏完成后可选地触发一个回调函数。 slideToggle([speed],[easing],[fn]) 上下切换 动画队列 因为动画是异步,所以将动画执行函数放入回调函数中,等动画执行完毕再执行其他的. 但是这样写会形成回调地狱.又因为存在动画队列,可以按代码二方法执行会有同样效果. 12345678910111213141516171819202122 $box.hide(1000, function()&#123; $box.show(1000, function()&#123; $box.fadeOut('slow',function()&#123; $box.fadeIn('slow',function()&#123; $box.slideUp(function()&#123; $box.slideDown(function()&#123; console.log('动画执行完毕') &#125;) &#125;) &#125;) &#125;) &#125;)&#125;)//等价于$box.hide(1000) .show(1000) .fadeOut() .fadeIn() .slideUp() .slideDown(function()&#123; console.log('真的完毕了') &#125;) 自定义动画animate(params,[speed],[easing],[fn])这个函数的关键在于指定动画形式及结果样式属性对象。这个对象中每个属性都表示一个可以变化的样式属性（如“height”、“top”或“opacity”）。注意：所有指定的属性必须用驼峰形式，比如用marginLeft代替margin-left. params:一组包含作为动画属性和终值的样式属性和及其值的集合 speed:三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) easing:要使用的擦除效果的名称(需要插件支持).默认jQuery提供”linear” 和 “swing”. fn:在动画完成时执行的函数，每个元素执行一次。 .finish停止当前动画，并清除动画队列中所有未完成的动画,最终展示动画队列最后一帧的最终状态 .stop( [clearQueue] [,jumpToEnd])停止当前正在运行的动画 AJAXjQuery.ajax(url,[settings])jQuery底层AJAX实现.$.ajax()返回其创建的XMLHttpRequest对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。最简单的情况下，$.ajax()可以不带任何参数直接使用。注意，所有的选项都可以通过$.ajaxSetup()函数来全局设置。回调函数如果要处理$.ajax()得到的数据，则需要使用回调函数。beforeSend、error、dataFilter、success、complete。 beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。 error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter 在请求成功之后调用。传入返回的数据以及”dataType“参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。 success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。 12345678910111213141516$.ajax(&#123; url: 'test.com', type: 'GET', datatype: json, data: &#123; name: 'tom', age: '12' &#125;, &lt;!-- success: function(result)&#123; console.log(result) &#125; --&gt;&#125;).done(function(result)&#123; console.log(result)&#125;).fail(function(jqXHR, textStatus)&#123; consloe.log(textStatus)&#125;) url: 一个用来包含发送请求的URL字符串。settings: AJAX请求设置。所有选项都是可选的。 seting中的设置 async：默认设置下，所有请求均为异步请求（也就是说这是默认设置为 true ）。如果需要发送同步请求，请将此选项设置为 false beforeSend：请求发送前的回调函数，用来修改请求发送前jqXHR对象，此功能用来设置自定义 HTTP 头信息该jqXHR和设置对象作为参数传递 cache：如果设置为 false ，浏览器将不缓存此页面。注意: 设置cache为 false将在 HEAD和GET请求中正常工作。它的工作原理是在GET请求参数中附加”_={timestamp}” context：这个对象用于设置Ajax相关回调函数的上下文。默认情况下，这个上下文是一个ajax请求使用的参数设置对象 data：发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后面，POST请求作为表单数据 headers：一个额外的{键:值}对映射到请求一起发送。此设置会在beforeSend 函数调用之前被设置;因此，请求头中的设置值，会被beforeSend 函数内的设置覆盖 type: 请求方式 (“POST” 或 “GET”)，默认为 “GET”。注意:其它HTTP请求方法，如PUT和DELETE也可以使用，但仅部分浏览器支持。 jQuery.get( [settings] ) / jQuery.post( [settings ] )这两个方法专门用来处理get和post请求 123$.get('test.html',function(data)&#123; $('.result').html(data)&#125;) jQuery.getJSON(url[,data][,success(data,textStatus,jqXHR)])使用一个HTTP GET请求从服务器加载JSON编码的数据范例 123456789101112$.getJSON('ajax/test.json', function(data) &#123; var items = []; $.each(data, function(key, val) &#123; items.push('&lt;li id="' + key + '"&gt;' + val + '&lt;/li&gt;'); &#125;); $('&lt;ul/&gt;', &#123; 'class': 'my-new-list', html: items.join('') &#125;).appendTo('body');&#125;); .load(url[,data][,complete(responseText,textStatus,XMLHttpRequest)])从服务器载入数据并且将返回的HTML代码并插入至匹配的元素中$(&#39;#result&#39;).load(&#39;ajax/test.html&#39;) .serialize() / serializeArray()将用作提交的表单元素的值编译成字符串，方法没有参数，使用标准的 URL-encoded 符号上建立一个文本字符串.它可以对一个代表一组表单元素的 jQuery 对象进行操作，比如&lt;input&gt;, &lt;textarea&gt;, 和 &lt;select&gt;: 123456789101112131415161718192021222324&lt;form id="holder"&gt; &lt;input type="text" name="a" value="1"/&gt; &lt;div&gt; &lt;input type="text" name="b" value="2" id="b" /&gt; &lt;/div&gt; &lt;input type="hidden" name="c" value="3" id="c" /&gt; &lt;div&gt; &lt;input type="checkbox" name="f" value="8" checked="true"/&gt; &lt;input type="checkbox" name="f" value="9" checked="true"/&gt; &lt;/div&gt;&lt;/form&gt;$("#holder").serialize(); //a=1&amp;b=2&amp;c=3&amp;f=8&amp;f=9$("#holder").serializeArray();/* [ &#123;name: 'a', value: '1'&#125;, &#123;name: 'b', value: '2'&#125;, &#123;name: 'c', value: '3'&#125;, &#123;name: 'f', value: '8'&#125;, &#123;name: 'f', value: '9'&#125; ]*/ serialize和serializeArray都是针对JQuery对象(选中的form元素)进行操作，只是返回值格式不同而已。这里特别要注意：这2个API只能操作form，如果将holder改成div，会发现不起作用 jsonp123456789function getBooks()&#123; $.ajax(&#123; type:'get', url:'http://test.com/bookservice.php', dataType:'jsonp', jsonp:'callback', jsonpCallback:'displayBooks' &#125;);&#125; 当然使用jsonp会在一定程度上造成安全性问题，如果请求的站点不是信任站点，那么可能会在返回的方法调用中包含一些恶意代码。所以尽量向信任的站点发送请求。另外xss也经常会利用jsonp向站点注入恶意代码。]]></content>
      <categories>
        <category>JS</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础]]></title>
    <url>%2F2019%2F08%2F21%2FHTTP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ajaxajax是一种技术方案，核心依赖浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出http请求与接受响应。 如何与后端交互 form表单提交.缺点会跳转，无后台反馈 ajax websocket 实现方法 XMLHttpRequest对象(该对象支持同步和异步请求) fetch 范例1234567891011121314var xhr = new XMLHttpRequst() //true默认是异步的方式,false是同步的方式xhr.open("get", "/xxx.com", true) xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; //成功 console.log(xhr.responseText) &#125; else &#123; console.log("服务器异常") &#125; &#125;//发送请求xhr.send() API123456789101112131. let xhr = new XMLHttpRequest();2. xhr.open('GET','/xxx') //初始化xhr3. xhr.send() //发送请求4. xhr.onreadystatechange //监听请求状态的变化&lt;readystatechange&gt;是一个事件5. xhr.readyState === 1 //xhr.open()已经完成6. xhr.readyState === 2 //xhr.send()已经完成7. xhr.readyState === 3 //xhr.responseText正在下载5. xhr.readyState === 4 //响应完成6. xhr.status //HTTP状态码7. var string = xhr.responseText //响应的内容8. var value = JSON.parse(xhr.responseText) //把符合JSON语法的字符串转换成JS，解析响应返回的内容9. value.node //若value是对象，这就是对象里内容10. value.node.name //对象里的name的值 post形式需要将数据放入到send中 跨域同源策略同协议，域名，端口 实现跨域的方法JSONPJSON with padding 通过script标签加载数据的方式获取数据当做js代码来执行。jsonp需要对应接口的后端配合才可以实现。 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; "ip": "8.8.8.8"&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 必考面试题：JSONP为什么不支持POST请求答：因为JSONP是通过动态创建script的方法进行的，而script只能发送get请求不能发送post请求。 jquery的写法12345678$.ajax(&#123; url:"http://jack.com:8002/pay", dataType: "jsonp", success:function (response) &#123; console.log(response) &#125; &#125; &#125;) axios写法1234567this.$http = axios;this.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'handleCallback'&#125;).then((res) =&gt; &#123; console.log(res); &#125;) CORS跨域资源共享，是一种ajax跨域请求资源的方式。写法就是普通的ajax写法.不过在浏览器请求上加点处理.而且是浏览器自动处理的.当使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给请求加一个请求头:Origin。后台进行处理，如果确定接受请求，则在返回结果中加响应头：Access-Control-Allow-Origin。浏览器判断该响应头中是否包含Origin的值，如果有，浏览器会处理响应，就可以拿到响应数据。 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; postMessage A页面 1234567891011121314151617181920componentDidMount() &#123; window.addEventListener('message', this.receiveMessage, false) const iframeImg = this.iframe.contentWindow iframeImg.onload = function() &#123; iframeImg.postMessage('message', 'http://www.blogoog.com:8088') &#125;&#125;receiveMessage = (event) =&gt;&#123; const origin = event.origin || event.originalEvent.origin const thisData = JSON.parse(event.data) const imgUrl = Object.values(thisData) this.setState(&#123; imgUrl &#125;) setTimeout(() =&gt;&#123; this.closeIframe(); message.success('上传成功') &#125;,1000) if (origin !== 'http://www.blogoog.com:80881) &#123; window.location.hash = '#/exception/404' &#125;&#125; 123&lt; iframe className = &#123; styles.iframeWrap &#125;src="http://www.blogoog.com:8088" name="imgIframe" frameBorder="0" scrolling="auto" ref=&#123;dom =&gt; &#123;this.iframe = dom &#125;&#125;&gt;您的浏览器不支持iframe&lt;/iframe&gt; A页面使用的语法 window.postMessage()otherWindow.postMessage(message, targetOrigin, [transfer]) otherWindow：其他窗口的一个引用（在这里我使用了iframe的contentWindow属性） message：将要发送到其他window的数据（可以不受限制的将数据对象安全的传送给目标窗口而无需自己序列化，原因是因为采用了结构化克隆算法） targetOrigin：接收信息的URL（在这里我当然填的B页面的URL） transfer：可选参数 window.addEventListener(‘message’, receiveMessage, false)target.addEventListener(type, listener, options) type：表示监听事件类型的字符串 listener：当所监听的事件类型触发时，会通知的一个对象或者一个函数 potions：可选参数（在此我用false，表示在listener被调用之后不会自动移除） receiveMessage = (event) =&gt; {} event.data：从另一个window传递过来的对象（包含传递过来的所有信息） event.origin||event.originalEvent.origin：window.postMessage()发送消息的目标URL event.source：对发送消息的窗口对象的引用注意点！！！ 在页面内嵌入iframe页面的情况下，需要等到页面内的iframe页面，也就是B页面加载完成之后，才能进行postMessage跨域通信 event.origin中的origin不能保证是该窗口的当前origin或者未来origin，因为postMessage被调用后，可能会被导航到不同的位置，所以需要做个异常情况判断处理origin !== &#39;http://www.blogoog.com:8088&#39; B页面 123456789101112created() &#123; window.addEventListener&#123;"message", this.receiveMessage, false) &#125;,receiveMessage(e) &#123; if (e origin === 'http://www.blogoog.com:8080' || e.origin === 'http://www.blogoog.com:8088') &#123; this.sendBtnShow = true this.originSource = e.origin this.magicBuildData = JSON.parse(e.data) &#125;, sendMsg() &#123; top.postMessage(JSON.stringify(data), 'http://www.blogoog.com:8000') &#125; B页面使用到的语法 top.postMessage(&#39;data&#39;, &#39;http://www.blogoog.com:8000&#39;)参考上面A页面的语法为什么用top而不用window下面再讲window.addEventListener(&#39;message&#39;, receiveMessage, false)参考上面A页面的语法receiveMessage = (event) =&gt; {}参考上面A页面的语法 window.postMessage()中的window到底是啥？始终是你需要通信的目标窗口 A页面中：A页面向B页面发送跨域信息，window就是在A页面中嵌入的iframe指向的B页面的window，即：iframe.contentWindow B页面中：B页面想A页面发送跨域信息，window就是A页面的window，在这里因为B页面时嵌入到A页面中的，对于B页面来讲，window就是top或者parent 需要特别注意的坑 一定要等A页面嵌入的B页面加载完成之后，再进行postMessage跨域通信 一定要对origin做判断，去掉不是来自我们目标窗口的origin，防止来自其他origin的攻击 着重注意window.postMessage()中window的用法，明确目标窗口的window websocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type="text"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; 后端node 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); 标签iframeHTML内联框架元素&lt;iframe&gt; 表示嵌套的browsing context。它能够将另一个HTML页面嵌入到当前页面中。 123&lt;iframe src="https://mdn-samples.mozilla.org/snippets/html/iframe-simple-contents.html" title="iframe example 1" width="400" height="300"&gt; &lt;p&gt;Your browser does not support iframes.&lt;/p&gt;&lt;/iframe&gt; canvas标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API source定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; command定义命令按钮，比如单选按钮、复选框或按钮 figure规定独立的流内容（图像、图表、照片、代码等等） nav导航 section定义文档中的节（section、区段） HTTP报文HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，描述报文的内容及含义，后面跟着可选的数据部分 URI和URLURI：统一资源标识符URL：统一资源定位符 报文组成 对报文进行描述的起始行 —— start line 包含属性的首部块 —— header 可选的包含数据的主体部分 —— body 报文语法 请求报文： 向web服务器请求一个动作 1234&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 响应报文 把请求结果返回给客户端 1234&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; 状态码服务器和浏览器之间的约定 分类:100-199 用于指定客户端应相应的某些动作。200-299 用于表示请求成功。300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。400-499 用于指出客户端的错误。500-599 用于支持服务器错误。 状态码 状态信息 解释 100 Continue 初始请求已接受,继续发送 101 switching Protocols 服务器遵从客户请求转换到另一种协议 200 OK 请求成功 201 Created 服务器已经创建了文档,Location头给出了他的URL 202 Accepted 已接受请求,但处理尚未完成 203 Non-Authoritative Information 文档已正常返回但一些应答头可能不正确,因为使用的是文档的拷贝 204 No Content 服务器接到请求已经处理完毕,但浏览器页面不会刷新 205 Reset Content 没有新内容,但浏览器应该重置它所显示的内容,用来强制浏览器清除表单输入内容. 206 Partial Content 客户发送了一个带有Range头的GET请求,服务器完成了它 300 Multiple Choices 客户请求的文档可以在多个位置找到,这些位置已经在返回的文档中列出.如果服务器要提出优先选择,则应该在Location应答头指明 301 Moved Permanently 永久重定向,请求的网页已经永久移动到新位置 302 Found 临时重定向,POST方法的重定向在未询问用户的情况下就会变成GET 303 See Other 类似301/302,不同之处在于,原来的请求是POST,现在是GET 304 Not Modified 自从上次请求后,网页未被修改过 305 Use Proxy 使用代理服务器 307 Temporary Redirect 临时重定向，不同之处,把POST转为GET 400 Bad Request 请求出现语法错误 401 Unauthorized 用户未授权,需要用户验证 403 Forbidden 服务器已经理解请求,但是拒绝执行 404 Not Found 服务器找不到请求的网页 405 Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权 408 Request Timeout 请求超时 500 Internal Server Error 服务器遇到错误,无法完成请求 503 Service Unavailable 由于临时的服务器维护或过载,暂时无法处理请求 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。 HTTP请求方法 GET 请求服务器发送某个资源 HEAD 与GET方法类似,但是在服务器的响应中没有资源的内容,只有资源的一些基本信息,主要用于 在不获取资源的情况下获取信息(类型,大小等) 通过状态码看资源是否存在 通过查看首部,测试资源是否被修改 PUT 和GET从服务器获取资源相反,PUT用于向服务器写入资源.PUT的语义就是让服务器用请求的主体部分创建一个请求URL命名的文档.如果存在就替换 POST POST用于向服务器发送数据,通常用来支持HTML的表单(input,select,textarea),表单中的数据会被发送到服务器 TRACE 客户端发送一个请求,这个请求可能会穿过防火墙,代理,网关,和一些其他应用程序,每个中间节点都可以修改HTTP请求,TRACE方法允许客户端在最终请求发往服务器的时候,看看他变成了什么样子TRACE请求会在目的服务器端发送一个”闭环”诊断,行程最后一站服务器会弹回一条TRACE响应,并在响应主题中携带他收到的原始请求报文 DELETE 用于要求服务器删除请求的URL,和PUT一样,服务器可能不支持 OPTIONS 用于请求服务器告知其支持的各种功能 浏览器缓存缓存是一种保存资源副本并在下次请求时直接使用该副本的技术.HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，分为两大类(强制缓存，协商缓存)http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。 cache-controlcache-control通常用于优化网页性能,适当使用可减少重复读取相同内容可以在服务端setHeader设置cache-control可以设置让该字段存于缓存中,浏览器下次访问时不发起请求,直接从缓存中读取该资源 ETagETag通常用于优化网页性能,适当使用可减少重复读取相同内容可通过服务端setHeader设置etag为相应的字段的md5值浏览器访问时,request.headers会带有if-none-match属性(为上述MD5),若不等于则说明服务器上的该资源与本地存储的该资源不相同,需要重新从服务器加载;若相等则说明两者资源相同,则直接从本地缓存获取.后端应设置statusCode=304.与cache-control不同的是:etag始终都要发请求和收响应,而cache-control不发请求. cookie存储信息到浏览器，可以用js设置，也可以在服务器端通过set-cookie让浏览器种下cookie，存在于响应头里。每次请求都会带上cookie，最大容量4k用途：记录用户名 设置cookie时的参数： path: cookie影响到的路径，匹配该路径才发送cookie expires和maxAge:告诉浏览器cookie多久过期不设置就会产生session cookie，当关闭浏览器，cookie就被清除 secure: 为true时，在http无效，在https生效 httpOnly: 浏览器不允许通过js修改cookie session用来保存状态。当用户输入用户名密码提交给服务器后，服务器验证通过后创建session用于记录用户信息，session可保存在服务器，也可以保存在数据库 创建session后，会把关联的session_id通过是set-cookie添加到响应头 浏览器加载页面发现有set-cookie字段，就把这个cookie种到指定域名下 下次刷新页面，发送的请求带上cookie，服务器接受后根据session_id来识别用户 cookie和session的区别:cookie是存储在浏览器中的一小段数据,session是让服务器识别某个用户的机制session.在实现过程中需要使用cookie.二者不是同一维度的东西. localStorage 本地存储，永不过期，除非手动js删除。5M大小。 不参与网络传输 一般用于性能优化 localStorage的存储,获取,删除只支持字符串存储. 1234567891011//存储localStorage.setItem('myCat', 'Tom')//读取localStorage.getItem('Tom')//移除localstorage.removeItem('myCat')//移除所有localstorage.clear() sessionstorage与localstorage类似,属于本地存储与上面的session无关.但是关闭浏览器失效. 浏览器缓存机制通俗语言版(自我理解)12Cache-Control: max-age=300；ETag:W/"e-cbxLFQW5zapn79tQwb/g6Q" 浏览器第一次请求a.jpg这张图片,服务器发回一张图片,并且附送一个ETag(相当于一个用于验证的文件).浏览器把这张图片和ETag缓存到本地.如果在300秒内,浏览器又请求这张图片,那么直接从缓存中读取这张图.如果超过300秒,浏览器发现已经过了时间了,就重新向服务器发请求,并且附带之前给的ETag.服务器拿着当前文件计算后的ETag和浏览器发回的ETag比较,如果一样,说明图片没换,发回一个响应头(不包含图片,304,表示文件没修改,还能用).如果不一样,就把新的文件和新的ETag发回去.另外还有Last-Modified/If-Modified-Since.和ETag功能类似.因为服务器可能不止一个,文件存储在不同的服务器,那就给请求文件上附带上Last-Modified声明,请求时带上If-Modified-Since,表明服务器上一次修改这个文件的时间,拿来和服务器上记录的最后修改时间对比.如果修改时间比较新,说明被动过,发回一个新文件.如果时间比较旧,说明不用换,发回304,使用缓存即可. 严谨说法浏览器缓存控制分为强缓存和协商缓存，协商缓存必须配合强缓存使用。 首先浏览器第一次跟服务器请求一个资源，服务器在返回这个资源和response header的同时，会根据开发者要求或者浏览器默认，在response的header加上相关字段的http response header。 一、当浏览器对某个资源的请求命中了强缓存时，利用[Expires]或者[Cache-Control]这两个http response header实现。 [Expires]：描述的是一个绝对时间，根据的是客户端时间。用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT 下次浏览器再次请求同一资源时。先从客户端缓存中寻找，找到这个资源后，拿出它的[Expires]跟当前的请求时间比较。如果请求时间在[Expires]指定的失效时间之前，就能命中缓存，这样就不用再次到服务器上去缓存一遍，节省了资源。但是正因为是绝对时间，如果客户端时间被随意更改下，这个机制就失效了。所以我们需要[Cache-Control]。 [Cache-Control]：描述的是一个相对时间，在进行缓存命中时，都是利用浏览器时间判断。 这两个header可以只启用一个，也可以同时启用，当response header中，[Expires]和[Cache-Control]同时存在时，[Cache-Control]优先级高于[Expires]。 二、当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中。如果命中，则还是从客户端缓存中加载。协商缓存利用的是[Last-Modified，If-Modified-Since]和[ETag、If-None-Match]这两对Header来管理的。 [Last-Modified]：原理和上面的[expires]相同，区别是它是根据服务器时间返回的header来判断缓存是否存在。但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况（这种问题也不容易被定位），这时候我们需要[ETag、If-None-Match]。 [ETag、If-None-Match]：原理与上相同，区别是浏览器跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同。 [ETag、If-None-Match]这么厉害我们为什么还需要[Last-Modified、If-Modified-Since]呢？有一个例子就是分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样） [Last-Modified，If-Modified-Since]和[ETag、If-None-Match]一般都是同时启用。 HTTPS原理HTTP+SSL/TLS， 即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL，用于安全的HTTP数据传输。 加密算法： 对称加密有流式、分组两种，加密和解密都是使用的同一个密钥。 非对称加密加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的 哈希算法将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 数字签名签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 简单通信流程概括来说，整个简化的加密通信的流程就是： 小明访问网站，网站将自己的证书给到小明（其实是给到浏览器，小明不会有感知） 浏览器从证书中拿到网站的公钥A 浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给网站（其实是有协商的过程，这里为了便于理解先简化） 网站通过私钥解密，拿到对称密钥B 浏览器、网站 之后的数据通信，都用密钥B进行加密 存在的问题证书可能存在的问题证书是伪造的：压根不是CA颁发的证书被篡改过：比如将XX网站的公钥给替换了解决方法: 数字签名和摘要“摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，在通过CA的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名.这段数字签名只有CA的公钥才能够解密。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）详细版：1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;4、进行HTTP协议会话，客户端发送报头(请求报头);5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版：浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；载入解析到的资源文件，渲染页面，完成。 WebSocket协议1.为什么需要WebSocketHTTP协议只能由客户端发起,WebSocket可以实现双向对话,服务端和客户端都可以发送信息. 2.WebSocket特点 建立在TCP协议之上,服务端实现容易. 与HTTP协议有着良好的兼容性,并且握手阶段采用HTTP协议,因此握手阶段不容易屏蔽,可通过HTTP代理服务器. 数据格式轻量,性能开销小,通信高效. 可以发送文本和二进制数据. 没有同源限制. 协议标识符是ws(加密是wss),服务器网址是URL. 1ws://example.com:80/some/path 客户端示例1234567891011121314151617181920var ws = new WebSocket("wss://echo.websocket.org");ws.onopen = function(evt) &#123; console.log("Connection open ..."); ws.send("Hello WebSockets!");&#125;;ws.onmessage = function(evt) &#123; console.log( "Received Message: " + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log("Connection closed.");&#125;; ``` ## WebSocket客户端API### WebSocket构造函数```jsws = new WebSocket('ws://localhost:8080') 执行上面语句之后，客户端就会与服务器进行连接。 WebSocket.readyStatereadyState属性返回实例对象的当前状态,共用四种. CONNECTING: 值为0,表示正在连接. OPEN: 值为1,表示连接成功,可以通信. CLOSEING: 值为2,表示正在关闭. CLOSED: 值为3,表示连接已经关闭,或者打开失败. 示例 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; WebSocket.onopen实例对象的onopen属性,用于指定连接成功后的回调函数. 123ws.onopen = function()&#123; ws.send("hello")&#125; 如果指定多个函数,可以使用addEventListener方法. 123ws.addEventListener('open', function(event)&#123; ws.send('hello')&#125;) WebSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。]]></content>
      <categories>
        <category>HTML</category>
        <category>HTTP基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础]]></title>
    <url>%2F2019%2F08%2F19%2FJS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS对象对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。{key: value}是 JS 对象字面量写法 数据类型number, boolean, string, undefined, null, object, symbol原始类型，又叫基本类型,值类型,number, string, boolean,undefined,null。指保存在栈内存里的简单数据段引用类型，对象object。又可分为狭义的对象，数组，函数，正则。指保存在堆内存中的对象 其中js的number类型是浮点类型,不是整型.并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。NaN属于number类型,NaN表示Not a Number,并且NaN不等于自身.undefined: 表示未定义或不存在.由于没有定义,所以目前没有值null: 表示无值.即此处的值就是”无”的状态. typeoftypeof 对于基本类型，除了 null 都可以显示正确的类型typeof undefined 输出 undefinedtypeof []// ‘object’typeof {} // ‘object’typeof function(){} //‘function’(这是具体的判断) typeof null 输出 objectPS：为什么会出现这种情况呢？因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。 运算符 &amp;&amp; (And) || (or) ! (not)123a = 1 &amp;&amp; 3 //3a = 1 || 3 //1!2 * 0 //0 instanceof运算符,判断是否为某一种的实例. == 和 ===，前者先转化类型，后进行判断，后者比较类型和值 三目运算符condition ? true case : false case 四则运算符只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。 123456789101112加法拼接两个字符串console.log("2"+"4") //"24"加法将其中不是字符串的一方转化为字符串进行拼接console.log(2+"4") //"24"只有一个字符串参数时将其转化成数字console.log(+"4") //4console.log(+new Date()) //1573972012164字符串加对象会把对象变成[object Object]console.log('aa:'+&#123;a:1&#125;) //aa:[object Object]在参数有对象的情况下调用其valueof或toString,其中valueof优先级更高console.log(2+new Date()) //"2Sun Nov 17 2019 14:21:50 GMT+0800 (香港标准时间)" valueof()返回适合该对象类型的原始值。toString()将该对象的原始值以字符串形式返回。这两个方法一般是交由js去隐式调用。在数值运算中，优先调用valueof().在字符串运算中，优先调用toString().自增运算符: ++a或a++ 12a = 1, b = a++ //a=2,b=1a = 1, b = ++a //a=2,b=2 无论是先加，还是后加，a的值计算后一定会加1； 12a = 3, b = 4a +++ b //相当于(a++)+b =&gt; 3 + 4 = 7 逗号运算符 取后一个表达式的值.也就是说,前一个会被覆盖. 1var d = (a=1,b=2) // 2 boolean值false: undefined null 0 NaN 空字符串除此之外,其他所有值都转化为true,包括所有对象. ==比较相等性相等操作符会先转换操作数（通常称为强制转型），然后比较它们的相等性。 在转换不同的数据类型时，相等操作符遵循下列基本规则： 如果有一个操作数是布尔值，则在比较相等性之前，将其转换为数值； 如果一个操作数是字符串，另一个操作数是数值，在比较之前先将字符串转换为数值； 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较； 如果有一个操作数是 NaN，无论另一个操作数是什么，相等操作符都返回 false； 如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回 true； 在比较相等性之前，不能将 null 和 undefined 转成其他值。 null 和 undefined 是相等的。 1234567891011121314151617[] == [] //false&#123;&#125; == &#123;&#125; //false声明引用类型的时候，变量名保存在 js 的栈内存里面，而对应的值保存在堆内存里面而这个变量在栈内存中实际保存的是：这个值在堆内存中的地址，也就是指针.如果a = &#123;&#125;b = &#123;&#125;虽然 a 和 b 都保存了一个 Object，但这是两个独立的 Object，它们的地址是不同的.再结合前面的第5条规则：如果两个对象指向同一个对象，相等操作符返回 true所以 &#123;&#125; == &#123;&#125; 的结果是 false，同样的， [] == [] 的结果也是 false[] == ![] //true按优先级,先判断![],是false. =&gt;[] == false.[]是对象,调用[].toString返回"",false转化成0. =&gt;"" == 0.Number("")是0,那么结果就是true.&#123;&#125; == !&#123;&#125; //false与上面类似,不过Number(&#123;&#125;)返回 NaN"hello" == true //先转化,后比较.true转化成数字是1,"hello"转化成数字是NaN,二者不相等."hello" == false //false转化为数字是0,NaN不等于0.二者也不相等. JSON格式(javascript object notation) 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 JSON.stringify用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。 12345678910111213141516JSON.stringify('abc') // ""abc""JSON.stringify(1) // "1"JSON.stringify(false) // "false"JSON.stringify([]) // "[]"JSON.stringify(&#123;&#125;) // "&#123;&#125;"JSON.stringify([1, "false", false])// '[1,"false",false]'JSON.stringify(&#123; name: "张三" &#125;)// '&#123;"name":"张三"&#125;'var arr = [undefined, function () &#123;&#125;];JSON.stringify(arr) // "[null,null]"JSON.stringify(/foo/) // "&#123;&#125;" //正则对象会被转成空对象。 上面代码将各种类型的值，转成 JSON 字符串。 需要注意的是，对于原始类型的字符串，转换结果会带双引号。如果原始对象中，有一个成员的值是undefined、函数或 XML 对象，这个成员会被过滤。如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。正则对象会被转成空对象。 JSON.parse()用于将JSON字符串转化成对象。 12345678JSON.parse('&#123;&#125;') // &#123;&#125;JSON.parse('true') // trueJSON.parse('"foo"') // "foo"JSON.parse('[1, 5, "false"]') // [1, 5, "false"]JSON.parse('null') // nullvar o = JSON.parse('&#123;"name": "张三"&#125;');o.name // 张三 JSON.parse只能解析字符串,下面这种情况会报错. 1234567var str = &#123;"name": "张三"&#125;var o = JSON.parse(str);o.name // 报错解决方法:var str = '&#123;"name": "张三"&#125;'或者var o = JSON.parse('str'); JavaScript 对象的字面量写法只是长的像 JSON 格式数据，二者属于不同的范畴，JavaScript 对象中很多类型(函数、正则、Date) JSON 格式的规范并不支持，JavaScript 对象的字面量写法更宽松。 写JavaScript的基本规范1.不要在同一行声明多个变量。2.请使用 ===/!==来比较true/false或者数值3.使用对象字面量替代new Array这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 JS函数函数会声明前置 1234foo() //hellofunction foo()&#123; return "hello"&#125; 函数表达式不会 1234fn()//报错var fn() = fnction()&#123; return "hello" &#125; 12345678var str = "一号";test();function test() &#123; console.log(str); var str = "二号"; console.log(str);&#125;console.log(str); 输出 12345//考察变量声明和作用域undefined //因为打印str时,首先从str所在的作用域找变量str,//因为有声明前置,var str,但是未赋值,是undefined.所以不再从外部找str二号一号 //函数test内部的str=二号只在函数内部,最后一个str的值是全局下的即"一号" js对象查看所有属性12var obj = &#123; p: 1&#125;Object.keys(obj) 删除命令delete object.p 循环判断 12345678910switch(判断语句）&#123; case 条件： 输出; break; case 条件: 输出; break; default: 输出&#125; while循环 12345while(expression)&#123; statement&#125;//如果expression为true，执行，//循环继续执行直到判断不成立。 do-while循环 1234do&#123; statement;&#125;while(expression);//先执行，后判断 for循环 123for(var i=0; i&lt;5;i++)&#123; console.log(i)&#125; 执行步骤如下:初始化语句: var i=0,只执行第一次判断语句: i&lt;5条件改变语句: i++内部执行: console.log(i)先执行初始化语句,然后判断条件是否成立,成立就执行内部语句,最后改变条件.重复进行判断. for-in循环1234var arr = [1,2,3]for(var key in arr)&#123; console.log(arr[key])&#125; break退出本次循环continue跳过本次循环执行下次循环 引用类型1234567891011121314151617181920212223//a,b存放在栈内存中var a = 1var b = 2//obj是对象,存放在堆内存中,obj只是一个指针,一个地址var obj = &#123; name: 'Tom', sex: 'male', age: 15, friend: &#123; name: 'Jerry', age: 10 &#125;&#125;var newobj = &#123;&#125; //空对象也是引用类型,只不过暂时还没有东西//基本类型b = aconsole.log(b) //1,把a赋值给b,b在栈内存中也被改变为1//引用类型var obj2 = obj //二者都是引用类型,都是把地址指向同一个地方,改变内存中的值,另一个也会改变obj2.name = 'Ann'console.log(obj.name) //'Ann' 1234var obj3 = &#123;name: 'hello'&#125; var obj4 = &#123;name: 'hello'&#125; obj3 === obj4 //false,//虽然二者内容看似相同,但是确是不同的内存中,两个地址 123456function sum()&#123; console.log('sum..')&#125;var sum2 = sumsum2() //'sum..',//函数同样是引用类型,当赋值给另一个函数时,二者也就指向同一地址 函数的参数传递1234567function inc(n)&#123; n++&#125;var a = 10inc(a)console.log(a) //10//inc(a)把a传递进去,先赋值后相加,a=10,inc(a) = 11,a并没有变化还是10 1234567function incObj(obj)&#123; obj.n++&#125;var o = &#123;n:10&#125;incObj(o)console.log(o) //&#123;n:11&#125;//incObj(o),o.n++,那么&#123;n:11&#125;,堆内存中的数值已经改变,输出o时,o也就变成了&#123;n:11&#125; 深拷贝123456789var obj = &#123; name: 'hunger', age: 3, friends: ['aa', 'bb', 'cc']&#125;var obj2 = JSON.parse(JSON.stringify(obj))obj.age = 4console.log(obj2.age) 缺点: JSON 不支持函数、引用、undefined、RegExp、Date…… jQuery.extend()jQuery.extend( [deep], target, object1 [, objectN ] )其中 deep 为 Boolean 类型，如果是true，则进行深拷贝。 123456789101112var target = &#123;a: 1, b: 1&#125;;var copy1 = &#123;a: 2, b: 2, c: &#123;ca: 21, cb: 22, cc: 23&#125;&#125;;var copy2 = &#123;c: &#123;ca: 31, cb: 32, cd: 34&#125;&#125;;var result = $.extend(true, target, copy1, copy2); // 进行深拷贝console.log(target); // &#123;a: 2, b: 2, c: &#123;ca: 31, cb: 32, cc: 23, cd: 34&#125;&#125; var target = &#123;a: 1, b: 1&#125;;var copy1 = &#123;a: 2, b: 2, c: &#123;ca: 21, cb: 22, cc: 23&#125;&#125;;var copy2 = &#123;c: &#123;ca: 31, cb: 32, cd: 34&#125;&#125;;var result = $.extend(target, copy1, copy2); // 不进行深拷贝console.log(target); // &#123;a: 1, b: 1, c: &#123;ca: 31, cb: 32, cd:34&#125;&#125; 递归深拷贝123456789101112131415function clone(object)&#123; var object2 if(! (object instanceof Object) )&#123; return object &#125;else if(object instanceof Array)&#123; object2 = [] &#125;else if(object instanceof Object)&#123; object2 = &#123;&#125; &#125; //你也可以把 Array Function Object 都当做 Object 来看待 for(let key in object)&#123; object2[key] = clone(object[key]) &#125; return object2&#125; 函数函数返回值return通过return返回结果,调用return后,函数立即中断并返回结果,即使后面还有语句也不再执行. 立即执行函数将整个函数表达式包含在括号内,最后添加一个括号表示执行. 123(function()&#123; console.log("hello")&#125;)() 命名冲突当在同一个作用域内定义了名字相同的变量和方法的话,无论其顺序如何,变量的赋值会覆盖方法的赋值. 123var fn = 3function fn()&#123;&#125;console.log(fn) //3 当函数执行有命名冲突时,函数执行时载入顺序是变量,函数,参数 12345678function fn(fn)&#123; console.log(fn)var fn = 3 console.log(fn)&#125;fn(10) //10 3 函数作用域（scope）作用域（scope）指的是变量存在的范围。在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数。 词法作用域创建当前函数所在的作用域. 递归一个函数可以指向并调用自身。调用自身的函数我们称之为递归函数。在某种意义上说，递归近似于循环。两者都重复执行相同的代码，并且两者都需要一个终止条件（避免无限循环或者无限递归）。 作用域链 函数在执行的过程中，先从自己内部找变量 如果找不到，再从创建当前函数所在的作用域去找, 以此往上 注意找的是变量的当前的状态 闭包(closure)它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。一般情况下使用闭包主要是为了 封装数据 暂存数据 面试官想听的版本:什么是闭包?由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。闭包解决了什么问题?由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。闭包的应用?闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。 12345678910111213function car()&#123; var speed = 0 function fn()&#123; speed++ console.log(speed) &#125; return fn&#125;var speedUp = car()speedUp() //1speedUp() //2//第二次执行speedup时,在fn内部,speed此时因为没有释放,还是上次的值1,也就相当于var speed = 1;不用再去上一级作用域找speed的值,可以直接相加输出 如果没有这个闭包，函数执行后，里面speed变量就会被清理掉。但我们声明了fn这个函数，并把它返回出来赋值给新的变量speedup。因为speedup是全局变量，是一直存在的，故这个fn函数就一直存在，speed变量也不会被清理 12345678910//演化版var speedup = (function(speed)&#123; return function()&#123; speed++ console.log(speed) &#125;&#125;)(3) speedup() //4speedup() //5speedup() //6 经典范例如下代码输出多少？如果想输出3，那如何改造代码？ 1234567var fnArr = [];for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i &#125;;&#125;console.log( fnArr[3]() ) // 10 我的理解: fnArr[i]声明的匿名函数的作用域是全局作用域,先遍历,并未执行,生成闭包(只是for循环,并没有执行函数,后面没有小括号),遍历结束开始执行,fnArr结果是10个匿名函数f(),全局作用域下0-9的fnArr[i]已经变成10了 原理解析：for循环每次执行，都把function(){ return i} 这个函数赋值给fnArr[i]，但这个函数不执行。因为fnArr[3] =function(){ return i};故当我们调用fnArr3 时，相当于function(){ return i};这个函数立刻执行，这时for循环已经完成，i已经变成了10。故输出10 如果要输出3，需要如下改造 123456789var fnArr = []for (var i = 0; i &lt; 10; i ++) &#123; (function(i)&#123; fnArr[i] = function()&#123; return i &#125; &#125;)(i)//这样保证遍历i时,函数会立即执行(生成10个闭包,暂存数据)&#125;console.log( fnArr[3]() ) // 3 我的理解: 从0开始遍历,(function(0){ fnArr[0] = function(){return i}})(0),(function(1){ fnArr[1] = function(){return i}})(1)(function(2){ fnArr[2] = function(){return i}})(2),(function(3){ fnArr[3] = function(){return i}})(3),传入3,最内部的function找i的变量,一直找到上一层,返回3. 123456789var fnArr = []for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = (function(j)&#123; return function()&#123; return j &#125; &#125;)(i)//生成10个闭包,暂存数据,j换成i也是一样&#125;console.log( fnArr[3]() ) // 3 如下代码输出什么? 123456for(var i=0; i&lt;5; i++)&#123; setTimeout(function()&#123; console.log( i ) &#125;, 0)&#125;//输出5个5 如何连续输出 0,1,2,3,4 12345678for(var i=0; i&lt;5; i++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log( j ) &#125;, 0) &#125;)(i)&#125;//0,1,2,3,4 12345678//第二种方法//把var换成letfor(let i=0; i&lt;5; i++)&#123; setTimeout(function()&#123; console.log( i ) &#125;, 0)&#125;//0,1,2,3,4 123456789101112var an = function (n)&#123; for(var i = 0; i &lt; 2; i++)&#123; n ++ console.log(n) //2,3. 遍历两次,内部就打印两次 console.log(i) //0,1. 遍历两次,内部就打印两次 &#125; console.log(n) //3. 打印最终结果 console.log(i) //2. 打印最终结果. //如果换成let,只有这里报错,因为i只在for循环体内被定义&#125;var g = an(1) 函数柯里化 只传递给函数一部分参数来调用它,让它返回一个函数去处理剩下的参数. 写一个函数sum,实现如下调用 123456789console.log(sum(1)(2)) //3console.log(sum(5)(-1)) //4//解答function sum(a)&#123; return function(b)&#123; return a + b &#125;&#125; 字符串12str.charAt(0) //获取第一个字符str.charCodeAt(0) //获取字符对应的ASC码 字符串截取 1234var str= "hello"str.substr(1,3) //第一个开始，第二个长度str.substring(1,3) //第一个开始，第二个结束str.slice(1,3) //同上，允许负参 查找 1234str.search("he") //返回下标str.indexOf("he") //同上str.replace("he", "you") //替换str.match("he") //匹配 大小写 12str.toUpperCase()str.toLowerCase() //本身不变化 去除首尾空格 1str.trim() //返回新数组,不影响原数组 split()方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。找到分隔符后，将其从字符串中删除，并将子字符串的数组返回。如果没有找到或者省略了分隔符，则该数组包含一个由整个字符串组成的元素。如果分隔符为空字符串，则将str转换为字符数组。如果分隔符出现在字符串的开始或结尾，或两者都分开，分别以空字符串开头，结尾或两者开始和结束。因此，如果字符串仅由一个分隔符实例组成，则该数组由两个空字符串组成。示例: 12345678910111213var str = 'The quick brown fox jumps over the lazy dog.';var words = str.split(' ');console.log(words[3]);// expected output: "fox"var chars = str.split('');console.log(chars[8]);// expected output: "k"var strCopy = str.split();console.log(strCopy);// expected output: Array ["The quick brown fox jumps over the lazy dog."] 当字符串为空时，split（）返回一个包含一个空字符串的数组，而不是一个空数组，如果字符串和分隔符都是空字符串，则返回一个空数组。 123var str = ''var strEm = str.split();console.log(strEm); //返回[""] 数组12345678910111213141516171819202122232425262728293031323334353637arr.push(newelement) //末尾新增一个arr.pop() //末尾踢出一个字arr.shift() //开头拿出一个arr.unshift() //开头新增一个arr.splice(index,替换几个，替换内容) //原数组变//返回由删除元素组成的新数组arr.slice(start，end) //原数组不变arr.join("-") //将数组变成字符串并用-连接arr.reverse() //数组反转arr.sort(v1-v2) //没有参数按顺序排列，但是会出现10,11,7,8,9排列，//有参数设置比较函数，函数结果v1-v2如果大于0，两两替换位置。否则，不变a.concat(array) //拼接，返回数组a和array的集合。原数组不变Array.isArray(obj) //判断传入的obj是不是数组a.indexof(2) //判断数组a中是否含有2,返回其索引a.forEach(fn(element,index,arr)&#123;&#125;)//forEach里是一个回调函数，有三个参数，分别是当前元素，索引值，整个数组a.map(fn(element)&#123;&#125;)//与forEach类似，返回新数组，原数组不变,是被一个函数处理后的数组.//而forEach会修改原数组a.every(fn(element,index,arr)&#123;&#125;)//every是所有函数返回true才会返回true，遇到false终止，并返回falsea.some(fn(element,index,arr)&#123;&#125;)//some是存在一个返回true时就终止返回truea.filter(fn(element)&#123;&#125;)//返回新数组，回调函数用于逻辑判断，为true则把当前元素加到返回的数组中//为false则不加a.reduce(fn(v1,v2),value)//将数组元素合成一个值，从索引值最小开始。value表示初始值a.abs(x) //返回x的绝对值Array.from(new Set(a)) //数组去重 数组扁平化123456789const flattenDeep = (arr) =&gt; Array.isArray(arr) ? arr.reduce( (a, b) =&gt; [...a, ...flattenDeep(b)] , []) : [arr]flattenDeep([1, [[2], [3, [4]], 5]])//flatMap方法,目前该函数在浏览器中还不支持[1, [2], 3].flatMap((v) =&gt; v + 1)// -&gt; [2, 3, 4] 数组去重双重循环去重 1234567891011121314function unique(arr)&#123; for(var i=0; i&lt;arr.length; i++)&#123; for(var j=i+1; j&lt;arr.length; j++&gt;&#123; if(arr[i]===arr[j])&#123; //如果数组第一个等于第二个 arr.splice(j,1) //就干掉第j个 j-- //因为数组arr被干掉一个,长度-1,j就相应的-1 &#125; &#125;) &#125; return arr&#125; new Set去重 123456789function unique(arr)&#123; return Array.from(new Set(arr))&#125;//简化版function unique(arr) &#123; return [...new Set(arr)];&#125;//精简版var unique = (arr) =&gt; [...new Set(arr)] 如何将浮点数点左边的数每三位添加一个逗号如12000000.11转化为『12,000,000.11』? 1234567function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($1, $2)&#123; return $2 + ','; &#125;);&#125; 如何实现数组的随机排序？1234567891011121314151617181920212223242526272829303132方法一：var arr = [1,2,3,4,5,6,7,8,9,10];function randSort1(arr)&#123; for(var i = 0,i &lt; arr.length; i++ )&#123; var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr;&#125;console.log(randSort1(arr));方法二：var arr = [1,2,3,4,5,6,7,8,9,10];function randSort2(arr)&#123; var mixedArray = []; while(arr.length &gt; 0)&#123; var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return mixedArray;&#125;console.log(randSort2(arr));方法三：var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr); Math四舍五入 12Math.round(0.5)//1Math.round(-1.5)//-1 绝对值 1Math.abs(-1) //1 最大值Math.max() 函数返回一组数中的最大值。参数是value1, value2, ...是一组数值 123Math.max(10, 20,30); Math.max.call(null,10, 20,30); Math.max.apply(null,[10, 20,30]); 1234floor返回小于参数值的最大整数.向下取整Math.floor(-3.2) //-4ceil返回大于参数值的最小参数，向上取整Math.ceil(-3.2) //-3 parseInt(值，进制) 123parseInt(string,radix)//将一个字符串 string 转换为 radix 进制的整数，// radix 为介于2-36之间的数。 parseInt()可以将字符串转为数字，也可以将数字取整。向下取整。如果第一个字符是数字会解析直到遇到非数字结束，如果第一个字符不是数字或者符号（如：+、-）就返回NaN。带自动净化功能；带自动截断小数功能，且取整，不四舍五入。radix: 基数,也就是进制.介于2-36之间,超出都是返回NaN.radix不写默认是十进制.如果传入字符串是0x开头,默认是16进制.如果是0开头,默认8进制.任何数的0进制都是它本身.高于进制位能表示的最大值数返回NaN.比如说2的一进制返回NaN,因为一进制只能用1表示,2作为一进制来表示明显不对. 几次方 12Math.pow(x,y) //返回 x 的 y 次幂的值。Math.pow(2,2) //4 平方根 12Math.sqrt(4) // 2Math.sqrt(-4) //NaN random 12Math.random()//返回0-1之间的伪随机数.0≦x&lt;1 Date123Date.now() //获取1970年至今的毫秒数Date.parse() //解析日期字符串，返回距离1970年的毫秒数Date.parse("2011-01-11") //13234436600000 1234567new Date() //使用Date构造函数创建一个Date实例，//不传时间就返回当前时间的字符串var str = "2019-01-11"new Date(str) //Fri Jan 11 2019 08:00:00 GMT+0800 (香港标准时间)//获取的是东八区8点的时间，因为格林尼治时间伦敦是0点 get方法 12345678getDate() //日getDay() //星期几，周日是0，周一是1getFullyear() //返回四位的年份getMouth() //返回月份，一月是0，腊月是11getHours() //小时（0-23）getMinutes() // 返回分钟getSenconds() // 秒getMilliseconds() // 毫秒(0-999) set方法类似于get方法，是设置时间 时间格式化过滤器Vue版本 123456789101112131415161718192021222324&#123;&#123;date | dateFormat &#125;&#125;&lt;script&gt; filters: &#123; //时间格式化 dateFormat: function(date) &#123; //date是传入的时间字符串 let t = new Date(date); return ( t.getFullYear() + "-" + (t.getMonth() + 1) + "-" + t.getDate() + " " + t.getHours() + ":" + t.getMinutes() + ":" + t.getSeconds() ); &#125; &#125;,&lt;/script&gt; 异步和回调setTimeout和setInterval区别: setInterval指定某个任务每隔一段时间就执行一次,也就是无限次的定时执行.清除定时器: clearTimeout()和clearInterval() 运行机制setTimeout和setInterval的运行机制是,将指定的代码移出本次执行,等到下一轮Event Loop,再检查是否到了指定时间.如果到了,就执行对应代码,不到,就等到下一轮重新判断.这也就意味着,setTimeout指定的代码,必须等到本次执行的所有代码都执行完,才会执行. 单线程模型异步的任务放在任务队列(callback queue)中,setTimeout也是.必须等放在栈(stack)中的同步代码执行完,才会执行任务队列中的. event loop(事件循环)经典案例: 12345for(var i=0; i&lt;5; i++)&#123; setTimeout(fucntion timer()&#123; comsole.log(i) &#125;,1000)&#125; 我的理解:开始循环遍历.(同步代码)i=0.创建一个console.log(i).放到队列里，并不执行.i=1.创建一个console.log(i).放到队列里，并不执行，直到i=5.依次创建了5个console.log(i)因为setTimeout是异步,所以必须等同步执行完才开始执行异步.同步代码i循环到5，输出，有5个console.log(i)在队列里嗷嗷待哺，把i=5赋值进去.得到5个5. 函数节流在时间内，如果执行，就重新开始原理：当达到了一定的时间间隔就会执行一次；可以理解为是缩减执行频率函数节流会用在比input, keyup更频繁触发的事件中，如resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。常用场景: 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 简单版本: 123456789101112131415function throttle(fn,ms)&#123;let timer //命名一个定时器 return function()&#123; if(timer)&#123; //如果有定时器就退出 return &#125; timer = setTimeout(fn,ms) &#125;&#125;function fn()&#123; console.log("hello")&#125;var fn2 = throttle(fn, 1000) 时间戳版本: 12345678910const throttle = (fn, wait) =&gt; &#123; let last = 0; return () =&gt; &#123; const current_time = +new Date(); if (current_time - last &gt; wait) &#123; fn.apply(this, arguments); last = +new Date(); &#125; &#125;;&#125;; 函数防抖原理：将若干函数调用合成为一次，并在给定时间过去之后，或者连续事件完全触发完成之后，调用一次(仅仅只会调用一次) 适合场景: 滚动加载，加载更多或滚到底部监听 谷歌搜索框，搜索联想功能 高频点击提交，表单重复提交 123456789101112function debounce(fn,ms)&#123; let timer = null return () =&gt; &#123; clearTimeout(timer) timer = setTimerout(fn,ms) &#125;&#125;//实际上上面这就可以了function vlog()&#123; console.log(1)&#125;window.onscroll = debounce(vlog,500) 带有立即执行选项的防抖函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 这个是用来获取当前时间戳的function now() &#123; return +new Date()&#125;/** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */function debounce (func, wait = 50, immediate = true) &#123; let timer, context, args // 延迟执行函数 const later = () =&gt; setTimeout(() =&gt; &#123; // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) &#123; func.apply(context, args) context = args = null &#125; &#125;, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) &#123; // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) &#123; timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) &#123; func.apply(this, params) &#125; else &#123; context = this args = params &#125; // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 &#125; else &#123; clearTimeout(timer) timer = later() &#125; &#125;&#125; 对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数 节流和防抖的区别 他们的区别在于防抖只会在连续的事件周期结束时执行一次，而节流会在事件周期内按间隔时间有规律的执行多次。 我的理解:函数节流:只要又执行函数,就退出.必须等上一次定时器任务执行完.这一段时间只执行一次.函数防抖:只要又执行函数,就清除定时器,重新设置定时器.只要重复就重新开始,最后肯定有一次. DOM元素创建和选取DOM是文档对象模型，是html的编程接口readyState加载状态 1234567891011document.location//location属性返回一个只读对象，提供当前文档的url信息document.location.href //获取urldocument.location.protocol //获取"http:"document.location.hostname // "www.example.com"document.location.port // "4097" document.location.pathname // "/path/a.html"document.location.assign("http://www.Google.com") //跳转到指定网址document.location.reload(true) //优先从服务器重新加载document.location.reload(false) //优先从本地缓存加载 123document.open() //新建文档可以使用write写入document.close() //关闭文档document.write() //写入文档,会清除之前的文档流 Element表示html元素 element的属性： nodeName: 元素标签名 nodeType:元素类型 className:类名 id:元素id children:子元素列表 childNodes: 子元素列表（NodeList） firstChild: 第一个子元素 lastChild:最后一个 nextSibling: 下一个兄弟元素 previousSibling: 上一个兄弟元素 parentNode.parentElement: 父元素 查询元素 12345678910111213document.getElementById("target")document.getElementsByClassName("box")//上述为ES3写法//下面是ES5写法document.querySelector(".box")document.querySelector("#tatget")//多个元素只会选择第一个//选择多个document.querySelectorAll("div")//浏览器控制台测试时可以用$替代document.querySelector//用$$替代document.querySelectorAll 创建元素 1234567document.createElement("div")//生成文本节点document.createTextNode("Hello")//生成DocumentFragment对象document.createDocumentFragment()//存在于内存中的DOM片段，不属于当前文档。//对它的任何改动，都不会引发网页的重新渲染 修改元素 1234567891011121314151617在元素末尾添加元素appendChild()newDiv.appendChild(newContent)在元素之前插入元素insertBefore()替换元素replaceChild(newElement,oldElement)删除元素parentNode.removeChild(childNode)clone元素node.cloneNode(true)//方法有一个布尔值，传入true时会深拷贝，//复制元素及其子元素，false只会复制元素本身 DOM元素属性123456789101112获取属性node.getAttribute("id")生成新的属性对象节点attribute = document.createAttribute(name)一般用 setAttribute()设置元素属性var node = document.getElementById("id")node.setAttribute("id", "newVal")删除属性节点node.removeAttribute("id") innerText可写属性，返回元素内包含的文本内容，在多层次的时候按照元素由浅到深的顺序拼接内容 123456&lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 外层div的innerText返回内容是 &quot;123456&quot; innerHTML返回元素html结构，在写入的时候也会自动构建DOM 样式修改样式 1document.querySelector("p").style.color = "red" 获取样式getComputedStyle 1234var node = document.querySelector('p') var color = window.getComputedStyle(node).color console.log(color)//获取计算后的样式，只读。全局属性 class操作的增删改查123456var nodeBox = document.querySelector(".box")console.log(nodeBox.classList)nodeBox.classList.add("active") //新增classnodeBox.classList.remove("active") //删除nodeBox.classList.toggle("active") //新增删除切换node.classList.contains("active") //判断是否拥有class 页面宽高1234567element.clientHeight //包括padding,相当于IE盒模型,content-boxelement.offsetHeight //包括border,相当于标准盒模型,border-box element.scrollHeight //滚动区域的总高度(元素的起始位置的底边到停止位置的顶边),包括元素的padding，但不包括元素的border和marginelement.scrollTop //滚动的高度element.offsetTop //返回当前元素相对于其 offsetParent 元素的顶部内边距的距离。window.innerHeight //视口的高度,不包括标题栏等,包括水平滚动条window.outerHeight //整个浏览器窗口的高度,包括标题栏等所有浏览器内容 如何判断一个元素是否出现在窗口视野中滚动的距离 + 窗口的高度 = 目标元素到顶部的距离 123`window.scrollTop + window.innerHeight = element.offsetTop`//方法二$('element').offset().top &lt;= $(window).height() + $(window).scrollTop() 如何判断页面滚动到底部12345//窗口滚动的距离 + 窗口的高度 = 整个页面的高度$(window).scrollTop() + $(window).height() = $('body').height()//方法二//元素滚动的距离 + 元素的高度 = 元素的滚动区域的高度element.scrollTop + element.clientHeight = element.scrollHeight 事件DOM事件流: 捕获阶段，目标阶段，冒泡阶段 事件绑定12345678&lt;input id="btnClick" type="button" value="Click here"&gt; &lt;script type="text/javascript"&gt;var btnClick = document.getElementById("btnClick")btnClick.onclick = function showMessage()&#123; alert(this.id)&#125;&lt;/script&gt; 点击事件是异步的.会存在覆盖 DOM2事件处理(升级版) addEventListener //绑定事件 removeEventListener //解绑事件 所有DOM节点都包含这两个方法，且都接受三个函数： 事件类型 事件处理方法 布尔参数，true表示在捕获阶段调用，false表示在事件冒泡阶段处理，默认是冒泡阶段 123btnClick.addEventListener("click", function()&#123; alert(this.id)&#125;, false) 不存在覆盖，可以写多个方法 属性方法123preventDefault() //取消默认事件行为stopPropagation() //取消事件进一步捕获或冒泡target() //事件的目标元素 事件代理事件委托(代理)就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。使用事件代理来实现它，监听的元素应该是这些元素的父元素，当我点击父元素内的元素时，父元素都会得到响应，并分发相应的事件。 e.target就是点击的元素。 1234567$('.container').onclick = function(e)&#123; console.log(this) console.log(e.target) if(e.target.classList.contains('box'))&#123; console.log(e.target.innerText) &#125; &#125; 常见事件及自定义事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950鼠标事件clickdblclick //双击左键mouseover //鼠标放上mouseout //鼠标移出mouseenter //类似over，区别不计算子元素mouseleave //类似out，区别不计算子元素mousedown //鼠标按下mouseup //鼠标松开触摸事件touchstarttouchendtouchmove键盘事件keyup //按键后松开触发keydown //按键即会触发keypress //按下松开页面相关事件onload //加载完成时触发onmove //浏览器窗口被移动scroll //滚动条滚动resize //窗口大小变化表单相关focus //获取焦点blur //失去焦点change //失去焦点且内容发生改变reset //reset属性被激活submit //提交，一般是表格提交input //在input元素内容修改后立即触发onload //页面所有资源加载完成DOMContentLoaded //dom结构解析完成编辑事件beforecopy //复制之前beforecut //剪切之前beforepaste //粘贴之前beforeeditfocus //将要进去编辑状态contextmenu //按右键出现菜单或者键盘触发页面菜单losecapture //失去鼠标移动所形成的选择焦点select //被选择时拖动事件drag //某个对象被拖动dragdrop //外部对象被拖到当前窗口dragend //拖动结束dragenter //被拖动对象进入其容器范围 js拖动div 使用mouse实现 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt; mouse实现div拖动 &lt;/title&gt;&lt;style type="text/css"&gt;#div &#123; position: absolute; left: 100px; top: 100px; width: 200px; height: 200px; background-color: #f60;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="drag"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var drag = document.getElementById("drag");var dragFlag = false;var x,y;drag.onmousedown = function (e) &#123; e = e || window.event; x = e.clientX - drag.offsetLeft; y = e.clientY - drag.offsetTop; dragFlag = true;&#125;;document.onmousemove = function (e) &#123; if (dragFlag) &#123; e = e || window.event; drag.style.left = e.clientX - x + "px"; drag.style.top = e.clientY - y + "px"; &#125;&#125;;document.onmouseup = function (e) &#123; dragFlag = false;&#125;;&lt;/script&gt;&lt;/body&gt; drag实现 12345678910111213141516171819202122232425262728293031323334353637&lt;head&gt;&lt;style&gt;.divblok &#123; background-color:#ccc; width:30px; height:30px; position:absolute; left:20px; top:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="dragdiv" draggable="true" class="divblok"&gt;我要移动 &lt;/div&gt;&lt;script&gt;var dragdiv = document.querySelector('#dragdiv');var x, y; //记录到点击时鼠标到移动框左边和上边的距离dragdiv.addEventListener('dragstart', function (e) &#123; e.dataTransfer.effectAllowed = "move"; //移动效果 e.dataTransfer.setData("text", ''); //附加数据， 没有这一项，firefox中无法移动 x = e.offsetX || e.layerX; y = e.offsetY || e.layerY; return true;&#125;, false);document.addEventListener('dragover', function (e) &#123;//取消冒泡 ,不取消则不能触发 drop事件 e.preventDefault()|| e.stopPropagation();&#125;, false);document.addEventListener('drop', function (e) &#123; dragdiv.style.left = (e.pageX - x) + 'px'; dragdiv.style.top = (e.pageY - y) + 'px'; e.preventDefault() || e.stopPropagation(); //不取消，firefox中会触发网页跳转到查找setData中的内容&#125;, false);&lt;/script&gt;&lt;/body&gt; 自定义事件123456789101112131415var EventCenter = &#123; on: function(type, handler)&#123; document.addEventListener(type, handler) &#125;, fire: function(type, data)&#123; return document.dispatchEvent(new CustomEvent(type, &#123; detail: data &#125;)) &#125; &#125; EventCenter.on('hello', function(e)&#123; console.log(e.detail) &#125;) EventCenter.fire('hello', '你好') //一个监听函数，一个处理函数 JS动画requestAnimationFrame可以在一定时间内自动执行 123456789function move()&#123; if(moveOffset &lt; offsetX)&#123; ball.style.left = parseInt(getComputedStyle(ball).left) + step +"px" moveOffset += step requestAnimationFrame(move) &#125;&#125;move() BOMbom指浏览器对象模型，核心是window对象。是浏览器的实例window.innerHeight属性，window.innerWidth属性.这两个属性返回网页的CSS布局占据的浏览器窗口的高度和宽度，单位为像素。很显然，当用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。 注意，这两个属性值包括滚动条的高度和宽度。 scrollX：滚动条横向偏移 scrollY：滚动条纵向偏移 这两个值随着滚动位置变化而变化 window.frames返回一个类似数组的对象，成员为页面内的所有框架，包括frame元素和iframe元素。需要注意的是，window.frames的每个成员对应的是框架内的窗口（即框架的window对象），获取每个框架的DOM树，需要使用window.frames[0].document。 12var iframe = window.getElementsByTagName("iframe")[0];var iframe_title = iframe.contentWindow.title; 上面代码用于获取框架页面的标题。 iframe元素遵守同源政策，只有当父页面与框架页面来自同一个域名，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。在iframe框架内部，使用window.parent指向父页面。 navigator指向一个包含浏览器相关信息的对象. window.getComputedStylegetComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值 1var style = window.getComputedStyle("元素", "伪类") URL的编码/解码方法JavaScript提供四个URL的编码/解码方法。 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 区别 encodeURI方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!@#$&amp;*()=:/,;?+' encodeURIComponent方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!*()' alert()，prompt()，confirm()alert()、prompt()、confirm()都是浏览器用来与用户互动的方法。它们会弹出不同的对话框，要求用户做出回应。 需要注意的是，alert()、prompt()、confirm()这三个方法弹出的对话框，都是浏览器统一规定的式样，是无法定制的。]]></content>
      <categories>
        <category>JS</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F18%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[介绍超文本标记语言(Hypertext Markup Language, HTML)是一个可以用来结构化 Web 内容并给予其含义和目标的编码语言。HTML并不是真正的的程序语言，它是一种标记语言.它由一系列的元素（elements）所组成，不同的元素各有功用. HTML5是定义HTML标准的最新的版本。是一个新版本的HTML语言，具有新的元素，属性和行为. doctypedoctype是文档类型说明. &lt;!DOCTYPE html&gt;有什么作用?告诉浏览器的语言解析器用什么类型解析文档 HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行） 设定文档语言&lt;html lang=&quot;zh-CN&quot;&gt; SEO(搜索引擎优化) 有利于视障人士通过读屏器阅读 HTML 头部元数据&lt;meta&gt;:指定文档编码: &lt;meta charset=&quot;UTF-8&quot;&gt;适配移动页面: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;设置 referer: &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;添加页面描述: &lt;meta name=&quot;description&quot; content=&quot;腾讯网(www.QQ.com)是中国浏览量最大...&gt;定制页面图标: &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; 应用 CSS 和 JS12&lt;link rel="stylesheet" href="app.css"&gt;&lt;script src="app.js"&gt;&lt;/script&gt; 使用link和@import有什么区别？ link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; link支持使用js控制DOM去改变样式，而@import不支持; src与href的区别区别：src 用于替代这个元素，而 href 用于建立这个标签与外部资源之间的关系 &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;浏览器加载到这里的时候，html 的渲染和解析不会暂停，css 文件的加载是同时进行的 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件 标签行内元素有：a b span img input select strong（强调的语气）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 空(void)标签就是不用加闭标签的标签，也可以叫闭元素。如： &lt;area&gt; &lt;base&gt; &lt;br&gt; &lt;col&gt; &lt;colgroup&gt; when the span is present &lt;command&gt; &lt;embed&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;keygen&gt; &lt;link&gt; &lt;meta&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 可替换标签 宽高由自己决定的元素，如： &lt;img&gt; &lt;video&gt; &lt;input&gt; &lt;button&gt; 总结:常见块级div:文档节section:文档节nav:导航header:页眉article:文章aside:文章侧栏footer:页脚details:元素的细节summary:details元素可见的标题dialog:对话框窗口h1,h2,h3,h4,h5,h6:标题p:段落ul:无序列表ol:有序列表dir:目录列表li:项目dl:列表dt:列表项目dd:项目描述menu:命令的菜单,列表menuitem:菜单项目command:命令按钮form:表单fieldset:围绕元素的边框(可用于表单内元素分组)legend:在边框上的标题select:选择列表(内联元素)optgroup:组合选择列表选项option:选择列表选项(也可做datalist选项)datalist:下拉列表(id要与input中list属性值绑定)table:表格caption:表格标题thead:组合表头内容(th)tbody:组合主体内容(td)tfoot:组合表注内容(td)tr:表格行th:表头单元格td:表格单元col:表格列属性;(空标签)colgroup:表格格式化列组;iframe:内联框架figure:媒介内容分组figcaption:figure标题map:图像映射area:图像区域canvas:图形容器(脚本来绘制图形)video:视频source:媒介源track:文本轨道audio:声音内容br:换行(空标签)hr:水平分割线(空标签)pre:格式文本blockquote:块引用address:文档联系信息center:居中文本(不赞成使用)spacer:在水平和垂直方向插入空间(空元素) 常见行内标签span:内联容器abbr:缩写em:强调strong:粗体强调mark:突出显示的文本b:粗体i:斜体bdi:文本方向bdo:文字方向big:大字体small:小字体sup:上标sub:下标del:被删除的文本strike:删除线s:删除线ins:被插入的文本u:下划线nobr:禁止换行wbr:单词换行时机(空标签)tt:打字机文本kbd:键盘文本time:日期/时间cite:引用q:短引用(“”)font:字体设定(不常用)acronym:缩写(html5不支持)dfn:字段(不常用)a:锚点img:图片embed:内嵌(空标签)label:input标记(点击文本触发控件)input:输入框button:按钮keygen:生成秘钥(空标签)textarea:多行文本输入框output:输出结果ruby:中文注音rt:注音rp:浏览器不支持ruby元素显示的内容progress:进度条meter:度量var:定义变量code:计算机代码文本samp:计算机代码样本select:下拉列表 文本HTML 包括六个级别的标题， &lt;h1&gt; – &lt;h6&gt;。通常一个页面只有一个&lt;h1&gt;，请尽量按顺序使用 &lt;h1&gt; – &lt;h6&gt;。段落:&lt;p&gt;&lt;/p&gt;无序列表: &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;有序列表: &lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;描述列表: 1234&lt;dl&gt; &lt;dt&gt;吃藕&lt;/dt&gt; &lt;dd&gt;chi ou = 吃藕 = 丑 例句：被老板忽悠剪了个吃藕的发型。&lt;dd&gt;&lt;/dl&gt; 缩写: 1&lt;p&gt;最近大家都在学 &lt;abbr title="Hypertext Markup Language"&gt;HTML&lt;/abbr&gt;。&lt;/p&gt; 时间:&lt;time datetime=&quot;2016-01-20&quot;&gt;2016年1月20日&lt;/time&gt; 特殊字符: 符号 代码 &lt; &amp;lt &gt; &amp;gt “ &amp;quot ‘ &amp;apos &amp; &amp;amp 空格 &amp;nbsp title与h1的区别、b与strong的区别、i与em的区别？title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;b&gt;是展示强调内容。i内容展示为斜体，em表示强调的文本； 自然样式标签:b, i,u,s, pre语义样式标签:strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。 图片普通图片: 12&lt;!-- 显示 Vue.js logo --&gt;&lt;img src="https://vuejs.org/images/logo.png" alt="Vue.js logo" width="200"&gt; 带说明的图片(比如博客头像): 1234567&lt;figure&gt; &lt;img src="https://c-ssl.duitang.com/uploads/item/201608/12/20160812105654_JaZUi.thumb.700_0.jpeg" alt="我是说明,小新" width="60" height="60"&gt; &lt;figcaption&gt;小新&lt;/figcaption&gt;&lt;/figure&gt; 表格简单表格: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;球员&lt;/th&gt; &lt;th&gt;号码&lt;/th&gt; &lt;th&gt;身高&lt;/th&gt; &lt;th&gt;体重&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;国籍&lt;/th&gt; &lt;th&gt;出生地&lt;/th&gt; &lt;tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;勒布朗·詹姆斯&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;2.03米/6英尺8英寸&lt;/td&gt; &lt;td&gt;113.4公斤&lt;/td&gt; &lt;td&gt;1984年12月30日&lt;/td&gt; &lt;td colspan="2"&gt;美国&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;凯里·欧文&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;1.91米/6英尺3英寸&lt;/td&gt; &lt;td&gt;88公斤/193磅&lt;/td&gt; &lt;td&gt;1992年3月23日&lt;/td&gt; &lt;td&gt;美国/澳洲&lt;/td&gt; &lt;td&gt;澳洲&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;凯文·乐福&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;2.08米/6英尺10英寸&lt;/td&gt; &lt;td&gt;110公斤/243磅&lt;/td&gt; &lt;td&gt;1988年9月7日&lt;/td&gt; &lt;td colspan="2"&gt;美国&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;style&gt;table &#123; border-collapse: collapse; //表格线合并&#125;th, td &#123; border: 1px solid green; //设置边框&#125;&lt;/style&gt; 表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div class="login"&gt;//设置登录框 &lt;input type="text" name="sex" placeholder="可以显示未输入前的字"&gt; //输入框 &lt;form action="/getInfo" method="get"&gt; &lt;div class="submit"&gt; &lt;button&gt;提交😁&lt;/button&gt; &lt;/div&gt; &lt;div class="username"&gt; &lt;label for="username"&gt;姓名&lt;/label&gt; &lt;input id="username" type="text" name="username" value="ruo"&gt; //文本类型输入框 &lt;/div&gt; &lt;div class="password"&gt; &lt;label for="password"&gt;密码&lt;/label&gt; &lt;input id="password" type="password" name="password" placeholder="输入密码"&gt; //密码类型输入框 &lt;/div&gt; &lt;div class="hobby"&gt; &lt;label&gt;爱好&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="read"&gt; 读书 &lt;input type="checkbox" name="hobby" value="music"&gt; 听歌 &lt;input type="checkbox" name="hobby" value="study"&gt; 学习 //多选框(复选框) &lt;/div&gt; &lt;div class="sex"&gt; &lt;label&gt;性别&lt;/label&gt; &lt;input type="radio" name="sex" value="男"&gt; 男 &lt;input type="radio" name="sex" value="女"&gt; 女 //单选框 &lt;/div&gt; &lt;div class="file"&gt; &lt;input type="file" name="myfile" accept="image/png"&gt; //上传文件按钮 &lt;/div&gt; &lt;div class="select"&gt; &lt;select name="city"&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai" selected&gt;上海&lt;/option&gt; &lt;option value="hangzhou"&gt;杭州&lt;/option&gt; &lt;/select&gt; //下拉框,默认上海 &lt;/div&gt; &lt;div class="textarea"&gt; &lt;textarea name="article"&gt; 多行文本，注意和 type=text的区别 &lt;/textarea&gt; //下面是四种按钮提交方式 &lt;input type="hidden" name="csrf" value="12345623fafdffdd"&gt; &lt;input type="button" value="Buttom" /&gt; 不会提交 &lt;input type="submit" value="Submit" /&gt; 会提交 &lt;input type="reset" value="Reset" /&gt; 重置输入 &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 表单提交中Get和Post方式的区别 Get一般用于从服务器上获取数据，Post向服务器传送数据 Get传输的数据是拼接在Url之后的，对用户是可见的；Post的传输数据对用户是不可见的 Get传送的数据量较小，不能大于 2KB。Post传送的数据量较大，一般被默认为不受限制 Get安全性非常低，Post安全性较高 在 FORM 提交的时候，如果不指定 Method，则默认为Get请求 label标签的作用label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 超链接123456789//简单链接:&lt;a href="https://github.com/fe13"&gt;FE 13&lt;/a&gt;//title属性:&lt;a href="https://github.com/fe13" title="可能是未来中国最火的前端工程师的聚集地"&gt;FE 13&lt;/a&gt;//外部链接://将target设置成_blank时，点击链接浏览器会新开一个 Tab 打开该网页。&lt;a href="https://github.com/fe13" title="可能是未来中国最火的前端工程师的聚集地" target="_blank"&gt;FE 13&lt;/a&gt;//返回顶部链接:&lt;a href="#"&gt;返回页面顶部&lt;/a&gt; 文档内部链接:用于定位到文档的某一部分，&lt;a&gt; 的 href 要对应文档内某个元素的 id（id 的值在文档内要唯一） 12&lt;a href="#email链接"&gt;Email链接&lt;/a&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Forms"&gt;表单相关标签&lt;/a&gt; 图片链接: 123&lt;a href="https://github.com/fe13" title="可能是未来中国最火的前端工程师的聚集地"&gt; &lt;img src="https://avatars0.githubusercontent.com/u/28950695?v=3&amp;s=200" height="100"&gt;&lt;/a&gt; 123456下载链接:&lt;a href="https://angular.io/resources/images/logos/angular/angular.svg" download&gt;下载 Angular Logo&lt;/a&gt;电话链接:&lt;a href="tel:+8613701234567"&gt;+86 13701234567&lt;/a&gt;Email 链接:&lt;a href="mailto:xiaoxin@xiaoxin.cn"&gt;发封邮件给小新&lt;/a&gt; &lt;br&gt; 文档结构页头 &lt;header&gt;导航栏 &lt;nav&gt;主内容 &lt;main&gt;，后面一般接 &lt;article&gt;,&lt;section&gt;,&lt;div&gt;侧边栏 &lt;aside&gt;页尾 &lt;footer&gt; 语义化 HTML选择合适的标签、使用合理的代码结构，便于开发者和视觉障碍人士阅读，同时让浏览器的爬虫和机器很好地解析。 相对路径同一站点尽量使用相对路径。 123456&lt;!-- index.html --&gt;&lt;img src="images/logo.png"&gt;/* app.css */.container &#123; background: url('../images/background.png');&#125; 绝对路径https://github.com/fe13/fe/blob/master/README.md 浏览器内核主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] HTML5新特性 语义化标签: header footer main article nav section aside等 增强型表单: date name email range search tel 视频音频: video audio canvas绘图, svg绘图 地理定位: geolocation 拖放API: drag web worker: 是运行在后台的js脚本 webstorage: localStorage sessionStorage webSocket: HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议 如何实现浏览器内多个标签页之间的通信 使用 localStorage: localStorage.setItem(key,value)、localStorage.getItem(key) websocket协议 webworker]]></content>
      <categories>
        <category>HTML</category>
        <category>HTML基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start文本插值的双大括号形式会被识别导致无法上传,注意!!!Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
