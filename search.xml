<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS基础]]></title>
    <url>%2F2019%2F08%2F19%2FJS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据类型number.boolean.string.undefined.null.object.symbol原始类型，number.string.boolean。指保存在栈内存里的简单数据段引用类型，对象。又可分为狭义的对象，数组，函数，正则。指保存在堆内存中的对象typeof undefined 输出 undefinedtypeof null 输出 object 运算符 &amp;&amp; (And) || (or) ! (not) == 和 ===，前者先转化类型，后进行判断，后者比较类型和值 三元运算符condition ? true case : false case boolean值false: undefined null 0 NaN 空字符串 JS函数函数会声明前置 1234foo() //hellofunction foo()&#123; return "hello"&#125; 函数表达式不会 1234fn()//报错var fn() = fnction()&#123; return "hello" &#125; 深拷贝js对象查看所有属性 12var objects = &#123; p: 1&#125;Object.keys(obj) 删除命令delete object.p 循环判断 12345678910switch(判断语句）&#123; case 条件： 输出; break; case 条件: 输出; break; default: 输出&#125; while循环 12345while(expression)&#123; statement&#125;//如果expression为true，执行，//循环继续执行直到判断不成立。 do-while循环 1234do&#123; statement;&#125;while(expression);//先执行，够判断 for循环 break退出本次循环continue跳过本次循环执行下次循环 字符串12str.charAt(0) //获取第一个字符str.charCodeAt(0) //获取字符对应的ASC码 字符串截取 1234var str= "hello"str.substr(1,3) //第一个开始，第二个长度str.substring(1,3) //第一个开始，第二个结束str.slice(1,3) //同上，允许负参 查找 1234str.search("he") //返回下标strong.indexOf("he") //同上str.replace("he", "you") //替换str.match("he") //匹配 大小写 12str.toUpperCase()str.toLowerCase() //本身不变化 数组1234567891011121314151617181920212223242526272829303132333435arr.push(newelement) //末尾新增一个arr.pop() //末尾踢出一个字arr.shift() //开头拿出一个arr.unshift() //开头新增一个arr.splice(index,替换几个，替换内容) //原数组变//返回由删除元素组成的新数组arr.slice(start，end) //原数组不变arr.join("-") //将数组变成字符串并用-连接arr.reverse() //数组反转arr.sort(v1-v2) //没有参数按顺序排列，但是会出现10,11,7,8,9排列，//有参数设置比较函数，函数结果v1-v2如果大于0，两两替换位置。否则，不变a.concat(array) //拼接，返回数组a和array的集合。原数组不变Array.isArray(obj) //判断传入的obj是不是数组a.indexof(2) //判断数组a中是否含有2,返回其索引a.forEach(fn(element,index,arr)&#123;&#125;)//forEach里是一个回调函数，有三个参数，分别是当前元素，索引值，整个数组a.map(fn(element)&#123;&#125;)//与forEach类似，返回新数组，原数组不变//而forEach会修改原数组a.every(fn(element,index,arr)&#123;&#125;)//every是所有函数返回true才会返回true，遇到false终止，并返回falsea.some(fn(element,index,arr)&#123;&#125;)//some是存在一个返回true时就终止返回truea.filter(fn(element)&#123;&#125;)//返回新数组，回调函数用于逻辑判断，为true则把当前元素加到返回的数组中//为false则不加a.reduce(fn(v1,v2),value)//将数组元素合成一个值，从索引值最小开始。value表示初始值a.abs(x) //返回x的绝对值 Math四舍五入 12Math.round(0.5)//1Math.round(-1.5)//-1 绝对值 1Math.abs(-1) //1 1234floor返回小于参数值的最大整数.向下取整Math.floor(-3.2) //-4ceil返回大于参数值的最小参数，向上取整Math.ceil(-3.2) //-3 parseInt(值，进制) 123parseInt(string,radix)//将一个字符串 string 转换为 radix 进制的整数，// radix 为介于2-36之间的数。 parseInt()可以将字符串转为数字，也可以将数字取整。向下取整。radix不写默认是2进制.如果第一个字符是数字会解析直到遇到非数字结束，如果第一个字符不是数字或者符号（如：+、-）就返回NaN。带自动净化功能；带自动截断小数功能，且取整，不四舍五入。 几次方 12Math.pow(x,y) //返回 x 的 y 次幂的值。Math.pow(2,2) //4 平方根 12Math.sqrt(4) // 2Math.sqrt(-4) //NaN random 12Math.random()//返回0-1之间的伪随机数.0≦x&lt;1 Date123Date.now() //获取1970年至今的毫秒数Date.parse() //解析日期字符串，返回距离1970年的毫秒数Date.parse("2011-01-11") //13234436600000 1234567new Date() //使用Date构造函数创建一个Date实例，//不传时间就返回当前时间的字符串var str = "2019-01-11"new Date(str) //Fri Jan 11 2019 08:00:00 GMT+0800 (香港标准时间)//获取的是东八区8点的时间，因为格林尼治时间伦敦是0点 get方法 12345678getDate() //日getDay() //星期几，周日是0，周一是1getFullyear() //返回四位的年份getMouth() //返回月份，一月是0，腊月是11getHours() //小时（0-23）getMinutes() // 返回分钟getSenconds() // 秒getMilliseconds() // 毫秒(0-999) set方法类似于get方法，是设置时间 node.js基础 12345678910node index.js //启动服务器index.js文件中引入http模块var http = require("http") //引入http模块var server = http.creatserve(fn(res,req))//创建服务器response.end() //结束server.listen(9000) //启动服务器，监听9000端口res.setHeader("Content-Type", "text/plain; chartset=gbk")//设置响应头res.writeHead(200,"ok") //设置状态码console.log("open http://localhost:9000") 进阶 12345678910111213141516171819202122232425262728293031323334var http = require("http") //引入http模块var path = require("path") //自动处理路径问题var fs = require("fs") //读写文件var url = require("url") //解析urlfunction staticRoot(staticPath, req, res)&#123; var pathObj = url.parse(req.url, true) //url.parse是node.js方法，将一个URL字符串转换成对象并返回 console.log(pathObj) if(pathObj.pathname === "/")&#123; pathObj.pathname += "index.html" &#125; //不加后缀可以默认加后缀var filePath = path.join(staticPath, pathObj.pathname)//拼接文件地址fs.readFile(filePath, "binary", function(err, fileContent)&#123; if(err)&#123; res.writeHead(404, "not found") res.end("&lt;h1&gt;404 Not Found&lt;/h1&gt;")&#125;else&#123; res.writeHead(200, "ok") res.write(fileContent, "binary") res.end() &#125;&#125;)console.log("path.join(_dirname, "static")var server = http.createServer(function(res,req)&#123; staticRoot(path.join(__dirname, "static"), req, res) //__dirname代表当前文件server.listen(8080)console.log("visit http://localhost:8080") 异步和回调函数节流，在时间内，如果执行，就重新开始原理：当达到了一定的时间间隔就会执行一次；可以理解为是缩减执行频率 12345678910111213function throttle(fn,delay)&#123; const timer = null return function()&#123; clearTimeout(timer) timer = setTimeout(function()&#123; fn(arguments) &#125;,delay) &#125;&#125;function fn()&#123; console.log("hello")&#125;var fn2 = throttle(fn, 1000) 函数防抖原理：将若干函数调用合成为一次，并在给定时间过去之后，或者连续事件完全触发完成之后，调用一次(仅仅只会调用一次) 12345678910111213function debounce(fn,ms)&#123; let timer = null return function()&#123; clearTimeout(timer) timer = setTimerout(()=&gt;&#123; fn() &#125;,ms) &#125;&#125;Function _log()&#123; console.log(1)&#125;Window.onscroll = debounce(_log,500) 区别 他们的区别在于防抖只会在连续的事件周期结束时执行一次，而节流会在事件周期内按间隔时间有规律的执行多次。 DOM元素创建和选取DOM是文档对象模型，是html的编程接口readyState加载状态 1234567891011document.location//location属性返回一个只读对象，提供当前文档的url信息document.location.href //获取urldocument.location.protocol //获取"http:"document.location.hostname // "www.example.com"document.location.port // "4097" document.location.pathname // "/path/a.html"document.location.assign("http://www.Google.com") //跳转到指定网址document.location.reload(true) //优先从服务器重新加载document.location.reload(false) //优先从本地缓存加载 123document.open() //新建文档可以使用write写入document.close() //关闭文档document.write() //写入文档 Element表示html元素 element的属性： nodeName: 元素标签名 nodeType:元素类型 className:类名 id:元素id children:子元素列表 childNodes: 子元素列表（NodeList） firstChild: 第一个子元素 lastChild:最后一个 nextSibling: 下一个兄弟元素 previousSibling: 上一个兄弟元素 parentNode.parentElement: 父元素 查询元素 12345678910111213document.getElementById("target")document.getElementsByClassName("box")//上述为ES3写法//下面是ES5写法document.querySelector(".box")document.querySelector("#tatget")//多个元素只会选择第一个//选择多个document.querySelectorAll("div")//浏览器控制台测试时可以用$替代document.querySelector//用$$替代document.querySelectorAll 创建元素 1234567document.createElement("div")//生成文本节点document.createTextNode("Hello")//生成DocumentFragment对象document.createDocumentFragment()//存在于内存中的DOM片段，不属于当前文档。//对它的任何改动，都不会引发网页的重新渲染 修改元素 1234567891011121314151617在元素末尾添加元素appendChild()newDiv.appendChild(newContent)在元素之前插入元素insertBefore()替换元素replaceChild(newElement,oldElement)删除元素parentNode.removeChild(childNode)clone元素node.cloneNode(true)//方法有一个布尔值，传入true时会深拷贝，//复制元素及其子元素，false只会复制元素本身 DOM元素属性123456789101112获取属性node.getAttribute("id")生成新的属性对象节点attribute = document.createAttribute(name)一般用 setAttribute()设置元素属性var node = document.getElementById("id")node.setAttribute("id", "newVal")删除属性节点node.removeAttribute("id") innerText可写属性，返回元素内包含的文本内容，在多层次的时候按照元素由浅到深的顺序拼接内容123456&lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 外层div的innerText返回内容是 &quot;123456&quot; innerHTML返回元素html结构，在写入的时候也会自动构建DOM 样式修改样式 1document.querySelector("p").style.color = "red" 获取样式getComputedStyle 1234var node = document.querySelector('p') var color = window.getComputedStyle(node).color console.log(color)//获取计算后的样式，只读。全局属性 class操作的增删改查123456var nodeBox = document.querySelector(".box")console.log(nodeBox.classList)nodeBox.classList.add("active") //新增classnodeBox.classList.remove("active") //删除nodeBox.classList.toggle("active") //新增删除切换node.classList.contains("active") //判断是否拥有class 页面宽高 12345clientWidth() //包括paddingoffsetHeight() //包括borderscrollHeight() //滚动内容的总高度scrollTop() //滚动的高度innerHeight() //窗口的高度 事件捕获阶段，目标阶段，冒泡阶段 事件绑定12345678&lt;input id="btnClick" type="button" value="Click here"&gt; &lt;script type="text/javascript"&gt;var btnClick = document.getElementById("btnClick")btnClick.onclick = function showMessage()&#123; alert(this.id)&#125;&lt;/script&gt; 会存在覆盖 DOM2事件处理(升级版) addEventListener //绑定事件 removeEventListener //解绑事件 所有DOM节点都包含这两个方法，且都接受三个函数： 事件类型 事件处理方法 布尔参数，true表示在捕获阶段调用，false表示在事件冒泡阶段处理，默认是冒泡阶段123btnClick.addEventListener("click", function()&#123; alert(this.id)&#125;, false) 不存在覆盖，可以写多个方法 属性方法123preventDefault() //取消默认事件行为stopPropagation() //取消事件进一步捕获或冒泡target() //事件的目标元素 事件代理使用事件代理来实现它，监听的元素应该是这些元素的父元素，当我点击父元素内的元素时，父元素都会得到响应，并分发相应的事件。 e.target就是点击的元素。 1234567$('.container').onclick = function(e)&#123; console.log(this) console.log(e.target) if(e.target.classList.contains('box'))&#123; console.log(e.target.innerText) &#125; &#125; 常见事件及自定义事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950鼠标事件clickdblclick //双击左键mouseover //鼠标放上mouseout //鼠标移出mouseenter //类似over，区别不计算子元素mouseleave //类似out，区别不计算子元素mousedown //鼠标按下mouseup //鼠标松开触摸事件touchstarttouchendtouchmove键盘事件keyup //按键后松开触发keydown //按键即会触发keypress //按下松开页面相关事件onload //加载完成时触发onmove //浏览器窗口被移动scroll //滚动条滚动resize //窗口大小变化表单相关focus //获取焦点blur //失去焦点change //失去焦点且内容发生改变reset //reset属性被激活submit //提交，一般是表格提交input //在input元素内容修改后立即触发onload //页面所有资源加载完成DOMContentLoaded //dom结构解析完成编辑事件beforecopy //复制之前beforecut //剪切之前beforepaste //粘贴之前beforeeditfocus //将要进去编辑状态contextmenu //按右键出现菜单或者键盘触发页面菜单losecapture //失去鼠标移动所形成的选择焦点select //被选择时拖动事件drag //某个对象被拖动dragdrop //外部对象被拖到当前窗口dragend //拖动结束dragenter //被拖动对象进入其容器范围 自定义事件123456789101112131415var EventCenter = &#123; on: function(type, handler)&#123; document.addEventListener(type, handler) &#125;, fire: function(type, data)&#123; return document.dispatchEvent(new CustomEvent(type, &#123; detail: data &#125;)) &#125; &#125; EventCenter.on('hello', function(e)&#123; console.log(e.detail) &#125;) EventCenter.fire('hello', '你好') //一个监听函数，一个处理函数 JS动画requestAnimationFrame可以在一定时间内自动执行 123456789function move()&#123; if(moveOffset &lt; offsetX)&#123; ball.style.left = parseInt(getComputedStyle(ball).left) + step +"px" moveOffset += step requestAnimationFrame(move) &#125;&#125;move() BOMbom指浏览器对象模型，核心是window对象。是浏览器的实例window.innerHeight属性，window.innerWidth属性.这两个属性返回网页的CSS布局占据的浏览器窗口的高度和宽度，单位为像素。很显然，当用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。 注意，这两个属性值包括滚动条的高度和宽度。 scrollX：滚动条横向偏移 scrollY：滚动条纵向偏移 这两个值随着滚动位置变化而变化 window.frames返回一个类似数组的对象，成员为页面内的所有框架，包括frame元素和iframe元素。需要注意的是，window.frames的每个成员对应的是框架内的窗口（即框架的window对象），获取每个框架的DOM树，需要使用window.frames[0].document。 12var iframe = window.getElementsByTagName("iframe")[0];var iframe_title = iframe.contentWindow.title; 上面代码用于获取框架页面的标题。 iframe元素遵守同源政策，只有当父页面与框架页面来自同一个域名，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。在iframe框架内部，使用window.parent指向父页面。 navigator指向一个包含浏览器相关信息的对象. window.getComputedStylegetComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值 1var style = window.getComputedStyle("元素", "伪类") URL的编码/解码方法JavaScript提供四个URL的编码/解码方法。 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 区别 encodeURI方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!@#$&amp;*()=:/,;?+' encodeURIComponent方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!*()' alert()，prompt()，confirm()alert()、prompt()、confirm()都是浏览器用来与用户互动的方法。它们会弹出不同的对话框，要求用户做出回应。 需要注意的是，alert()、prompt()、confirm()这三个方法弹出的对话框，都是浏览器统一规定的式样，是无法定制的。]]></content>
      <categories>
        <category>JS</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
