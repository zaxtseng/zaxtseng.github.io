<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端安全防范]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83%2F</url>
    <content type="text"><![CDATA[XSS攻击 什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？ XSS 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导 致大量正常访问页面的用户都受到攻击。举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容&lt;script&gt;alert(2)&lt;/script&gt;.这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行. 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt; &lt;div&gt;&lt;/div&gt; 但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我 们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器. 防御对于 XSS 攻击来说，通常有两种方式可以用来防御。 转义字符首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进 行转义 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\//g, '&amp;#x2F;') return str &#125; 123//通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt; escape('&lt;script&gt;alert(1)&lt;/script&gt;') 但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 CSP(白名单)CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何 拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置meta标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 这里以设置 HTTP Header 来举例 123456//只允许加载本站资源Content-Security-Policy: default-src ‘self’//只允许加载 HTTPS 协议图片Content-Security-Policy: img-src https://*//允许加载任何来源框架Content-Security-Policy: child-src 'none' CSRF攻击 什么是CSRF攻击？如何防范CSRF攻击？CSRF中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。举个例子，假设网站中有一个通过GET请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src="http://www.domain.com/xxx?comment='attack'"/&gt; 那么你是否会想到使用POST方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交POST请求 如何防御防范CSRF攻击可以遵循以下几种规则： GET请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token SameSite可以对Cookie设置SameSite属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。验证Referer对于需要防范CSRF的请求，我们可以通过验证Referer来判断该请求是否为第三方网站发起的。Token服务器下发一个随机Token，每次发起请求时将Token携带上，服务器验证Token是否有效。 点击劫持 什么是点击劫持？如何防范点击劫持？点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击。 如何防御X-FRAME-OPTIONSX-FRAME-OPTIONS是一个HTTP响应头，在现代浏览器有一个很好的支持。这个HTTP响应头就是为了防御用iframe嵌套的点击劫持攻击。该响应头有三个值可选，分别是DENY，表示页面不允许通过iframe的方式展示SAMEORIGIN，表示页面可以在相同域名下通过iframe的方式展示ALLOW-FROM，表示页面可以在指定来源的iframe中展示JS防御对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过JS的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id="click-jack"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById('click-jack') document.body.removeChild(style) &#125; else &#123; top.location = self.location &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过iframe的方式加载页面时，攻击者的网页直接不显示所有内容了。 中间人攻击 什么是中间人攻击？如何防范中间人攻击？ 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。通常来说不建议使用公共的Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS就可以用来防御中间人攻击，但是并不是说使用了HTTPS就可以高枕无忧了，因为如果你没有完全关闭HTTP访问的话，攻击方可以通过某些方式将HTTPS降级为HTTP从而实现中间人攻击。]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>HTTP安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue服务端渲染]]></title>
    <url>%2F2019%2F09%2F15%2FVue%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[介绍 Vue.js是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出Vue组件，进行生成DOM和操作DOM。然而，也可以将同一个组件渲染为服务器端的HTML字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 服务器渲染的Vue.js应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。 优缺点优点: 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。缺点: 开发条件所限。 涉及构建设置和部署的更多要求。 更多的服务器端负载。基本用法安装npm install vue vue-server-renderer --save渲染实例12345678910111213141516171819202122// 第 1 步：创建一个 Vue 实例const Vue = require('vue')const app = new Vue(&#123; template: `&lt;div&gt;Hello World&lt;/div&gt;`&#125;)// 第 2 步：创建一个 rendererconst renderer = require('vue-server-renderer').createRenderer()// 第 3 步：将 Vue 实例渲染为 HTMLrenderer.renderToString(app, (err, html) =&gt; &#123; if (err) throw err console.log(html) // =&gt; &lt;div data-server-rendered="true"&gt;Hello World&lt;/div&gt;&#125;)// 在 2.5.0+，如果没有传入回调函数，则会返回 Promise：renderer.renderToString(app).then(html =&gt; &#123; console.log(html)&#125;).catch(err =&gt; &#123; console.error(err)&#125;) 与服务端集成12345678910111213141516171819202122232425262728293031//安装npm install express --save//操作expressconst Vue = require('vue')const server = require('express')()const renderer = require('vue-server-renderer').createRenderer()server.get('*', (req, res) =&gt; &#123; const app = new Vue(&#123; data: &#123; url: req.url &#125;, template: `&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;` &#125;) renderer.renderToString(app, (err, html) =&gt; &#123; if (err) &#123; res.status(500).end('Internal Server Error') return &#125; res.end(` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt; &lt;body&gt;$&#123;html&#125;&lt;/body&gt; &lt;/html&gt; `) &#125;)&#125;)server.listen(8080) 使用页面模板123456789//index.template.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;!--这里将是应用程序 HTML 标记注入的地方--&gt; &lt;/body&gt;&lt;/html&gt; 读取和传输文件到 Vue renderer 中： 1234567const renderer = createRenderer(&#123; template: require('fs').readFileSync('./index.template.html', 'utf-8')&#125;)renderer.renderToString(app, (err, html) =&gt; &#123; console.log(html) // html 将是注入应用程序内容的完整页面&#125;)]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex]]></title>
    <url>%2F2019%2F09%2F14%2FVueX%2F</url>
    <content type="text"><![CDATA[Vuex 介绍每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态(state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。我的理解: Vuex 相当于一个扩展板的bus中介.起步虽相似,但功能更丰富. Vuex 之 store起步: 安装,引入,use,创建状态仓库.在 Vue 实例中注入(把 store 写进去).一条龙服务. 1234567891011121314151617181920212223//创建仓库格式var store = new Vuex.Store(&#123; state: &#123; //定义你的状态 XXX: xxx &#125;, mutations: &#123; //在此处定义状态改变的方法 increase(state)&#123; state.num ++ &#125; decrease(state)&#123; state.num -- &#125; &#125;, actions: &#123; //actions中传递的不再是state,而是context increaseAction(context)&#123; //actions中只能对mutations中的方法进行操作 context.commit('increase') &#125; &#125;&#125;) mutations 改变状态:直接通过this.$store.state.XXX拿到状态在 methods 中.定义一个函数通过this.$store.commit(&#39;xxx&#39;)方法触发状态变更 actions 改变状态:通过this.$store.dispatch(xxx)调用 二者区别: 传入参数不同,mutations 传入state.actions 传入context 调用方式不同,前者this.$store.commit(&#39;xxx&#39;).后者this.$store.dispatch(xxx) 函数要求不同.mutations 中只能有同步操作,actions 中可以有异步操作. getters有时需要对 mutations 处理后的 state 进行处理.可以当做 vuex 的计算属性(computed). 1234567getters: &#123; getNum(state)&#123; //因为要处理state,自然传入state return state.num &gt; 0 ? state.num : 0 //这里是防止一直减出现负数进行的处理 &#125;&#125; 获取状态也就改为 1234567//在组件中computed: &#123; getCount()&#123; //return this.$store.state.num return this.$store.getters.getNu &#125;&#125; Vuex 状态管理流程view–&gt;actions–&gt;mutations–&gt;state–&gt;view 新增VueX 中state相当于datagetter相当于computedmutation相当于methodsaction是异步的mutationmodule模块将上述进行封装分块 mapState 和 mapGettersmapState辅助函数仅仅是将 store 中的getter映射到局部计算属性 1234567891011121314...Vuex.mapState(['firstName', 'lastName'])//相当于firstName()&#123; return this.$store.state.firstName&#125;,lastName()&#123; return this.$store.state.lastName&#125;..Vuex.mapGetters(['fullName'])//相当于fullName()&#123; return this.$store.getters.fullName&#125; store.commit(&#39;xxFirstName&#39;, &#39;jirengu&#39;)提交 mutation 中 xxFirstName 的方法。第一个参数是 state 中有的，后添加的 jirengu 是载荷payload。 提交载荷（payload）向store.commit传入额外参数，即mutation的载荷 12345678mutations:&#123;increment (state, payload)&#123;state.count += payload.amount&#125;&#125;store.commit('increment', &#123;amount: 10&#125;) actions 中传入第一个参数是context，第二个是payload触发 action 1store.dispatch("increment"); moudle(模块化)12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueRouter]]></title>
    <url>%2F2019%2F09%2F14%2FVueRouter%2F</url>
    <content type="text"><![CDATA[vue-router路由 安装vue-routernpm install --save vue-router 引用 12import router from 'vue-router'Vue.use(router) 配置路由文件,并在Vue实例中注入 123456789101112131415161718192021import Vue from 'vue'import App from './App'import router from 'vue-router'import HelloWorld from './components/HelloWorld'Vue.use(router) //引入并且使用var rt = new VueRouter(&#123; //下面这个routes是数组,用[] routes: [&#123; path: '/hello', //指定要跳转的路径 component: HelloWorld //指定要跳转的组件 &#125;]&#125;)new Vue(&#123; el: "#app", router: rt, //把路由实例rt写到Vue实例中就注入了 components: &#123; App &#125;, //组件直接注入.分开写便于模块化 template: '&lt;App/&gt;' //同上&#125;) 确定视图加载的位置 123456789101112131415161718192021222324&lt;router-view&gt;&lt;/router-view&gt;//把这个写到想注入的位置就可以了``` ## 路由跳转在路由文件中,一般是`router/index.js`.就是把路由单独写一个文件```javascriptimport Vue from 'vue'import router from 'vue-router'import HelloWorld from './components/HelloWorld'import HelloEarth from './components/Helloearth'Vue.use(router) //引入并且使用export default new router(&#123; routes: [&#123; path: '/helloworld', //指定要跳转的路径 component: HelloWorld //指定要跳转的组件 &#125;, &#123; path: '/helloearth', //指定要跳转的路径 component: HelloEarth //指定要跳转的组件 &#125;, ]&#125;) 然后在页面组件中 12345678910&lt;template&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to="/helloworld"&gt;HelloWorld&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to="/helloearth"&gt;HelloEarth&lt;/router-link&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/template&gt; vue-router路由参数传递 必须在路由内加入路由的name 必须在path后加/:加传递的参数 传递参数和接收参数(具体看下面两种方法)12345678910111213141516171819//两种方式: &lt;router-link :to="&#123;name: helloworld,params:&#123;worldmsg: '你好世界' &#125;&#125;"&gt; helloworld&lt;/router-link&gt; //读取参数:$route.params.xxx //这种方式等同于./helloworld/你好世界export default new router(&#123; routes: [&#123; name: 'helloworld', path: '/helloworld/:id', //动态绑定,各个不同id就都使用HelloWorld组件了 component: HelloWorld //指定要跳转的组件 &#125;, &#123; name: 'helloearth', path: '/helloearth/:earthmsg', //指定要跳转的路径 component: HelloEarth //指定要跳转的组件 &#125;, ]&#125;) 1234567891011 &lt;router-link :to="&#123;path: '/helloearth',query:&#123;msg: 只有一个地球&#125;&#125;"&gt; &lt;/router-link&gt; //方式等同于./helloworld?name=xxx&amp;count=xxx coust couter = new VueRouter(&#123; routes:[ &#123;path: '/search', component: SearchUser, props: (route) =&gt;(&#123; query: route.query.q &#125;) &#125; ] &#125;) 导航守卫导航守卫就是路由跳转过程中的一些钩子函数. 1234567891011//钩子函数执行后输出的顺序全局前置守卫: beforeEach路由独享守卫: beforeEnter组件路由守卫: beforeRouteEnter,此时this并不指向该组件实例全局解析守卫: beforeResolve全局后置守卫: aferEach组件生命周期: beforeCreate组件生命周期: created组件生命周期: borforeMount组件生命周期: mounted组件路由守卫: beforeRouteEnter的next回调 导航守卫分为：全局的、单个路由独享的、组件内的三种. 全局的分别是beforeEach,beforeResolve,afterEach 12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) beforeEach: 全局前置守卫.在路由跳转前触发,参数:to,from,next.这个钩子函数主要用于登录验证.beforeResolve: 全局解析守卫.和beforeEach类似.区别是在beforeEach和组件内beforeRouteEnter之后，afterEach之前调用.afterEach: 全局后置钩子.和beforeEach相反,在路由跳转完成后触发,参数: to,from.他发生在beforeEach和beforeResolve之后. 三个参数(to,from,next) to: Route: 即将要进入的目标路由对象 from: Route: 当前导航正要离开的路由 next: Function: 必须调用该方法来resolve这个钩子.否则不能进入路由.执行效果依赖next方法的调用函数. next(false): 中断当前导航.如果浏览器的URL改变,那么URL会重置到from路由对应的地址. next(&#39;/&#39;): 跳转到一个不同的地址. next(error): 如果传入的next的参数是一个Error实例.则导航会被终止且该错误会被传递给router.onerror()注册过的回调. 确保要调用next方法,否则钩子就不会被resolved. 路由独享的守卫beforeEnter可以在路由配置上直接定义beforeEnter守卫:123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, brforeEnter: (to, from, next) =&gt; &#123; //参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 //... &#125; &#125; ]&#125;) 组件内的守卫beforeRouteEnter 进入路由前beforeRouteUpdate 路由复用同一个组件时beforeRouteLeave 离开当前路由时 123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter(to, from, next)&#123; //在渲染该组件的对应路由被confirm前调用 //不能!!获取组件实例this //因为当守卫执行前,组件实例还未创建 &#125;, beforeRouteUpdate(to, from, next)&#123; //在当前路由改变,但是该组件被复用时调用 //举例来说,对于一个带有动态参数的路径 /foo/:id,在/foo/1和/foo/2之间跳转的时候, //由于会渲染同样的Foo组件,因此组件实例会被复用.而这个钩子就会在这个情况下被调用. //可以访问组件实例this &#125;, beforeRouteLeave(to, from, next)&#123; //导航离开该组件的对应路由时调用 //可以访问组件实例this &#125;&#125; beforeRouteEnter守卫不能访问this因为钩子在组件实例还没被创建的时候调用,可以通过传一个回调给next来访问组件实例 。不过,可以通过传一个回调给next来访问组件实例.在导航被确认的时候执行回调,并且把组件实例作为回调方法的参数.但是回调的执行时机在mounted后面,所以在我看来这里对this的访问意义不太大，可以放在created或者mounted里面。 12345beforeRouteEnter(to, from, next)&#123; next(vm =&gt; &#123; //通过`vm`访问组件实例 &#125;)&#125; beforeRouteLeave导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。 1234567beforeRouteLeave (to, from , next) &#123; if (文章保存) &#123; next(); // 允许离开或者可以跳到别的路由 上面讲过了 &#125; else &#123; next(false); // 取消离开 &#125;&#125; 路由钩子函数的错误捕获如果在导航守卫的钩子函数中有错误,可以这样捕获: 123router.onError(callback =&gt; &#123; console.log(callback, 'callback')&#125;) 完整的路由导航解析流程: 触发进入其他路由。 调用要离开路由的组件守卫beforeRouteLeave 调用全局前置守卫: beforeEach 在重用的组件里调用beforeRouteUpdate 调用路由独享守卫beforeEnter 解析异步路由组件 在将要进入的路由组件中调用beforeRouteEnter 调用全局解析守卫beforeResolve 导航被确认 调用全局后置钩子afterEach 触发DOM更新(mounted) 执行beforeRouteEnter守卫中传给next的回调函数]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js进阶]]></title>
    <url>%2F2019%2F09%2F13%2FVuejs%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[render函数初识render12345678910111213141516171819202122232425262728293031&lt;template id="hdom"&gt;//template下只允许有一个子节点,所以用div包裹三个标题 &lt;div&gt; &lt;h1 v-if="level==1"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-if="level==2"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-if="level==3"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; Vue.component('child', &#123; //使用template命名的方法将大段代码写在html里 props: ['level'], template: '#hdom' &#125;) Vue.component('child', &#123; //使用render函数替代template,节省大量代码 render: function (createElement) &#123; return createElement('h' + this.level, this.$slots.default); &#125;, props: ['level'] &#125;)&lt;/script&gt; render函数的第一个参数在render函数的方法中,参数必须是createElement,它的类型是functioncreateElement的第一个参数必选.类型可以是String|Object|Function 1234567891011121314151617Vue.component('child',&#123; render: function(createElement)&#123; return createELement('h1') //参数是字符串.返回&lt;h1&gt;&lt;/h1&gt; return createElement(&#123; template: `&lt;div&gt;鹅鹅鹅&lt;/div&gt;` &#125;) //参数是对象.返回&lt;div&gt;鹅鹅鹅&lt;/div&gt; var domFun = function()&#123; return &#123; template: `&lt;div&gt;鹅鹅鹅&lt;/div&gt;` &#125; &#125; return createELement(domFun()) //参数是函数.返回&lt;div&gt;鹅鹅鹅&lt;/div&gt; &#125;&#125;) render函数的第二个参数createElement的第二个参数可选.参数是数据对象,只能是Object 1234567891011121314151617181920212223242526272829Vue.component('child',&#123; render: function(createElement)&#123; return CreateElement(&#123; template: `&lt;div&gt;鹅鹅鹅&lt;/div&gt;` &#125;,&#123; //添加class选项,其中为true的会添加到模板&lt;div&gt;中 'class':&#123; foo: true baz: false &#125;, //添加style属性 style: &#123; color: 'red', fontSize: '18px' &#125;, //正常的html属性 attrs: &#123; id: 'foo', src: 'xxxx' &#125;, //原生DOM属性 domProps: &#123; innerHTML: '&lt;span style="color:blue"&gt;我是蓝色&lt;/span&gt;' &#125; &#125; ) &#125;&#125;) render函数的第三个参数createElement的第三个参数可选.参数可以是String|Array,代表子节点 1234567Vue.component('child', &#123; render: function (createElement) &#123; return createElement('div', [ createElement('h1', '我是h1标题'), createElement('h6', '我是h6标题') ]) &#125;&#125;); 在render函数中使用this.$slots第三个参数存的是VNode,也就是虚拟节点 12345678910111213Vue.component('my-component',&#123; render: function(createElement)&#123; var header = this.$slots.header //返回的就是含有VNode的数组 var main = this.$slots.default var footer = this.$slots.footer return createElement('div',[ createElement('header',header), createElement('main',main), createElement('footer',footer) ]) &#125;&#125;) 在render函数中使用props传数据1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;button @click="switchShow"&gt;点击切换&lt;/button&gt; &lt;my-component :show="show"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; props: ['show'], render: function(createElement)&#123; var imgsrc if(this.show)&#123; imgsrc = 'img/001.jpg' &#125;else&#123; imgsrc = 'img/002.jpg' &#125; return createElement('img',&#123; attrs: &#123; scr: imgsrc &#125; &#125;) &#125;&#125;)var app = new Vue(&#123; el: "#app", data: &#123; show: true &#125;, methods: &#123; switchShow: function()&#123; this.show = !this.show &#125; &#125;&#125;)&lt;/script&gt; 在render函数中使用v-modelv-model作用: 接收input的内容并绑定到后面的值上. 1234567891011121314151617181920212223242526272829303132&lt;div id="app"&gt;&lt;my-component v-bind:name="name" v-model="name"&gt;&lt;/my-component&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; render: function(createElement)&#123; props:['name'], var self = this //指的是当前的Vue实例 return createElement('input',&#123; domProps: &#123; //原生DOM value: self.name &#125;, on: &#123; //这里添加事件 input: function(event)&#123; //此处的this是window,所以需要声明self指代vue实例 self.$emit('input',event.target.value) &#125; &#125; &#125;) &#125;&#125;)var app = new Vue(&#123; el: "#app", data: &#123; name: "Tom" &#125;&#125;)&lt;/script&gt; render函数中使用作用域插槽123456789101112131415161718192021222324&lt;div id="app"&gt;&lt;my-component&gt; &lt;template scoped="prop"&gt; &#123;&#123; prop.text &#125;&#125; &#123;&#123; prop.msg &#125;&#125; &lt;/template&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; render: function(createElement)&#123; return createElement('div',this.$scopedSlots.default(&#123; text: '我是子组件传递的数据', msg: 'scopetext' &#125;))&#125;)var app = new Vue(&#123; el: "#app", data: &#123; &#125;&#125;)&lt;/script&gt; 函数化组件先设置functional: true,表示该组件无状态无实例,不能使用this使用上下文context进行替换替换规律: 12this.text-----context.props.textthis.$slots.default------context.children 123456789101112131415161718192021222324252627282930&lt;div id="app"&gt;&lt;my-component value="haha"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; functional: true, //开启函数化,无实例,无状态.this失效 render: function(createElement,context)&#123; //添加context参数 return createElement('button',&#123; on: &#123; click: function()&#123; console.log(context) console.log(context.parent) //父组件 console.log(context.parent.msg) console.log(context.props.value) &#125; &#125; &#125;,'点击我') //第三个参数 &#125;, props:['value'] )var app = new Vue(&#123; el: "#app", data: &#123; msg: "我是父组件内容" &#125;&#125;)&lt;/script&gt; Axiosaxios是一个基于Promise用于浏览器和nodejs的HTTP客户端，它本身具有以下特征： 从浏览器中创建XMLHttpRequest 从node.js发出http请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 步骤: 安装 引入 一般是把axios挂载到原型上,便于全局使用1Vue.prototype.$http = axios Axios之get请求12345678910111213141516methods: &#123; getData()&#123; this.$http.get('https://cnode.js.org/api/v1/topic',&#123; params: &#123; page: 1, limit: 10 &#125; &#125;) .then(res=&gt;&#123; this.items = res.data.data &#125;) .catch(err=&gt;&#123; comsole.log(err) &#125;) &#125;&#125; 123456789101112//上面get请求的其他写法axios.get('/user',&#123; params: &#123; ID: 12345 &#125;&#125;)//如果只有一个选项axios.get('/user',&#123; ID: 12345&#125;)//将数据写到url里axios.get('/user?page=1&amp;limit=10') Axios之post请求12345678910axios.post('/user',&#123; firstName: 'tom', lastName: 'green'&#125;).then(res=&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;) POST传递参数有两种格式: form­-data 格式: ?page=1&amp;limit=48.但是不能写在url里 x-­www-­form-­urlencoded格式: { page: 1,limit: 10 } 在axios中，post请求接收的参数必须是form-­data可以使用qs插件—­qs.stringify 1234567891011121314postData()&#123; //先要安装qs插件,然后引入 //使用qs插件将对象格式转化为form-data格式 this.$http.post(url,qs.stringify(&#123; page: 1, limit: 10 &#125;)) .then(res=&gt;&#123; console.log(res) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;)&#125; 响应式原理官方解释总结: 任何一个Vue组件都有一个与之对应的Watcher实例。 Vue的data上的属性会被添加getter和setter属性。 当Vue组件的render函数被执行的时候,data上会被触碰(touch),即被读,getter方法会被调用,此时Vue会去记录此Vue组件所依赖的所有data。(这一过程被称为依赖收集) data被改动时（主要是用户操作）,即被写,setter方法会被调用,此时Vue会去通知所有依赖于此data的组件去调用他们的render函数进行更新。 其他说法:mvvm用来初始化数据observer用来对初始数据通过Object.defineProperty添加setter和getter，当取数据（即调用get）的时候添加订阅对象（watcher）到数组里， 当给数据赋值（即调用set）的时候就能知道数据的变化，此时调用发布订阅中心的notify，从而遍历当前这个数据的订阅数组，执行里面所有的watcher，通知变化update。compiler是用来把data编译到dom中。分三步：1.先把真实的dom移入到内存中fragment，2.编译：提取想要的元素节点v-model和文本节点；3.把编译好的fragment塞回到页面去。第二步骤中会对编译到dom中的data添加watcher,当data变化时，这里的watcher回调也能收到通知得到执行。watcher是oberver和compiler之间通信的桥梁。 Object.defineProperty 的缺陷 无法监听数组变化。 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 使用Proxy实现Vue数据劫持proxy定义: Proxy对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）. Proxy第一个参数是目标对象，第二个参数是一个对象，其属性是当执行一个操作时定义代理的行为的函数。这时可以在第二个参数中加入一个set方法，这时可以监听到是哪个key做了改变。并且通过Reflect的set方法去模拟真实的set方法。 为什么说Proxy的性能比Object.defineProperty更好呢？Object.defineProperty只能监听属性，而Proxy能监听整个对象，省去对非对象或数组类型的劫持，也能做到监听。 vue是对对象每一个属性进行Object.defineProperty。第二点，Object.defineProperty不能监测到数组变化 总结Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改；Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利当然,Proxy的劣势就是兼容性问题,而且无法用polyfill实现 Proxy基本语法const obj = new Proxy(target, handler);参数说明如下：target: 被代理对象。handler: 是一个对象，声明了代理target的一些操作。obj: 是被代理完成之后返回的对象。 但是当外界每次对obj进行操作时，就会执行handler对象上的一些方法。handler中常用的对象方法如下： 123451. get(target, propKey, receiver)2. set(target, propKey, value, receiver)3. has(target, propKey)4. construct(target, args):5. apply(target, object, args) 常用(考)组件之keep-alive作用: 缓存组件内部状态，避免重新渲染注意: 和相似,是一个抽象组件:自身不会渲染一个DOM元素,也不会出现在父组件链中. 用法:缓存动态组件:&lt;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，此种方式并无太大的实用意义。 12345678910&lt;!-- 基本 --&gt; &lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 多个条件判断的子组件 --&gt; &lt;keep-alive&gt; &lt;comp-a v-if="a &gt; 1"&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt; &lt;/keep-alive&gt; 使用keep-alive可以将所有路径匹配到的路由组件都缓存起来，包括路由组件里面的组件，keep-alive大多数使用场景就是这种。 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 常用(考)API之nextTick作用: $nextTick是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM，Vue实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新。 123456789101112// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick() .then(function () &#123; // DOM 更新了 &#125;) 为了在数据变化之后等待Vue完成更新DOM，可以在数据变化之后立即使用Vue.nextTick(callback)。这样回调函数将在DOM更新完成后被调用。在组件内使用vm.$nextTick()实例方法特别方便，因为它不需要全局Vue，并且回调函数中的this将自动绑定到当前的Vue实例上.因为 $nextTick()返回一个Promise对象，所以可以使用ES6语法. 常用(考)API之set返回: 设置的值.用法: 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 . 注意对象不能是Vue实例，或者Vue实例的根数据对象。 常用(考)API之watch一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 1234567891011121314151617181920212223242526272829303132333435363738394041var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 方法名 b: 'someMethod', // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: 'someMethod', immediate: true &#125;, e: [ 'handle1', function handle2 (val, oldVal) &#123; /* ... */ &#125;, &#123; handler: function handle3 (val, oldVal) &#123; /* ... */ &#125;, /* ... */ &#125; ], // watch vm.e.f's value: &#123;g: 5&#125; 'e.f': function (val, oldVal) &#123; /* ... */ &#125; &#125;&#125;)vm.a = 2 // =&gt; new: 2, old: 1 注意，不应该使用箭头函数来定义watcher函数 (例如searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以this将不会按照期望指向Vue实例，this.updateAutocomplete将是undefined。 其他APIVue.extend(options)用法: 使用Vue构造器创建一个子类.参数是一个包含组件选项的对象.data在Vue.extend中是函数 12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point') Vue.set(target,propertyName/index,value)返回值: 设置的值用法: 向响应式添加新属性,并确保这个新属性同样是响应式的.且触发识图更新.它必须用于响应式对象上添加新属性,因为Vue无法探测新增的属性.如果我们在创建实例以后，再在实例上绑定新属性，vue是无法进行双向绑定的。 注意: 对象不能是Vue实例,或者Vue实例的根数据对象. Vue.mixin用法: 全局注册一个混入,影响注册之后所有创建的每个Vue实例.插件作者可以使用混入,向组件注入自定义行为.不推荐在应用代码中使用. Vue页面优化(spa首屏单页面) 压缩代码 框架和插件按需加载 框架和插件从CDN中引入 路由懒加载 SSR服务端渲染]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件]]></title>
    <url>%2F2019%2F09%2F09%2FVue%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[作用提高代码复用性组件使用方法全局注册123456789Vue.component('button-counter',&#123; data: function()&#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;)&#125;) 优点：所有的nue实例都可以用缺点：权限太大，容错率降低 局部注册12345678var app = new Vue(&#123; el: '#app', components: &#123; 'my-component': &#123; template: '&lt;div&gt;我是组件的内容&lt;/div&gt;' &#125; &#125;&#125;) 组件的复用12345&lt;div id="components-demo"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。 特殊情况vue组件的模板在某些情况下会受到html标签的限制，比如 &lt;table&gt; 中只能还 有 &lt;tr&gt; , &lt;td&gt;这些元素，所以直接在table中使用组件是无效的，此时可以使用is属性来挂载组件 123&lt;table&gt; &lt;tbody is="my-component"&gt;&lt;/tbody&gt; &lt;/table&gt; 组件使用技巧 必须使用小写字母加­进行命名child,my­component命名组件 template中的内容必须被一个DOM元素包括,也可以嵌套 在组件的定义中，除了template之外还可以使用其他选项,比如data,computed,methods 一个组件的 data 选项必须是一个函数,否则就会出现点一个其他按钮也跟着变化的情况 通过prop父传子通信1234567891011121314151617181920212223242526&lt;div id="blog-post-demo"&gt; &lt;blog-post v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title" &gt; &lt;/blog-post&gt; &lt;/div&gt;&lt;script&gt; new Vue(&#123; el: "#blog-post-demo", data: &#123; posts: [ &#123;id: 1, title: aaa &#125;, &#123;id: 2, title: bbb &#125;, &#123;id: 3, title: ccc &#125; ] &#125; &#125;) Vue.component('blog-post',&#123; props: ['title'], template: '&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;' &#125;)&lt;/script&gt; 一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问data中的值一样。如上所示，你会发现我们可以使用v-bind来动态传递prop。这在你一开始不清楚要渲染的具体内容，比如从一个 API 获取博文列表的时候，是非常有用的。总结 在组件中使用props来从父亲组件接收参数，注意，在props中定义的属性，都可以在组件中直接使用 props来自父级，而组件中data return的数据就是组件自己的数据，两种情况作用域就是 组件本身，可以在template，computed，methods中直接使用 props的值有两种，一种是字符串数组，一种是对象，本节先只讲数组 可以使用v-­bind动态绑定父组件来的内容 单向数据流 解释: 通过props传递数据是单向的了,也就是父组件数据变化时会传递给子组件,但是反过来不行。 目的: 是尽可能将父子组件解稿，避免子组件无意中修改了父组件的状态。 应用场景: 业务中会经常遇到两种需要改变prop的情况一种是父组件传递初始值进来，子组件将它作为初始值保存起来，在自己的作用域下可以随意使用和修改。这种情况可以在组件data内再声明一个数据，引用父组件的prop步骤一：注册组件步骤二：将父组件的数据传递进来，并在子组件中用props接收步骤三：将传递进来的数据通过初始值保存起来12345678910111213141516171819&lt;div id="app"&gt; &lt;my-comp init-count="666"&gt;&lt;/my-comp&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', components: &#123; 'my-comp': &#123; props: ['init-count'], template: '&lt;div&gt;&#123;&#123;init-count&#125;&#125;&lt;/div&gt;', data: function() &#123; return &#123; count: this.initCount &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 另一种情况就是prop作为需要被转变的原始值传入。这种情况用计算属性就可以了步骤一：注册组件步骤二：将父组件的数据传递进来，并在子组件中用props接收步骤三：将传递进来的数据通过计算属性进行重新计算 123456789101112131415161718192021222324252627&lt;div&gt; &lt;input type="text" v-model="width"&gt; &lt;my-comp :width="width"&gt;&lt;/my-comp&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: "#app", data: &#123; width: '' &#125;, components: &#123; 'my-comp': &#123; props: ['init-count', 'width'], template: '&lt;div :style="style"&gt;&#123;&#123; init-count &#125;&#125;&lt;/div&gt;', computed: &#123; style: function()&#123; return &#123; width: this.width + 'px', background: 'red' &#125; &#125; &#125; &#125; &#125;&#125;)&lt;/script&gt; 驼峰命名与短横线命名 在html中,myMessage和mymessage是一样的.因此在组件中的html中必须使用短横线命名. 在组件中,父组件给子组件传数据必须用短横线(属于HTML范围内),因为html不识别驼峰,在props中无所谓.在template中必须使用驼峰命名. 在组件中的data中,用this.XXX引用时,必须使用驼峰命名. 数据验证验证的 type 类型可以是：• String• Number• Boolean• Object• Array• Function 组件通信组件通信分为父子通信,兄弟通信,跨级通信. 子传父通信使用v­-on除了监听DOM事件外，还可以用于组件之间的自定义事件.JavaScript的设计模式 一一观察者模式， dispatchEvent和addEventListener这两个方法.Vue组件也有与之类似的一套模式，子组件用$emit()来触发事件,父组件用$on()来监昕子组件的事件. 自定义事件change 在子组件中用$emit触发change,即this.$emit(&#39;change&#39;,this.count).括号里前面是用户名,后面是传递参数. 在自定义事件中用一个参数来接受12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id="app"&gt; &lt;p&gt;您的余额为&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;btn-component @change="handleTotal"&gt;&lt;/btn-component&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: "#app", data: &#123; total: 0 &#125;, methods: &#123; handleTotal: function(total)&#123; this.total = total &#125; &#125;, components: &#123; 'btn-component': &#123; template: '&lt;div&gt;\ &lt;button @click="handleIncrease"&gt;+1&lt;/button&gt;\ &lt;button @click="handleReduce"&gt;-1&lt;/button&gt;\ &lt;/div&gt;', data: function()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; handleIncrease: function()&#123; this.count++; this.$emit('change', this.count) &#125;, handleReduce: function()&#123; this.count-- this.$emit('change', this.count) &#125; &#125; &#125; &#125;&#125;)&lt;/script&gt; 在组件中使用v-model$emit的代码实际上会触发一个input事件,input后的参数就是传递给v-model绑定的属性的值.v-model其实是一个语法糖,其实绑定了两层操作: v-bind绑定一个value值 v-on指令给当前元素绑定input事件123456&lt;input v-model="total"&gt;//等价于&lt;input v-bind:value="total" v-on:input="total = $event.target.value"&gt; 要使用v-model,要做到: 接收一个value属性 在有新的value时触发input事件 修改上面的实例: 1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;p&gt;您的余额为&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;btn-component v-model="total"&gt;&lt;/btn-component&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: "#app", data: &#123; total: 0 &#125;, components: &#123; 'btn-component': &#123; template: `&lt;div&gt; &lt;button @click="handleincrease"&gt;+1&lt;/button&gt; &lt;button @clcik="handlereduce"&gt;-1&lt;/button&gt; &lt;/div&gt;`, data: function()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; handleincrease: function()&#123; this.count++ this.$emit('input',this.count) &#125;, handlereduce: function()&#123; this.count-- this.$emit('input',this.count) &#125; &#125; &#125; &#125;&#125;)&lt;/script&gt; 非父子组件通信(兄弟通信)方法: 使用bus中介使用一个空的Vue实例作为中央事件总线(bus):var bus = new Vue()触发组件A中的事件bus.$emit(&#39;id-selected&#39;,1)在组件B创建的钩子中监听事件bus.$on(&#39;id-selected&#39;,function(id){//....}) 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt;&lt;my-acomponent&gt;&lt;/my-acomponent&gt;&lt;my-bcomponent&gt;&lt;/my-bcomponent&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-acomponent',&#123; template: `&lt;div&gt;&lt;button @click="handle"&gt;点击我向B组件传数据&lt;/button&gt;&lt;/div&gt;`, data: function()&#123; return &#123; aaa: '我来自a组件' &#125; &#125;, methods: &#123; handle: function()&#123; this.$root.bus.$emit('lala', this.aaa) &#125; &#125;&#125;)Vue.component('my-bcomponent',&#123; template: `&lt;div&gt;我是B组件&lt;/div&gt;`, created: function()&#123; //A组件在实例创建的时候就监听事件--lala事件 this.$root.bus.$on('lala',function(value)&#123; alert(value) &#125;) &#125;&#125;)var app = new Vue(&#123; el:"#app", data: &#123; //bus中介 bus: new Vue() &#125;&#125;)&lt;/script&gt; 父链和子链this.$parent(从父组件里拿内容)12345678Vue.component('child-component',&#123; template:`&lt;button @click="setFatherData"&gt;通过我修改父亲的数据&lt;/button&gt;`, methods: &#123; setFatherData: function()&#123; this.$parent.msg = "数据已修改" &#125; &#125;&#125;) this$refs(从子组件里拿内容 )为子组件提供索引的方法,用特殊的属性ref为其增加一个索引如果用$children会把所有子组件都拿到 12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;my-acomponent ref="A"&gt;&lt;/my-acomponent&gt; &lt;my-bcomponent ref="B"&gt;&lt;/my-bcomponent&gt; &lt;button @click="getChildData"&gt;我是父组件,我要拿到子组件的数据&lt;/button&gt;---&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: "#app", data: &#123; bus: new Vue() msg: '数据未拿到', formchild: '还未拿到' &#125;, methods: &#123; getChildData: function()&#123; //用来拿子组件中的内容---$refs this.fromChild = this.$refs.b.msg &#125; &#125; &#125;)Vue.component('my-acomponent',&#123; template: `&lt;div&gt;&lt;/div&gt;`, data: function()&#123; return &#123; msg: '我来自a组件' &#125; &#125;&#125;)&lt;/script&gt; 使用slot插槽分发内容什么是插槽为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为内容分发.Vue.js 实现了一个内容分发API，使用特殊的slot元素作为原始内容的插槽. 编译的作用域父组件的作用域在父组件内,即&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;内部(便于理解).子组件的作用域在子组件的template里. 插槽的用法 混合父组件的内容和子组件的模板 单个插槽 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;my-component&gt; &lt;p&gt;父组件&lt;/p&gt; //虽然是父组件的作用域,但没有slot插槽,父组件的信息是无法显示 //插槽的作用是把父组件的内容插入到下面的子组件中,最后会显示出来 &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; template: `&lt;div&gt; &lt;slot&gt; 如果父组件没有插入内容,那么我就作为默认出现 &lt;/slot&gt; &lt;/div&gt;`&#125;)var app = new Vue(&#123; el:"#app", data: &#123; &#125;&#125;)&lt;/script&gt; 具名插槽 123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;my-component&gt; &lt;h3 slot="header"&gt;我是标题&lt;/h3&gt; //给父组件的插槽命名,可以和子组件模板的slot一一对应 &lt;p&gt;父组件&lt;/p&gt; //这个不命名的自然就对应那个没有命名的slot &lt;p slot="footer"&gt;我是底部信息&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; template: `&lt;div&gt; &lt;div class="header"&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;`&#125;)var app = new Vue(&#123; el:"#app", data: &#123; &#125;&#125;)&lt;/script&gt; 作用域插槽作用域插槽是一种特殊的插槽,使用一个可复用的模板来替换已渲染的元素 从子组件获取数据 &lt;template&gt;标签是不会渲染出来的,Vue版本更新后,也可以写在其他标签上 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;my-component&gt; &lt;template slot="abc" slot-scope="prop"&gt; //写一个临时变量prop,用临时变量拿子组件的信息 &#123;&#123; prop.text &#125;&#125; &lt;/template&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; template: `&lt;div&gt; &lt;slot name="abc" text="我是子组件的内容"&gt; &lt;/slot&gt; &lt;/div&gt;`&#125;)var app = new Vue(&#123; el:"#app", data: &#123; &#125;&#125;)&lt;/script&gt; 访问slot通过this.$slots.(name) 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;my-component&gt; &lt;h3 slot="header"&gt;我是标题&lt;/h3&gt; &lt;p&gt;父组件&lt;/p&gt; &lt;p slot="footer"&gt;我是底部信息&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',&#123; template: `&lt;div&gt; &lt;div class="header"&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;`, mounted: function()&#123; //访问插槽 var header = this.$slots.header var text = header[0].elm.innerText console.log(header) //打印一个虚拟节点 console.log(text) &#125;&#125;)var app = new Vue(&#123; el:"#app", data: &#123; &#125;&#125;)&lt;/script&gt; 组件高级用法-动态组件实现需求: 点击不同按钮切换不同页面使用is动态绑定组件,调用方法切换不同页面 123456789101112131415161718192021222324252627282930313233&lt;div id="app"&gt; &lt;component :is="thisView"&gt;&lt;/component&gt; &lt;button @click="handleView('A')"&gt;第一句&lt;/button&gt; &lt;button @click="handleView('B')"&gt;第二句&lt;/button&gt; &lt;button @click="handleView('C')"&gt;第三句&lt;/button&gt; &lt;button @click="handleView('D')"&gt;第四句&lt;/button&gt;&lt;/div&gt;&lt;script&gt;Vue.component('comA',&#123; template:`&lt;div&gt;鹅鹅鹅&lt;/div&gt;`&#125;)Vue.component('comB',&#123; template:`&lt;div&gt;曲项向天歌&lt;/div&gt;`&#125;)Vue.component('comC',&#123; template:`&lt;div&gt;白毛浮绿水&lt;/div&gt;`&#125;)Vue.component('comD',&#123; template:`&lt;div&gt;红掌拨清波&lt;/div&gt;`&#125;)var app = new Vue(&#123; el: "#app", data: &#123; thisView: 'comA' &#125;, methods: &#123; handleView: function(tag)&#123; this.thisView = 'com' + tag &#125; &#125;&#125;)&lt;/script&gt;]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基础]]></title>
    <url>%2F2019%2F09%2F07%2FVue-js%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[介绍Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。 引入在html内引入:&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;工程化时最好使用vue/cli构建. 实例和数据绑定通过构造函数Vue就可以创建一个Vue的实例.并启动Vue应用. 1234let app = new Vue(&#123; el: '#app', data: &#123;msg: 'hello world' &#125;&#125;) el用于指定页面中的DOM元素来挂载Vue实例.可以是标签,可以是css语法.通过Vue实例的data选项,可以声明应用内可以双向绑定的数据.建议所有会用到的数据都预先在data内声明,也可以指向一个已有的变量.值可以先设置默认值.挂载成功后,可以通过app.$el来访问该元素,Vue实例本身也代理了data对象里的所有属性,所以可以这样访问:访问Vue实例的属性: app.$el, app.$data.访问data元素的属性: app.msg 生命周期钩子钩子(hook),可以理解为挂载点.在整个Vue实例创建过程中,有一些挂载点. 生命周期流程: 所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 生命周期钩子 类型 详细 beforeCreate Function 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created Function 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el属性目前不可见。 beforeMoute Function 在挂载开始之前被调用：相关的render函数首次被调用。 mounted Function el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当mounted被调用时vm.$el也在文档内。 beforeUpdate Function 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。 updated Function 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或watcher取而代之 actived Function keep-alive 组件激活时调用。 deactivated Function keep-alive 组件停用时调用。 beforeDestroy Function 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Function Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 errorCaptured (err: Error, vm: Component, info: string) =&gt; ?boolean 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回false以阻止该错误继续向上传播。 注意mounted不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用vm.$nextTick替换掉mounted： 123456mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 注意updated不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用vm.$nextTick替换掉updated： 123456updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been re-rendered &#125;)&#125; 文本插值和表达式使用双大括号(Mustache语法)的方法是最基本的文本插值的语法,它会自动将双向绑定的数据实时显示出来. 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt; 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 v-bindv-bind可缩写成:.双大括号语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令： 1&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt; 对于布尔特性 (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中： 1&lt;button v-bind:disabled="isButtonDisabled"&gt;Button&lt;/button&gt; 如果isButtonDisabled的值是null、undefined或false，则disabled特性甚至不会被包含在渲染出来的 &lt;button&gt; 元素中。 js表达式 Vue .js 只支持单个表达式，不支持语句和流控制。 1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt;//文本插值的形式，其中不能书写表达式,支持单个表达式 以下例子不会生效 1234&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 计算属性123&lt;div id="example"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 这里是想要显示变量 message 的翻转字符串,但是更复杂的就需要计算属性.所有的计算属性都以函数的形式写在 Vue 实例内的computed选项内，最终返回计算后的结果。范例: 1234&lt;div id="example"&gt;&lt;p&gt;message: "&#123;&#123; message &#125;&#125;"&lt;/p&gt;&lt;p&gt;reversed message: "&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516var vm = new Vue(&#123; el: '#example', data: &#123; message: 'hello' &#125;, computed: &#123; //计算属性的getter reversedMessage: function()&#123; //this指向vm实例 return this.message.split('').reverse.().join('') &#125; &#125;&#125;)//结果：//message: "hello"//reversed message: "olleh" 计算属性缓存123456// 在组件中methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125; 使用methods方法也可以起到和计算属性同样效果区别:methods: 如果调用方法,只要页面重新渲染.方法就会重新执行,不需要渲染就不需要重新执行计算属性: 不管渲不渲染,只要计算属性依赖的数据不变,就不会变何时使用: 取决于是否需要缓存,当遍历大量数组或大量计算,应该使用计算属性. 计算属性的setter计算属性默认只有getter，不过在需要时你也可以提供一个setter： 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 v-bind与class和style的绑定应用场景: dom元素经常绑定一些class类名或style样式 对象语法可以给v-bind:class传一个对象,动态切换class: 1&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 也可以传入多个属性来动态切换class.v-bind:class指令也可以与普通class属性共存.绑定的数据对象也可以写在data里. 12345678910&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;&lt;script&gt;data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125;&lt;/script&gt; 当class的表达式过长或者逻辑复杂,可以绑定一个计算属性.一般当条件多于两个时,就可以使用data或computed 123456789101112131415&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;&lt;script&gt;data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125;&#125;&lt;/script&gt; 数组语法当应用多个class时,可以使用数组语法,给v-bind:class绑定一个数组.数组成员直接对应类名. 1234567&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;&lt;script&gt;data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125;&lt;/script&gt; 渲染为 1&lt;div class="active text-danger"&gt;&lt;/div&gt; 根据条件切换,也可以使用三元表达式: 1&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt; 也可以数组语法,对象语法混用: 1&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;&lt;/div&gt; 绑定内联样式对象语法v-bind:style的对象语法十分直观——看着非常像CSS，但其实是一个JavaScript对象.CSS属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名： 1234567&lt;div v-bind:style="&#123;color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt;&lt;script&gt;data: &#123; color: 'red', fontSize: 30&#125;&lt;/script&gt; 同样的，对象语法常常结合返回对象的计算属性使用。 数组语法数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 应用多个样式对象时,可以使用数组语法.在实际业务中,style的数组语法并不常用,因为往往可以写在一个对象里面.而较为常用的应当是计算属性.使用:style时,Vue会自动给特殊的css属性名称增加前缀,比如transform,无需再加前缀属性. 基本指令v-cloak解决因为初始化慢,导致页面闪动的情况.这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕.一般和CSS规则如 [v-cloak] { display: none }配合使用(需要写到css里). v-once只渲染元素和组件一次.之后的重新渲染被当做静态内容跳过,用于优化性能.写在标签里. v-pre跳过这个元素和他子元素的编译过程.可以加快编译. 其他的单独写v-text, v-html, v-show, v-if, v-else, v-else-if, v-for, v-on, v-bind, v-model, v-slot. 条件渲染v-if,v-else,v-else-if用法: 根据表达式值的真假条件渲染元素.在切换时元素及它的数据绑定/组件被销毁并重建.如果元素是&lt;template&gt;,将提出他的内容作为条件块.当条件变化时,该指令触发过渡效果. 当和v-for一起使用时,v-for的优先级更高. 也可以用 v-else 添加一个“else 块”： 12&lt;h1 v-if="awesome"&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt; 在&lt;template&gt;上使用v-if因为v-if是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个&lt;template&gt;元素当做不可见的包裹元素，并在上面使用v-if。最终的渲染结果将不包含&lt;template&gt;元素。 12345&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 用key管理可复用元素Vue会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染.&lt;input&gt;不会被替换掉——仅仅是替换了它的 placeholder。如果要表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的key属性即可. 12345678&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt; v-show1&lt;h1 v-show="ok"&gt;Hello!&lt;/h1&gt; v-show只是切换css属性display.v-show不支持&lt;template&gt;元素,也不支持v-else. v-if和v-show相比v-if: 真正的条件渲染,条件为真就渲染,为false就移除.v-show: 不管初始条件是什么,都会渲染.只是切换css的display属性.总结: 如果需要非常频繁地切换，则使用v-show较好；如果在运行时条件很少改变，则使用v-if较好 v-for列表渲染两种使用场景: 遍历多个对象 遍历一个对象的多个属性 遍历数组语法: v-for=&quot;(item, index) in items&quot;第一个是数组元素名,第二个是索引.遍历对象的多个属性语法: v-for=&quot;(value, name, index) in object&quot;第一个是属性值,第二个是属性名,第三个是索引. 数组更新过滤排序改变数组的一系列方法： push() pop() shift() unshift() splice() sort() reverse() 两个数组变动Vue检测不到: 改变数组指定项,vm.items[indexOfItem] = newValue 改变数组长度,vm.items.length = newLength 解决办法:改变指定项: Vue.set(app.arr, 1, ‘car’)改变数组长度: app.arr.splice(1) v-onv-on用来绑定事件监听器.v-on可以缩写成@.在普通元素上,v­-on可以监听原生的DOM事件，除了click外，还有dblclick、keyup,mousemove等。表达式可以是一个方法名，这些方法都写在Vue实例的methods属性内，并且是函数的形式，函数内的this指向的是当前Vue实例本身，因此可以直接使用this.xxx的形式来访问或修改数据. 如果方法中带有参数，但是没有加括号，默认传原生事件对象event 从2.6.0开始，可以用方括号括起来的JavaScript表达式作为一个指令的参数：&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;方括号里的属性可以被替换.可以使用动态参数为一个动态的事件名绑定处理函数：&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;当 eventName的值为 “focus” 时,v-on:[eventName]将等价于 v-on:focus。 动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在HTML特性名里是无效的。同样，在DOM中使用模板时你需要回避大写键名。 修饰符在Vue中传入event对象用$event修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。.stop 阻止单击事件冒泡 &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;.prevent 提交事件不再重载页面.capture 添加事件侦听器时使用时间捕获模式.self 只当事件在该元素本身（而不是子元素）触发时触发回调.once只执行一次的方法 v-model用于在表单类元素上双向绑定可以用于input框，以及textarea等注意:所显示的值只依赖于所绑定的数据，不再关心初始化时的插入的value 文本12&lt;input v-model="message" placeholder="edit me"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 多行文本将v-model绑定到textarea上``javascriptMultiline message is: 12345678910111213141516171819202122### 单选按钮1. 单个单选按钮，直接用v-­bind绑定一个布尔值，用v-­model是不可以的 2. 如果是组合使用，就需要v-­model来配合value使用，绑定选中的单选框的value值.```javascript&lt;div id="example-4"&gt; &lt;input type="radio" id="one" value="One" v-model="picked"&gt; &lt;label for="one"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type="radio" id="two" value="Two" v-model="picked"&gt; &lt;label for="two"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#example-4', data: &#123; picked: '' &#125;&#125;)&lt;/script&gt; 复选框单个复选框,绑定到布尔值: 12&lt;input type="checkbox" id="checkbox" v-model="checked"&gt;&lt;label for="checkbox"&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt; 多个复选框,绑定到同一个数组: 123456789101112131415161718&lt;div id='example-3'&gt; &lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt; &lt;label for="jack"&gt;Jack&lt;/label&gt; &lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt; &lt;label for="john"&gt;John&lt;/label&gt; &lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt; &lt;label for="mike"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: "#example-3", data: &#123; checkedNames: [] &#125;&#125;)&lt;/script&gt; 下拉框单选下拉:12345678910111213141516171819&lt;div id="example-5"&gt; &lt;select v-model="selected"&gt; // 将v-model绑定到select上,data中selected使用空字符串 &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: "#example-5", data: &#123; selected: '' &#125; &#125;)&lt;/script&gt; 多选下拉:123456789101112131415161718&lt;div id="example-6"&gt; &lt;select v-model="selected" multiple style="width: 50px"&gt; // 将v-model绑定到select上,data中selected使用空数组 &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;)&lt;/script&gt; 使用v-for配合1234567891011121314151617181920&lt;select v-model="selected"&gt; &lt;option v-for="option in options" v-bind:value="option.value"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;script&gt;new Vue(&#123; el: "...", data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;)&lt;/script&gt; 绑定值 单选按钮只需要用v-­bind给单个单选框绑定一个value值，此时,v­-model绑定的就是他的value值 复选框 下拉框在select标签上绑定value值对option并没有影响修饰符 修饰符 解释 lazy v-­model默认是在input输入时实时同步输入框的数据，而lazy修饰符，可以使其在失去焦点或者敲回车键之后再更新 number 将输入的字符串转化为number类型 trim trim自动过滤输入过程中首尾输入的空格 自定义指令]]></content>
      <tags>
        <tag>Vue.js</tag>
        <tag>Vue.js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express]]></title>
    <url>%2F2019%2F09%2F06%2FExpress%2F</url>
    <content type="text"><![CDATA[介绍Express是基于Node.js平台的web开发框架. 快速创建使用以下命令安装express 1npm install express-generator -g 使用-h选项显示命令选项 1234567891011121314151617express -h Usage: express [options][dir] //用法 Options: -h, --help output usage information --version output the version number -e, --ejs add ejs engine support --hbs add handlebars engine support --pug add pug engine support -H, --hogan add hogan.js engine support --no-view generate without view engine -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade) -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory 例如，以下语句在当前工作目录中创建名为 myapp 的 Express 应用程序： 12345678910111213141516171819$ express --view=pug myapp create : myapp create : myapp/package.json create : myapp/app.js create : myapp/public create : myapp/public/javascripts create : myapp/public/images create : myapp/routes create : myapp/routes/index.js create : myapp/routes/users.js create : myapp/public/stylesheets create : myapp/public/stylesheets/style.css create : myapp/views create : myapp/views/index.pug create : myapp/views/layout.pug create : myapp/views/error.pug create : myapp/bin create : myapp/bin/www 然后安装依赖项: 12cd myappnpm install 在Mac或Linux下采用以下命令运行此程序 1DEBUG=myapp:* npm start 在windows上 1set DEBUG=myapp:* &amp; npm start 然后在浏览器输入`http://localhost:3000访问 基本路由中间件: 处理请求的函数.模板引擎: &lt;%= 写入的变量名 %&gt;,其中变量名可以在其他地方赋值,这样就可以批量改变变量了. 后台基本页面: 创建,列表,展示 静态文件提供图像,css和js之类的静态文件,请使用express.static内置中间件函数.使用以下代码在名为public的目录中提供图像,css和js之类的静态文件 1app.use(express.static('public')) 现在，可以访问位于 public 目录中的文件： 1234567http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/app.jshttp://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html要使用多个静态资源目录，请多次调用 express.static 中间件函数： app.use(express.static(‘public’));app.use(express.static(‘files’)); 123Express 以您使用 express.static 中间件函数设置静态目录的顺序来查找文件。要为 express.static 函数提供的文件创建虚拟路径前缀（路径并不实际存在于文件系统中），请为静态目录指定安装路径，如下所示： app.use(‘/static’, express.static(‘public’)); 12 向 express.static 函数提供的路径相对于您在其中启动 node 进程的目录。如果从另一个目录运行 Express 应用程序，那么对于提供资源的目录使用绝对路径会更安全： 1app.use('/static', express.static(__dirname + '/public')); 路由基本路由示例: 123456var express = require('express')var app = express() //在`myapp/bin/www`里创建了app的服务器app.get('/', function(req, res)&#123; red.send('hello world')//给浏览器发一个hello world&#125;) 路由方法GET和POST的示例 123456789//GETapp.get('/', function(req, res)&#123; res.send('GET request to the homepage')&#125;)//POSTapp.post('/', function(req, res)&#123; res.send('POST request to the homepage')&#125;) 有一种特殊路由方法：app.all()，它并非派生自 HTTP 方法。该方法用于在所有请求方法的路径中装入中间件函数。 在以下示例中，无论您使用 GET、POST、PUT、DELETE 还是在 http 模块中支持的其他任何 HTTP 请求方法，都将为针对“/secret”的请求执行处理程序。 1234app.all('/secret', function (req, res, next) &#123; console.log('Accessing the secret section ...'); next(); // pass control to the next handler&#125;); 路由路径‘/‘表示根路径 123app.get('/', function(req, res)&#123; res.send('root')&#125;) 和’/about’路径匹配 123app.get('/about', function(req, res)&#123; res.send('random.txt')&#125;) 基于字符串模式的匹配12345678910111213141516171819202122232425//此路由路径将匹配 abcd、abbcd、abbbcd 等。app.get('/ab+cd', function(req, res) &#123; res.send('ab+cd');&#125;);//此路由路径将匹配 abcd、abbcd、abbbcd 等。app.get('/ab+cd', function(req, res) &#123; res.send('ab+cd');&#125;);//此路由路径将匹配 abcd、abxcd、abRABDOMcd、ab123cd 等。app.get('/ab*cd', function(req, res) &#123; res.send('ab*cd');&#125;);//此路由路径将匹配 /abe 和 /abcde。app.get('/ab(cd)?e', function(req, res) &#123; res.send('ab(cd)?e');&#125;); 字符 ?、+、* 和 () 是其正则表达式同应项的子集。基于字符串的路径按字面理解连字符 (-) 和点 (.)。 路由处理程序可以提供多个回调函数，以类似于中间件的行为方式来处理请求。唯一例外是这些回调函数可能调用 next(‘route’) 来绕过剩余的路由回调。可以使用此机制对路由施加先决条件，在没有理由继续执行当前路由的情况下，可将控制权传递给后续路由。 路由处理程序的形式可以是一个函数、一组函数或者两者的结合，如以下示例中所示。 单个回调函数可以处理一个路由。例如： 123app.get('/example/a', function (req, res) &#123; res.send('Hello from A!');&#125;); 多个回调函数可以处理一个路由（确保您指定 next 对象）。例如： 123456app.get('/example/b', function (req, res, next) &#123; console.log('the response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from B!');&#125;); 一组回调函数可以处理一个路由。例如： 123456789101112131415var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/example/c', [cb0, cb1, cb2]); 独立函数与一组函数的组合可以处理一个路由。例如： 12345678910111213141516var cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;app.get('/example/d', [cb0, cb1], function (req, res, next) &#123; console.log('the response will be sent by the next function ...'); next();&#125;, function (req, res) &#123; res.send('Hello from D!');&#125;); 响应方法响应对象 (res) 的方法可以向客户端发送响应，并终止请求/响应循环。如果没有从路由处理程序调用其中任何方法，客户端请求将保持挂起状态。 方法 描述 res.download() 提示将要下载文件。 res.end() 结束响应进程。 res.json() 发送 JSON 响应。 res.jsonp() 在 JSONP 的支持下发送 JSON 响应。 res.redirect() 重定向请求。 res.render() 呈现视图模板。 res.send() 发送各种类型的响应。 res.sendFile 以八位元流形式发送文件。 res.sendStatus() 设置响应状态码并以响应主体形式发送其字符串表示。 app.route()可以使用app.route()为路由路径创建可连接的路由处理程序因为在单一位置指定路径,可以减少冗杂和输入错误. 12345678910app.route('/book') .get(function(req, res)&#123; res.send('get a book') &#125;) .post(function(req, res)&#123; res.send('add a book') &#125;) .put(function(req, res)&#123; res.send('update a book') &#125;) express.Router使用 express.Router 类来创建可安装的模块化路由处理程序。Router 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。 以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。 在应用程序目录中创建名为 birds.js 的路由器文件，其中包含以下内容： 12345678910111213141516171819var express = require('express');var router = express.Router();// middleware that is specific to this router//use是不管get还是post都可以匹配router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// define the home page routerouter.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// define the about routerouter.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 接着，在应用程序中装入路由器模块： 123var birds = require('./birds');...app.use('/birds', birds); 此应用程序现在可处理针对 /birds 和 /birds/about 的请求，调用特定于此路由的 timeLog 中间件函数。]]></content>
      <categories>
        <category>后端</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2019%2F09%2F05%2FES6%2F</url>
    <content type="text"><![CDATA[ES6常见语法let和constlet定义局部变量var定义全局变量.用var定义的全部变量，有时候会污染整个js的作用域。const定义常量在全局作用域下使用let和const声明变量，变量并不会挂载到window var可声明前置(变量提升)变量会提升，函数也会提升，并且函数优先于变量提升，函数提升会把整个函数提到作用域顶部，变量提升只会把声明提上去. 123a = 3var avar a = 4 let不可声明前置暂时性死区：不能在变量声明之前使用变量 12a = 3 //报错let a let不可重复声明 123let a = 3let a = 4 //报错var a = 5 //报错 存在块级作用域 1234for(let i=0; i&lt;3; i++)&#123; console.log(i) //块级作用域只在大括号内,出了大括号,i并没有声明,会报错&#125;console.log(i) //报错 暂时性死区: 在let声明变量之前都是该变量的死区,在死区内该变量不可使用.不能被声明也不能被获取. const声明的常量不可改变123456const a = 1a = 2//报错const obj = &#123;a: 1&#125;obj.a = 2 //正常obj = &#123;a: 2&#125; //报错 const 对象等于引用类型,obj存的是{a: 1}的地址,里面的东西改变并不影响地址.而obj = {a: 2}是赋给一个新的地址,发生了改变,会报错. 适用于let同样适用于constlet和const作用基本一致，const声明的变量不能再次赋值ES6可以大量使用let,如果认定模块不改变,可以使用const 解构赋值关于数组的解构赋值123456789let [a,b,c] = [1,2,3]console.log(a, b, c) let [a, [b], c] = [2, [3], 4]a //2b //3c //4let [a] = 1 //报错,因为[a]是一个数组,把值赋值给数组就报错了 默认值 123456789101112131415let [a, b = 2] = [3]a // 3b // 2,因为b没有对应值,所以是undefined,使用默认值let [a, b = 2] = [3, 4]a //3b //4数组对应对值有没有？如果没有（数组对没有指undefined）就使用默认值，如果有就使用对应值let [a=2, b=3] = [undefined, null]a //2b //nulllet [a=1, b=a] = [2]a //2b //2,因为b没有对应值,所以是undefined,使用默认值,此时a的默认值为2 对象的解构赋值前置知识 1234567891011121314let [name, age] = ['hunger', 3]let p1 = &#123;name, age&#125;//等同于let p2 = &#123;name: name, age: age&#125;解构范例let &#123;name, age&#125; = &#123;name: 'jirengu', age: 4&#125;name //‘jirengu’age //4以上代码等同于let namelet age(&#123;name: name, age: age&#125; = &#123;name: 'jirengu', age: 4&#125;) 默认值 123let &#123;x, y=5&#125; = &#123;x: 1&#125;x //1y //5 函数解构 1234567891011function add([x=1, y=2])&#123; return x+y&#125;add() //Erroradd([2]) //4add([3,4]) //7function sum(&#123;x, y&#125;=&#123;x:0, y:0&#125;, &#123;a=1, b=1&#125;)&#123; return [x+a, y+b]&#125;sum(&#123;x:1, y:2&#125;, &#123;a:2&#125;) //[3, 3] 作用 1234567let [x, y] = [1, 2];[x, y] = [y, x]x //2y // 1function ajax(&#123;url, type=‘GET’&#125;)&#123;&#125;ajax(&#123;url: ‘http://localhost:3000/getData’&#125;) 字符串,数组,对象字符串 多行字符串 12345let str =`Hi,This is jirengu.com.You can study frontend here.` 字符串模板 1234567let website = 'jirengucom'let who = 'You'let str = `HiThis is $&#123;website&#125;.$&#123;who&#125; can study frontend here`//$&#123;&#125;,可以替换变量 12345var data= [1,2,3,4]var liArr = data.map(v=&gt;`&lt;li&gt;$&#123;v&#125;&lt;/li&gt;`).join('')var html = `&lt;ul&gt;$&#123;liArr&#125;&lt;/ul&gt;`console.log(html)//"&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;" 数组 扩展运算符... 1234567var a = [1, 2]console.log(...a) // 1, 2,这三个点相当于脱壳,把数组的壳拿掉var b = [...a, 3]b // [1, 2, 3]var c = b.concat([4, 5]) //b拼接[4,5]变成[1,2,3,4,5]var d = [...b, 4, 5] //直接把脱壳后的1,2,3放入数组中 函数参数的扩展 12345678function sort(...arr)&#123; console.log(arr.sort())&#125;sort(3, 1, 5) //[1, 3, 5]function max(arr)&#123; return Math.max(...arr)&#125;max([3, 4, 1]) // 4 类数组对象转数组 12345let ps = document.querySelectorAll('p');Array.from(ps).forEach(p=&gt; &#123; console.log(p.innerText);&#125;);[...ps].forEach(p=&gt;&#123;console.log(p.innerText)&#125;); 函数 默认值12345function sayHi(name='jirengu') &#123; console.log(`hi, $&#123;name&#125;`)&#125;sayHi()sayHi('ruoyu') 1234function fetch(url, &#123; body='', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com')//如果没有定义那么就是undefined,使用默认值,如果传入了参数,那就使用传入值 以下两种写法的区别? 12345678910111213141516171819202122232425262728//ex1function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;//ex2 function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];把&#123;&#125;赋给(x = 0,y = 0)m2(&#123;&#125;) // [undefined, undefined];把&#123;&#125;赋给&#123;x,y&#125;,也就是把undefined, undefined赋给&#123;x,y&#125;m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] ex1：调用函数需要你传递一个对象，如果你没传对象就用默认值对象{}，默认值对象里面都是 undefined， 所以属性使用初始值 ex2：参数需要是一个对象，如果没传对象，就用默认值对象{ x: 0, y: 0 }如果传了对象，就使用你传递的对象 箭头函数箭头后面的内容，就相当于return的内容。12345678910111213var f = v =&gt; v+1//等价于var f = function(v)&#123;return v+1&#125;var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;//适用于立刻返回,即把代码写成一行的情况// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 1234//数组的平方var arr = [1, 2, 3]var arr2 = arr.map(v=&gt;v*v)arr2 //[1, 4, 9] 箭头函数里面的 this1234567891011121314// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// 等同于如下ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 对象123var name = 'jirengu'var age = 3var people = &#123;name, age&#125; //&#123;name:'jirengu', age:3&#125; 123456789let app = &#123;selector: '#app',//函数简写init() &#123;&#125;,bind() &#123;&#125;&#125;app.init() 类和继承 构造函数 12345678910111213141516171819202122232425262728293031323334353637class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHello() &#123; console.log( `hello, $&#123;this.name&#125;, i am $&#123;this.age&#125; years old`); &#125;&#125;等价于function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.sayHello = function () &#123; console.log( `hello, $&#123;this.name&#125;, i am $&#123;this.age&#125; years old`);&#125;;var p = new Person('hunger', 2);静态方法class EventCenter &#123; static fire() &#123; return 'fire'; &#125; static on()&#123; return 'on' &#125;&#125;等同于function EventCenter()&#123;&#125;EventCenter.fire = function()&#123;&#125;EventCenter.on = function()&#123;&#125; 继承js中并不存在类，class只是语法糖，本质是函数class继承的核心在于使用extends表明继承自哪个父类，并在子类构造函数中必须调用super 123456789101112131415161718192021class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; sayHello() &#123; //写的函数会直接放到原型上 console.log( `hello, $&#123;this.name&#125;, i am $&#123;this.age&#125; years old`); &#125;&#125;class Student extends Person &#123; constructor(name, age, score) &#123; super(name, age); this.score = score; &#125; sayScore() &#123; console.log( `hello, $&#123;this.name&#125;, i am $&#123;this.age&#125; years old, i get $&#123;this.score&#125;`); &#125;&#125; 模块化为什么使用模块化? 解决命名冲突 提供复用性 提高代码可维护性 写法1 1234567// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;//useage.jsimport &#123;firstName, lastName, year&#125; from './profile';console.log(firstName) 写法2 12345678var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;;//useage.jsimport &#123;firstName, lastName, year&#125; from './profile';console.log(firstName) 写法3 123456//helper.jsexport function getName()&#123;&#125;export function getYear()&#123;&#125;//main.jsimport &#123;getName, getYear&#125; from './helper';getName() 写法4 1234567//helper.jsfunction getName()&#123;&#125;function getYear()&#123;&#125;export &#123;getName, getYear&#125;//main.jsimport &#123;getName, getYear&#125; from './helper';getName() 写法5 1234567// export-default.jsexport default function () &#123; console.log('foo');&#125;// import-default.jsimport getName from './export-default'getName()]]></content>
      <categories>
        <category>JS</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2F2019%2F09%2F01%2FNode-js%2F</url>
    <content type="text"><![CDATA[node.js基础12345678910node index.js //启动服务器index.js文件中引入http模块var http = require("http") //引入http模块var server = http.creatserve(fn(res,req))//创建服务器response.end() //结束server.listen(9000) //启动服务器，监听9000端口res.setHeader("Content-Type", "text/plain; chartset=gbk")//设置响应头res.writeHead(200,"ok") //设置状态码console.log("open http://localhost:9000") 进阶 12345678910111213141516171819202122232425262728293031323334var http = require("http") //引入http模块var path = require("path") //自动处理路径问题var fs = require("fs") //读写文件var url = require("url") //解析urlfunction staticRoot(staticPath, req, res)&#123; var pathObj = url.parse(req.url, true) //url.parse是node.js方法，将一个URL字符串转换成对象并返回 console.log(pathObj) if(pathObj.pathname === "/")&#123; pathObj.pathname += "index.html" &#125; //不加后缀可以默认加后缀var filePath = path.join(staticPath, pathObj.pathname)//拼接文件地址fs.readFile(filePath, "binary", function(err, fileContent)&#123; if(err)&#123; res.writeHead(404, "not found") res.end("&lt;h1&gt;404 Not Found&lt;/h1&gt;")&#125;else&#123; res.writeHead(200, "ok") res.write(fileContent, "binary") res.end() &#125;&#125;)console.log("path.join(_dirname, "static")var server = http.createServer(function(res,req)&#123; staticRoot(path.join(__dirname, "static"), req, res) //__dirname代表当前文件server.listen(8080)console.log("visit http://localhost:8080") 常用APIfs.readFile(path[,options],callback)/fs.writeFile(file,data[,options],callback)12345678910111213141516171819let fs = require('fs') //引入fs模块fs.readFile('flie.txt', 'utf-8', function(err, str)&#123; if(err)&#123; console.log('error') &#125;else&#123; console.log(str) //要去掉字符串里的数字空格 const strAfter = str.replace(/\d/gm, '') console.log(strAfter) //去掉数字后把strAfter写出来 fs.writeFile('fileAfter.txt', strAfter, (err)=&gt;&#123; if(err) throw err; //如果报错直接使用throw抛出 console.log('the file has been save!'); &#125;) &#125;&#125;) 模块将上面的去数字的方法封装成函数,单独写一个文件,并调用创建stringApi.js 12345function replaceDigit(str)&#123; return str.replace(/\d/gm, '')&#125;module.exports.replaceDigit = replaceDigit //把这个封装好的函数暴露出来可以使用了 123456//封装好后在上面的代码里就可以使用了//先引入let strApi = require('./stringApi') //如果在同级目录下,直接使用相对路径引入//然后将上面的代码const strAfter = str.replace(/\d/gm, '')替换成const strAfter = strApi.replaceDigit(str) NPM如果需要一些功能,node.js自带的没有,可以去npm官网上找一些其他人发布的npm包.找到之后,首先进行安装 package.json记录保存模块依赖,当没有依赖时,比如下载其他人的项目里没有依赖,可以使用npm.init初始化,将package.json中记录的模块依赖全都下载下来,方便. npm切换源工具1234npm install -g nrm //安装nrm工具nrm ls //查看nrm支持的源的列表nrm use taobao //使用淘宝的源nrm use npm //切换回npm源 NPM Script在package.json文件里有一个scripts对象,写入里面的命令可以比较方便快捷的执行.直接npm xxx就可以执行.而且会自动搜索路径,不用写相对路径. 123456789101112&#123; "scripts": &#123; "css:autoprefixer": "postcss -u autoprefixer -r dist/css/*", "css:compress": "csso in.css --output out.css", "js:lint": "eslint src/js", "js:uglify": "mkdir -p dist/js &amp;&amp; uglifyjs src/js/*.js -m -o dist/js/app.js", "image:imagemin": "app=imagemin-cli npm run check; imagemin src/images dist/images -p", "server": "browser-sync start --server --files 'dist/css/*.css, dist/js/*.js'", "watch": "onchange 'src/js/*.js' -- npm run css:compress", "start": "npm run server" &#125;&#125; 12npm run css:autoprefixernpm start]]></content>
      <categories>
        <category>后端</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程化]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[模块化初探模块化系统的风格模块化的价值 最主要的目的： 解决命名冲突 依赖管理其他价值: 提高代码可读性 代码解耦,提高复用性 &lt;script&gt;标签风格123&lt;script src="module1.js"&gt;&lt;/script&gt;&lt;script src="module2.js"&gt;&lt;/script&gt;&lt;script src="module3.js"&gt;&lt;/script&gt; 各个模块把接口暴露给全局对象,比如window.各个模块通过全局对象进行相互访问出现的问题: 全局对象的冲突 加载的顺序很重要 开发者需要解决模块的依赖问题 在大项目中模块非常多难以维护CommonJs: 同步的require使用同步的require方法来加载依赖和返回暴露的接口.一个模块可以通过exports对象添加属性,或者设置module.exports的值来描述暴露对象.1234require('moudle')require('../file.js')exports.doStuff = function()&#123;&#125;moudle.exports = someValue 优点: 服务端代码可以被复用. npm有大量的代码 使用方便缺点: 阻塞调用无法在网络环境应用,网络请求是异步的 不能并行require多个模块CommonJS规范 在一个模块中,存在一个自由的变量”require”,它是一个函数。这个”require”函数接收一个模块标识符。“require”返回外部模块所输出的API。 在一个模块中,会存在一个名为”exports”的自由变量,它是一个对象,模块可以在执行的时候把自身的API加入到其中。 模块必须使用”exports”对象来做为输出的唯一表示。AMD规范: 异步的requireAMD主要解决两个问题: 多个js文件可能有依赖关系,被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染,加载文件越多,页面失去响应时间越长requireJS语法RequireJS 遵循 AMD 规范,用于解决命名冲突和文件依赖的问题.requireJS定义了一个函数 define,它是全局变量,用来定义模块define(id?, dependencies?, factory); id：可选参数,用来定义模块的标识,如果没有提供该参数,脚本文件名(去掉拓展名) dependencies：是一个当前模块依赖的模块名称数组 factory：工厂方法,模块初始化要执行的函数或对象。如果为函数,它应该只被执行一次。如果是对象,此对象应该为模块的输出值 在页面上使用require函数加载模块require([dependencies], function(){});require()函数接受两个参数: 第一个参数是一个数组,表示所依赖的模块 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用。加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块. require()函数在加载依赖的函数的时候是异步加载的,这样浏览器不会失去响应,它指定的回调函数,只有前面的模块都加载成功后,才会运行,解决了依赖性的问题。 1234require(['moudle', '../file'], function(moudle, file)&#123; /* ... */&#125;)define('moudle',['dep1', 'dep2'], function(d1, d2)&#123; return someExportedValue&#125;) webpackwebpack是收把项目当作一个整体,通过一个给定的的主文件,webpack将从这个文件开始找到你的项目的所有依赖文件,使用loaders处理它们,最后打包成一个或多个浏览器可识别的js文件. 初始化 新建一个文件夹,cd到它的目录下.执行npm init -y命令 执行npm install --save--dev webpack命令安装(也可以全局安装)12345678910111213141516171819/配置touch webpack.config.jsvi webpack.config.js//在里面写以下内容/*const path = require('path');module.exports = &#123; entry: './src/index.js', //入口 output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;;*///创建文件touch src/index.js//运行webpacknpx webpack //这时会多出dist目录,里面有bundle.js文件 2.使用1.在index.js里写123456console.log(1)//再运行webpack:npx webpack//再看bundle.js,这时会多出来一行console.log(1) 2.安装babel-loader自动转换es612345678910111213141516171819202122232425262728293031323334353637383940414243//安装v6,命令行npm install babel-loader babel-core babel-preset-env webpack//将这个复制到webpack的配置文件webpack.config.js里,加在output的下面module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ]&#125;//加在output的下面,复制完后成这样const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ]&#125;&#125;; 运行npx webpack若出现can’t find ‘…’或can’t resolve ‘…’的报错,则安装省略号里的东西npm i ‘省略号’注意：若是Couldn’t find preset “env”,不要安装env,而是npm i babel-preset-env 3.使用babel123//当你在写index.js里写let a=1//它就会帮你自动转换成es5了 NPM 脚本(NPM Scripts)在package.json文件中写入npm脚本,就可以使用npm run build替代npx命令. 123456789101112131415161718 &#123; "name": "webpack-demo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",+ "build": "webpack" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.0.1", "webpack-cli": "^2.0.9", "lodash": "^4.17.5" &#125; &#125; 管理资源(css,图片之类)加载CSS 需要先安装style-laoder和css-loadernpm install --save-dev style-loader css-loader 然后在webpack.config.js文件里添加规则1234567891011121314151617181920 const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,+ module: &#123;+ rules: [+ &#123;+ test: /\.css$/,+ use: [+ 'style-loader',+ 'css-loader'+ ]+ &#125;+ ]+ &#125; &#125;; webpack 根据正则表达式,来确定应该查找哪些文件,并将其提供给指定的 loader。在这种情况下,以 .css 结尾的全部文件,都将被提供给 style-loader 和 css-loader。 这使你可以在依赖于此样式的文件中import &#39;./style.css&#39;。现在,当该模块运行时,含有 CSS 字符串的&lt;style&gt;标签,将被插入到 html 文件的 &lt;head&gt;中。 加载图片 安装npm install --save-dev file-loader插件 配置webpack.config.js文件现在,当你 import MyImage from &#39;./my-image.png&#39;,该图像将被处理并添加到 output 目录,并且 MyImage 变量将包含该图像在处理后的最终 url。当使用 css-loader 时,如上所示,你的 CSS 中的url(&#39;./my-image.png&#39;) 会使用类似的过程去处理。loader 会识别这是一个本地文件,并将 &#39;./my-image.png&#39;路径,替换为输出目录中图像的最终路径。html-loader 以相同的方式处理 &lt;img src=&quot;./my-image.png&quot; /&gt;。 在src文件夹下创建icon.png. 修改src/index.js文件 123456789101112131415161718192021 import _ from 'lodash'; import './style.css';+ import Icon from './icon.png'; function component() &#123; var element = document.createElement('div'); // Lodash,现在由此脚本导入 element.innerHTML = _.join(['Hello', 'webpack'], ' '); element.classList.add('hello');+ // 将图像添加到我们现有的 div。+ var myIcon = new Image();+ myIcon.src = Icon;++ element.appendChild(myIcon); return element; &#125; document.body.appendChild(component()); src/style.css中引入图片 1234 .hello &#123; color: red;+ background: url('./icon.png'); &#125; 重新构建npm run build Glup简介它是一款nodejs应用。它是打造前端工作流的利器,打包、压缩、合并、git、远程操作…,简单易用无快不破高质量的插件 安装 安装gulpnpm install -g gulp如果报Error: EACCES, open &#39;/Users/xxx/xxx.lock错误。先执行：sudo chown -R $(whoami) $HOME/.npm 如果使用npm安装插件太慢(被墙),可执行 npm install -g cnpm --registry=https://registry.npm.taobao.org先安装cnpm, 之后再安装插件时用cnpm安装cnpm install gulp 安装各种插件123456789101112131415npm install --save gulp //本地使用gulpnpm install --save gulp-imagemin //压缩图片npm install --save gulp-minify-css //压缩cssnpm install --save gulp-ruby-sass //sassnpm install --save gulp-jshint //js代码检测npm install --save gulp-uglify //js压缩npm install --save gulp-concat //文件合并npm install --save gulp-rename //文件重命名npm install --save png-sprite //png合并npm install --save gulp-htmlmin //压缩htmlnpm install --save gulp-clean //清空文件夹npm install --save browser-sync //文件修改浏览器自动刷新npm install --save gulp-shell //执行shell命令npm install --save gulp-ssh //操作远程机器npm install --save run-sequence //task顺序执行 或者根据package.json 自动安装。把package.json拷贝到自己的工程目录下,进入目录,执行:npm install 语法gulp APIgulp.src(globs[,options])1234gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) //压缩文件 .pipe(gulp.dest('build/minified_templates')); 作用: 输出符合所提供的匹配模式或数组的文件.globs 类型: string或Array所要读取的glob或者包含globs的数组.可以是地址options 类型:object额外的选项参数 gulp.dest(path[,options])12345gulp.src('./client/templates/*.jade') .pipe(jade()) .pipe(gulp.dest('./build/templates')) .pipe(minify()) .pipe(gulp.dest('./build/minified_templates')); 文件被pipe进来,dest生成或者写入一个文件.path文件将被写入的路径(输出目录)。 gulp.task(name[,deps],fn)定义一个实现任务 123gulp.task('somename', function()&#123; //任务&#125;) name任务名字deps 类型: array一个包含任务列表的数组,这些任务会在你当前运行任务之前完成. 123gulp.task('mytask', ['array', 'of', 'task', 'names'], function()&#123; //任务&#125;) fn该函数定义任务所要执行的一些操作。通常来说,它会是这种形式：gulp.src().pipe(someplugin())。 gulp.watch(glob[, opts], tasks)监视文件,并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射(emit) change 事件。 1234var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); gulp使用实例范例1. 压缩合并demo1目录结构如下。把demo1中的 index.html压缩,把src里面的less编译、合并、压缩、重命名、存储到dist。src里面的图片压缩、合并存储到dist。src里面的js做代码检查,压缩,合并,存储到dist。 123456789101112131415161718192021+ demo1 + dist + css - merge.min.css + js - merge.min.js + imgs - 1.png - 2.png - index.html + src + css - a.css - b.css + js - a.js - b.js + imgs - 1.png - 2.png - index.html 创建gulpfile.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var gulp = require('gulp');// 引入组件var minifycss = require('gulp-minify-css'), // CSS压缩 uglify = require('gulp-uglify'), // js压缩 concat = require('gulp-concat'), // 合并文件 rename = require('gulp-rename'), // 重命名 clean = require('gulp-clean'), //清空文件夹 minhtml = require('gulp-htmlmin'), //html压缩 jshint = require('gulp-jshint'), //js代码规范性检查 imagemin = require('gulp-imagemin'); //图片压缩gulp.task('html', function() &#123; return gulp.src('src/*.html') .pipe(minhtml(&#123;collapseWhitespace: true&#125;)) //html压缩 .pipe(gulp.dest('dist'));&#125;);gulp.task('css', function(argument) &#123; gulp.src('src/css/*.css') .pipe(concat('merge.css')) // CSS压缩 .pipe(rename(&#123; suffix: '.min' // 重命名 &#125;)) .pipe(minifycss()) // CSS压缩 .pipe(gulp.dest('dist/css/'));&#125;);gulp.task('js', function(argument) &#123; gulp.src('src/js/*.js') .pipe(jshint()) //js代码规范性检查 .pipe(jshint.reporter('default')) .pipe(concat('merge.js')) // 合并文件 .pipe(rename(&#123; suffix: '.min' // 重命名 &#125;)) .pipe(uglify()) // js压缩 .pipe(gulp.dest('dist/js/'));&#125;);gulp.task('img', function(argument)&#123; gulp.src('src/imgs/*') .pipe(imagemin()) //图片压缩 .pipe(gulp.dest('dist/imgs'));&#125;);gulp.task('clear', function()&#123; gulp.src('dist/*',&#123;read: false&#125;) .pipe(clean()); //清空文件夹&#125;);gulp.task('build', ['html', 'css', 'js', 'img']); 最后命令行gulp build;可实现src目录下的html压缩,css、js合并压缩,图片压缩,最后放入 dist目录下 范例2. 监控变动自动同步1234567891011121314151617181920212223242526272829303132333435363738394041var gulp = require('gulp');// 引入组件var browserSync = require('browser-sync').create(); //用于浏览器自动刷新var scp = require('gulp-scp2'); //用于scp到远程机器var fs = require('fs'); gulp.task('reload', function()&#123; browserSync.reload();&#125;);gulp.task('server', function() &#123; browserSync.init(&#123; server: &#123; baseDir: "./src" &#125; &#125;); gulp.watch(['**/*.css', '**/*.js', '**/*.html'], ['reload', 'scp']);&#125;);gulp.task('scp', function() &#123; return gulp.src('src/**/*') .pipe(scp(&#123; host: '121.40.201.213', username: 'root', privateKey: fs.readFileSync('/Users/wingo/.ssh/id_rsa'), dest: '/var/www/fe.jirengu.com', watch: function(client) &#123; client.on('write', function(o) &#123; console.log('write %s', o.destination); &#125;); &#125; &#125;)) .on('error', function(err) &#123; console.log(err); &#125;);&#125;); 命令行执行: 12gulp scp; // 可把本地开发环境代码拷贝到服务器gulp server; //可在本地创建服务器,本地开发浏览器立刻刷新 范例3. 监控项目文件变动,自动压缩、合并、打包、添加版本号12345678910111213141516171819202122html&lt;/html&gt;&lt;head&gt;&lt;!-- build:css css/merge.css --&gt; &lt;link href="css/a.css" rel="stylesheet"&gt; &lt;link href="css/b.css" rel="stylesheet"&gt;&lt;!-- endbuild --&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;demo1-工程化手动版&lt;/p&gt;&lt;!-- build:js js/merge.js --&gt; &lt;script type="text/javascript" src="js/a.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/b.js"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt;&lt;/body&gt;&lt;/html&gt; 设置gulpfile.js文件 1234567891011121314151617181920212223242526272829303132333435var gulp = require('gulp'); var rev = require('gulp-rev'); //添加版本号var revReplace = require('gulp-rev-replace'); //版本号替换var useref = require('gulp-useref'); //解析html资源定位var filter = require('gulp-filter'); //过滤数据var uglify = require('gulp-uglify'); var csso = require('gulp-csso'); //css优化压缩var clean = require('gulp-clean');gulp.task("index", ['clear'], function() &#123; var jsFilter = filter("**/*.js", &#123;restore: true&#125;); var cssFilter = filter("**/*.css", &#123;restore: true&#125;); var userefAssets = useref.assets(); return gulp.src("src/index.html") .pipe(userefAssets) // Concatenate with gulp-useref .pipe(jsFilter) .pipe(uglify()) // Minify any javascript sources .pipe(jsFilter.restore) .pipe(cssFilter) .pipe(csso()) // Minify any CSS sources .pipe(cssFilter.restore) .pipe(rev()) // Rename the concatenated files .pipe(userefAssets.restore()) .pipe(useref()) .pipe(revReplace()) // Substitute in new filenames .pipe(gulp.dest('dist'));&#125;);gulp.task('clear', function()&#123; gulp.src('dist/*',&#123;read: false&#125;) .pipe(clean());&#125;); 范例4. 本地shell命令, 远程shell, 任务顺序执行…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var gulp = require('gulp');var shell = require('gulp-shell');var runSequence = require('run-sequence');var fs = require('fs');var GulpSSH = require('gulp-ssh');//shell操作, gulp.task('git', shell.task(['git add .', 'git commit -am "dd"', 'git push -u origin dev']));gulp.task('clear', shell.task(['find . -name ".DS_Store" -depth -exec rm &#123;&#125; \\;']));//操作远程主机var gulpSSH = new GulpSSH(&#123; ignoreErrors: false, sshConfig: &#123; host: '121.40.201.213', port: 22, username: 'root', privateKey: fs.readFileSync('/Users/wingo/.ssh/id_rsa') &#125;&#125;);gulp.task('remote', function() &#123; return gulpSSH .shell(['cd /var/www/fe.jirengu.com', 'git pull origin dev', 'rm -rf _runtime']);&#125;);gulp.task('build', function(callback) &#123; runSequence( 'git', 'clear', 'remote', callback );&#125;);gulp.task('watch', function() &#123; gulp.watch(['**/*.css', '**/*.js', '**/*.html', '**/*.php'], ['build']);&#125;); webpack相关问题 webpack与grunt、gulp的不同？ 三者都是前端构建工具,grunt和gulp在早期比较流行,现在webpack相对来说比较主流,不过一些轻量化的任务还是会用gulp来处理,比如单独打包CSS文件等。 grunt和gulp是基于任务和流(Task、Stream)的。类似jQuery,找到一个(或一类)文件,对其做一系列链式操作,更新流上的数据, 整条链式操作构成了一个任务,多个任务就构成了整个web的构建流程。 webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件,然后用不同的Loader来处理不同的文件,用Plugin来扩展webpack功能。 所以总结一下： 从构建思路来说gulp和grunt需要开发者将整个前端构建过程拆分成多个Task,并合理控制所有Task的调用关系webpack需要开发者找到入口,并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工 对于知识背景来说gulp更像后端开发者的思路,需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路 与webpack类似的工具还有哪些？谈谈你为什么最终选择(或放弃)使用webpack？ 同样是基于入口的打包工具还有以下几个主流的：webpackrollupparcel从应用场景上来看： webpack适用于大型复杂的前端站点构建rollup适用于基础库的打包,如vue、reactparcel适用于简单的实验性项目,他可以满足低门槛的快速看到效果由于parcel在打包过程中给出的调试信息十分有限,所以一旦打包出错难以调试,所以不建议复杂的项目使用parcel 有哪些常见的Loader？他们是解决什么问题的？ file-loader：把文件输出到一个文件夹中,在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似,但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件,以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS,支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中,通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码 有哪些常见的Plugin？他们是解决什么问题的？ define-plugin：定义环境变量commons-chunk-plugin：提取公共代码uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 Loader和Plugin的不同？ 不同的作用Loader直译为”加载器”。Webpack将一切文件视为模块,但是webpack原生是只能解析js文件,如果想将其他文件也打包的话,就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。Plugin直译为”插件”。Plugin可以扩展webpack的功能,让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件,Plugin 可以监听这些事件,在合适的时机通过 Webpack 提供的 API 改变输出结果。不同的用法Loader在module.rules中配置,也就是它作为模块的解析规则而存在。 类型为数组,每一项都是一个Object,里面描述了对于什么类型的文件(test),使用什么加载(loader)和使用的参数(options)Plugin在plugins中单独配置。 类型为数组,每一项是一个plugin的实例,参数都通过构造函数传入。 webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全 Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数;开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译;确定入口：根据配置中的 entry 找出所有的入口文件;编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理;完成模块编译：在经过第4步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系;输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会;输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？ Loader像一个”翻译官”把读到的源文件内容转义成新的文件内容,并且每个Loader通过链式操作,将源文件一步步翻译成想要的样子。 编写Loader时要遵循单一原则,每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容(source),可以通过返回值的方式将处理后的内容输出,也可以调用this.callback()方法,将内容返回给webpack。 还可以通过 this.async()生成一个callback函数,再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。 相对于Loader而言,Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件,Plugin 可以监听这些事件,在合适的时机通过 Webpack 提供的 API 改变输出结果。 webpack的热更新是如何做到的？说明其原理？ webpack的热更新又称热替换(Hot Module Replacement),缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理：首先要知道server端和client端都做了处理工作 第一步,在 webpack 的 watch 模式下,文件系统中某一个文件发生修改,webpack 监听到文件变化,根据配置文件对模块重新编译打包,并将打包后的代码通过简单的 JavaScript 对象保存在内存中。第二步是 webpack-dev-server 和 webpack 之间的接口交互,而在这一步,主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互,webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控,并且告诉 webpack,将代码打包到内存中。第三步是 webpack-dev-server 对文件变化的一个监控,这一步不同于第一步,并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候,Server 会监听这些配置文件夹中静态文件的变化,变化后会通知浏览器端对应用进行 live reload。注意,这儿是浏览器刷新,和 HMR 是两个概念。第四步也是 webpack-dev-server 代码的工作,该步骤主要是通过 sockjs(webpack-dev-server 的依赖)在浏览器端和服务端之间建立一个 websocket 长连接,将 webpack 编译打包的各个阶段的状态信息告知浏览器端,同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值,后面的步骤根据这一 hash 值来进行模块热替换。webpack-dev-server/client 端并不能够请求更新的代码,也不会执行热更模块操作,而把这些工作又交回给了 webpack,webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器,也就没有后面那些步骤了。HotModuleReplacement.runtime 是客户端 HMR 的中枢,它接收到上一步传递给他的新模块的 hash 值,它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求,服务端返回一个 json,该 json 包含了所有要更新的模块的 hash 值,获取到更新列表后,该模块再次通过 jsonp 请求,获取到最新的模块代码。这就是上图中 7、8、9 步骤。而第 10 步是决定 HMR 成功与否的关键步骤,在该步骤中,HotModulePlugin 将会对新旧模块进行对比,决定是否更新模块,在决定更新模块后,检查模块之间的依赖关系,更新模块的同时更新模块间的依赖引用。最后一步,当 HMR 失败后,回退到 live reload 操作,也就是进行浏览器刷新来获取最新打包代码。 如何利用webpack来优化前端性能？(提高性能和体验) 用webpack优化前端性能是指优化webpack的输出结果,让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件, 利用cssnano(css-loader?minimize)来压缩css利用CDN加速。在构建过程中,将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径删除死代码(Tree Shaking)。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现提取公共代码。 如何提高webpack的构建速度？ 多入口情况下,使用CommonsChunkPlugin来提取公共代码通过externals配置来提取常用库利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译,再通过DllReferencePlugin将预编译的模块加载进来。使用Happypack 实现多线程加速编译使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度使用Tree-shaking和Scope Hoisting来剔除多余代码 怎么配置单页应用？怎么配置多页应用? 单页应用可以理解为webpack的标准模式,直接在entry中指定单页应用的入口即可,这里不再赘述 多页应用的话,可以使用webpack的 AutoWebPlugin来完成简单自动化的构建,但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码,可以将这些代码抽离出来,避免重复的加载。比如,每个页面都引用了同一套css样式表随着业务的不断扩展,页面可能会不断的追加,所以一定要让入口的配置足够灵活,避免每次添加新页面还需要修改构建配置 npm打包时需要注意哪些？如何利用webpack来更好的构建？ Npm是目前最大的 JavaScript 模块仓库,里面有来自全世界开发者上传的可复用模块。你可能只是JS模块的使用者,但是有些情况你也会去选择上传自己开发的模块。 关于NPM模块上传的方法可以去官网上进行学习,这里只讲解如何利用webpack来构建。 NPM模块需要注意以下问题： 要支持CommonJS模块化规范,所以要求打包后的最后结果也遵守该规则。Npm模块使用者的环境是不确定的,很有可能并不支持ES6,所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的,请最好连同SourceMap一同上传。Npm包大小应该是尽量小(有些仓库会限制包大小)发布的模块不能将依赖的模块也一同打包,应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。UI组件类的模块应该将依赖的其它资源文件,例如.css文件也需要包含在发布的模块里。基于以上需要注意的问题,我们可以对于webpack配置做以下扩展和优化： CommonJS模块化规范的解决方案：设置output.libraryTarget=&#39;commonjs2&#39;使输出的代码符合CommonJS2 模块化规范,以供给其它模块导入使用输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: &#39;source-map&#39;输出SourceMap以发布调试。Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数,最终导致每个输出的文件中都包含这段辅助函数的代码,造成了代码的冗余。解决方法是修改.babelrc文件,为其加入transform-runtime插件不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现,配置如下： 12345678910111213141516171819202122const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; module: &#123; rules: [ &#123; //增加对CSS文件的支持 test: /\.css/, //提取出 Chunk 中的CSS代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: ['css-loader'] &#125;), &#125;, ] &#125;, plugins: [ new ExtractTextPlugin( &#123; //输出的CSS文件名称 filename: 'index.css', &#125;), ], &#125;; 如何在vue项目中实现按需加载？ Vue UI组件库的按需加载: 为了快速开发前端项目,经常会引入现成的UI组件库如ElementUI、iView等,但是他们的体积和他们所提供的功能一样,是很庞大的。 而通常情况下,我们仅仅需要少量的几个组件就足够了,但是我们却将庞大的组件库打包到我们的源码中,造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案,如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后,在.babelrc配置中或babel-loader的参数中进行设置,即可实现组件按需加载了。 单页应用的按需加载现在很多前端项目都是通过单页应用的方式开发的,但是随着业务的不断扩展,会面临一个严峻的问题——首次加载的代码量会越来越多,影响用户的体验。 通过import(*)语句来控制加载时机,webpack内置了对于import(*)的解析,会将import(*)中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import(*)语句时,会去加载Chunk对应生成的文件。import()会返回一个Promise对象,所以为了让浏览器支持,需要事先注入Promise polyfill.]]></content>
      <categories>
        <category>JS</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶]]></title>
    <url>%2F2019%2F08%2F27%2FJS%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[构造对象newnew运算符接受一个函数F及其参数: new F(arguments…).这个一过程分为: 创建类的实例.这步是把一个空的对象的proto属性设置为F.prototype. 初始化实例.函数F被传入参数并调用.关键字this被设定为该实例. 返回实例.123456789function person(name, age)&#123; this.name = name this.age = age this.sayName = function()&#123; console.log(this.name) &#125;&#125;p1 = new person('tom', 12) instanceofinstanceof是一个操作符,可以判断对象是否为某个类型的实例 1234p1 instanceof person//true,说明p1是由person创造的p1 instanceof Object//true,p1 instanceof Number//false 原型与原型链 当new一个函数的时候会创建一个对象,函数.prototype等于被创建对象.__proto__ 一切函数都是由Function这个函数创建的,所以Function.prototye === 被创建函数.__proto__ 一切函数的原型对象都是由Object这个函数创建的,所以Object.prototype === 一切函数.prototype.__proto__ __proto__把对象和原型连接起来，形成原型链 this在函数被直接调用时this绑定到全局对象.即window 12345console.log(this)//指向windowfunction fn1()&#123; console.log(this)//指向window&#125; fn1()//相当于window.fn1() 内部函数函数嵌套产生的内部函数的this不是他的父函数,仍然是全局,window 12345678function fn0()&#123; function fn()&#123; console.log(this) &#125; fn()&#125;fn0() setTimeOut()和setInterval()这两个函数执行的函数this也是全局 123456document.addEventListener('click', function(e)&#123; console.log(this); setTimeout(function()&#123; console.log(this); &#125;, 200);&#125;, false); DOM对象绑定事件在事件处理程序中this代表事件源DOM对象 12345678document.addEventListener('click', function(e)&#123; console.log(this); var _document = this; setTimeout(function()&#123; console.log(this); console.log(_document); &#125;, 200);&#125;, false); Function.prototype.bind()bind改变this的指向.返回一个新函数,并使函数内部的this为传入的第一个参数,并不执行 12var fn3 = obj1.fn.bind(obj1);fn3(); 使用call和apply设置thiscall,apply调用一个函数,传入函数执行上下文及其参数,并立即执行 12fn.call(context,param1,param2...)//接受参数列表fn.apply(context,paramArray)//接收参数数组 第一个参数都是希望设置的this对象举例 12345678//实现一个函数可以遍历传入的参数function sum()&#123; //arguments.forEach无法执行,因为arguments不是数组,使用call将forEach的this指向arguments,使之可以遍历 Array.prototype.forEach.call(arguments,function(value)&#123; console.log(value) &#125;)&#125;sum(3,4,1,6)//函数就可以遍历了 12345678910function sum()&#123; var result = 0 //arguments.forEach无法执行,因为arguments不是数组,使用call将forEach的this指向arguments,使之可以遍历 Array.prototype.forEach.call(arguments,function(value)&#123; console.log(value) return result += value &#125;) console.log(result)&#125;sum(3,4,1,6)//函数就可以将传入值相加了 argument 在函数调用时，会自动在该函数内部生成一个名为 arguments的隐藏对象 该对象类似于数组，可以使用[]运算符获取函数调用时传递的实参 只有函数被调用时，arguments对象才会创建，未调用时其值为null12345678function fn5(name, age)&#123; console.log(arguments); name = 'XXX'; console.log(arguments); arguments[1] = 30; console.log(arguments);&#125;fn5('Byron', 20); 研究this123456789var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 打印出的 this 是 objbar() // 打印出的 this 是 window 实际上的正常调用方式func.call(context, p1, p2)其他简化方式都可以转化 12345func(p1, p2) 等价于func.call(undefined, p1, p2)obj.child.method(p1, p2) 等价于obj.child.method.call(obj.child, p1, p2) this，就是上面代码中的 context。就这么简单。 this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。 浏览器规则:如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） 上面的代码就解释的通了 12345678910111213var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 转换为 obj.foo.call(obj)，this 就是 objbar() // 转换为 bar.call()// 由于没有传 context// 所以 this 就是 undefined// 最后浏览器给你一个默认的 this —— window 对象 Event Handler中的this123btn.addEventListener('click' ,function handler()&#123; console.log(this) // 请问这里的 this 是什么&#125;) 当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样。 jQuery Event Handler 中的 this那么下面代码中的 this 是什么呢： 123$ul.on('click', 'li' , function()&#123; console.log(this)&#125;) 当jQuery的调用处理程序时，this关键字指向的是当前正在执行事件的元素。对于直接事件而言，this 代表绑定事件的元素。对于代理事件而言，this 则代表了与 selector 相匹配的元素。(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)若要使用 jQuery 的相关方法，可以根据当前元素创建一个 jQuery 对象，即使用 $(this)。 []语法123function fn ()&#123; console.log(this) &#125;var arr = [fn, fn2]arr[0]() // 这里面的 this 又是什么呢？ 我们可以把 arr0 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了： 1234 arr[0]() 假想为 arr.0()然后转换为 arr.0.call(arr)那么里面的 this 就是 arr 了 call、apply 、函数执行的本质当我们执行一个函数，以下几种调用方式等价 12345678"use strict"function fn(a,b)&#123; console.log(this)&#125;fn(1, 2)//等价于fn.call(undefined, 1, 2)fn.apply(undefined, [1, 2]) 在严格模式下， fn 里的 this 就是 call 的第一个参数，也就是 undefined。在非严格模式下(不加”use strict”)， call 传递的第一个参数如果是 undefined 或者 null， 那 this 会自动替换为 Window 对象 123456789101112131415161718var obj = &#123; fn: function(a, b)&#123; console.log(this) &#125;, child: &#123; fn2: function()&#123; console.log(this) &#125; &#125;&#125;obj.fn(1, 2)//等价于obj.fn.call(obj, 1, 2) // 所以 this 是 objobj.fn.apply(obj, [1, 2])obj.child.fn2()//等价于obj.child.fn2.call(obj.chid) // 所以 this 是 obj.child 箭头函数中的this1234567891011121314let app = &#123; fn1: function(a)&#123; console.log(this) //app &#125;, fn2(a)&#123; console.log(this) //app &#125;, fn3: (a)=&gt; &#123; console.log(this) //window &#125;&#125;app.fn2.call(app)app.fn3.call(它上一级环境下的this) 箭头函数的复杂情况示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var app = &#123; fn1()&#123; setTimeout(function()&#123; console.log(this) &#125;,10) &#125;, fn2()&#123; setTimeout(()=&gt;&#123; console.log(this) &#125;,20) &#125;, fn3()&#123; setTimeout((function()&#123; console.log(this) &#125;).bind(this),30) &#125;, fn4: ()=&gt;&#123; setTimeout(()=&gt;&#123; console.log(this) &#125;,40) &#125;&#125;app.fn1()app.fn2()app.fn3()app.fn4()以上代码相当于var app = &#123; fn1()&#123; function fn()&#123; console.log(this) &#125; //过10ms后执行 //fn.call(undefined),所以输出window &#125;, fn2()&#123; //过20ms执行箭头函数 //箭头函数里没有资格有自己的this,借用setTimeout外面的this,也就是app &#125;, fn3()&#123; //创建了一个新函数,这个新函数绑定了外面的this,也就是app //20ms后执行新函数,输出this,也就是刚刚绑定的app &#125;, fn4: ()=&gt;&#123; //过40ms执行箭头函数 //箭头函数里没有资格有自己的this,借用setTimeout外面的this //setTimeout所在的fn4也是箭头函数,没资格拥有自己的this,借用外面的this,也就是window &#125;&#125; 函数的执行环境JavaScript中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因 一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数 接下来创建作用域链，然后初始化变量。首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。 如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解JavaScript中的变量作用域非常重要，最后为this变量赋值，会根据函数调用方式的不同，赋给this全局对象，当前对象等 至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取. 三种变量实例变量：（this）类的实例才能访问到的变量 静态变量：（属性）直接类型对象能访问到的变量 私有变量：（局部变量）当前作用域内有效的变量 123456789101112131415function ClassA()&#123; var a = 1; //私有变量，只有函数内部可以访问 this.b = 2; //实例变量，只有实例可以访问&#125;ClassA.c = 3; // 静态变量，也就是属性，类型访问console.log(a); // errorconsole.log(ClassA.b) // undefinedconsole.log(ClassA.c) //3var classa = new ClassA();console.log(classa.a);//undefinedconsole.log(classa.b);// 2console.log(classa.c);//undefined 继承继承是指一个对象直接使用另一个对象的属性和方法.如果实现以下两点就实现了继承 得到一个类的属性 得到一个类的方法 原型继承，核心在于在子类的构造函数中通过parent.call(this)继承父亲的属性，然后改变子类的原型为new parent()来继承父类的函数. 属性的获取对象属性的获取是通过构造函数的执行.在一个类中执行另外一个类的构造函数,就可以把属性赋值到自己内部,但是需要把环境改到自己的作用域内,用call修改this的指向即可. 123456789101112131415161718192021222324252627function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;;function Male(age)&#123; this.age = age;&#125;Male.prototype.printAge = function()&#123; console.log(this.age);&#125;;function Male(name,sex,age)&#123; Person.call(this,name,sex) this.age = age&#125;Male.prototype.printAge = function()&#123; console.log(this.age)&#125;var m = new Male('Tom','male',10)console.log(m.sex) //'male' 继承的范例12345678910function Male(name,sex,age)&#123; Person.call(this, name, sex) this.age = age&#125;Male.prototype = Object.create(Person.prototype)Male.prototype.printAge = function()&#123; console.log(this.age)&#125; 12345678910111213141516171819202122function Person(name, sex)&#123; this.name = name this.age = age&#125;Person.prototype.printName = function()&#123; console.log(this.name)&#125;function Male(name, sex, age)&#123; Person.call(this, name, age) this.sex = sex&#125;Male.prototype = new Person()Male.prototype.printAge = function()&#123; console.log(this.age)&#125;Male.prototype.constuctor = Malevar man = new Male('Tom', 'Male', 10)man.printName()//'Tom' hasOwnProperty判断属性是自己的还是继承的 12m.hasOwnProperty('name')//truem.hasOwnProperty('printName')//false Promise对象回调地狱下列代码实现按顺序执行,1秒后执行fn1,再过1秒执行fn2,再过1秒执行fn3 123456789101112131415161718192021222324252627function fn1(callback) &#123; setTimeout(()=&gt;&#123; console.log('fn1') callback() &#125;, 1000)&#125;function fn2(callback) &#123; setTimeout(()=&gt;&#123; console.log('fn2') callback() &#125;, 1000)&#125;function fn3() &#123; setTimeout(()=&gt;&#123; console.log('fn3') &#125;, 1000)&#125;fn1(function()&#123; fn2(function()&#123; fn3() &#125;)&#125;) 由于层层嵌套,形成回调地狱.(如果套个十几二十个,真的要崩溃) 什么是PromisePromise是一个对象,对象里存储着状态.分别是pending(等待态),fulfilled(完成态),rejected(拒绝态)Promise 启动之后，当满足成功的条件时我们让状态从 pending 变成 fullfilled （执行 resolve）；当满足失败的条件，我们让状态从 pending 变成 rejected（执行 reject）面试官想听的版本:所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理，让开发者不用再关注于时序和底层的结果。Promise的状态具有不受外界影响和不可逆两个特点。 Promise+ajax范例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//获取IPfunction getIp()&#123; return new Promise(function(resolve,reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET','https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getIp',true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson.ip) &#125; xhr.onerror = function()&#123; reject('获取IP失败') &#125; xhr.send() &#125;)&#125;//从IP获取城市function getCityFromIp(ip)&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET', 'https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip='+ip, true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson.city) &#125; xhr.onerror = function()&#123; reject('获取city失败') &#125; xhr.send() &#125;)&#125;//通过城市获取天气function getWeatherFromCity(city&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET', 'https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getWeatherFromCity?city='+city, true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson) &#125; xhr.onerror = function()&#123; reject('获取天气失败') &#125; xhr.send() &#125;)&#125;)getIp().then(function(ip)&#123; return getCityFromIp(ip)&#125;).then(function(city)&#123; return getWeatherFromCity(city)&#125;).then(function(data)&#123; console.log(data)&#125;).catch(function(e)&#123; console.log('出现了错误',e)&#125;)//getIP()得到一个promise对象,传入ip,返回另一个promise对象,依次往下//中途报错直接执行catch() Promise.all1234567891011121314151617181920212223function getCityFromIp(ip)&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET','https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip='+ip',true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson) &#125; xhr.onerror = function()&#123; reject('获取city失败') &#125; xhr.send() &#125;)&#125;var p1 = getCityFromIp('10.10.10.1')var p2 = getCityFromIp('10.10.10.2')var p3 = getCityFromIp('10.10.10.3')//Promise.all, 当所有的 Promise 对象都完成后再执行Promise.all([p1,p2,p3]).then(data =&gt; &#123; console.log(data)&#125;) Promise.race123456789101112131415161718192021222324252627function getCityFromIp(ip) &#123; var promise = new Promise(function(resolve, reject)&#123; var xhr = new XMLHttpRequest() xhr.open('GET', 'https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip='+ip, true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responseText) // &#123;"city": "hangzhou","ip": "23.45.12.34"&#125; resolve(retJson) &#125; xhr.onerror = function()&#123; reject('获取city失败') &#125; setTimeout(()=&gt;&#123; xhr.send() &#125;, Math.random()*1000) &#125;) return promise&#125;var p1 = getCityFromIp('10.10.10.1')var p2 = getCityFromIp('10.10.10.2')var p3 = getCityFromIp('10.10.10.3')//Promise.race, 谁的先输出就先执行谁Promise.race([p1, p2, p3]).then(data=&gt;&#123; console.log(data)&#125;) callback&amp;Promise&amp;async/await把一个需求不断简化需求如下: 读取 a.md 文件，得到内容 把内容转换成 HTML 字符串 把HTML 字符串写入 b.html callback()处理1234567891011121314var fs = require('fs')var markdown = require('markdown').markdownfs.readFile('a.md', 'UTF-8', function(err,str)&#123; if(err)&#123; return console.log(err) &#125; var html = markown.toHTML(str) fs.writeFile('b.html', html, function(err)&#123; if(err)&#123; return console.log(err) &#125; console.log('write.success') &#125;)&#125;) ES6语法简化处理1234567891011121314let fs = require('fs')let markdown = require('markdown').markdownfs.readFile('a.md', 'UTF-8', (err, str)=&gt;&#123; if(err)&#123; return console.log(err) &#125; let html = markdown.toHTML(str) fs.writeFile('b.html', html, (err)=&gt;&#123; if(err)&#123; return console.log(err) &#125; console.log('write.success') &#125;)&#125;) Promise处理1234567891011121314151617181920212223242526272829303132333435363738const fs = require('fs')const markdown = require('markdown').markdownreadFile('a.md') .then((mdStr)=&gt;&#123; return markdown.toHTML(mdStr) //返回结果作为下个回调函数 &#125;).then(html=&gt;&#123; writeFile('b.html', html) &#125;).catch((e)=&gt;&#123; console.log(e) &#125;)//对读取文件进行包装function readFile(url)&#123; return new Promise((resolve, reject)=&gt;&#123; fs.readFlie(url, 'UTF-8', (err, str)=&gt;&#123; if(err)&#123; reject(new Error('readFlie error')) &#125;else&#123; resolve(str) &#125; &#125;) &#125;)&#125;//对写入文件进行包装function writeFile(url, data)&#123; return new Promise((resolve, reject)=&gt;&#123; fs.writeFile(url, data, (err, str)=&gt;&#123; if(err)&#123; reject(new Error('write error')) &#125;else&#123; resolve() &#125; &#125;) &#125;)&#125; 使用模块改装上面代码123456789101112const markdown = require('markdown').markdownconst fsp = require('fs-promise') //用于把fs变promise化let onerror = err=&gt;&#123; console.error('something wrong')&#125;fsp.readFile('a.md', 'UTF-8') .then((mdStr)=&gt;&#123; return markdown.toHTML(mdStr) &#125;).then(html=&gt;&#123; fsp.writeFile('b.html', html) &#125;).catch(onerror) async/await处理12345678910111213const markdown = require('markdown').markdownconst fsp = require('fs-promise')let onerror = err=&gt;&#123; console.error('sonething wrong')&#125;async function start()&#123; let mdStr = await fsp.readFile('a.md', 'UTF-8') let html = markdown.toHTML(mdStr) await fsp.writeFile('b.html', html)&#125;start().catch(onerror) 方法Promise.prototype.then(onFulfilled, onRejected)接收成功或失败的结果回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve. Promise.prototype.catch(onRejected)接受一个失败的结果回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果. Promise.prototype.finally(onFinally)添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected) async/awaitAsync 函数的创建时通过在函数声明语句之前加上 async 关键字，这是异步函数的特征之一 ––它将任何函数转换为promise。示例如下： 1234567const asyncFunction = async () =&gt; &#123; // Code&#125;//或者async function asyncFunction()&#123; //code&#125; awaitasync异步函数可通过await来暂停，该关键字只能用在async函数内部。每当函数执行完毕，await返回的是任何async函数会返回的东西。 只能放在async函数内部使用，不能放在普通函数里面，否则会报错。后面放Promise对象，在Pending状态时，相应的协程会交出控制权，进入等待状态。等等党永不为奴!这个是本质。await是async wait的意思，wait的是resolve(data)消息，并把数据data返回。await后面也可以跟同步代码，不过系统会自动转化成一个Promise对象。await只关心异步过程成功的消息resolve(data)，拿到相应的数据data。至于失败消息reject(error)，不关心，不处理。 MDN例子: 123456async function hello() &#123; return greeting = await Promise.resolve("Hello");&#125;;hello().then(alert);//先等返回了hello再打印 简单案例: 1234567891011function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value); &#125;asyncPrint('hello world', 50);// 上面代码指定50毫秒以后，输出"hello world"。]]></content>
      <categories>
        <category>JS</category>
        <category>JS进阶</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas画板]]></title>
    <url>%2F2019%2F08%2F27%2Fcanvas%2F</url>
    <content type="text"><![CDATA[简介canvas本身没有绘图能力，只是定义了一个容器，都是由canvas内部的CanvasRenderingContext2D对象来做，需要我们用 JavaScript脚本 完成绘制工作。 基础 html引入&lt;canvas&gt;标签&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; js获取&lt;canvas&gt;属性,使用2d绘制上下文. 123var canvas = getElementById("canvas")var context = canvas.getContext("2d")//使用context进行绘制 设置宽高使用canvas.width设置宽度.canvas.height设置高度. 123456789101112131415161718&lt;body&gt;&lt;canvas id="canvas" sytle="border: 1px solid #aaa;display: block;margin: 50px auto;"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function()&#123; var canvas = document.getElementById("canvas") canvas.width: 1024; canvas.height: 768; if(canvas.getContext("2d"))&#123; //如果浏览器支持canvas,可以使用 var context = canvas.getContext("2d") &#125;else&#123; alert('当前浏览器不支持,请使用谷歌浏览器') &#125; &#125;&lt;/script&gt;&lt;/body&gt; 设置全屏 12345let pageWidth = document.documentElement.clientWidth;let pageHeight = document.documentElement.clientHeight;canvas.width = pageWidth;canvas.height = pageHeight; 绘制线段1234567891011121314151617181920212223var context = canvas.getContext("2d")conext.beginPath()//开始第一段绘制,与其他绘制可以区别开context.moveTo(100,100)//以画布左上角为原点,从坐标(100,100)开始context.lineTO(700,700)//把线画到(700,700)位置context.lineTO(100,700)//折到(100,700)位置context.lineTO(100,100)//线段完成封闭,形成三角形context.closePath()//结束本段状态context.fillStyle="rgab(168,168,168)"//设置三角形填充颜色context.fill()//执行填充颜色context.lineWidth = 5 //设置线段宽度context.strokeStyle = "red" //设置线段颜色context.stroke//执行绘图conext.beginPath()//开始第二段绘制,与其他绘制可以区别开context.moveTo(200,100)//以画布左上角为原点,从坐标(200,100)开始context.lineTO(700,600)//把线画到(700,600)位置context.closePath()//结束本段状态context.strokeStyle = "blue" //设置线段颜色context.stroke//执行第二段绘图 标签属性 标签 描述 height 设置 canvas 的高度 width 设置 canvas 的宽度 fill() 可以填充 fillRect(x,y,width,height) 绘制一个矩形边框 fillRect(x,y,width,height) 绘制一个填充的矩形 clearRect(x,y,width,height) 清除指定矩形区域，让清除部分完全透明 ctx.strokeStyle 可以改变画笔颜色 ctx.beginPath() 设置开始路径 ctx.moveTo(x,y) 设置起点 ctx.lineTo(x,y) 设置终点 ctx.stroke() 绘制 ctx.closePath() 结束路径 ctx.arc(弧形圆心x坐标，y坐标，半径，起始角(以3点钟的位置开始)，结束角、方向(true表示逆时针，false表示顺时针)) 绘制一个弧形 ctx.quadraticCurveTo(cpx,cpy,x,y)参数是控制点x坐标，控制点y坐标，结束点x坐标，结束点y坐标 绘制二次贝塞尔曲线 ctx.quadraticCurveTo(cpx1,cpy1,cpx2,cpy2,x,y)参数是控制点1的x坐标，控制点1的y坐标，控制点2的x坐标，控制点2的y坐标，结束点x坐标，结束点y坐标 绘制三次贝塞尔曲线 canvas画板代码实现html12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;div id="actions"class="actions x"&gt; &lt;svg id="pen"class="icon"&gt; &lt;use xlink:href="#icon-pencil"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="eraser"class="icon"&gt; &lt;use xlink:href="#icon-eraser"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="clear"class="icon"&gt; &lt;use xlink:href="#icon-delete"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="download"class="icon"&gt; &lt;use xlink:href="#icon-download"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;ul class='colorCir'&gt; &lt;li id="black"class="black"&gt;&lt;/li&gt; &lt;li id="red"class="red"&gt;&lt;/li&gt; &lt;li id="yellow"class="yellow"&gt;&lt;/li&gt; &lt;li id="blue"class="blue"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class='lineWidth'&gt; &lt;li id="thin" class="thin"&gt;&lt;/li&gt; &lt;li id="thick" class="thick"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127*&#123; margin:0; padding:0;&#125;body&#123; background:#eee&#125;ul,ol&#123; list-style: none; &#125;.colorCir&#123; top:60px; left:20px; position: fixed; &#125;.colorCir li&#123; border: 1px solid grey; height:20px; width: 20px; border-radius: 50%; margin-bottom:10px;&#125;.colorCir .red&#123; background:red;&#125; .colorCir .yellow&#123; background:yellow;&#125; .colorCir .blue&#123; background:blue;&#125; .colorCir .black&#123; background:black;&#125; .colorCir .red.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .yellow.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .blue.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .black.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; &#125;body&#123; overflow: hidden;&#125;#canvas&#123; display: block; position: fixed; top:0px; left:0px;&#125;.actions&#123; position: fixed; top:0px; left:0px; padding-top:20px; padding-left:15px;&#125;.actions svg&#123; width:1.5em; height:1.5em; transition: all 0.3s; margin:0 5px;&#125;.actions svg.active&#123; fill:red; transform: scale(1.2);&#125;.lineWidth&#123; position: relative; left:-10px; top:140px;&#125;.lineWidth .thin&#123; height:0px; width:40px; border-top:2px solid black; margin:15px;&#125;.lineWidth .thick&#123; height:0px; width:40px; border-top:6px solid black; margin:15px;&#125;.lineWidth .thin.active&#123; transform: scale(1.2); &#125;.lineWidth .thick.active&#123; transform: scale(1.2);&#125; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208var canvas=document.getElementById('canvas');var context=canvas.getContext('2d');var using=false;var lastPoint=&#123; x:undefined, y:undefined&#125;/*画板逻辑 */autoSetSize(canvas);listenToUser(canvas);/********///画笔、橡皮擦按钮替换var eraserEnabled=false;pen.onclick=function()&#123; eraserEnabled=false; pen.classList.add('active'); eraser.classList.remove('active'); &#125;eraser.onclick=function()&#123; eraserEnabled=true; eraser.classList.add('active'); pen.classList.remove('active');&#125; //颜色替换并高亮red.onclick=function()&#123; context.fillStyle ="red"; context.strokeStyle="red"; red.classList.add('active'); yellow.classList.remove('active'); blue.classList.remove('active'); black.classList.remove('active');&#125;yellow.onclick=function()&#123; context.fillStyle ="yellow"; context.strokeStyle="yellow"; yellow.classList.add('active'); red.classList.remove('active'); blue.classList.remove('active'); black.classList.remove('active');&#125;blue.onclick=function()&#123; context.fillStyle ="blue"; context.strokeStyle="blue"; blue.classList.add('active'); yellow.classList.remove('active'); red.classList.remove('active'); black.classList.remove('active');&#125;black.onclick=function()&#123; context.fillStyle ="black"; context.strokeStyle="black"; black.classList.add('active'); yellow.classList.remove('active'); blue.classList.remove('active'); red.classList.remove('active');&#125;/********/thin.onclick=function()&#123; thin.classList.add('active'); thick.classList.remove('active'); context.lineWidth=2;&#125;thick.onclick=function()&#123; thick.classList.add('active'); thin.classList.remove('active'); context.lineWidth=4;&#125;clear.onclick=function()&#123; context.clearRect(0,0,canvas.clientWidth,canvas.clientHeight); &#125;download.onclick = function()&#123; var url = canvas.toDataURL('image/png'); var a = document.createElement('a'); document.body.appendChild(a); a.href=url; a.download='my drawing'; a.click();&#125;/********//********//********///drawLinefunction drawLine(x1,y1,x2,y2)&#123; context.beginPath(); context.moveTo(x1,y1); context.lineTo(x2,y2); context.stroke(); context.closePath(); &#125;//drawCirfunction drawCir(x,y)&#123;context.beginPath()context.arc(x,y,0.1,0,Math.PI*2);context.fill();&#125;//重置canvas画板宽高function setCanvasSize()&#123; var pageWidth=document.documentElement.clientWidth; var pageHeight=document.documentElement.clientHeight; canvas.width = pageWidth; canvas.height = pageHeight; &#125;//自动设置canvas画板宽高function autoSetSize()&#123; setCanvasSize(); window.onresize =function()&#123; setCanvasSize(); &#125; &#125;function preventBehavior(e) &#123; e.preventDefault()&#125; document.addEventListener("touchmove", preventBehavior, false) function listenToUser()&#123; //特性检测 if(document.body.ontouchstart!== undefined )&#123; //是触屏设备 canvas.ontouchstart =function(aaa)&#123; var x=aaa.touches[0].clientX; var y=aaa.touches[0].clientY; using=true; lastPoint=&#123;x:x,y:y&#125;; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); &#125; &#125; // canvas.ontouchmove = function(aaa)&#123; var x=aaa.touches[0].clientX; var y=aaa.touches[0].clientY; var newPoint=&#123;x:x,y:y&#125; if(using)&#123; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); drawLine(lastPoint.x,lastPoint.y,newPoint.x,newPoint.y) lastPoint=newPoint; &#125; &#125; &#125; canvas.ontouchend = function(aaa)&#123; using=false; &#125; &#125;else&#123; //不是触屏设备 canvas.onmousedown=function(aaa)&#123; var x=aaa.clientX; var y=aaa.clientY; using=true; lastPoint=&#123;x:x,y:y&#125;; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); &#125; &#125; //鼠标移动监听 canvas.onmousemove=function(aaa)&#123; var x=aaa.clientX; var y=aaa.clientY; var newPoint=&#123;x:x,y:y&#125; if(using)&#123; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); drawLine(lastPoint.x,lastPoint.y,newPoint.x,newPoint.y) lastPoint=newPoint; &#125; &#125; &#125; //鼠标松开监听 canvas.onmouseup=function(aaa)&#123; using=false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JS</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F08%2F23%2Fcss%2F</url>
    <content type="text"><![CDATA[css,即层叠样式表,可以为网页添加样式. 应用方式外部样式表 通过&lt;link&gt;引入&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; 通过@import引入,注意末尾加;号,CSS语法,只能在CSS内使用. 1234&lt;style&gt;@import url("index.css");@import "index.css";&lt;/style&gt; 媒体查询(响应式) 12345678&lt;style&gt;@media (min-width: 801px) &#123; body &#123; margin: 0 auto; width: 800px; &#125;&#125;&lt;/style&gt; 内部样式表将css放到&lt;style&gt;元素中,一般放到文档的&lt;&gt;中. 12345678910111213141516&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;style&gt;h1 &#123; background: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;AMD yes!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 内联样式&lt;p style=&quot;background: red; font-size: 20px;&quot;&gt;AMD yes!&lt;p&gt; CSS选择器 基本选择器 名称 含义 * 通用选择器 匹配任何元素 E 标签选择器 匹配所有使用E标签的元素 .info class选择器 匹配所有class属性中包含info的元素 #footer id选择器 匹配所有id属性等于footer的元素 组合选择器 名称 含义 E,F 多元素选择器 同时匹配所有E元素或F元素 E F 后代选择器 匹配所有属于E元素后代的F元素 E&gt;F 子元素选择器 匹配所有E元素的直接子元素 E+F 直接相邻元素选择器 匹配E元素后的直接相邻元素 E~F 兄弟元素选择器 匹配E元素后的所有兄弟元素 属性选择器 含义 E[attr] 匹配所有具有attr属性的E元素 E[attr=val] 匹配所有attr属性等于val的E元素 E[attr~=val] 匹配所有attr属性具有多个空格分隔的值,其中一个等于val的E元素 E[attr =val] E[attr*=val] 匹配所有attr属性中包含val的E元素 E[attr^=val] 匹配所有attr属性中以val开头的E元素 E[attr$=val] 匹配所有attr属性中以val结尾的E元素 伪类 含义 E:first-child 匹配父元素的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经按下没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得焦点的E元素 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio或者checkbox元素 E:root 匹配文档的根元素,对于html文档,就是html元素 E:nth-child(n) 匹配其父元素的第n个子元素,第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素,第一个编号为1 E:nth-of-type 与nth-child类似,但仅匹配使用同种标签的元素 E:nth-last-child 与nth-last-child类似,但仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个元素 E:first-of-type 匹配父元素下使用同种标签的第一个子元素 E:last-of-type 匹配父元素下使用同种标签的最后一个子元素 E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素,注意,文本节点也被看做子元素 E:not(s) 匹配不符合当前选择器的任何元素 E:target 代表一个唯一的页面元素(目标元素)，其id 与当前URL片段匹配 伪元素 含义 E::first-line 匹配E元素的第一行 E::first-letter 匹配E元素的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 E::selection 匹配用户当前选中的元素 伪元素必须要有content 选择器优先级!important优先级最高(由于IE不支持!important，所以也可以利用它区分不同的浏览器。)行内样式(写在style标签里的样式) &gt; id样式 &gt; class样式 &gt; 标签名样式 CSS基本样式div（块级元素）：高度是由内部文档流元素高度的总和决定的。文档流：文档内元素的流动方向，内联元素是从左往右，块级元素是从上往下span（内联元素）：高度是由其中文字高度决定的，内联元素设置width和height是无效的，上下的margin和padding也无效，要将它们设为display:inline-block才有效。 常见块级元素: div h1~h6 p hr form ul ol li table td tr th dl dt dd pre 常见内联元素: em strong span a br img button input label select textarea code script 尽量不写height和width，这两个属性会引出很多bug，要宽高的时候可以用padding，但img最好先写width，因为可以先占位，因为引用图片时浏览器不知道图片大小，所有等图片下载完成，它后面的元素又要重新排位置，若先写好width，则不用重排，知道height也可以先写好height。另外span元素设置padding的时候要将它设为display:inline-block，因为内联元素不能设置宽高，inline-block具有inline的同行特性，也具有block的高度特性。对于display:inline(内联元素)的元素，设置width/height/上下margin和padding都是无效的 inline-block inline-block 之间空隙 inline-block 之间有空格、Tab、换行符。 给父元素设置 font-size: 0，在 inline-block 元素上重新设置 font-size。 inline-block 导致父元素增高若干像素 给 inline-block 元素设置 vertical-align: top 通用解决办法 不要设置 inline-block，使用 float 或 flex。 浏览器默认样式浏览器对某些元素设置有默认样式，如 h1, ul, li 等。 常见处理方式 Normalize.css CSS Reset 简单去除 1234* &#123; margin: 0; padding: 0;&#125; CSS常见样式边框border1234567891011.box &#123; border-width: 1px; border-color: red; border-style: solid; border-bottom: none;//下边框消失 border-radius: 50%;//圆角&#125;//简写.box2 &#123; border: 1px red solid;&#125; 内边距paddingpadding: 10px 20px 30px;//按照上右下左,即顺时针,缺哪个补哪个,缺左边,按20px补上. 外边距marginmargin可以合写,可以分开.可以是数值,可以是百分比(相对于父元素).还可以是负值.有外边距合并问题 display 块级: block,list-item,table 行内: inline,inline-table,inline-blockfont123456789body&#123; font: 12px/1.5 Arial;&#125;p&#123; line-height: 1.5;//行高是字体的1.5倍 font-size: 14px;//字体大小 font-family: Arial;//字体 font-weight: bold;//文字粗度,粗体&#125; Chrome默认字体是16px,最小字体是12px. 文本 text-aglin: 文本对齐方式,left,right,center,justify text-ident: 文案第一行缩进距离 text-decoration: 划线,none,underline,line-through,overline text-transform: 改变文字大小写,none,uppercase,lowercase,captialize word-spacing: 可以改变字(单词)之间的标准间距 letter-spacing: 字母之间的间隔单行文本溢出加…12345.box&gt;h3 &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 颜色 单词: red,blue,black,pink,yellow 十六进制: #000000(黑),#fff(白),#eee(淡灰),#ccc(灰色),#666(深灰) rgb:rgb(255,255,255)白色,rgba(0,0,0,0.5)透明度为0.5的黑色单位px rpx em rem的区别 px是像素pixel，相对于屏幕分辨率的单位 em是相对单位，相对于当前对象内的文本尺寸。如果没有设置，则相对浏览器默认尺寸16px，1em=16px。为了简化，可以将body里font-size=62.5%，那么em就是16px*62%=10px。1em=10px em特点：em值不固定，会继承父元素字体大小 rem是root em。只相对于html根元素 rpx是微信小程序的方案1px=2rpx vh vw: 相对单位,1vw为屏幕宽度的1%background background-color: transparent 透明背景;颜色值;半透明浮层的背景颜色建议使用 rgba() 而不是 opacity 设置透明度。 background-image: url(../images/bg.png);// 属性用于给元素设置一张或多张背景图。 background-repeat 控制背景图片的重复方式。no-repeat不重复;repeat-x水平方向重复;repeat-y 垂直方向重复; background-position 设置背景图的位置。x y;x% y%;[top|center|bottom][left|center|right] background-size 设定背景图片的大小。IE9 以下不支持;cover缩放背景图片以完全覆盖背景区，可能背景图片部分看不见;contain缩放背景图片以完全装入背景区，可能背景区部分空白。 background-clip: 设置元素背景区域覆盖的范围.border-box 覆盖至边框的最外围;padding-box 覆盖至内边距的最外围;content-box 仅覆盖元素内容区域 缩写: 123.avatar &#123; background: #fff url(avatar.svg) no-repeat left center;&#125; 隐藏or透明 opacity: 0;//透明度为0,整体 visibility: hidden;//和opacity: 0;类似 display: none;//消失,不占用位置 background-color: rgba(0,0,0,0.2);//只是背景色透明box-shadowbox-shadow: -16px 0 16px 1px rgba(102,102,102,0.4);第一个值代表阴影左右偏移，正数往右，负数往左第二个值代表上下偏移，正往下，负往上第三个值越大，模糊面积越大越淡第四个值取正值时，阴影扩大，取负值时，阴影收缩line-height line-height: 2;//本身字体高度的2倍 line-height: 200%;//父元素高度的2倍,父元素没写行高就是默认16px*2=32px height=line-height;//垂直居中单行文本盒模型 标准盒模型: border-box,即padding,border不在width,height范围内 IE盒模型: content-box,即width=content尺寸+padding+border css3可以设置box-sizing: content-box;//标准盒模型 positionCSS position属性用于指定一个元素在文档中的定位方式。语法: static | relative | absolute | sticky | fixed static: 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 relative: 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table元素无效. absolute: 不为元素预留空间，通过指定元素相对于最近的非 static 定位父元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 fixed: 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 sticky: 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。相对定位(relative)相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。绝对定位(absolute,fixed)相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）。固定定位(fixed)固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。粘性定位(sticky)粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。#one { position: sticky; top: 10px; }在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。(理解为大于10px时,属于相对定位,可以在页面滚动时随之滚动,当距视口10px时,固定了,就像粘在那里了)浮动float: left;//向左浮动 浮动元素并不是完全意义上的脱离文档流,至少普通元素里的文本可以发现,行内元素也可以发现 设置浮动会让块级元素从左到右或从右到左排列. 块级元素设置浮动呈现inline-block特性,不再撑开父元素,宽度也会收缩 行内元素设置浮动呈现inline-block特性,可以设置宽高.清除浮动问题: 对后续元素位置产生影响 父容器高度计算出现问题通用解决方案12345678910父元素加clearfix.clearfix::after&#123; content:''; display: block; clear: both;&#125;.clearfix&#123; *zoom: 1 //兼容IE6,7&#125; BFC(块级格式化上下文)决定了其子元素将如何定位,以及其他元素的关系和相互作用在正常流中的盒子要么属于块级格式化上下文,要么属于内联格式化上下文 BFC的产生 根元素 float不为none; position: absolute/fixed; display: inline-block/flex/inline-flex/table-cell; overflow不为visible; 特性 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠.每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。(如果有多个浮动盒,因为是浮动盒,所以后面的有新的BFC,会挨着前面的从左到右排列) BFC的区域不会与float box重叠。(不跟外面的浮动盒重叠,会把浮动盒挤到一边) BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算(包裹浮动元素).作用 阻止margin合并,因为BFC与外界隔离,自己的margin也就不再合并. contain float(包裹浮动元素). 边距合并合并场景 相邻元素合并,间距为二者中较大值 父子合并 自己合并取消合并 加border,padding BFC CSS布局单栏布局方式: 定宽+水平居中 123456&lt;style&gt;.layout&#123;max-width: 100px;margin: 0 auto;&#125;&lt;/style&gt; 通栏的话再加一层div,单独给div设置背景色即可 双列布局固定margin+浮动元素先设置浮动,再设置普通元素,最后清除浮动 flex布局display:flex一个容器 设置了display:flex属性,就定义了一个flex容器.它的直接子元素会接受这个flex环境. flex-direction1234.container&#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 设置子元素在父容器中的位置1.row默认值,水平从左到右2.row-reverse,从右到左3.column,垂直从上到下4.column-reverse,垂直从下到上 flex-wrap设置换行 1234.container&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125;依次为:不换行,换行,换行切颠倒顺序 flex-flowflex-direction和flex-wrap的缩写,默认值row nowrapflex-flow: &lt;&#39;flex-direction&#39;&gt; || &lt;&#39;flex-wrap&#39;&gt; justify-content设置子元素在水平方向上的对齐方式 1234.container&#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125;分别是水平靠左,水平靠右,水平居中,均匀分布,均匀分布且两端保留子元素间距一半(空间包裹) align-items设置子元素在垂直方向上的对齐方式 1234.container&#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125;分别是垂直靠上,垂直靠下,垂直居中,垂直基线对齐,垂直方向拉伸 align-content设置子元素整体内容的在垂直方向上的对齐方式 1234.container&#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125;分别是整体靠上,整体靠下,整体居中,整体垂直均匀排列,整体均匀分布且垂直两端保留间距一半空间,整体垂直拉伸占用剩余空间 用在子元素上的属性order默认情况下flex order会按照书写顺序排列,可以通过order属性改变,数值小的在前面,也可以是负数. 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow.item {flex-grow: 1}按比例瓜分父元素剩余的空间,1即分一份.不写默认是0 flex-basis基准宽度 flex-shrink按比例吸收超出的空间.不写默认是1 flex flex-grow,flex-shrink,flex-basis的缩写 123.item&#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt; || &lt;''flex-basis'&gt;]&#125; aglin-self单独修改自身的属性 Grid布局父元素Grid container的属性display将元素定义为gird container,并为其建立新的网格格式化上下文 1234.container&#123; display: grid | inline-grid | subgrid;&#125;分别是生成一个块级网格;一行网格;如果本身是gird-item,可从父元素获取行列大小 gird-template-columns和gird-template-rows设置网格的列和行 1234.container&#123; gird-template-columns: 40px 50px auto 50px 40px; grid-template-rows: 25% 100px auto;&#125; 简化写法’’ 1234567.container&#123; gird-template-columns: repeat(3, 20px [col-start]) 5%;&#125;等价于.container&#123; gird-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;&#125; “fr”单位允许将轨道大小设置为网格容器自由空间的一部分.如下代码会将每个gird item设置为gird container宽度的三分之一 123.container&#123; .grid-template-columns: 1fr 1fr 1fr;&#125; gird-template-areas — 使用gird-area属性设置的网络区域的名称 . — 点号代表一个空网格单元 none — 没有定义网格单元1234567891011121314151617181920.item-a &#123; grid-area: header;&#125;.item-b &#123; grid-area: main;&#125;.item-c &#123; grid-area: sidebar;&#125;.item-d &#123; grid-area: footer;&#125;.container &#123; grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: "header header header header" "main main . sidebar" "footer footer footer footer";&#125; 这将创建一个四列宽三行高的网格。 整个第一行将由 header 区域组成。 中间一行将由两个 main 区域、一个空单元格和一个 sidebar 区域组成。 最后一行是footer区域组成。 居中水平居中 块级元素水平居中 12margin-left:auto;margin-right:auto; 内联元素水平居中，给它们的父元素加上 1text-align:center; 若不是内联元素想让它居中，可加display:inline-block，加了之后一般还要加下面这句，不然可能会有bug（下面可能会空出一行） 1vertical-align: top; 让导航栏横过来，并在同一行里均匀分布给ul加css1234ul&#123; display:flex; justyfy-content:space-between;&#125; 去掉li的float:left去掉ul的clearfix 垂直居中 若父元素没有写height，则直接在父元素写1padding: 10px 0; 子元素就可以居中，所以尽量避免父亲高度确定 让一个元素在父级元素中绝对居中方法一：给父级元素加:1position:relative; //若父级元素是body可以不用加 再给自己加： 12345678div&#123; position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: auto;&#125; 方法二：（若不兼容IE，工作中只要用这一种方法即可，最简单，Chrome，移动端都可以用）给父元素加： 123display: flex; //让它变成一个弹性盒justify-content: center; //水平居中align-items: center; //垂直居中 table自带居中（兼容IE）1234567891011121314151617181920&lt;html&gt;&lt;style&gt;.parent&#123; border: 1px solid red; height: 600px;&#125;.child&#123; border: 1px solid green;&#125;&lt;/style&gt;&lt;body&gt;&lt;table class="parent"&gt; &lt;tr&gt; &lt;td class="child"&gt; 文字 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 文字会居中 用div假扮table（兼容IE） 123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;style&gt;div.table&#123; display: table; border: 1px solid red; height: 600px;&#125;div.tr&#123; display: table-row; border: 1px solid green;&#125;div.td&#123; display: table-cell; border: 1px solid blue; vertical-align: middle;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="table"&gt; &lt;div class="tr"&gt; &lt;div class="td"&gt; 文字 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用100%高度的before和after 12345678910111213141516171819202122232425.parent&#123; border: 3px solid red; height: 600px; text-align: center;&#125;.child&#123; border: 3px solid black; display: inline-block; width: 300px; vertical-align: middle;&#125;.parent:before&#123; content:''; display: inline-block; height: 100%; vertical-align: middle;&#125;.parent:after&#123; content:''; display: inline-block; height: 100%; vertical-align: middle;&#125; 绝对定位加上margin-top: -自身height的50% 123456789101112131415161718192021222324252627&lt;html&gt;&lt;style&gt;.parent&#123; height: 600px; border: 1px solid red; position: relative;&#125;.child&#123; border: 1px solid green; width: 300px; position: absolute; top: 50%; left: 50%; margin-left: -150px; height: 20px; margin-top: -10px; text-align: center;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="parent"&gt; &lt;div class="child"&gt; 文字 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用transform子元素加{top:50%,transform:translate(-50%)} 媒体查询(响应式)12345678910111213141516&lt;style&gt; /* 屏幕宽度为300px-325px时的css样式 */ @media(min-width: 300px) and (max-width: 325px)&#123; body&#123; background: red; &#125; &#125; /* 屏幕宽度小于450px时的css样式 */ @media(max-width: 450px)&#123; body&#123; background: black; &#125; &#125; /* 这样前面那个就没用了，被覆盖了 */&lt;/style&gt; 一般不用第一个方法，直接引用一个手机版的css即可 &lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width:768px)&quot; href=&quot;mobile.css&quot;&gt;在屏幕宽度小于768px时，就会渲染这个css，要把这个引用写在main.css之后，把main.css覆盖。并加上meta:vp&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; CSS动画transition(过渡)transition的作用在于指定状态变化所需要的时间. 123div&#123; transition: 1s;&#125; 指定属性可以指定transition使用的属性,比如只适用于heighttransition: 1s height; delay(延迟)transition: 1s height,1s 1s width;width在一秒之后在开始变化,也就是延迟一秒.delay可以指定动画发生的顺序,使得不同transition可以连在一起,形成不同效果. transition-timing-function(缓动函数)transition的状态变化速度,默认不是匀速的,而是逐渐放慢的,这叫做ease.transition: 1s ease;除了ease,其他模式还有: linear: 匀速 ease-in: 加速 ease-out: 减速 cubic-bezier: 自定义速度模式(可以在cubic-bezier.com里设置)语法简写:transition: 1s 1s height ease;完整写法:1234transition-property: height;transition-duration: 1s;transition-delay: 1s;transition-timing-function: ease; 注意 transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态，什么none到block之类的是不行的 transition是一次性的，不能重复发生，除非一再触发animation(动画)使用animation首先需要定义动画过程,即关键帧12345@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 写动画帧里的css记得加;号.定义关键帧后可以给DOM元素绑定动画,和事件比较像.加infinite代表无限次,改成数字就是循环多少次. 123div:hover &#123; animation: 1s rainbow infinite;&#125; animation-fill-mode动画结束后,会立即跳到结束状态,如果想让动画保持在结束状态,需要使用animation-fill-mode属性. 123div:hover&#123; animation: 1s rainbow forwards;&#125; animation-fill-mode的属性: none: 默认值,回到动画未开始的状态. forwards: 让动画停留在结束状态 backwards: 让动画回到第一帧的状态 both: animation-direction轮流应用forwards和backwards规则animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变顺序默认情况是，animation-direction等于normal.此外，还可以等于取alternate(先从前往后再从后往前)、reverse(从后往前)、alternate-reverse等值.123div:hover &#123; animation: 1s rainbow 3 normal;&#125; animation-play-state有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态，如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。 12345678div &#123; animation: spin 1s linear infinite; animation-play-state: paused;&#125;div:hover &#123; animation-play-state: running;&#125; 语法简写: 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 完整: 123456789div:hover &#123; animation-name: rainbow; animation-duration: 1s; animation-timing-function: linear; animation-delay: 1s; animation-fill-mode:forwards; animation-direction: normal; animation-iteration-count: 3;&#125; 0%可以用from代表，100%可以用to代表，因此上面的代码等同于下面的形式 12345@keyframes rainbow &#123; from &#123; background: #c00 &#125; 50% &#123; background: orange &#125; to &#123; background: yellowgreen &#125;&#125; steps(分步过渡)浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡。 123div:hover &#123; animation: 1s rainbow infinite steps(10);&#125; 歌词效果12345678910111213141516171819202122232425262728293031323334&lt;style&gt;@keyframes moving &#123; from &#123; width: 0; &#125;&#125;.line &#123; position: relative;&#125;p &#123; width: 600px; font-size: 40px; white-space: nowrap; overflow: hidden; position: absolute; top: 0; z-index: 2;&#125;p:nth-child(1) &#123; color: red; animation: moving 20s&#125;p:nth-child(2) &#123; z-index: -1; color: #666;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="line"&gt; &lt;p&gt;To my days change my ways为生活我试着不断改变&lt;/p&gt; &lt;p&gt;This sudden end to my days这生命的终点突如其来&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 打字机效果12345678910111213141516171819202122&lt;style&gt;@keyframes typing &#123;from &#123; width: 0 &#125; &#125;@keyframes blink-caret &#123; 50% &#123; border-clolr: transparent &#125; &#125;h1 &#123; border-right: 0.1em solid; color: #fff; width: 352px; height: 30px; white-space: nowrap; overflow: hidden; animation: typing 5s steps(11, end),//变11次变成最终状态 blink-caret .5s infinite alternate;&#125;body &#123; background: #000; height: 100vh;&#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;躺在你的学校操场看星空&lt;/h1&gt;&lt;/body&gt; transform(变形)transform属性主要包括rotate(旋转),skew(扭曲),scale(缩放),translate(移动),matrix(矩阵变形)transform ： none | [ ]*transform中使用多个属性时却需要有空格隔开，可用于内联(inline)元素和块级(block)元素 rotate(旋转)可以通过rotate使元素旋转一定的度数transform: rotate(30deg)//顺时针旋转30度 旋转之后元素仍占据原来位置，实际上所有的transform都是这样，缩放、位移等都不会改变元素占据的位置 元素旋转的的基点默认是中心，可以通过transform-origin属性改变transform:rotate(30deg); transform-origin: 0% 0%;transform-origin的取值可以是: top, bottom, left, right, center 百分数translate(位移)transform: translateY(100px)//Y轴位移100px;scale(缩放)scale(x,y): 使元素水平方向和垂直方向同时缩放transform: translate(3)//相同的比例缩放两个方向skew(扭曲)通过skew使元素扭曲一定的度数transform:skew(10deg, 20deg);//x轴扭曲10度,y轴扭曲20度3D元素需要设置需要设置perspective来激活3D效果 transform: perspective( 600px ); perspective: 600px;perspective属性的值决定了3D效果的强烈程度，可以认为是观察者到页面的距离。越大距离越远，视觉上的3D效果就会相应的减弱。3D变形方法rotateX( angle )rotateY( angle )rotateZ( angle )translateZ( tz )scaleZ( sz )translateX()方法使元素延X轴移动，translateZ()使元素延Z轴（在3D空间中方向从前到后）移动。正值使元素离观察者更近，负值使元素变远。]]></content>
      <categories>
        <category>css</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F08%2F22%2FjQuery%2F</url>
    <content type="text"><![CDATA[选择器 jQuery基本选择器 解释 $(‘*‘) 匹配所有元素 $(‘#id’) id选择器 $(‘.class’) 类选择器 $(‘element’) 标签选择器 组合选择器 解释 $(‘E,F’) 多元素选择器，同时匹配E和F $(‘E F’) 后代选择器,用空格分隔,匹配E元素所有后代 $(‘E&gt;F’) 子元素选择器,匹配E元素所有直接子元素 $(‘E+F’) 直接相邻元素,匹配E元素之后的相邻的同级元素F $(‘E~F’) 普通相邻元素(弟弟选择器),匹配E元素之后的同级元素F(无论是否直接相邻) $(‘class1.class2’) 匹配类名中既含有class1又含有class2的元素 基本过滤选择器 解释 $(‘E:first’) 所有E中的第一个 $(‘E:last’) 所有E中的最后一个 $(‘E:not(selector)’) 按照selector过滤E $(‘E:even’) 所有E中index是偶数 $(‘E:odd’) 所有E中index是奇数 $(‘E:eq(n)’) 所有E中index为n的元素 $(‘E:gt(n)’) 所有E中index大于n的元素 $(‘E:lt(n)’) 所有E中index小于n的元素 $(‘header’) 选择h1~h6元素 $(‘div:animated’) 选择正在执行动画效果的元素 内容过滤器 解释 $(‘E:contains(value)’) 内容包含value的元素 $(‘E:empty’) 内容为空的元素 $(‘E:has(F)’) 子元素中有F的元素,$(‘div:has(a)’):包含a标签的div $(‘E:parent’) 父元素是E的元素 可视化选择器 解释 $(‘E:hidden’) 所有被隐藏的E $(‘E:visible’) 所有可见的E 属性过滤选择器 解释 $(‘E[attr]’) 含有属性attr的E $(‘E[attr=value]’) 属性attr=value的E $(‘E[attr !=value]’) 属性attr！=value的E $(‘E[attr ^=value]’) 属性attr以value开头的E $(‘E[attr $=value]’) 属性attr以value结尾的E $(‘E[attr *=value]’) 属性attr包含value的E $(‘E[attr][attr*value]’) 可以连用 子元素过滤器 解释 $(‘E:nth-child(n)’) E的第n个子节点 $(‘E:nth-child(3n+1)’) E的第3n+1个子节点 $(‘E:nth-child(even)’) E的index为偶数的子节点 $(‘E:nth-child(odd)’) E的index为奇数的子节点 $(‘E:first-child’) 所有E的第一个子节点 $(‘E:last-child’) 所有E的最后一个子节点 $(‘E:only-child’) 只有唯一子节点的E的子节点 表单元素选择器 解释 $(‘E:type’) 特定类型的input $(‘:checked’) 被选中的checkbox或者radio $(‘option:selected’) 被选中的option 其他查找相关元素的方法.eq(index), .get([index])$(&#39;div&#39;).eq(3) //获取所有div中第4个jQuery对象$(&#39;div&#39;)[2] 或者 $(&#39;div&#39;).get(2) //获取第三个的DOM对象get()不写参数把所有对象转为DOM对象返回 兄弟元素获取 选择器 解释 .next([selector]) 没有写selcetor,返回所有后面的兄弟元素.写了就返回满足条件的 .prev([selector]) 和上面相反,获取前面的兄弟元素 .nextAll([selector]) 获取所有后面的兄弟元素 .prevAll([selector]) 获取所有前面的兄弟元素 .siblings([selector]) 获取所有前后邻居的元素 父子元素获取 选择器 解释 .parent([selector]) 获取父元素,可选筛选器 .parents([selector]) 获取祖先元素,可选筛选器 .children([selector]) 获取子元素,可选筛选器 .find([selector]) 查找符合选择器的后代 筛选当前结果集 选择器 解释 .first() 获取当前结果集第一个对象 .last() 获取当前结果集最后一个对象 .filter(slector), .filter(function(index)) 筛选当前结果集符合条件的对象 .not(selector), .not(function(index)) 从当前结果集中移除指定元素 .is(selector), is(function(index)), is(dom/jqObj) 判断结果集中的元素，是否为一个选择器，DOM元素，或者jQuery对象，如果这些元素至少一个匹配给定的参数，那么返回true .has(seletor), has(dom) 筛选匹配结果集中符合条件的后代元素 jQueryDOM操作创建元素将DOM传入$方法即可返回一个jQuery对象var obj = $(&#39;&lt;div class=&quot;test&quot;&gt;&lt;p&gt;&lt;span&gt;Done&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&#39;) 添加元素 方法 解释 示例 .append(content[,content]) / .append(function(index,html)) 可以添加多个内容,DOM对象,字符串,jQuery对象 $(‘p’).append($newdiv); $(‘p’).append($(‘strong’)); $(‘p’).append(document.createTextNode(‘hello’)) .appendTo(target) 把对象插入到目标target尾部,可以是selector,DOM对象,字符串,元素集合,jQuery对象(最后一个孩子) $(‘h2’).appendTo($(‘.container’)); $(‘&lt;p&gt;Test&lt;/p&gt;’).appendTo(‘.inner’) .prepend(content[,content]) / .prepend(function(index, html)) 向头部追加内容,内容添加到最前面(第一个孩子) $(‘.inner’).prepend(‘&lt;p&gt;Test&lt;/p&gt;’) .prependTo(Target) 把对象插入到目标头部 $(‘&lt;p&gt;Test&lt;/p&gt;’).prependTo(‘.inner’) .before([content][,content]) / .before(function) 在对象前面(不是头部,而是外面,和对象并列同级)插入内容(放到前面做邻居) $(‘.inner’).before(‘&lt;p&gt;Test&lt;/p&gt;’); $(‘.container’).before($(‘h2’)); $( “p” ).before( document.createTextNode( “Hello” ) ) .insertBefore(target) 把对象插入到target之前(不是头部,是同级)(做邻居) $(‘h2’).insertBefore($(‘.container)) .after([content][,content]) / .after(function（index）) 和before相反，在对象后面(不是尾部，而是外面，和对象并列同级)插入内容，参数和append类似 $( “.inner” ).after( “&lt;p&gt;Test&lt;/p&gt;” ); $( “p” ).after( document.createTextNode( “Hello” ) ); .insertAfter(target) 和insertBefore相反，把对象插入到target之后（同样不是尾部，是同级） $( “&lt;p&gt;Test&lt;/p&gt;” ).insertAfter( “.inner” ); $( “p” ).insertAfter( “#foo” ); 删除元素 方法 解释 示例 .remove([selector]) 删除被选元素及其子元素 $(‘.div’).remove() .empty() 清空被选元素内所有子元素 $(‘body’).empty() .detach() .detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。 $(‘.div’).detach() 包裹元素 方法 解释 示例 .wrap(wrapElement) / .wrap(function(index)) 为每个对象包裹一层HTML结构，可以是selector, element, HTML string, jQuery object $( “.inner” ).wrap( “&lt;div class=’new’&gt;&lt;/div&gt;” ) .wrapAll(wrappingElement) 把所有匹配对象包裹在同一个html结构里 $(‘.inner’).wrapAll(‘&lt;div class=”new”&gt;&lt;/div&gt;) .wrapInner(wrapingElement) 为每个匹配的对象包裹一层HTML结构 $(‘.inner’).wrapInner(‘&lt;div class=”new”&gt;&lt;/div&gt;) .unwrap 把DOM元素外的壳去掉 $(‘p’).unwrap() html([string])$(&#39;div&#39;).html()$(&#39;div&#39;).html(&#39;123&#39;)这是一个读写两用的方法,用于获取修改元素的innerHTML 没有传递参数的时候,返回元素的innerHTML 当传递一个string参数时,修改元素的innerHTML为参数值 text()和html方法类似，操作的是DOM的innerText值 jQuery属性操作属性相关.val([value])这是一个读写双用的方法,用来处理input的value值,当方法没有参数时返回input的value值.当传递一个参数时,方法修改input的value值为参数值. 12$('.input').val()$('.input').val('newValue') .attr().attr(attributeName)获取元素特定属性的值var title = $(&#39;em&#39;).attr(&#39;title&#39;) .attr(attributeName,value)/.attr(attributesJson)/.attr(attributeName,funtion(index,attr))为元素属性赋值$( &quot;#greatphoto&quot; ).attr( &quot;alt&quot;, &quot;Beijing&quot; ) .removeAttr()为匹配的元素集合中的每个元素移除一个属性$(&#39;div&#39;).removeAttr(&#39;id&#39;) .prop()/.removeProp()这两个方法是用来操作元素的property的 CSS相关.css().css(propertyName) / .css(propertyNames)获取元素style特定property的值 12345678var color = $( this ).css( "background-color" )var styleProps = $( this ).css([ "width", "height", "color", "background-color"]) .css(propertyName,value)/.css(propertyName,function(index,value))/ .css(propertiesJson)设置元素style特定property的值 123456789101112$( "div.example" ).css( "width", function( index ) &#123; return index * 50;&#125;)$( this ).css( "width", "+=200" )$( this ).css( "background-color", "yellow" )$( this ).css(&#123; "background-color": "yellow", "font-weight": "bolder"&#125;) .addClass(className) / .addClass(function(index,currentClass))为元素添加class，不是覆盖原class，是追加，也不会检查重复 12345$( "p" ).addClass( "myClass yourClass" )$( "ul li" ).addClass(function( index ) &#123; return "item-" + index;&#125;) .removeClass([className])/.removeClass(function(index,class))移除元素单个/多个/所有class 12345$( "p" ).removeClass( "myClass yourClass" );$( "li:last" ).removeClass(function() &#123; return $( this ).prev().attr( "class" );&#125;) .hasClass(className)检查元素是否包含某个class，返回true/false 1$( "#mydiv" ).hasClass( "foo" ) .toggleClass(className)toggle是切换的意思，方法用于切换，switch是个bool类型值 123456789&lt;div class="tumble"&gt;Some text.&lt;/div&gt;//第一次执行 $( "div.tumble" ).toggleClass( "bounce" )&lt;div class="tumble bounce"&gt;Some text.&lt;/div&gt;//第二次执行$( "div.tumble" ).toggleClass( "bounce" )&lt;div class="tumble"&gt;Some text.&lt;/div&gt; jQuery常用方法.each(fnction(index, Element))遍历一个jQuery对象,为每个匹配元素执行一个函数 12345$('li').each(function(index)&#123; console.log(index + ':' + $(this).text())&#125;)//回调函数返回的是DOM对象,所以this需要加$变成jQuery对象才能使用.text()方法//否则使用this.innerText方法 jQuery.each(collection, callback(indexInArray, valueOfElement))一个通用迭代函数,可以迭代对象和数组.数组和类数组对象通过长度属性来迭代数字索引,从0到length-1.其他对象通过其属性名进行迭代.上面jQuery可以用$替代,即$.each(). 1234567var obj = &#123; "fla" : "infla", "duh" : " no duh"&#125;$.each(obj, function(key, value)&#123; console.log(key + ":" + value)&#125; .map(callback(index, domElement))通过一个函数匹配当前集合中的每个元素,返回一个包含新的jQuery对象 123$('.div').map(function(i, ele)&#123; return this.id&#125;) jQuery.extend([deep,]target[,ovject1][,objectN]) 当提供两个或多个对象给$.extend(),对象的所有属性都添加到目标对象(target参数). 如果只有一个参数提供给$.extend(),这意味着目标参数被省略,在这种情况下,jQuery对象本身默认为目标对象.这样我们可以在jQuery的命名空间下添加新功能.var obj = $.extend({}, object1, object2)object1,object2会被添加到{}中 如果第一个对象的属性本身是一个数组或对象,那它将完全用第二个对象相同的key重写一个属性.这些值不会被合并.如果true作为第一个参数,那么会在对象上进行递归的合并. .clone([withDataAndEvents]).clone()方法深度复制所有匹配的元素集合,包括所有匹配元素,匹配元素的下级,文字节点.$(&#39;.hello&#39;).clone().appendTo(&#39;.Goodbye&#39;) .index()/.index(selector)/.index(element)从给定集合中查找特定元素index 没参数返回第一个元素index 如果参数是DOM对象或jQuery对象,则返回参数在集合中的index 如果参数是选择器,返回第一个匹配元素的index,没有找到返回-1 12var listItem = $('.bar')console.log('Index:' + $('li').index( listItem )) .ready(handler)当DOM加载完毕,执行.下面两种等价 $(document).ready(handler) $(handler) jQuery事件.on(events[,selector][,data],handler(eventObject)) events: 一个或多个空格分隔的事件类型和可选空间 selector: 一个选择器字符串,用于过滤被选中的元素中能触发事件的后代元素.如果选择器是null或者忽略,那么被选中的元素总能触发事件 data: 当一个事件被触发,要传递给事件处理函数的event.data handler(eventObject): 事件被触发时,执行的函数. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class="box"&gt;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;input id="ipt" type="text"&gt;&lt;button id="btn"&gt;添加&lt;/button&gt;&lt;div id="wrap"&gt;&lt;/div&gt;&lt;script&gt;$('.box li').on('click',function()&#123; console.log(1) var str = $(this).text() $('#wrap').text(str)&#125;)//等同于$('.box&gt;ul&gt;li').click(function()&#123; console.log(2) var str = $(this).text() $('#wrap').text(str)&#125;)//下面新增的元素是没有绑定事件的$('btn').on('click',function()&#123; var value = $('#ipt').val() $('.box&gt;li').append('&lt;li&gt;' + value + '&lt;/li&gt;')&#125;)//可以用事件代理$('.box ul').on('click','li',function()&#123; var str = $(this).text() $('#wrap').text(Str)&#125;)//上面代码换成原生js代码document.querySelector('.box ul').addEventListener('click',function(e)&#123; if(e.target.tagName.toLowerCase() === 'li')&#123; //do something &#125;&#125;)&lt;/script&gt; .one(events[,selector][,data],handler(eventObject))同on，绑定事件，但只执行一次 .off(events[,selector][,handler])移除一个事件处理函数$(&#39;.box li&#39;).off(&#39;click&#39;) .trigger(eventType[,extraParameters])根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为 1234$('#foo').on('click', function() &#123; console.log($(this).text())&#125;);$('#foo').trigger('click') 其他事件blur([[data],fn])change([[data],fn])click([[data],fn])dblclick([[data],fn])error([[data],fn])1.8-focus([[data],fn])focusin([data],fn)focusout([data],fn)keydown([[data],fn])keypress([[data],fn])keyup([[data],fn])mousedown([[data],fn])mouseenter([[data],fn])mouseleave([[data],fn])mousemove([[data],fn])mouseout([[data],fn])mouseover([[data],fn])mouseup([[data],fn])resize([[data],fn])scroll([[data],fn])select([[data],fn])submit([[data],fn]) 事件对象eve.currentTargeteve.dataeve.delegateTarget1.7+eve.isDefaultPrevented()eve.isImmediatePropag…()eve.isPropagationStopped()eve.namespaceeve.pageXeve.pageYeve.preventDefault()eve.relatedTargeteve.resulteve.stopImmediatePro…()eve.stopPropagation()eve.targeteve.timeStampeve.typeeve.which jQuery动画基础.hide([duration][,easting][,fn]) duration: 三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) easing: 用来指定切换效果，默认是”swing”，可用参数”linear” fn: 在动画完成时执行的函数，每个元素执行一次。用于隐藏元素,没有参数等同于直接设置display属性 12$('.target').hide()//等同于$('.target').css('display','none') 123$('#book').hide(300, 'linear', function() &#123; console.log('Animation complete.') &#125;) .show([duration][,easing][,fn])显示元素,用法类似hide .toggle([duration][,easing][,fn])事件处理套件也有一个名为.toggle()方法。哪一个被调用取决于传递的参数的设置用来切换元素的隐藏、显示，类似于toggleClass，用法和show、hide类似 渐变.fadeIn( [duration ] [, easing ] [, complete ] )渐入效果 .fadeOut( [duration ] [, easing ] [, complete ] )渐出效果 .fadeTo( duration, opacity [, easing ] [, complete ] )调整匹配元素的透明度，方法通过匹配元素的不透明度做动画效果 123$('#book').fadeTo('slow', 0.5, function() &#123; // Animation complete.&#125;) fadeToggle([speed,[easing],[fn]])通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数。这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。 1234$("p").fadeToggle("fast",function()&#123; alert("Animation Done.") &#125;) //用200毫秒快速将段落淡入，之后弹出一个对话框 slideDown([speed],[easing],[fn]) 下拉动画.这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式显示出来。 slideUp([speed,[easing],[fn]]) 上浮动画,向上隐藏,在隐藏完成后可选地触发一个回调函数。 slideToggle([speed],[easing],[fn]) 上下切换 动画队列 因为动画是异步,所以将动画执行函数放入回调函数中,等动画执行完毕再执行其他的. 但是这样写会形成回调地狱.又因为存在动画队列,可以按代码二方法执行会有同样效果. 12345678910111213141516171819202122 $box.hide(1000, function()&#123; $box.show(1000, function()&#123; $box.fadeOut('slow',function()&#123; $box.fadeIn('slow',function()&#123; $box.slideUp(function()&#123; $box.slideDown(function()&#123; console.log('动画执行完毕') &#125;) &#125;) &#125;) &#125;) &#125;)&#125;)//等价于$box.hide(1000) .show(1000) .fadeOut() .fadeIn() .slideUp() .slideDown(function()&#123; console.log('真的完毕了') &#125;) 自定义动画animate(params,[speed],[easing],[fn])这个函数的关键在于指定动画形式及结果样式属性对象。这个对象中每个属性都表示一个可以变化的样式属性（如“height”、“top”或“opacity”）。注意：所有指定的属性必须用驼峰形式，比如用marginLeft代替margin-left. params:一组包含作为动画属性和终值的样式属性和及其值的集合 speed:三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) easing:要使用的擦除效果的名称(需要插件支持).默认jQuery提供”linear” 和 “swing”. fn:在动画完成时执行的函数，每个元素执行一次。 .finish停止当前动画，并清除动画队列中所有未完成的动画,最终展示动画队列最后一帧的最终状态 .stop( [clearQueue] [,jumpToEnd])停止当前正在运行的动画 AJAXjQuery.ajax(url,[settings])jQuery底层AJAX实现.$.ajax()返回其创建的XMLHttpRequest对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。最简单的情况下，$.ajax()可以不带任何参数直接使用。注意，所有的选项都可以通过$.ajaxSetup()函数来全局设置。回调函数如果要处理$.ajax()得到的数据，则需要使用回调函数。beforeSend、error、dataFilter、success、complete。 beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。 error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter 在请求成功之后调用。传入返回的数据以及”dataType“参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。 success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。 12345678910111213141516$.ajax(&#123; url: 'test.com', type: 'GET', datatype: json, data: &#123; name: 'tom', age: '12' &#125;, &lt;!-- success: function(result)&#123; console.log(result) &#125; --&gt;&#125;).done(function(result)&#123; console.log(result)&#125;).fail(function(jqXHR, textStatus)&#123; consloe.log(textStatus)&#125;) url: 一个用来包含发送请求的URL字符串。settings: AJAX请求设置。所有选项都是可选的。 seting中的设置 async：默认设置下，所有请求均为异步请求（也就是说这是默认设置为 true ）。如果需要发送同步请求，请将此选项设置为 false beforeSend：请求发送前的回调函数，用来修改请求发送前jqXHR对象，此功能用来设置自定义 HTTP 头信息该jqXHR和设置对象作为参数传递 cache：如果设置为 false ，浏览器将不缓存此页面。注意: 设置cache为 false将在 HEAD和GET请求中正常工作。它的工作原理是在GET请求参数中附加”_={timestamp}” context：这个对象用于设置Ajax相关回调函数的上下文。默认情况下，这个上下文是一个ajax请求使用的参数设置对象 data：发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后面，POST请求作为表单数据 headers：一个额外的{键:值}对映射到请求一起发送。此设置会在beforeSend 函数调用之前被设置;因此，请求头中的设置值，会被beforeSend 函数内的设置覆盖 type: 请求方式 (“POST” 或 “GET”)，默认为 “GET”。注意:其它HTTP请求方法，如PUT和DELETE也可以使用，但仅部分浏览器支持。 jQuery.get( [settings] ) / jQuery.post( [settings ] )这两个方法专门用来处理get和post请求 123$.get('test.html',function(data)&#123; $('.result').html(data)&#125;) jQuery.getJSON(url[,data][,success(data,textStatus,jqXHR)])使用一个HTTP GET请求从服务器加载JSON编码的数据范例 123456789101112$.getJSON('ajax/test.json', function(data) &#123; var items = []; $.each(data, function(key, val) &#123; items.push('&lt;li id="' + key + '"&gt;' + val + '&lt;/li&gt;'); &#125;); $('&lt;ul/&gt;', &#123; 'class': 'my-new-list', html: items.join('') &#125;).appendTo('body');&#125;); .load(url[,data][,complete(responseText,textStatus,XMLHttpRequest)])从服务器载入数据并且将返回的HTML代码并插入至匹配的元素中$(&#39;#result&#39;).load(&#39;ajax/test.html&#39;) .serialize() / serializeArray()将用作提交的表单元素的值编译成字符串，方法没有参数，使用标准的 URL-encoded 符号上建立一个文本字符串.它可以对一个代表一组表单元素的 jQuery 对象进行操作，比如&lt;input&gt;, &lt;textarea&gt;, 和 &lt;select&gt;: 123456789101112131415161718192021222324&lt;form id="holder"&gt; &lt;input type="text" name="a" value="1"/&gt; &lt;div&gt; &lt;input type="text" name="b" value="2" id="b" /&gt; &lt;/div&gt; &lt;input type="hidden" name="c" value="3" id="c" /&gt; &lt;div&gt; &lt;input type="checkbox" name="f" value="8" checked="true"/&gt; &lt;input type="checkbox" name="f" value="9" checked="true"/&gt; &lt;/div&gt;&lt;/form&gt;$("#holder").serialize(); //a=1&amp;b=2&amp;c=3&amp;f=8&amp;f=9$("#holder").serializeArray();/* [ &#123;name: 'a', value: '1'&#125;, &#123;name: 'b', value: '2'&#125;, &#123;name: 'c', value: '3'&#125;, &#123;name: 'f', value: '8'&#125;, &#123;name: 'f', value: '9'&#125; ]*/ serialize和serializeArray都是针对JQuery对象(选中的form元素)进行操作，只是返回值格式不同而已。这里特别要注意：这2个API只能操作form，如果将holder改成div，会发现不起作用 jsonp123456789function getBooks()&#123; $.ajax(&#123; type:'get', url:'http://test.com/bookservice.php', dataType:'jsonp', jsonp:'callback', jsonpCallback:'displayBooks' &#125;);&#125; 当然使用jsonp会在一定程度上造成安全性问题，如果请求的站点不是信任站点，那么可能会在返回的方法调用中包含一些恶意代码。所以尽量向信任的站点发送请求。另外xss也经常会利用jsonp向站点注入恶意代码。]]></content>
      <categories>
        <category>JS</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础]]></title>
    <url>%2F2019%2F08%2F21%2FHTTP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ajaxajax是一种技术方案，核心依赖浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出http请求与接受响应。 如何与后端交互 form表单提交.缺点会跳转，无后台反馈 ajax websocket 实现方法 XMLHttpRequest对象 fetch 范例123456789101112var xhr = new XMLHttpRequst() xhr.open("get", "/xxx.com") xhr.onreadystate = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; //成功 console.log(xhr.responseText) &#125; else &#123; console.log("服务器异常") &#125; &#125; xhr.send() API123456789101112131. let request = new XMLHttpRequest();2. request.open('GET','/xxx') //初始化request3. request.send() //发送请求4. request.onreadystatechange //监听请求状态的变化5. request.readyState === 1 //request.open()已经完成6. request.readyState === 2 //request.send()已经完成7. request.readyState === 3 //request.responseText正在下载5. request.readyState === 4 //响应完成6. request.status //HTTP状态码7. var string = request.responseText //响应的内容8. var value = JSON.parse(request.responseText) //把符合JSON语法的字符串转换成JS，解析响应返回的内容9. value.node //若value是对象，这就是对象里内容10. value.node.name //对象里的name的值 post形式需要将数据放入到send中 跨域同源策略同协议，域名，端口 实现跨域的方法JSONPJSON with padding 通过script标签加载数据的方式获取数据当做js代码来执行。jsonp需要对应接口的后端配合才可以实现。 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; "ip": "8.8.8.8"&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 必考面试题：JSONP为什么不支持POST请求答：因为JSONP是通过动态创建script的方法进行的，而script只能发送get请求不能发送post请求。 jquery的写法123456789$.ajax(&#123; url:"http://jack.com:8002/pay", dataType: "jsonp", success:function (response) &#123; if(response === 'success')&#123; amount.innerText = amount.innerText-1; &#125; &#125; &#125;) axios写法1234567this.$http = axios;this.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'handleCallback'&#125;).then((res) =&gt; &#123; console.log(res); &#125;) CORS跨域资源共享，是一种ajax跨域请求资源的方式。写法就是普通的ajax写法.不过在浏览器请求上加点处理.而且是浏览器自动处理的.当使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给请求加一个请求头:Origin。后台进行处理，如果确定接受请求，则在返回结果中加响应头：Access-Control-Allow-Origin。浏览器判断该响应头中是否包含Origin的值，如果有，浏览器会处理响应，就可以拿到响应数据。 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; postMessage A页面 1234567891011121314151617181920componentDidMount() &#123; window.addEventListener('message', this.receiveMessage, false) const iframeImg = this.iframe.contentWindow iframeImg.onload = function() &#123; iframeImg.postMessage('message', 'http://www.blogoog.com:8088') &#125;&#125;receiveMessage = (event) =&gt;&#123; const origin = event.origin || event.originalEvent.origin const thisData = JSON.parse(event.data) const imgUrl = Object.values(thisData) this.setState(&#123; imgUrl &#125;) setTimeout(() =&gt;&#123; this.closeIframe(); message.success('上传成功') &#125;,1000) if (origin !== 'http://www.blogoog.com:80881) &#123; window.location.hash = '#/exception/404' &#125;&#125; 123&lt; iframe className = &#123; styles.iframeWrap &#125;src="http://www.blogoog.com:8088" name="imgIframe" frameBorder="0" scrolling="auto" ref=&#123;dom =&gt; &#123;this.iframe = dom &#125;&#125;&gt;您的浏览器不支持iframe&lt;/iframe&gt; A页面使用的语法 window.postMessage()otherWindow.postMessage(message, targetOrigin, [transfer]) otherWindow：其他窗口的一个引用（在这里我使用了iframe的contentWindow属性） message：将要发送到其他window的数据（可以不受限制的将数据对象安全的传送给目标窗口而无需自己序列化，原因是因为采用了结构化克隆算法） targetOrigin：接收信息的URL（在这里我当然填的B页面的URL） transfer：可选参数 window.addEventListener(‘message’, receiveMessage, false)target.addEventListener(type, listener, options) type：表示监听事件类型的字符串 listener：当所监听的事件类型触发时，会通知的一个对象或者一个函数 potions：可选参数（在此我用false，表示在listener被调用之后不会自动移除） receiveMessage = (event) =&gt; {} event.data：从另一个window传递过来的对象（包含传递过来的所有信息） event.origin||event.originalEvent.origin：window.postMessage()发送消息的目标URL event.source：对发送消息的窗口对象的引用注意点！！！ 在页面内嵌入iframe页面的情况下，需要等到页面内的iframe页面，也就是B页面加载完成之后，才能进行postMessage跨域通信 event.origin中的origin不能保证是该窗口的当前origin或者未来origin，因为postMessage被调用后，可能会被导航到不同的位置，所以需要做个异常情况判断处理origin !== &#39;http://www.blogoog.com:8088&#39; B页面 123456789101112created() &#123; window.addEventListener&#123;"message", this.receiveMessage, false) &#125;,receiveMessage(e) &#123; if (e origin === 'http://www.blogoog.com:8080' || e.origin === 'http://www.blogoog.com:8088') &#123; this.sendBtnShow = true this.originSource = e.origin this.magicBuildData = JSON.parse(e.data) &#125;, sendMsg() &#123; top.postMessage(JSON.stringify(data), 'http://www.blogoog.com:8000') &#125; B页面使用到的语法top.postMessage(&#39;data&#39;, &#39;http://www.blogoog.com:8000&#39;)参考上面A页面的语法为什么用top而不用window下面再讲window.addEventListener(&#39;message&#39;, receiveMessage, false)参考上面A页面的语法receiveMessage = (event) =&gt; {}参考上面A页面的语法 window.postMessage()中的window到底是啥？始终是你需要通信的目标窗口 A页面中：A页面向B页面发送跨域信息，window就是在A页面中嵌入的iframe指向的B页面的window，即：iframe.contentWindow B页面中：B页面想A页面发送跨域信息，window就是A页面的window，在这里因为B页面时嵌入到A页面中的，对于B页面来讲，window就是top或者parent需要特别注意的坑 一定要等A页面嵌入的B页面加载完成之后，再进行postMessage跨域通信 一定要对origin做判断，去掉不是来自我们目标窗口的origin，防止来自其他origin的攻击 着重注意window.postMessage()中window的用法，明确目标窗口的window websocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type="text"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; 后端node 123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); 标签iframeHTML内联框架元素&lt;iframe&gt; 表示嵌套的browsing context。它能够将另一个HTML页面嵌入到当前页面中。 123&lt;iframe src="https://mdn-samples.mozilla.org/snippets/html/iframe-simple-contents.html" title="iframe example 1" width="400" height="300"&gt; &lt;p&gt;Your browser does not support iframes.&lt;/p&gt;&lt;/iframe&gt; canvas标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API source定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; command定义命令按钮，比如单选按钮、复选框或按钮 figure规定独立的流内容（图像、图表、照片、代码等等） nav导航 section定义文档中的节（section、区段） HTTP报文HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，描述报文的内容及含义，后面跟着可选的数据部分 URI和URLURI：统一资源标识符URL：统一资源定位符 报文组成 对报文进行描述的起始行 —— start line 包含属性的首部块 —— header 可选的包含数据的主体部分 —— body报文语法 请求报文：向web服务器请求一个动作 1234&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 响应报文把请求结果返回给客户端 1234&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; 状态码服务器和浏览器之间的约定 分类:100-199 用于指定客户端应相应的某些动作。200-299 用于表示请求成功。300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。400-499 用于指出客户端的错误。500-599 用于支持服务器错误。 状态码 状态信息 解释 100 Continue 初始请求已接受,继续发送 101 switching Protocols 服务器遵从客户请求转换到另一种协议 200 OK 请求成功 201 Created 服务器已经创建了文档,Location头给出了他的URL 202 Accepted 已接受请求,但处理尚未完成 203 Non-Authoritative Information 文档已正常返回但一些应答头可能不正确,因为使用的是文档的拷贝 204 No Content 服务器接到请求已经处理完毕,但浏览器页面不会刷新 205 Reset Content 没有新内容,但浏览器应该重置它所显示的内容,用来强制浏览器清除表单输入内容. 206 Partial Content 客户发送了一个带有Range头的GET请求,服务器完成了它 300 Multiple Choices 客户请求的文档可以在多个位置找到,这些位置已经在返回的文档中列出.如果服务器要提出优先选择,则应该在Location应答头指明 301 Moved Permanently 永久重定向,请求的网页已经永久移动到新位置 302 Found 临时重定向,POST方法的重定向在未询问用户的情况下就会变成GET 303 See Other 类似301/302,不同之处在于,原来的请求是POST,现在是GET 304 Not Modified 自从上次请求后,网页未被修改过 305 Use Proxy 使用代理服务器 307 Temporary Redirect 临时重定向，不同之处,把POST转为GET 400 Bad Request 请求出现语法错误 401 Unauthorized 用户未授权,需要用户验证 403 Forbidden 服务器已经理解请求,但是拒绝执行 404 Not Found 服务器找不到请求的网页 405 Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权 408 Request Timeout 请求超时 500 Internal Server Error 服务器遇到错误,无法完成请求 503 Service Unavailable 由于临时的服务器维护或过载,暂时无法处理请求 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。 HTTP请求方法 GET请求服务器发送某个资源 HEAD与GET方法类似,但是在服务器的响应中没有资源的内容,只有资源的一些基本信息,主要用于 在不获取资源的情况下获取信息(类型,大小等) 通过状态码看资源是否存在 通过查看首部,测试资源是否被修改 PUT和GET从服务器获取资源相反,PUT用于向服务器写入资源.PUT的语义就是让服务器用请求的主体部分创建一个请求URL命名的文档.如果存在就替换 POSTPOST用于向服务器发送数据,通常用来支持HTML的表单(input,select,textarea),表单中的数据会被发送到服务器 TRACE客户端发送一个请求,这个请求可能会穿过防火墙,代理,网关,和一些其他应用程序,每个中间节点都可以修改HTTP请求,TRACE方法允许客户端在最终请求发往服务器的时候,看看他变成了什么样子TRACE请求会在目的服务器端发送一个”闭环”诊断,行程最后一站服务器会弹回一条TRACE响应,并在响应主题中携带他收到的原始请求报文 DELETE用于要求服务器删除请求的URL,和PUT一样,服务器可能不支持 OPTIONS用于请求服务器告知其支持的各种功能 浏览器缓存缓存是一种保存资源副本并在下次请求时直接使用该副本的技术.HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，分为两大类(强制缓存，协商缓存)http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。 cache-controlcache-control通常用于优化网页性能,适当使用可减少重复读取相同内容可以在服务端setHeader设置cache-control可以设置让该字段存于缓存中,浏览器下次访问时不发起请求,直接从缓存中读取该资源 ETagETag通常用于优化网页性能,适当使用可减少重复读取相同内容可通过服务端setHeader设置etag为相应的字段的md5值浏览器访问时,request.headers会带有if-none-match属性(为上述MD5),若不等于则说明服务器上的该资源与本地存储的该资源不相同,需要重新从服务器加载;若相等则说明两者资源相同,则直接从本地缓存获取.后端应设置statusCode=304.与cache-control不同的是:etag始终都要发请求和收响应,而cache-control不发请求. cookie存储信息到浏览器，可以用js设置，也可以在服务器端通过set-cookie让浏览器种下cookie，存在于响应头里。每次请求都会带上cookie，最大容量4k用途：记录用户名 设置cookie时的参数： path: cookie影响到的路径，匹配该路径才发送cookie expires和maxAge:告诉浏览器cookie多久过期不设置就会产生session cookie，当关闭浏览器，cookie就被清除 secure: 为true时，在http无效，在https生效 httpOnly: 浏览器不允许通过js修改cookie session用来保存状态。当用户输入用户名密码提交给服务器后，服务器验证通过后创建session用于记录用户信息，session可保存在服务器，也可以保存在数据库 创建session后，会把关联的session_id通过是set-cookie添加到响应头 浏览器加载页面发现有set-cookie，就把这个cookie种到指定域名下 下次刷新页面，发送的请求带上cookie，服务器接受后根据session_id来识别用户 localStorage 本地存储，永不过期，除非手动js删除。5M大小。 不参与网络传输 一般用于性能优化 sessionstorage与localstorage类似,属于本地存储与上面的session无关.但是关闭浏览器失效. 浏览器缓存机制通俗语言版(自我理解)12Cache-Control: max-age=300；ETag:W/"e-cbxLFQW5zapn79tQwb/g6Q" 浏览器第一次请求a.jpg这张图片,服务器发回一张图片,并且附送一个ETag(相当于一个用于验证的文件).浏览器把这张图片和ETag缓存到本地.如果在300秒内,浏览器又请求这张图片,那么直接从缓存中读取这张图.如果超过300秒,浏览器发现已经过了时间了,就重新向服务器发请求,并且附带之前给的ETag.服务器拿着当前文件计算后的ETag和浏览器发回的ETag比较,如果一样,说明图片没换,发回一个响应头(不包含图片,304,表示文件没修改,还能用).如果不一样,就把新的文件和新的ETag发回去.另外还有Last-Modified/If-Modified-Since.和ETag功能类似.因为服务器可能不止一个,文件存储在不同的服务器,那就给请求文件上附带上Last-Modified声明,请求时带上If-Modified-Since,表明服务器上一次修改这个文件的时间,拿来和服务器上记录的最后修改时间对比.如果修改时间比较新,说明被动过,发回一个新文件.如果时间比较旧,说明不用换,发回304,使用缓存即可. 严谨说法浏览器缓存控制分为强缓存和协商缓存，协商缓存必须配合强缓存使用。 首先浏览器第一次跟服务器请求一个资源，服务器在返回这个资源和response header的同时，会根据开发者要求或者浏览器默认，在response的header加上相关字段的http response header。 一、当浏览器对某个资源的请求命中了强缓存时，利用[Expires]或者[Cache-Control]这两个http response header实现。 [Expires]：描述的是一个绝对时间，根据的是客户端时间。用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT 下次浏览器再次请求同一资源时。先从客户端缓存中寻找，找到这个资源后，拿出它的[Expires]跟当前的请求时间比较。如果请求时间在[Expires]指定的失效时间之前，就能命中缓存，这样就不用再次到服务器上去缓存一遍，节省了资源。但是正因为是绝对时间，如果客户端时间被随意更改下，这个机制就失效了。所以我们需要[Cache-Control]。 [Cache-Control]：描述的是一个相对时间，在进行缓存命中时，都是利用浏览器时间判断。 这两个header可以只启用一个，也可以同时启用，当response header中，[Expires]和[Cache-Control]同时存在时，[Cache-Control]优先级高于[Expires]。 二、当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中。如果命中，则还是从客户端缓存中加载。协商缓存利用的是[Last-Modified，If-Modified-Since]和[ETag、If-None-Match]这两对Header来管理的。 [Last-Modified]：原理和上面的[expires]相同，区别是它是根据服务器时间返回的header来判断缓存是否存在。但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况（这种问题也不容易被定位），这时候我们需要[ETag、If-None-Match]。 [ETag、If-None-Match]：原理与上相同，区别是浏览器跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同。 [ETag、If-None-Match]这么厉害我们为什么还需要[Last-Modified、If-Modified-Since]呢？有一个例子就是分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样） [Last-Modified，If-Modified-Since]和[ETag、If-None-Match]一般都是同时启用。 HTTPS原理HTTP+SSL/TLS， 即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL，用于安全的HTTP数据传输。 加密算法： 对称加密有流式、分组两种，加密和解密都是使用的同一个密钥。 非对称加密加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的 哈希算法将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 数字签名签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 简单通信流程概括来说，整个简化的加密通信的流程就是： 小明访问网站，网站将自己的证书给到小明（其实是给到浏览器，小明不会有感知） 浏览器从证书中拿到网站的公钥A 浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给网站（其实是有协商的过程，这里为了便于理解先简化） 网站通过私钥解密，拿到对称密钥B 浏览器、网站 之后的数据通信，都用密钥B进行加密 存在的问题证书可能存在的问题证书是伪造的：压根不是CA颁发的证书被篡改过：比如将XX网站的公钥给替换了解决方法: 数字签名和摘要“摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，在通过CA的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名.这段数字签名只有CA的公钥才能够解密。]]></content>
      <categories>
        <category>HTML</category>
        <category>HTTP基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础]]></title>
    <url>%2F2019%2F08%2F19%2FJS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据类型number, boolean, string, undefined, null, object, symbol原始类型，number, string, boolean。指保存在栈内存里的简单数据段引用类型，对象。又可分为狭义的对象，数组，函数，正则。指保存在堆内存中的对象 typeof undefined 输出 undefinedtypeof null 输出 object 运算符 &amp;&amp; (And) || (or) ! (not) == 和 ===，前者先转化类型，后进行判断，后者比较类型和值 三元运算符condition ? true case : false case boolean值false: undefined null 0 NaN 空字符串 JS函数函数会声明前置 1234foo() //hellofunction foo()&#123; return "hello"&#125; 函数表达式不会 1234fn()//报错var fn() = fnction()&#123; return "hello" &#125; js对象查看所有属性12var objects = &#123; p: 1&#125;Object.keys(obj) 删除命令delete object.p 循环判断 12345678910switch(判断语句）&#123; case 条件： 输出; break; case 条件: 输出; break; default: 输出&#125; while循环 12345while(expression)&#123; statement&#125;//如果expression为true，执行，//循环继续执行直到判断不成立。 do-while循环 1234do&#123; statement;&#125;while(expression);//先执行，够判断 for循环 break退出本次循环continue跳过本次循环执行下次循环 深拷贝123456789var obj = &#123; name: 'hunger', age: 3, friends: ['aa', 'bb', 'cc']&#125;var obj2 = JSON.parse(JSON.stringify(obj))obj.age = 4console.log(obj2.age) 缺点: JSON 不支持函数、引用、undefined、RegExp、Date…… jQuery.extend()jQuery.extend( [deep], target, object1 [, objectN ] )其中 deep 为 Boolean 类型，如果是true，则进行深拷贝。 123456789101112var target = &#123;a: 1, b: 1&#125;;var copy1 = &#123;a: 2, b: 2, c: &#123;ca: 21, cb: 22, cc: 23&#125;&#125;;var copy2 = &#123;c: &#123;ca: 31, cb: 32, cd: 34&#125;&#125;;var result = $.extend(true, target, copy1, copy2); // 进行深拷贝console.log(target); // &#123;a: 2, b: 2, c: &#123;ca: 31, cb: 32, cc: 23, cd: 34&#125;&#125; var target = &#123;a: 1, b: 1&#125;;var copy1 = &#123;a: 2, b: 2, c: &#123;ca: 21, cb: 22, cc: 23&#125;&#125;;var copy2 = &#123;c: &#123;ca: 31, cb: 32, cd: 34&#125;&#125;;var result = $.extend(target, copy1, copy2); // 不进行深拷贝console.log(target); // &#123;a: 1, b: 1, c: &#123;ca: 31, cb: 32, cd:34&#125;&#125; 递归深拷贝123456789101112131415function clone(object)&#123; var object2 if(! (object instanceof Object) )&#123; return object &#125;else if(object instanceof Array)&#123; object2 = [] &#125;else if(object instanceof Object)&#123; object2 = &#123;&#125; &#125; //你也可以把 Array Function Object 都当做 Object 来看待 for(let key in object)&#123; object2[key] = clone(object[key]) &#125; return object2&#125; 函数作用域（scope）作用域（scope）指的是变量存在的范围。在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数。 递归一个函数可以指向并调用自身。调用自身的函数我们称之为递归函数。在某种意义上说，递归近似于循环。两者都重复执行相同的代码，并且两者都需要一个终止条件（避免无限循环或者无限递归）。 作用域链 函数在执行的过程中，先从自己内部找变量 如果找不到，再从创建当前函数所在的作用域去找, 以此往上 注意找的是变量的当前的状态闭包它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。一般情况下使用闭包主要是为了 封装数据 暂存数据 面试官想听的版本:什么是闭包?由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。闭包解决了什么问题?由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。闭包的应用?闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。 123456789101112function car()&#123; var speed = 0 function fn()&#123; speed++ console.log(speed) &#125; return fn&#125;var speedUp = car()speedUp() //1speedUp() //2 如果没有这个闭包，函数执行后，里面speed变量就会被清理掉。但我们声明了fn这个函数，并把它返回出来赋值给新的变量speedup。因为speedup是全局变量，是一直存在的，故这个fn函数就一直存在，speed变量也不会被清理 范例如下代码输出多少？如果想输出3，那如何改造代码？ 1234567var fnArr = [];for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i &#125;;&#125;console.log( fnArr[3]() ) // 10 我的理解: fnArr[i]声明的匿名函数的作用域是全局作用域,先遍历,并未执行,遍历结束开始执行,fnArr结果是10个匿名函数f(),全局作用域下0-9的fnArr[i]已经变成10了 原理解析：for循环每次执行，都把function(){ return i} 这个函数赋值给fnArr[i]，但这个函数不执行。因为fnArr[3] =function(){ return i};故当我们调用fnArr3 时，相当于function(){ return i};这个函数立刻执行，这时for循环已经完成，i已经变成了10。故输出10 如果要输出3，需要如下改造 123456789var fnArr = []for (var i = 0; i &lt; 10; i ++) &#123; (function(i)&#123; fnArr[i] = function()&#123; return i &#125; &#125;)(i)//这样保证遍历i时,函数会立即执行(生成10个闭包,暂存数据)&#125;console.log( fnArr[3]() ) // 3 我的理解: 从0开始遍历,(function(0){ fnArr[0] = function(){return i}})(0),(function(1){ fnArr[1] = function(){return i}})(1)(function(2){ fnArr[2] = function(){return i}})(2),(function(3){ fnArr[3] = function(){return i}})(3),传入3,最内部的function找i的变量,一直找到上一层,返回3. 123456789var fnArr = []for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = (function(j)&#123; return function()&#123; return j &#125; &#125;)(i)//生成10个闭包,暂存数据,j换成i也是一样&#125;console.log( fnArr[3]() ) // 3 如下代码输出什么? 123456for(var i=0; i&lt;5; i++)&#123; setTimeout(function()&#123; console.log('delayer:' + i ) &#125;, 0)&#125;//输出5个5 如何连续输出 0,1,2,3,4 12345678for(var i=0; i&lt;5; i++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log('delayer:' + j ) &#125;, 0) &#125;)(i)&#125;//0,1,2,3,4 字符串12str.charAt(0) //获取第一个字符str.charCodeAt(0) //获取字符对应的ASC码 字符串截取 1234var str= "hello"str.substr(1,3) //第一个开始，第二个长度str.substring(1,3) //第一个开始，第二个结束str.slice(1,3) //同上，允许负参 查找 1234str.search("he") //返回下标strong.indexOf("he") //同上str.replace("he", "you") //替换str.match("he") //匹配 大小写 12str.toUpperCase()str.toLowerCase() //本身不变化 去除首尾空格 1str.trim() //返回新数组,不影响原数组 split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。找到分隔符后，将其从字符串中删除，并将子字符串的数组返回。如果没有找到或者省略了分隔符，则该数组包含一个由整个字符串组成的元素。如果分隔符为空字符串，则将str转换为字符数组。如果分隔符出现在字符串的开始或结尾，或两者都分开，分别以空字符串开头，结尾或两者开始和结束。因此，如果字符串仅由一个分隔符实例组成，则该数组由两个空字符串组成。示例: 12345678910111213var str = 'The quick brown fox jumps over the lazy dog.';var words = str.split(' ');console.log(words[3]);// expected output: "fox"var chars = str.split('');console.log(chars[8]);// expected output: "k"var strCopy = str.split();console.log(strCopy);// expected output: Array ["The quick brown fox jumps over the lazy dog."] 当字符串为空时，split（）返回一个包含一个空字符串的数组，而不是一个空数组，如果字符串和分隔符都是空字符串，则返回一个空数组。 123var str = ''var strEm = str.split();console.log(strEm); //返回[""] 数组12345678910111213141516171819202122232425262728293031323334353637arr.push(newelement) //末尾新增一个arr.pop() //末尾踢出一个字arr.shift() //开头拿出一个arr.unshift() //开头新增一个arr.splice(index,替换几个，替换内容) //原数组变//返回由删除元素组成的新数组arr.slice(start，end) //原数组不变arr.join("-") //将数组变成字符串并用-连接arr.reverse() //数组反转arr.sort(v1-v2) //没有参数按顺序排列，但是会出现10,11,7,8,9排列，//有参数设置比较函数，函数结果v1-v2如果大于0，两两替换位置。否则，不变a.concat(array) //拼接，返回数组a和array的集合。原数组不变Array.isArray(obj) //判断传入的obj是不是数组a.indexof(2) //判断数组a中是否含有2,返回其索引a.forEach(fn(element,index,arr)&#123;&#125;)//forEach里是一个回调函数，有三个参数，分别是当前元素，索引值，整个数组a.map(fn(element)&#123;&#125;)//与forEach类似，返回新数组，原数组不变,是被一个函数处理后的数组.//而forEach会修改原数组a.every(fn(element,index,arr)&#123;&#125;)//every是所有函数返回true才会返回true，遇到false终止，并返回falsea.some(fn(element,index,arr)&#123;&#125;)//some是存在一个返回true时就终止返回truea.filter(fn(element)&#123;&#125;)//返回新数组，回调函数用于逻辑判断，为true则把当前元素加到返回的数组中//为false则不加a.reduce(fn(v1,v2),value)//将数组元素合成一个值，从索引值最小开始。value表示初始值a.abs(x) //返回x的绝对值Array.from(new Set(a)) //数组去重 数组去重双重循环去重 1234567891011121314function unique(arr)&#123; for(var i=0; i&lt;arr.length; i++)&#123; for(var j=i+1; j&lt;arr.length; j++&gt;&#123; if(arr[i]===arr[j])&#123; //如果数组第一个等于第二个 arr.splice(j,1) //就干掉第j个 j-- //因为数组arr被干掉一个,长度-1,j就相应的-1 &#125; &#125;) &#125; return arr&#125; new Set去重 123456789function unique(arr)&#123; return Array.from(new Set(arr))&#125;//简化版function unique(arr) &#123; return [...new Set(arr)];&#125;//精简版var unique = (arr) =&gt; [...new Set(arr)] Math四舍五入 12Math.round(0.5)//1Math.round(-1.5)//-1 绝对值 1Math.abs(-1) //1 最大值Math.max() 函数返回一组数中的最大值。参数是value1, value2, ...是一组数值 123Math.max(10, 20,30); Math.max.call(null,10, 20,30); Math.max.apply(null,[10, 20,30]); 1234floor返回小于参数值的最大整数.向下取整Math.floor(-3.2) //-4ceil返回大于参数值的最小参数，向上取整Math.ceil(-3.2) //-3 parseInt(值，进制) 123parseInt(string,radix)//将一个字符串 string 转换为 radix 进制的整数，// radix 为介于2-36之间的数。 parseInt()可以将字符串转为数字，也可以将数字取整。向下取整。如果第一个字符是数字会解析直到遇到非数字结束，如果第一个字符不是数字或者符号（如：+、-）就返回NaN。带自动净化功能；带自动截断小数功能，且取整，不四舍五入。radix: 基数,也就是进制.介于2-36之间,超出都是返回NaN.radix不写默认是十进制.如果传入字符串是0x开头,默认是16进制.如果是0开头,默认8进制.任何数的0进制都是它本身.高于进制位能表示的最大值数返回NaN.比如说2的一进制返回NaN,因为一进制只能用1表示,2作为一进制来表示明显不对. 几次方 12Math.pow(x,y) //返回 x 的 y 次幂的值。Math.pow(2,2) //4 平方根 12Math.sqrt(4) // 2Math.sqrt(-4) //NaN random 12Math.random()//返回0-1之间的伪随机数.0≦x&lt;1 Date123Date.now() //获取1970年至今的毫秒数Date.parse() //解析日期字符串，返回距离1970年的毫秒数Date.parse("2011-01-11") //13234436600000 1234567new Date() //使用Date构造函数创建一个Date实例，//不传时间就返回当前时间的字符串var str = "2019-01-11"new Date(str) //Fri Jan 11 2019 08:00:00 GMT+0800 (香港标准时间)//获取的是东八区8点的时间，因为格林尼治时间伦敦是0点 get方法 12345678getDate() //日getDay() //星期几，周日是0，周一是1getFullyear() //返回四位的年份getMouth() //返回月份，一月是0，腊月是11getHours() //小时（0-23）getMinutes() // 返回分钟getSenconds() // 秒getMilliseconds() // 毫秒(0-999) set方法类似于get方法，是设置时间 异步和回调event loop(事件循环)经典案例: 12345for(var i=0; i&lt;5; i++)&#123; setTimeout(fucntion timer()&#123; comsole.log(i) &#125;,1000)&#125; 我的理解:开始循环遍历.(同步代码)i=0.创建一个console.log(i).放到队列里，并不执行.i=1.创建一个console.log(i).放到队列里，并不执行，直到i=5.依次创建了5个console.log(i)因为setTimeout是异步,所以必须等同步执行完才开始执行异步.同步代码i循环到5，输出，有5个console.log(i)在队列里嗷嗷待哺，把i=5赋值进去.得到5个5. 函数节流，在时间内，如果执行，就重新开始原理：当达到了一定的时间间隔就会执行一次；可以理解为是缩减执行频率 12345678910111213function throttle(fn,delay)&#123; const timer = null return function()&#123; clearTimeout(timer) timer = setTimeout(function()&#123; fn(arguments) &#125;,delay) &#125;&#125;function fn()&#123; console.log("hello")&#125;var fn2 = throttle(fn, 1000) 函数防抖原理：将若干函数调用合成为一次，并在给定时间过去之后，或者连续事件完全触发完成之后，调用一次(仅仅只会调用一次) 12345678910111213function debounce(fn,ms)&#123; let timer = null return function()&#123; clearTimeout(timer) timer = setTimerout(()=&gt;&#123; fn() &#125;,ms) &#125;&#125;Function _log()&#123; console.log(1)&#125;Window.onscroll = debounce(_log,500) 区别 他们的区别在于防抖只会在连续的事件周期结束时执行一次，而节流会在事件周期内按间隔时间有规律的执行多次。 DOM元素创建和选取DOM是文档对象模型，是html的编程接口readyState加载状态 1234567891011document.location//location属性返回一个只读对象，提供当前文档的url信息document.location.href //获取urldocument.location.protocol //获取"http:"document.location.hostname // "www.example.com"document.location.port // "4097" document.location.pathname // "/path/a.html"document.location.assign("http://www.Google.com") //跳转到指定网址document.location.reload(true) //优先从服务器重新加载document.location.reload(false) //优先从本地缓存加载 123document.open() //新建文档可以使用write写入document.close() //关闭文档document.write() //写入文档 Element表示html元素 element的属性： nodeName: 元素标签名 nodeType:元素类型 className:类名 id:元素id children:子元素列表 childNodes: 子元素列表（NodeList） firstChild: 第一个子元素 lastChild:最后一个 nextSibling: 下一个兄弟元素 previousSibling: 上一个兄弟元素 parentNode.parentElement: 父元素 查询元素 12345678910111213document.getElementById("target")document.getElementsByClassName("box")//上述为ES3写法//下面是ES5写法document.querySelector(".box")document.querySelector("#tatget")//多个元素只会选择第一个//选择多个document.querySelectorAll("div")//浏览器控制台测试时可以用$替代document.querySelector//用$$替代document.querySelectorAll 创建元素 1234567document.createElement("div")//生成文本节点document.createTextNode("Hello")//生成DocumentFragment对象document.createDocumentFragment()//存在于内存中的DOM片段，不属于当前文档。//对它的任何改动，都不会引发网页的重新渲染 修改元素 1234567891011121314151617在元素末尾添加元素appendChild()newDiv.appendChild(newContent)在元素之前插入元素insertBefore()替换元素replaceChild(newElement,oldElement)删除元素parentNode.removeChild(childNode)clone元素node.cloneNode(true)//方法有一个布尔值，传入true时会深拷贝，//复制元素及其子元素，false只会复制元素本身 DOM元素属性123456789101112获取属性node.getAttribute("id")生成新的属性对象节点attribute = document.createAttribute(name)一般用 setAttribute()设置元素属性var node = document.getElementById("id")node.setAttribute("id", "newVal")删除属性节点node.removeAttribute("id") innerText可写属性，返回元素内包含的文本内容，在多层次的时候按照元素由浅到深的顺序拼接内容 123456&lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 外层div的innerText返回内容是 &quot;123456&quot; innerHTML返回元素html结构，在写入的时候也会自动构建DOM 样式修改样式 1document.querySelector("p").style.color = "red" 获取样式getComputedStyle 1234var node = document.querySelector('p') var color = window.getComputedStyle(node).color console.log(color)//获取计算后的样式，只读。全局属性 class操作的增删改查123456var nodeBox = document.querySelector(".box")console.log(nodeBox.classList)nodeBox.classList.add("active") //新增classnodeBox.classList.remove("active") //删除nodeBox.classList.toggle("active") //新增删除切换node.classList.contains("active") //判断是否拥有class 页面宽高 12345clientWidth() //包括paddingoffsetHeight() //包括borderscrollHeight() //滚动内容的总高度scrollTop() //滚动的高度innerHeight() //窗口的高度 事件捕获阶段，目标阶段，冒泡阶段 事件绑定12345678&lt;input id="btnClick" type="button" value="Click here"&gt; &lt;script type="text/javascript"&gt;var btnClick = document.getElementById("btnClick")btnClick.onclick = function showMessage()&#123; alert(this.id)&#125;&lt;/script&gt; 会存在覆盖 DOM2事件处理(升级版) addEventListener //绑定事件 removeEventListener //解绑事件 所有DOM节点都包含这两个方法，且都接受三个函数： 事件类型 事件处理方法 布尔参数，true表示在捕获阶段调用，false表示在事件冒泡阶段处理，默认是冒泡阶段 123btnClick.addEventListener("click", function()&#123; alert(this.id)&#125;, false) 不存在覆盖，可以写多个方法 属性方法123preventDefault() //取消默认事件行为stopPropagation() //取消事件进一步捕获或冒泡target() //事件的目标元素 事件代理事件委托(代理)就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。使用事件代理来实现它，监听的元素应该是这些元素的父元素，当我点击父元素内的元素时，父元素都会得到响应，并分发相应的事件。 e.target就是点击的元素。 1234567$('.container').onclick = function(e)&#123; console.log(this) console.log(e.target) if(e.target.classList.contains('box'))&#123; console.log(e.target.innerText) &#125; &#125; 常见事件及自定义事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950鼠标事件clickdblclick //双击左键mouseover //鼠标放上mouseout //鼠标移出mouseenter //类似over，区别不计算子元素mouseleave //类似out，区别不计算子元素mousedown //鼠标按下mouseup //鼠标松开触摸事件touchstarttouchendtouchmove键盘事件keyup //按键后松开触发keydown //按键即会触发keypress //按下松开页面相关事件onload //加载完成时触发onmove //浏览器窗口被移动scroll //滚动条滚动resize //窗口大小变化表单相关focus //获取焦点blur //失去焦点change //失去焦点且内容发生改变reset //reset属性被激活submit //提交，一般是表格提交input //在input元素内容修改后立即触发onload //页面所有资源加载完成DOMContentLoaded //dom结构解析完成编辑事件beforecopy //复制之前beforecut //剪切之前beforepaste //粘贴之前beforeeditfocus //将要进去编辑状态contextmenu //按右键出现菜单或者键盘触发页面菜单losecapture //失去鼠标移动所形成的选择焦点select //被选择时拖动事件drag //某个对象被拖动dragdrop //外部对象被拖到当前窗口dragend //拖动结束dragenter //被拖动对象进入其容器范围 js拖动div 使用mouse实现 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt; mouse实现div拖动 &lt;/title&gt;&lt;style type="text/css"&gt;#div &#123; position: absolute; left: 100px; top: 100px; width: 200px; height: 200px; background-color: #f60;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="drag"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var drag = document.getElementById("drag");var dragFlag = false;var x,y;drag.onmousedown = function (e) &#123; e = e || window.event; x = e.clientX - drag.offsetLeft; y = e.clientY - drag.offsetTop; dragFlag = true;&#125;;document.onmousemove = function (e) &#123; if (dragFlag) &#123; e = e || window.event; drag.style.left = e.clientX - x + "px"; drag.style.top = e.clientY - y + "px"; &#125;&#125;;document.onmouseup = function (e) &#123; dragFlag = false;&#125;;&lt;/script&gt;&lt;/body&gt; drag实现 12345678910111213141516171819202122232425262728293031323334353637&lt;head&gt;&lt;style&gt;.divblok &#123; background-color:#ccc; width:30px; height:30px; position:absolute; left:20px; top:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="dragdiv" draggable="true" class="divblok"&gt;我要移动 &lt;/div&gt;&lt;script&gt;var dragdiv = document.querySelector('#dragdiv');var x, y; //记录到点击时鼠标到移动框左边和上边的距离dragdiv.addEventListener('dragstart', function (e) &#123; e.dataTransfer.effectAllowed = "move"; //移动效果 e.dataTransfer.setData("text", ''); //附加数据， 没有这一项，firefox中无法移动 x = e.offsetX || e.layerX; y = e.offsetY || e.layerY; return true;&#125;, false);document.addEventListener('dragover', function (e) &#123;//取消冒泡 ,不取消则不能触发 drop事件 e.preventDefault()|| e.stopPropagation();&#125;, false);document.addEventListener('drop', function (e) &#123; dragdiv.style.left = (e.pageX - x) + 'px'; dragdiv.style.top = (e.pageY - y) + 'px'; e.preventDefault() || e.stopPropagation(); //不取消，firefox中会触发网页跳转到查找setData中的内容&#125;, false);&lt;/script&gt;&lt;/body&gt; 自定义事件123456789101112131415var EventCenter = &#123; on: function(type, handler)&#123; document.addEventListener(type, handler) &#125;, fire: function(type, data)&#123; return document.dispatchEvent(new CustomEvent(type, &#123; detail: data &#125;)) &#125; &#125; EventCenter.on('hello', function(e)&#123; console.log(e.detail) &#125;) EventCenter.fire('hello', '你好') //一个监听函数，一个处理函数 JS动画requestAnimationFrame可以在一定时间内自动执行 123456789function move()&#123; if(moveOffset &lt; offsetX)&#123; ball.style.left = parseInt(getComputedStyle(ball).left) + step +"px" moveOffset += step requestAnimationFrame(move) &#125;&#125;move() BOMbom指浏览器对象模型，核心是window对象。是浏览器的实例window.innerHeight属性，window.innerWidth属性.这两个属性返回网页的CSS布局占据的浏览器窗口的高度和宽度，单位为像素。很显然，当用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。 注意，这两个属性值包括滚动条的高度和宽度。 scrollX：滚动条横向偏移 scrollY：滚动条纵向偏移 这两个值随着滚动位置变化而变化 window.frames返回一个类似数组的对象，成员为页面内的所有框架，包括frame元素和iframe元素。需要注意的是，window.frames的每个成员对应的是框架内的窗口（即框架的window对象），获取每个框架的DOM树，需要使用window.frames[0].document。 12var iframe = window.getElementsByTagName("iframe")[0];var iframe_title = iframe.contentWindow.title; 上面代码用于获取框架页面的标题。 iframe元素遵守同源政策，只有当父页面与框架页面来自同一个域名，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。在iframe框架内部，使用window.parent指向父页面。 navigator指向一个包含浏览器相关信息的对象. window.getComputedStylegetComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值 1var style = window.getComputedStyle("元素", "伪类") URL的编码/解码方法JavaScript提供四个URL的编码/解码方法。 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 区别 encodeURI方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!@#$&amp;*()=:/,;?+' encodeURIComponent方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!*()' alert()，prompt()，confirm()alert()、prompt()、confirm()都是浏览器用来与用户互动的方法。它们会弹出不同的对话框，要求用户做出回应。 需要注意的是，alert()、prompt()、confirm()这三个方法弹出的对话框，都是浏览器统一规定的式样，是无法定制的。]]></content>
      <categories>
        <category>JS</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F18%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[介绍超文本标记语言(Hypertext Markup Language, HTML)是一个可以用来结构化 Web 内容并给予其含义和目标的编码语言。HTML 并不是真正的的程序语言，它是一种标记语言.它由一系列的元素（elements）所组成，不同的元素各有功用. 设定文档语言&lt;html lang=&quot;zh-CN&quot;&gt; SEO(搜索引擎优化) 有利于视障人士通过读屏器阅读 HTML 头部元数据&lt;meta&gt;:指定文档编码: &lt;meta charset=&quot;UTF-8&quot;&gt;适配移动页面: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;设置 referer: &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;添加页面描述: &lt;meta name=&quot;description&quot; content=&quot;腾讯网(www.QQ.com)是中国浏览量最大...&gt; 定制页面图标: &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; 应用 CSS 和 JS 12&lt;link rel="stylesheet" href="app.css"&gt;&lt;script src="app.js"&gt;&lt;/script&gt; 标签空标签就是不用加闭标签的标签，也可以叫闭元素。如： &lt;area&gt; &lt;base&gt; &lt;br&gt; &lt;col&gt; &lt;colgroup&gt; when the span is present &lt;command&gt; &lt;embed&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;keygen&gt; &lt;link&gt; &lt;meta&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;可替换标签宽高由自己决定的元素，如： &lt;img&gt; &lt;video&gt; &lt;input&gt; 文本HTML 包括六个级别的标题， &lt;h1&gt; – &lt;h6&gt;。通常一个页面只有一个&lt;h1&gt;，请尽量按顺序使用 &lt;h1&gt; – &lt;h6&gt;。段落:&lt;p&gt;&lt;/p&gt;无序列表: &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;有序列表: &lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;描述列表: 1234&lt;dl&gt; &lt;dt&gt;吃藕&lt;/dt&gt; &lt;dd&gt;chi ou = 吃藕 = 丑 例句：被老板忽悠剪了个吃藕的发型。&lt;dd&gt;&lt;/dl&gt; 缩写: 1&lt;p&gt;最近大家都在学 &lt;abbr title="Hypertext Markup Language"&gt;HTML&lt;/abbr&gt;。&lt;/p&gt; 时间:&lt;time datetime=&quot;2016-01-20&quot;&gt;2016年1月20日&lt;/time&gt; 特殊字符: 符号 代码 &lt; &amp;lt &gt; $gt “ &amp;quot ‘ &amp;apos &amp; &amp;amp 空格 &amp;nbsp 图片普通图片: 12&lt;!-- 显示 Vue.js logo --&gt;&lt;img src="https://vuejs.org/images/logo.png" alt="Vue.js logo" width="200"&gt; 带说明的图片(比如博客头像): 1234567&lt;figure&gt; &lt;img src="https://c-ssl.duitang.com/uploads/item/201608/12/20160812105654_JaZUi.thumb.700_0.jpeg" alt="我是说明,小新" width="60" height="60"&gt; &lt;figcaption&gt;小新&lt;/figcaption&gt;&lt;/figure&gt; 表格简单表格: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;球员&lt;/th&gt; &lt;th&gt;号码&lt;/th&gt; &lt;th&gt;身高&lt;/th&gt; &lt;th&gt;体重&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;国籍&lt;/th&gt; &lt;th&gt;出生地&lt;/th&gt; &lt;tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;勒布朗·詹姆斯&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;2.03米/6英尺8英寸&lt;/td&gt; &lt;td&gt;113.4公斤&lt;/td&gt; &lt;td&gt;1984年12月30日&lt;/td&gt; &lt;td colspan="2"&gt;美国&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;凯里·欧文&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;1.91米/6英尺3英寸&lt;/td&gt; &lt;td&gt;88公斤/193磅&lt;/td&gt; &lt;td&gt;1992年3月23日&lt;/td&gt; &lt;td&gt;美国/澳洲&lt;/td&gt; &lt;td&gt;澳洲&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;凯文·乐福&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;2.08米/6英尺10英寸&lt;/td&gt; &lt;td&gt;110公斤/243磅&lt;/td&gt; &lt;td&gt;1988年9月7日&lt;/td&gt; &lt;td colspan="2"&gt;美国&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;style&gt;table &#123; border-collapse: collapse; //表格线合并&#125;th, td &#123; border: 1px solid green; //设置边框&#125;&lt;/style&gt; 表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div class="login"&gt;//设置登录框 &lt;input type="text" name="sex" placeholder="可以显示未输入前的字"&gt; //输入框 &lt;form action="/getInfo" method="get"&gt; &lt;div class="submit"&gt; &lt;button&gt;提交😁&lt;/button&gt; &lt;/div&gt; &lt;div class="username"&gt; &lt;label for="username"&gt;姓名&lt;/label&gt; &lt;input id="username" type="text" name="username" value="ruo"&gt; //文本类型输入框 &lt;/div&gt; &lt;div class="password"&gt; &lt;label for="password"&gt;密码&lt;/label&gt; &lt;input id="password" type="password" name="password" placeholder="输入密码"&gt; //密码类型输入框 &lt;/div&gt; &lt;div class="hobby"&gt; &lt;label&gt;爱好&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="read"&gt; 读书 &lt;input type="checkbox" name="hobby" value="music"&gt; 听歌 &lt;input type="checkbox" name="hobby" value="study"&gt; 学习 //多选框(复选框) &lt;/div&gt; &lt;div class="sex"&gt; &lt;label&gt;性别&lt;/label&gt; &lt;input type="radio" name="sex" value="男"&gt; 男 &lt;input type="radio" name="sex" value="女"&gt; 女 //单选框 &lt;/div&gt; &lt;div class="file"&gt; &lt;input type="file" name="myfile" accept="image/png"&gt; //上传文件按钮 &lt;/div&gt; &lt;div class="select"&gt; &lt;select name="city"&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai" selected&gt;上海&lt;/option&gt; &lt;option value="hangzhou"&gt;杭州&lt;/option&gt; &lt;/select&gt; //下拉框,默认上海 &lt;/div&gt; &lt;div class="textarea"&gt; &lt;textarea name="article"&gt; 多行文本，注意和 type=text的区别 &lt;/textarea&gt; //下面是四种按钮提交方式 &lt;input type="hidden" name="csrf" value="12345623fafdffdd"&gt; &lt;input type="button" value="Buttom" /&gt; 不会提交 &lt;input type="submit" value="Submit" /&gt; 会提交 &lt;input type="reset" value="Reset" /&gt; 重置输入 &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 超链接123456789//简单链接:&lt;a href="https://github.com/fe13"&gt;FE 13&lt;/a&gt;//title属性:&lt;a href="https://github.com/fe13" title="可能是未来中国最火的前端工程师的聚集地"&gt;FE 13&lt;/a&gt;//外部链接://将target设置成_blank时，点击链接浏览器会新开一个 Tab 打开该网页。&lt;a href="https://github.com/fe13" title="可能是未来中国最火的前端工程师的聚集地" target="_blank"&gt;FE 13&lt;/a&gt;//返回顶部链接:&lt;a href="#"&gt;返回页面顶部&lt;/a&gt; 文档内部链接:用于定位到文档的某一部分，&lt;a&gt; 的 href 要对应文档内某个元素的 id（id 的值在文档内要唯一） 12&lt;a href="#email链接"&gt;Email链接&lt;/a&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Forms"&gt;表单相关标签&lt;/a&gt; 图片链接: 123&lt;a href="https://github.com/fe13" title="可能是未来中国最火的前端工程师的聚集地"&gt; &lt;img src="https://avatars0.githubusercontent.com/u/28950695?v=3&amp;s=200" height="100"&gt;&lt;/a&gt; 123456下载链接:&lt;a href="https://angular.io/resources/images/logos/angular/angular.svg" download&gt;下载 Angular Logo&lt;/a&gt;电话链接:&lt;a href="tel:+8613701234567"&gt;+86 13701234567&lt;/a&gt;Email 链接:&lt;a href="mailto:xiaoxin@xiaoxin.cn"&gt;发封邮件给小新&lt;/a&gt; &lt;br&gt; 文档结构页头 &lt;header&gt;导航栏 &lt;nav&gt;主内容 &lt;main&gt;，后面一般接 &lt;article&gt;,&lt;section&gt;,&lt;div&gt;侧边栏 &lt;aside&gt;页尾 &lt;footer&gt; 语义化 HTML选择合适的标签、使用合理的代码结构，便于开发者和视觉障碍人士阅读，同时让浏览器的爬虫和机器很好地解析。 相对路径同一站点尽量使用相对路径。 123456&lt;!-- index.html --&gt;&lt;img src="images/logo.png"&gt;/* app.css */.container &#123; background: url('../images/background.png');&#125; 绝对路径https://github.com/fe13/fe/blob/master/README.md]]></content>
      <categories>
        <category>HTML</category>
        <category>HTML基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start文本插值的双大括号形式会被识别导致无法上传,注意!!!Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
