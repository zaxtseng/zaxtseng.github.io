<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2F2019%2F09%2F01%2FNode-js%2F</url>
    <content type="text"><![CDATA[node.js基础12345678910node index.js //启动服务器index.js文件中引入http模块var http = require("http") //引入http模块var server = http.creatserve(fn(res,req))//创建服务器response.end() //结束server.listen(9000) //启动服务器，监听9000端口res.setHeader("Content-Type", "text/plain; chartset=gbk")//设置响应头res.writeHead(200,"ok") //设置状态码console.log("open http://localhost:9000") 进阶 12345678910111213141516171819202122232425262728293031323334var http = require("http") //引入http模块var path = require("path") //自动处理路径问题var fs = require("fs") //读写文件var url = require("url") //解析urlfunction staticRoot(staticPath, req, res)&#123; var pathObj = url.parse(req.url, true) //url.parse是node.js方法，将一个URL字符串转换成对象并返回 console.log(pathObj) if(pathObj.pathname === "/")&#123; pathObj.pathname += "index.html" &#125; //不加后缀可以默认加后缀var filePath = path.join(staticPath, pathObj.pathname)//拼接文件地址fs.readFile(filePath, "binary", function(err, fileContent)&#123; if(err)&#123; res.writeHead(404, "not found") res.end("&lt;h1&gt;404 Not Found&lt;/h1&gt;")&#125;else&#123; res.writeHead(200, "ok") res.write(fileContent, "binary") res.end() &#125;&#125;)console.log("path.join(_dirname, "static")var server = http.createServer(function(res,req)&#123; staticRoot(path.join(__dirname, "static"), req, res) //__dirname代表当前文件server.listen(8080)console.log("visit http://localhost:8080") 常用APIfs.readFile(path[,options],callback)/fs.writeFile(file,data[,options],callback)12345678910111213141516171819let fs = require('fs') //引入fs模块fs.readFile('flie.txt', 'utf-8', function(err, str)&#123; if(err)&#123; console.log('error') &#125;else&#123; console.log(str) //要去掉字符串里的数字空格 const strAfter = str.replace(/\d/gm, '') console.log(strAfter) //去掉数字后把strAfter写出来 fs.writeFile('fileAfter.txt', strAfter, (err)=&gt;&#123; if(err) throw err; //如果报错直接使用throw抛出 console.log('the file has been save!'); &#125;) &#125;&#125;) 模块将上面的去数字的方法封装成函数,单独写一个文件,并调用创建stringApi.js 12345function replaceDigit(str)&#123; return str.replace(/\d/gm, '')&#125;module.exports.replaceDigit = replaceDigit //把这个封装好的函数暴露出来可以使用了 123456//封装好后在上面的代码里就可以使用了//先引入let strApi = require('./stringApi') //如果在同级目录下,直接使用相对路径引入//然后将上面的代码const strAfter = str.replace(/\d/gm, '')替换成const strAfter = strApi.replaceDigit(str) NPM如果需要一些功能,node.js自带的没有,可以去npm官网上找一些其他人发布的npm包.找到之后,首先进行安装 package.json记录保存模块依赖,当没有依赖时,比如下载其他人的项目里没有依赖,可以使用npm.init初始化,将package.json中记录的模块依赖全都下载下来,方便. npm切换源工具1234npm install -g nrm //安装nrm工具nrm ls //查看nrm支持的源的列表nrm use taobao //使用淘宝的源nrm use npm //切换回npm源 NPM Script在package.json文件里有一个scripts对象,写入里面的命令可以比较方便快捷的执行.直接npm xxx就可以执行.而且会自动搜索路径,不用写相对路径. 123456789101112&#123; "scripts": &#123; "css:autoprefixer": "postcss -u autoprefixer -r dist/css/*", "css:compress": "csso in.css --output out.css", "js:lint": "eslint src/js", "js:uglify": "mkdir -p dist/js &amp;&amp; uglifyjs src/js/*.js -m -o dist/js/app.js", "image:imagemin": "app=imagemin-cli npm run check; imagemin src/images dist/images -p", "server": "browser-sync start --server --files 'dist/css/*.css, dist/js/*.js'", "watch": "onchange 'src/js/*.js' -- npm run css:compress", "start": "npm run server" &#125;&#125; 12npm run css:autoprefixernpm start]]></content>
      <categories>
        <category>后端</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程化]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[模块化初探模块化系统的风格模块化的价值 最主要的目的： 解决命名冲突 依赖管理其他价值: 提高代码可读性 代码解耦，提高复用性 &lt;script&gt;标签风格123&lt;script src="module1.js"&gt;&lt;/script&gt;&lt;script src="module2.js"&gt;&lt;/script&gt;&lt;script src="module3.js"&gt;&lt;/script&gt; 各个模块把接口暴露给全局对象,比如window.各个模块通过全局对象进行相互访问出现的问题: 全局对象的冲突 加载的顺序很重要 开发者需要解决模块的依赖问题 在大项目中模块非常多难以维护CommonJs: 同步的require使用同步的require方法来加载依赖和返回暴露的接口.一个模块可以通过exports对象添加属性,或者设置module.exports的值来描述暴露对象.1234require('moudle')require('../file.js')exports.doStuff = function()&#123;&#125;moudle.exports = someValue 优点: 服务端代码可以被复用. npm有大量的代码 使用方便缺点: 阻塞调用无法在网络环境应用,网络请求是异步的 不能并行require多个模块CommonJS规范 在一个模块中，存在一个自由的变量”require”，它是一个函数。这个”require”函数接收一个模块标识符。“require”返回外部模块所输出的API。 在一个模块中，会存在一个名为”exports”的自由变量，它是一个对象，模块可以在执行的时候把自身的API加入到其中。 模块必须使用”exports”对象来做为输出的唯一表示。AMD规范: 异步的requireAMD主要解决两个问题: 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长requireJS语法RequireJS 遵循 AMD 规范，用于解决命名冲突和文件依赖的问题.requireJS定义了一个函数 define，它是全局变量，用来定义模块define(id?, dependencies?, factory); id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） dependencies：是一个当前模块依赖的模块名称数组 factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 在页面上使用require函数加载模块require([dependencies], function(){});require()函数接受两个参数: 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块. require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 1234require(['moudle', '../file'], function(moudle, file)&#123; /* ... */&#125;)define('moudle',['dep1', 'dep2'], function(d1, d2)&#123; return someExportedValue&#125;) webpack 新建一个文件夹,cd到它的目录下.执行npm init -y命令 执行npm install --save--dev webpack命令安装(也可以全局安装)12345678910111213141516171819/配置touch webpack.config.jsvi webpack.config.js//在里面写以下内容/*const path = require('path');module.exports = &#123; entry: './src/index.js', //入口 output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;;*///创建文件touch src/index.js//运行webpacknpx webpack //这时会多出dist目录，里面有bundle.js文件 2.使用1.在index.js里写123456console.log(1)//再运行webpack:npx webpack//再看bundle.js，这时会多出来一行console.log(1) 2.安装babel-loader自动转换es612345678910111213141516171819202122232425262728293031323334353637383940414243//安装v6，命令行npm install babel-loader babel-core babel-preset-env webpack//将这个复制到webpack的配置文件webpack.config.js里，加在output的下面module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ]&#125;//加在output的下面，复制完后成这样const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'] &#125; &#125; &#125; ]&#125;&#125;; 运行npx webpack若出现can’t find ‘…’或can’t resolve ‘…’的报错，则安装省略号里的东西npm i ‘省略号’注意：若是Couldn’t find preset “env”，不要安装env，而是npm i babel-preset-env 3.使用babel123//当你在写index.js里写let a=1//它就会帮你自动转换成es5了 NPM 脚本(NPM Scripts)在package.json文件中写入npm脚本,就可以使用npm run build替代npx命令. 123456789101112131415161718 &#123; "name": "webpack-demo", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",+ "build": "webpack" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.0.1", "webpack-cli": "^2.0.9", "lodash": "^4.17.5" &#125; &#125; 管理资源(css,图片之类)加载CSS 需要先安装style-laoder和css-loadernpm install --save-dev style-loader css-loader 然后在webpack.config.js文件里添加规则1234567891011121314151617181920 const path = require('path'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,+ module: &#123;+ rules: [+ &#123;+ test: /\.css$/,+ use: [+ 'style-loader',+ 'css-loader'+ ]+ &#125;+ ]+ &#125; &#125;; webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这种情况下，以 .css 结尾的全部文件，都将被提供给 style-loader 和 css-loader。 这使你可以在依赖于此样式的文件中import &#39;./style.css&#39;。现在，当该模块运行时，含有 CSS 字符串的&lt;style&gt;标签，将被插入到 html 文件的 &lt;head&gt;中。 加载图片 安装npm install --save-dev file-loader插件 配置webpack.config.js文件现在，当你 import MyImage from &#39;./my-image.png&#39;，该图像将被处理并添加到 output 目录，并且 MyImage 变量将包含该图像在处理后的最终 url。当使用 css-loader 时，如上所示，你的 CSS 中的url(&#39;./my-image.png&#39;) 会使用类似的过程去处理。loader 会识别这是一个本地文件，并将 &#39;./my-image.png&#39;路径，替换为输出目录中图像的最终路径。html-loader 以相同的方式处理 &lt;img src=&quot;./my-image.png&quot; /&gt;。 在src文件夹下创建icon.png. 修改src/index.js文件 123456789101112131415161718192021 import _ from 'lodash'; import './style.css';+ import Icon from './icon.png'; function component() &#123; var element = document.createElement('div'); // Lodash，现在由此脚本导入 element.innerHTML = _.join(['Hello', 'webpack'], ' '); element.classList.add('hello');+ // 将图像添加到我们现有的 div。+ var myIcon = new Image();+ myIcon.src = Icon;++ element.appendChild(myIcon); return element; &#125; document.body.appendChild(component()); src/style.css中引入图片 1234 .hello &#123; color: red;+ background: url('./icon.png'); &#125; 重新构建npm run build Glup 简介它是一款nodejs应用。它是打造前端工作流的利器，打包、压缩、合并、git、远程操作…，简单易用无快不破高质量的插件 安装 安装gulpnpm install -g gulp如果报Error: EACCES, open &#39;/Users/xxx/xxx.lock错误。先执行：sudo chown -R $(whoami) $HOME/.npm 如果使用npm安装插件太慢（被墙），可执行 npm install -g cnpm --registry=https://registry.npm.taobao.org先安装cnpm, 之后再安装插件时用cnpm安装cnpm install gulp 安装各种插件123456789101112131415npm install --save gulp //本地使用gulpnpm install --save gulp-imagemin //压缩图片npm install --save gulp-minify-css //压缩cssnpm install --save gulp-ruby-sass //sassnpm install --save gulp-jshint //js代码检测npm install --save gulp-uglify //js压缩npm install --save gulp-concat //文件合并npm install --save gulp-rename //文件重命名npm install --save png-sprite //png合并npm install --save gulp-htmlmin //压缩htmlnpm install --save gulp-clean //清空文件夹npm install --save browser-sync //文件修改浏览器自动刷新npm install --save gulp-shell //执行shell命令npm install --save gulp-ssh //操作远程机器npm install --save run-sequence //task顺序执行 或者根据package.json 自动安装。把package.json拷贝到自己的工程目录下，进入目录，执行:npm install 语法gulp APIgulp.src(globs[,options])1234gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) //压缩文件 .pipe(gulp.dest('build/minified_templates')); 作用: 输出符合所提供的匹配模式或数组的文件.globs 类型: string或Array所要读取的glob或者包含globs的数组.可以是地址options 类型:object额外的选项参数 gulp.dest(path[,options])12345gulp.src('./client/templates/*.jade') .pipe(jade()) .pipe(gulp.dest('./build/templates')) .pipe(minify()) .pipe(gulp.dest('./build/minified_templates')); 文件被pipe进来,dest生成或者写入一个文件.path文件将被写入的路径（输出目录）。 gulp.task(name[,deps],fn)定义一个实现任务 123gulp.task('somename', function()&#123; //任务&#125;) name任务名字deps 类型: array一个包含任务列表的数组,这些任务会在你当前运行任务之前完成. 123gulp.task('mytask', ['array', 'of', 'task', 'names'], function()&#123; //任务&#125;) fn该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。 gulp.watch(glob[, opts], tasks)监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。 1234var watcher = gulp.watch('js/**/*.js', ['uglify','reload']);watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); gulp使用实例范例1. 压缩合并demo1目录结构如下。把demo1中的 index.html压缩，把src里面的less编译、合并、压缩、重命名、存储到dist。src里面的图片压缩、合并存储到dist。src里面的js做代码检查，压缩，合并，存储到dist。 123456789101112131415161718192021+ demo1 + dist + css - merge.min.css + js - merge.min.js + imgs - 1.png - 2.png - index.html + src + css - a.css - b.css + js - a.js - b.js + imgs - 1.png - 2.png - index.html 创建gulpfile.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var gulp = require('gulp');// 引入组件var minifycss = require('gulp-minify-css'), // CSS压缩 uglify = require('gulp-uglify'), // js压缩 concat = require('gulp-concat'), // 合并文件 rename = require('gulp-rename'), // 重命名 clean = require('gulp-clean'), //清空文件夹 minhtml = require('gulp-htmlmin'), //html压缩 jshint = require('gulp-jshint'), //js代码规范性检查 imagemin = require('gulp-imagemin'); //图片压缩gulp.task('html', function() &#123; return gulp.src('src/*.html') .pipe(minhtml(&#123;collapseWhitespace: true&#125;)) //html压缩 .pipe(gulp.dest('dist'));&#125;);gulp.task('css', function(argument) &#123; gulp.src('src/css/*.css') .pipe(concat('merge.css')) // CSS压缩 .pipe(rename(&#123; suffix: '.min' // 重命名 &#125;)) .pipe(minifycss()) // CSS压缩 .pipe(gulp.dest('dist/css/'));&#125;);gulp.task('js', function(argument) &#123; gulp.src('src/js/*.js') .pipe(jshint()) //js代码规范性检查 .pipe(jshint.reporter('default')) .pipe(concat('merge.js')) // 合并文件 .pipe(rename(&#123; suffix: '.min' // 重命名 &#125;)) .pipe(uglify()) // js压缩 .pipe(gulp.dest('dist/js/'));&#125;);gulp.task('img', function(argument)&#123; gulp.src('src/imgs/*') .pipe(imagemin()) //图片压缩 .pipe(gulp.dest('dist/imgs'));&#125;);gulp.task('clear', function()&#123; gulp.src('dist/*',&#123;read: false&#125;) .pipe(clean()); //清空文件夹&#125;);gulp.task('build', ['html', 'css', 'js', 'img']); 最后命令行gulp build;可实现src目录下的html压缩，css、js合并压缩，图片压缩，最后放入 dist目录下 范例2. 监控变动自动同步1234567891011121314151617181920212223242526272829303132333435363738394041var gulp = require('gulp');// 引入组件var browserSync = require('browser-sync').create(); //用于浏览器自动刷新var scp = require('gulp-scp2'); //用于scp到远程机器var fs = require('fs'); gulp.task('reload', function()&#123; browserSync.reload();&#125;);gulp.task('server', function() &#123; browserSync.init(&#123; server: &#123; baseDir: "./src" &#125; &#125;); gulp.watch(['**/*.css', '**/*.js', '**/*.html'], ['reload', 'scp']);&#125;);gulp.task('scp', function() &#123; return gulp.src('src/**/*') .pipe(scp(&#123; host: '121.40.201.213', username: 'root', privateKey: fs.readFileSync('/Users/wingo/.ssh/id_rsa'), dest: '/var/www/fe.jirengu.com', watch: function(client) &#123; client.on('write', function(o) &#123; console.log('write %s', o.destination); &#125;); &#125; &#125;)) .on('error', function(err) &#123; console.log(err); &#125;);&#125;); 命令行执行: 12gulp scp; // 可把本地开发环境代码拷贝到服务器gulp server; //可在本地创建服务器，本地开发浏览器立刻刷新 范例3. 监控项目文件变动，自动压缩、合并、打包、添加版本号12345678910111213141516171819202122html&lt;/html&gt;&lt;head&gt;&lt;!-- build:css css/merge.css --&gt; &lt;link href="css/a.css" rel="stylesheet"&gt; &lt;link href="css/b.css" rel="stylesheet"&gt;&lt;!-- endbuild --&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;demo1-工程化手动版&lt;/p&gt;&lt;!-- build:js js/merge.js --&gt; &lt;script type="text/javascript" src="js/a.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/b.js"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt;&lt;/body&gt;&lt;/html&gt; 设置gulpfile.js文件 1234567891011121314151617181920212223242526272829303132333435var gulp = require('gulp'); var rev = require('gulp-rev'); //添加版本号var revReplace = require('gulp-rev-replace'); //版本号替换var useref = require('gulp-useref'); //解析html资源定位var filter = require('gulp-filter'); //过滤数据var uglify = require('gulp-uglify'); var csso = require('gulp-csso'); //css优化压缩var clean = require('gulp-clean');gulp.task("index", ['clear'], function() &#123; var jsFilter = filter("**/*.js", &#123;restore: true&#125;); var cssFilter = filter("**/*.css", &#123;restore: true&#125;); var userefAssets = useref.assets(); return gulp.src("src/index.html") .pipe(userefAssets) // Concatenate with gulp-useref .pipe(jsFilter) .pipe(uglify()) // Minify any javascript sources .pipe(jsFilter.restore) .pipe(cssFilter) .pipe(csso()) // Minify any CSS sources .pipe(cssFilter.restore) .pipe(rev()) // Rename the concatenated files .pipe(userefAssets.restore()) .pipe(useref()) .pipe(revReplace()) // Substitute in new filenames .pipe(gulp.dest('dist'));&#125;);gulp.task('clear', function()&#123; gulp.src('dist/*',&#123;read: false&#125;) .pipe(clean());&#125;); 范例4. 本地shell命令， 远程shell， 任务顺序执行…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var gulp = require('gulp');var shell = require('gulp-shell');var runSequence = require('run-sequence');var fs = require('fs');var GulpSSH = require('gulp-ssh');//shell操作, gulp.task('git', shell.task(['git add .', 'git commit -am "dd"', 'git push -u origin dev']));gulp.task('clear', shell.task(['find . -name ".DS_Store" -depth -exec rm &#123;&#125; \\;']));//操作远程主机var gulpSSH = new GulpSSH(&#123; ignoreErrors: false, sshConfig: &#123; host: '121.40.201.213', port: 22, username: 'root', privateKey: fs.readFileSync('/Users/wingo/.ssh/id_rsa') &#125;&#125;);gulp.task('remote', function() &#123; return gulpSSH .shell(['cd /var/www/fe.jirengu.com', 'git pull origin dev', 'rm -rf _runtime']);&#125;);gulp.task('build', function(callback) &#123; runSequence( 'git', 'clear', 'remote', callback );&#125;);gulp.task('watch', function() &#123; gulp.watch(['**/*.css', '**/*.js', '**/*.html', '**/*.php'], ['build']);&#125;);]]></content>
      <categories>
        <category>JS</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS进阶]]></title>
    <url>%2F2019%2F08%2F27%2FJS%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[构造对象newnew运算符接受一个函数F及其参数: new F(arguments…).这个一过程分为: 创建类的实例.这步是把一个空的对象的proto属性设置为F.prototype. 初始化实例.函数F被传入参数并调用.关键字this被设定为该实例. 返回实例.123456789function person(name, age)&#123; this.name = name this.age = age this.sayName = function()&#123; console.log(this.name) &#125;&#125;p1 = new person('tom', 12) instanceofinstanceof是一个操作符,可以判断对象是否为某个类型的实例 1234p1 instanceof person//true,说明p1是由person创造的p1 instanceof Object//true,p1 instanceof Number//false 原型与原型链 当new一个函数的时候会创建一个对象,函数.prototype等于被创建对象.__proto__ 一切函数都是由Function这个函数创建的,所以Function.prototye === 被创建函数.__proto__ 一切函数的原型对象都是由Object这个函数创建的,所以Object.prototype === 一切函数.prototype.__proto__this在函数被直接调用时this绑定到全局对象.即window12345console.log(this)//指向windowfunction fn1()&#123; console.log(this)//指向window&#125; fn1()//相当于window.fn1() 内部函数函数嵌套产生的内部函数的this不是他的父函数,仍然是全局,window 12345678function fn0()&#123; function fn()&#123; console.log(this) &#125; fn()&#125;fn0() setTimeOut()和setInterval()这两个函数执行的函数this也是全局 123456document.addEventListener('click', function(e)&#123; console.log(this); setTimeout(function()&#123; console.log(this); &#125;, 200);&#125;, false); DOM对象绑定事件在事件处理程序中this代表事件源DOM对象 12345678document.addEventListener('click', function(e)&#123; console.log(this); var _document = this; setTimeout(function()&#123; console.log(this); console.log(_document); &#125;, 200);&#125;, false); Function.prototype.bind()bind改变this的指向.返回一个新函数,并使函数内部的this为传入的第一个参数 12var fn3 = obj1.fn.bind(obj1);fn3(); 使用call和apply设置thiscall,apply调用一个函数,传入函数执行上下文及其参数 12fn.call(context,param1,param2...)//接受参数列表fn.apply(context,paramArray)//接收参数数组 第一个参数都是希望设置的this对象举例 12345678//实现一个函数可以遍历传入的参数function sum()&#123; //arguments.forEach无法执行,因为arguments不是数组,使用call将forEach的this指向arguments,使之可以遍历 Array.prototype.forEach.call(arguments,function(value)&#123; console.log(value) &#125;)&#125;sum(3,4,1,6)//函数就可以遍历了 12345678910function sum()&#123; var result = 0 //arguments.forEach无法执行,因为arguments不是数组,使用call将forEach的this指向arguments,使之可以遍历 Array.prototype.forEach.call(arguments,function(value)&#123; console.log(value) return result += value &#125;) console.log(result)&#125;sum(3,4,1,6)//函数就可以将传入值相加了 argument 在函数调用时，会自动在该函数内部生成一个名为 arguments的隐藏对象 该对象类似于数组，可以使用[]运算符获取函数调用时传递的实参 只有函数被调用时，arguments对象才会创建，未调用时其值为null12345678function fn5(name, age)&#123; console.log(arguments); name = 'XXX'; console.log(arguments); arguments[1] = 30; console.log(arguments);&#125;fn5('Byron', 20); 研究this123456789var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 打印出的 this 是 objbar() // 打印出的 this 是 window 实际上的正常调用方式func.call(context, p1, p2)其他简化方式都可以转化 12345func(p1, p2) 等价于func.call(undefined, p1, p2)obj.child.method(p1, p2) 等价于obj.child.method.call(obj.child, p1, p2) this，就是上面代码中的 context。就这么简单。 this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。 浏览器规则:如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） 上面的代码就解释的通了 12345678910111213var obj = &#123; foo: function()&#123; console.log(this) &#125;&#125;var bar = obj.fooobj.foo() // 转换为 obj.foo.call(obj)，this 就是 objbar() // 转换为 bar.call()// 由于没有传 context// 所以 this 就是 undefined// 最后浏览器给你一个默认的 this —— window 对象 Event Handler中的this123btn.addEventListener('click' ,function handler()&#123; console.log(this) // 请问这里的 this 是什么&#125;) 当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样。 jQuery Event Handler 中的 this那么下面代码中的 this 是什么呢： 123$ul.on('click', 'li' , function()&#123; console.log(this)&#125;) 当jQuery的调用处理程序时，this关键字指向的是当前正在执行事件的元素。对于直接事件而言，this 代表绑定事件的元素。对于代理事件而言，this 则代表了与 selector 相匹配的元素。(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)若要使用 jQuery 的相关方法，可以根据当前元素创建一个 jQuery 对象，即使用 $(this)。 []语法123function fn ()&#123; console.log(this) &#125;var arr = [fn, fn2]arr[0]() // 这里面的 this 又是什么呢？ 我们可以把 arr0 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了： 1234 arr[0]() 假想为 arr.0()然后转换为 arr.0.call(arr)那么里面的 this 就是 arr 了 call、apply 、函数执行的本质当我们执行一个函数，以下几种调用方式等价 12345678"use strict"function fn(a,b)&#123; console.log(this)&#125;fn(1, 2)//等价于fn.call(undefined, 1, 2)fn.apply(undefined, [1, 2]) 在严格模式下， fn 里的 this 就是 call 的第一个参数，也就是 undefined。在非严格模式下(不加”use strict”)， call 传递的第一个参数如果是 undefined 或者 null， 那 this 会自动替换为 Window 对象 123456789101112131415161718var obj = &#123; fn: function(a, b)&#123; console.log(this) &#125;, child: &#123; fn2: function()&#123; console.log(this) &#125; &#125;&#125;obj.fn(1, 2)//等价于obj.fn.call(obj, 1, 2) // 所以 this 是 objobj.fn.apply(obj, [1, 2])obj.child.fn2()//等价于obj.child.fn2.call(obj.chid) // 所以 this 是 obj.child 箭头函数中的this1234567891011121314let app = &#123; fn1: function(a)&#123; console.log(this) //app &#125;, fn2(a)&#123; console.log(this) //app &#125;, fn3: (a)=&gt; &#123; console.log(this) //window &#125;&#125;app.fn2.call(app)app.fn3.call(它上一级环境下的this) 箭头函数的复杂情况示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var app = &#123; fn1()&#123; setTimeout(function()&#123; console.log(this) &#125;,10) &#125;, fn2()&#123; setTimeout(()=&gt;&#123; console.log(this) &#125;,20) &#125;, fn3()&#123; setTimeout((function()&#123; console.log(this) &#125;).bind(this),30) &#125;, fn4: ()=&gt;&#123; setTimeout(()=&gt;&#123; console.log(this) &#125;,40) &#125;&#125;app.fn1()app.fn2()app.fn3()app.fn4()以上代码相当于var app = &#123; fn1()&#123; function fn()&#123; console.log(this) &#125; //过10ms后执行 //fn.call(undefined),所以输出window &#125;, fn2()&#123; //过20ms执行箭头函数 //箭头函数里没有资格有自己的this,借用setTimeout外面的this,也就是app &#125;, fn3()&#123; //创建了一个新函数,这个新函数绑定了外面的this,也就是app //20ms后执行新函数,输出this,也就是刚刚绑定的app &#125;, fn4: ()=&gt;&#123; //过40ms执行箭头函数 //箭头函数里没有资格有自己的this,借用setTimeout外面的this //setTimeout所在的fn4也是箭头函数,没资格拥有自己的this,借用外面的this,也就是window &#125;&#125; 函数的执行环境JavaScript中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因 一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数 接下来创建作用域链，然后初始化变量。首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。 如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解JavaScript中的变量作用域非常重要，最后为this变量赋值，会根据函数调用方式的不同，赋给this全局对象，当前对象等 至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取. 三种变量实例变量：（this）类的实例才能访问到的变量 静态变量：（属性）直接类型对象能访问到的变量 私有变量：（局部变量）当前作用域内有效的变量 123456789101112131415function ClassA()&#123; var a = 1; //私有变量，只有函数内部可以访问 this.b = 2; //实例变量，只有实例可以访问&#125;ClassA.c = 3; // 静态变量，也就是属性，类型访问console.log(a); // errorconsole.log(ClassA.b) // undefinedconsole.log(ClassA.c) //3var classa = new ClassA();console.log(classa.a);//undefinedconsole.log(classa.b);// 2console.log(classa.c);//undefined 继承继承是指一个对象直接使用另一个对象的属性和方法.如果实现以下两点就实现了继承 得到一个类的属性 得到一个类的方法属性的获取对象属性的获取是通过构造函数的执行.在一个类中执行另外一个类的构造函数,就可以把属性赋值到自己内部,但是需要把环境改到自己的作用域内,用call修改this的指向即可.123456789101112131415161718192021222324252627function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;;function Male(age)&#123; this.age = age;&#125;Male.prototype.printAge = function()&#123; console.log(this.age);&#125;;function Male(name,sex,age)&#123; Person.call(this,name,sex) this.age = age&#125;Male.prototype.printAge = function()&#123; console.log(this.age)&#125;var m = new Male('Tom','male',10)console.log(m.sex) //'male' 继承的范例12345678910function Male(name,sex,age)&#123; Person.call(this, name, sex) this.age = age&#125;Male.prototype = Object.create(Person.prototype)Male.prototype.printAge = function()&#123; console.log(this.age)&#125; 12345678910111213141516171819202122function Person(name, sex)&#123; this.name = name this.age = age&#125;Person.prototype.printName = function()&#123; console.log(this.name)&#125;function Male(name, sex, age)&#123; Person.call(this, name, age) this.sex = sex&#125;Male.prototype = new Person()Male.prototype.printAge = function()&#123; console.log(this.age)&#125;Male.prototype.constuctor = Malevar man = new Male('Tom', 'Male', 10)man.printName()//'Tom' hasOwnProperty判断属性是自己的还是继承的 12m.hasOwnProperty('name')//truem.hasOwnProperty('printName')//false Promise对象回调地狱下列代码实现按顺序执行,1秒后执行fn1,再过1秒执行fn2,再过1秒执行fn3 123456789101112131415161718192021222324252627function fn1(callback) &#123; setTimeout(()=&gt;&#123; console.log('fn1') callback() &#125;, 1000)&#125;function fn2(callback) &#123; setTimeout(()=&gt;&#123; console.log('fn2') callback() &#125;, 1000)&#125;function fn3() &#123; setTimeout(()=&gt;&#123; console.log('fn3') &#125;, 1000)&#125;fn1(function()&#123; fn2(function()&#123; fn3() &#125;)&#125;) 由于层层嵌套,形成回调地狱.(如果套个十几二十个,真的要崩溃) 什么是PromisePromise是一个对象,对象里存储着状态.分别是pending(等待态),fulfilled(完成态),rejected(拒绝态)Promise 启动之后，当满足成功的条件时我们让状态从 pending 变成 fullfilled （执行 resolve）；当满足失败的条件，我们让状态从 pending 变成 rejected（执行 reject） Promise范例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//获取IPfunction getIp()&#123; return new Promise(function(resolve,reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET','https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getIp',true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson.ip) &#125; xhr.onerror = function()&#123; reject('获取IP失败') &#125; xhr.send() &#125;)&#125;//从IP获取城市function getCityFromIp(ip)&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET', 'https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip='+ip, true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson.city) &#125; xhr.onerror = function()&#123; reject('获取city失败') &#125; xhr.send() &#125;)&#125;//通过城市获取天气function getWeatherFromCity(city&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET', 'https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getWeatherFromCity?city='+city, true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson) &#125; xhr.onerror = function()&#123; reject('获取天气失败') &#125; xhr.send() &#125;)&#125;)getIp().then(function(ip)&#123; return getCityFromIp(ip)&#125;).then(function(city)&#123; return getWeatherFromCity(city)&#125;).then(function(data)&#123; console.log(data)&#125;).catch(function(e)&#123; console.log('出现了错误',e)&#125;)//getIP()得到一个promise对象,传入ip,返回另一个promise对象,依次往下//中途报错直接执行catch() Promise.all1234567891011121314151617181920212223function getCityFromIp(ip)&#123; return new Promise(function(resolve, reject)&#123; var xhr = XMLHttpRequest() xhr.open('GET','https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip='+ip',true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responText) resolve(retJson) &#125; xhr.onerror = function()&#123; reject('获取city失败') &#125; xhr.send() &#125;)&#125;var p1 = getCityFromIp('10.10.10.1')var p2 = getCityFromIp('10.10.10.2')var p3 = getCityFromIp('10.10.10.3')//Promise.all, 当所有的 Promise 对象都完成后再执行Promise.all([p1,p2,p3]).then(data =&gt; &#123; console.log(data)&#125;) Promise.race123456789101112131415161718192021222324252627function getCityFromIp(ip) &#123; var promise = new Promise(function(resolve, reject)&#123; var xhr = new XMLHttpRequest() xhr.open('GET', 'https://easy-mock.com/mock/5ac2f80c3d211137b3f2843a/promise/getCityFromIp?ip='+ip, true) xhr.onload = function()&#123; var retJson = JSON.parse(xhr.responseText) // &#123;"city": "hangzhou","ip": "23.45.12.34"&#125; resolve(retJson) &#125; xhr.onerror = function()&#123; reject('获取city失败') &#125; setTimeout(()=&gt;&#123; xhr.send() &#125;, Math.random()*1000) &#125;) return promise&#125;var p1 = getCityFromIp('10.10.10.1')var p2 = getCityFromIp('10.10.10.2')var p3 = getCityFromIp('10.10.10.3')//Promise.race, 谁的先输出就先执行谁Promise.race([p1, p2, p3]).then(data=&gt;&#123; console.log(data)&#125;) callback&amp;Promise&amp;async/await把一个需求不断简化需求如下: 读取 a.md 文件，得到内容 把内容转换成 HTML 字符串 把HTML 字符串写入 b.html callback()处理1234567891011121314var fs = require('fs')var markdown = require('markdown').markdownfs.readFile('a.md', 'UTF-8', function(err,str)&#123; if(err)&#123; return console.log(err) &#125; var html = markown.toHTML(str) fs.writeFile('b.html', html, function(err)&#123; if(err)&#123; return console.log(err) &#125; console.log('write.success') &#125;)&#125;) ES6语法简化处理1234567891011121314let fs = require('fs')let markdown = require('markdown').markdownfs.readFile('a.md', 'UTF-8', (err, str)=&gt;&#123; if(err)&#123; return console.log(err) &#125; let html = markdown.toHTML(str) fs.writeFile('b.html', html, (err)=&gt;&#123; if(err)&#123; return console.log(err) &#125; console.log('write.success') &#125;)&#125;) Promise处理1234567891011121314151617181920212223242526272829303132333435363738const fs = require('fs')const markdown = require('markdown').markdownreadFile('a.md') .then((mdStr)=&gt;&#123; return markdown.toHTML(mdStr) //返回结果作为下个回调函数 &#125;).then(html=&gt;&#123; writeFile('b.html', html) &#125;).catch((e)=&gt;&#123; console.log(e) &#125;)//对读取文件进行包装function readFile(url)&#123; return new Promise((resolve, reject)=&gt;&#123; fs.readFlie(url, 'UTF-8', (err, str)=&gt;&#123; if(err)&#123; reject(new Error('readFlie error')) &#125;else&#123; resolve(str) &#125; &#125;) &#125;)&#125;//对写入文件进行包装function writeFile(url, data)&#123; return new Promise((resolve, reject)=&gt;&#123; fs.writeFile(url, data, (err, str)=&gt;&#123; if(err)&#123; reject(new Error('write error')) &#125;else&#123; resolve() &#125; &#125;) &#125;)&#125; 使用模块改装上面代码123456789101112const markdown = require('markdown').markdownconst fsp = require('fs-promise') //用于把fs变promise化let onerror = err=&gt;&#123; console.error('something wrong')&#125;fsp.readFile('a.md', 'UTF-8') .then((mdStr)=&gt;&#123; return markdown.toHTML(mdStr) &#125;).then(html=&gt;&#123; fsp.writeFile('b.html', html) &#125;).catch(onerror) async/await处理12345678910111213const markdown = require('markdown').markdownconst fsp = require('fs-promise')let onerror = err=&gt;&#123; console.error('sonething wrong')&#125;async function start()&#123; let mdStr = await fsp.readFile('a.md', 'UTF-8') let html = markdown.toHTML(mdStr) await fsp.writeFile('b.html', html)&#125;start().catch(onerror)]]></content>
      <categories>
        <category>JS</category>
        <category>JS进阶</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas画板]]></title>
    <url>%2F2019%2F08%2F27%2Fcanvas%2F</url>
    <content type="text"><![CDATA[简介canvas本身没有绘图能力，只是定义了一个容器，都是由canvas内部的CanvasRenderingContext2D对象来做，需要我们用 JavaScript脚本 完成绘制工作。 基础 html引入&lt;canvas&gt;标签&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; js获取&lt;canvas&gt;属性,使用2d绘制上下文. 123var canvas = getElementById("canvas")var context = canvas.getContext("2d")//使用context进行绘制 设置宽高使用canvas.width设置宽度.canvas.height设置高度. 123456789101112131415161718&lt;body&gt;&lt;canvas id="canvas" sytle="border: 1px solid #aaa;display: block;margin: 50px auto;"&gt;&lt;/canvas&gt;&lt;script&gt; window.onload = function()&#123; var canvas = document.getElementById("canvas") canvas.width: 1024; canvas.height: 768; if(canvas.getContext("2d"))&#123; //如果浏览器支持canvas,可以使用 var context = canvas.getContext("2d") &#125;else&#123; alert('当前浏览器不支持,请使用谷歌浏览器') &#125; &#125;&lt;/script&gt;&lt;/body&gt; 设置全屏 12345let pageWidth = document.documentElement.clientWidth;let pageHeight = document.documentElement.clientHeight;canvas.width = pageWidth;canvas.height = pageHeight; 绘制线段1234567891011121314151617181920212223var context = canvas.getContext("2d")conext.beginPath()//开始第一段绘制,与其他绘制可以区别开context.moveTo(100,100)//以画布左上角为原点,从坐标(100,100)开始context.lineTO(700,700)//把线画到(700,700)位置context.lineTO(100,700)//折到(100,700)位置context.lineTO(100,100)//线段完成封闭,形成三角形context.closePath()//结束本段状态context.fillStyle="rgab(168,168,168)"//设置三角形填充颜色context.fill()//执行填充颜色context.lineWidth = 5 //设置线段宽度context.strokeStyle = "red" //设置线段颜色context.stroke//执行绘图conext.beginPath()//开始第二段绘制,与其他绘制可以区别开context.moveTo(200,100)//以画布左上角为原点,从坐标(200,100)开始context.lineTO(700,600)//把线画到(700,600)位置context.closePath()//结束本段状态context.strokeStyle = "blue" //设置线段颜色context.stroke//执行第二段绘图 标签属性 标签 描述 height 设置 canvas 的高度 width 设置 canvas 的宽度 fill() 可以填充 fillRect(x,y,width,height) 绘制一个矩形边框 fillRect(x,y,width,height) 绘制一个填充的矩形 clearRect(x,y,width,height) 清除指定矩形区域，让清除部分完全透明 ctx.strokeStyle 可以改变画笔颜色 ctx.beginPath() 设置开始路径 ctx.moveTo(x,y) 设置起点 ctx.lineTo(x,y) 设置终点 ctx.stroke() 绘制 ctx.closePath() 结束路径 ctx.arc(弧形圆心x坐标，y坐标，半径，起始角(以3点钟的位置开始)，结束角、方向(true表示逆时针，false表示顺时针)) 绘制一个弧形 ctx.quadraticCurveTo(cpx,cpy,x,y)参数是控制点x坐标，控制点y坐标，结束点x坐标，结束点y坐标 绘制二次贝塞尔曲线 ctx.quadraticCurveTo(cpx1,cpy1,cpx2,cpy2,x,y)参数是控制点1的x坐标，控制点1的y坐标，控制点2的x坐标，控制点2的y坐标，结束点x坐标，结束点y坐标 绘制三次贝塞尔曲线 canvas画板代码实现html12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;div id="actions"class="actions x"&gt; &lt;svg id="pen"class="icon"&gt; &lt;use xlink:href="#icon-pencil"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="eraser"class="icon"&gt; &lt;use xlink:href="#icon-eraser"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="clear"class="icon"&gt; &lt;use xlink:href="#icon-delete"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;svg id="download"class="icon"&gt; &lt;use xlink:href="#icon-download"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;ul class='colorCir'&gt; &lt;li id="black"class="black"&gt;&lt;/li&gt; &lt;li id="red"class="red"&gt;&lt;/li&gt; &lt;li id="yellow"class="yellow"&gt;&lt;/li&gt; &lt;li id="blue"class="blue"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class='lineWidth'&gt; &lt;li id="thin" class="thin"&gt;&lt;/li&gt; &lt;li id="thick" class="thick"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127*&#123; margin:0; padding:0;&#125;body&#123; background:#eee&#125;ul,ol&#123; list-style: none; &#125;.colorCir&#123; top:60px; left:20px; position: fixed; &#125;.colorCir li&#123; border: 1px solid grey; height:20px; width: 20px; border-radius: 50%; margin-bottom:10px;&#125;.colorCir .red&#123; background:red;&#125; .colorCir .yellow&#123; background:yellow;&#125; .colorCir .blue&#123; background:blue;&#125; .colorCir .black&#123; background:black;&#125; .colorCir .red.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .yellow.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .blue.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.colorCir .black.active&#123; transform: scale(1.2); transition: all 0.3s;&#125;.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; &#125;body&#123; overflow: hidden;&#125;#canvas&#123; display: block; position: fixed; top:0px; left:0px;&#125;.actions&#123; position: fixed; top:0px; left:0px; padding-top:20px; padding-left:15px;&#125;.actions svg&#123; width:1.5em; height:1.5em; transition: all 0.3s; margin:0 5px;&#125;.actions svg.active&#123; fill:red; transform: scale(1.2);&#125;.lineWidth&#123; position: relative; left:-10px; top:140px;&#125;.lineWidth .thin&#123; height:0px; width:40px; border-top:2px solid black; margin:15px;&#125;.lineWidth .thick&#123; height:0px; width:40px; border-top:6px solid black; margin:15px;&#125;.lineWidth .thin.active&#123; transform: scale(1.2); &#125;.lineWidth .thick.active&#123; transform: scale(1.2);&#125; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208var canvas=document.getElementById('canvas');var context=canvas.getContext('2d');var using=false;var lastPoint=&#123; x:undefined, y:undefined&#125;/*画板逻辑 */autoSetSize(canvas);listenToUser(canvas);/********///画笔、橡皮擦按钮替换var eraserEnabled=false;pen.onclick=function()&#123; eraserEnabled=false; pen.classList.add('active'); eraser.classList.remove('active'); &#125;eraser.onclick=function()&#123; eraserEnabled=true; eraser.classList.add('active'); pen.classList.remove('active');&#125; //颜色替换并高亮red.onclick=function()&#123; context.fillStyle ="red"; context.strokeStyle="red"; red.classList.add('active'); yellow.classList.remove('active'); blue.classList.remove('active'); black.classList.remove('active');&#125;yellow.onclick=function()&#123; context.fillStyle ="yellow"; context.strokeStyle="yellow"; yellow.classList.add('active'); red.classList.remove('active'); blue.classList.remove('active'); black.classList.remove('active');&#125;blue.onclick=function()&#123; context.fillStyle ="blue"; context.strokeStyle="blue"; blue.classList.add('active'); yellow.classList.remove('active'); red.classList.remove('active'); black.classList.remove('active');&#125;black.onclick=function()&#123; context.fillStyle ="black"; context.strokeStyle="black"; black.classList.add('active'); yellow.classList.remove('active'); blue.classList.remove('active'); red.classList.remove('active');&#125;/********/thin.onclick=function()&#123; thin.classList.add('active'); thick.classList.remove('active'); context.lineWidth=2;&#125;thick.onclick=function()&#123; thick.classList.add('active'); thin.classList.remove('active'); context.lineWidth=4;&#125;clear.onclick=function()&#123; context.clearRect(0,0,canvas.clientWidth,canvas.clientHeight); &#125;download.onclick = function()&#123; var url = canvas.toDataURL('image/png'); var a = document.createElement('a'); document.body.appendChild(a); a.href=url; a.download='my drawing'; a.click();&#125;/********//********//********///drawLinefunction drawLine(x1,y1,x2,y2)&#123; context.beginPath(); context.moveTo(x1,y1); context.lineTo(x2,y2); context.stroke(); context.closePath(); &#125;//drawCirfunction drawCir(x,y)&#123;context.beginPath()context.arc(x,y,0.1,0,Math.PI*2);context.fill();&#125;//重置canvas画板宽高function setCanvasSize()&#123; var pageWidth=document.documentElement.clientWidth; var pageHeight=document.documentElement.clientHeight; canvas.width = pageWidth; canvas.height = pageHeight; &#125;//自动设置canvas画板宽高function autoSetSize()&#123; setCanvasSize(); window.onresize =function()&#123; setCanvasSize(); &#125; &#125;function preventBehavior(e) &#123; e.preventDefault()&#125; document.addEventListener("touchmove", preventBehavior, false) function listenToUser()&#123; //特性检测 if(document.body.ontouchstart!== undefined )&#123; //是触屏设备 canvas.ontouchstart =function(aaa)&#123; var x=aaa.touches[0].clientX; var y=aaa.touches[0].clientY; using=true; lastPoint=&#123;x:x,y:y&#125;; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); &#125; &#125; // canvas.ontouchmove = function(aaa)&#123; var x=aaa.touches[0].clientX; var y=aaa.touches[0].clientY; var newPoint=&#123;x:x,y:y&#125; if(using)&#123; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); drawLine(lastPoint.x,lastPoint.y,newPoint.x,newPoint.y) lastPoint=newPoint; &#125; &#125; &#125; canvas.ontouchend = function(aaa)&#123; using=false; &#125; &#125;else&#123; //不是触屏设备 canvas.onmousedown=function(aaa)&#123; var x=aaa.clientX; var y=aaa.clientY; using=true; lastPoint=&#123;x:x,y:y&#125;; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); &#125; &#125; //鼠标移动监听 canvas.onmousemove=function(aaa)&#123; var x=aaa.clientX; var y=aaa.clientY; var newPoint=&#123;x:x,y:y&#125; if(using)&#123; if(eraserEnabled)&#123; context.clearRect(x-10,y-10,20,20); &#125;else&#123; drawCir(x,y); drawLine(lastPoint.x,lastPoint.y,newPoint.x,newPoint.y) lastPoint=newPoint; &#125; &#125; &#125; //鼠标松开监听 canvas.onmouseup=function(aaa)&#123; using=false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JS</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2019%2F08%2F23%2Fcss%2F</url>
    <content type="text"><![CDATA[css,即层叠样式表,可以为网页添加样式. 应用方式外部样式表 通过&lt;link&gt;引入&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; 通过@import引入,注意末尾加;号,CSS语法,只能在CSS内使用. 1234&lt;style&gt;@import url("index.css");@import "index.css";&lt;/style&gt; 媒体查询(响应式) 12345678&lt;style&gt;@media (min-width: 801px) &#123; body &#123; margin: 0 auto; width: 800px; &#125;&#125;&lt;/style&gt; 内部样式表将css放到&lt;style&gt;元素中,一般放到文档的&lt;&gt;中. 12345678910111213141516&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;style&gt;h1 &#123; background: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;AMD yes!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 内联样式&lt;p style=&quot;background: red; font-size: 20px;&quot;&gt;AMD yes!&lt;p&gt; CSS选择器 基本选择器 名称 含义 * 通用选择器 匹配任何元素 E 标签选择器 匹配所有使用E标签的元素 .info class选择器 匹配所有class属性中包含info的元素 #footer id选择器 匹配所有id属性等于footer的元素 组合选择器 名称 含义 E,F 多元素选择器 同时匹配所有E元素或F元素 E F 后代选择器 匹配所有属于E元素后代的F元素 E&gt;F 子元素选择器 匹配所有E元素的直接子元素 E+F 直接相邻元素选择器 匹配E元素后的直接相邻元素 E~F 兄弟元素选择器 匹配E元素后的所有兄弟元素 属性选择器 含义 E[attr] 匹配所有具有attr属性的E元素 E[attr=val] 匹配所有attr属性等于val的E元素 E[attr~=val] 匹配所有attr属性具有多个空格分隔的值,其中一个等于val的E元素 E[attr =val] E[attr*=val] 匹配所有attr属性中包含val的E元素 E[attr^=val] 匹配所有attr属性中以val开头的E元素 E[attr$=val] 匹配所有attr属性中以val结尾的E元素 伪类 含义 E:first-child 匹配父元素的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经按下没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得焦点的E元素 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio或者checkbox元素 E:root 匹配文档的根元素,对于html文档,就是html元素 E:nth-child(n) 匹配其父元素的第n个子元素,第一个编号为1 E:nth-last-child(n) 匹配其父元素的倒数第n个子元素,第一个编号为1 E:nth-of-type 与nth-child类似,但仅匹配使用同种标签的元素 E:nth-last-child 与nth-last-child类似,但仅匹配使用同种标签的元素 E:last-child 匹配父元素的最后一个元素 E:first-of-type 匹配父元素下使用同种标签的第一个子元素 E:last-of-type 匹配父元素下使用同种标签的最后一个子元素 E:only-child 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1) E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1) E:empty 匹配一个不包含任何子元素的元素,注意,文本节点也被看做子元素 E:not(s) 匹配不符合当前选择器的任何元素 E:target 代表一个唯一的页面元素(目标元素)，其id 与当前URL片段匹配 伪元素 含义 E::first-line 匹配E元素的第一行 E::first-letter 匹配E元素的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 E::selection 匹配用户当前选中的元素 &gt;伪元素必须要有content # 选择器优先级 !important优先级最高(由于IE不支持!important，所以也可以利用它区分不同的浏览器。) 行内样式 &gt; id样式 &gt; class样式 &gt; 标签名样式 CSS基本样式div（块级元素）：高度是由内部文档流元素高度的总和决定的。文档流：文档内元素的流动方向，内联元素是从左往右，块级元素是从上往下span（内联元素）：高度是由其中文字高度决定的，内联元素设置width和height是无效的，上下的margin和padding也无效，要将它们设为display:inline-block才有效。 常见块级元素: div h1~h6 p hr form ul ol li table td tr th dl dt dd pre 常见内联元素: em strong span a br img button input label select textarea code script 尽量不写height和width，这两个属性会引出很多bug，要宽高的时候可以用padding，但img最好先写width，因为可以先占位，因为引用图片时浏览器不知道图片大小，所有等图片下载完成，它后面的元素又要重新排位置，若先写好width，则不用重排，知道height也可以先写好height。另外span元素设置padding的时候要将它设为display:inline-block，因为内联元素不能设置宽高，inline-block具有inline的同行特性，也具有block的高度特性。对于display:inline(内联元素)的元素，设置width/height/上下margin和padding都是无效的 inline-block inline-block 之间空隙 inline-block 之间有空格、Tab、换行符。 给父元素设置 font-size: 0，在 inline-block 元素上重新设置 font-size。 inline-block 导致父元素增高若干像素 给 inline-block 元素设置 vertical-align: top 通用解决办法 不要设置 inline-block，使用 float 或 flex。 浏览器默认样式浏览器对某些元素设置有默认样式，如 h1, ul, li 等。 常见处理方式 Normalize.css CSS Reset 简单去除1234* &#123; margin: 0; padding: 0;&#125; CSS常见样式边框border1234567891011.box &#123; border-width: 1px; border-color: red; border-style: solid; border-bottom: none;//下边框消失 border-radius: 50%;//圆角&#125;//简写.box2 &#123; border: 1px red solid;&#125; 内边距paddingpadding: 10px 20px 30px;//按照上右下左,即顺时针,缺哪个补哪个,缺左边,按20px补上. 外边距marginmargin可以合写,可以分开.可以是数值,可以是百分比(相对于父元素).还可以是负值.有外边距合并问题 display 块级: block,list-item,table 行内: inline,inline-table,inline-blockfont123456789body&#123; font: 12px/1.5 Arial;&#125;p&#123; line-height: 1.5;//行高是字体的1.5倍 font-size: 14px;//字体大小 font-family: Arial;//字体 font-weight: bold;//文字粗度,粗体&#125; Chrome默认字体是16px,最小字体是12px. 文本 text-aglin: 文本对齐方式,left,right,center,justify text-ident: 文案第一行缩进距离 text-decoration: 划线,none,underline,line-through,overline text-transform: 改变文字大小写,none,uppercase,lowercase,captialize word-spacing: 可以改变字(单词)之间的标准间距 letter-spacing: 字母之间的间隔单行文本溢出加…12345.box&gt;h3 &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 颜色 单词: red,blue,black,pink,yellow 十六进制: #000000(黑),#fff(白),#eee(淡灰),#ccc(灰色),#666(深灰) rgb:rgb(255,255,255)白色,rgba(0,0,0,0.5)透明度为0.5的黑色单位px rpx em rem的区别 px是像素pixel，相对于屏幕分辨率的单位 em是相对单位，相对于当前对象内的文本尺寸。如果没有设置，则相对浏览器默认尺寸16px，1em=16px。为了简化，可以将body里font-size=62.5%，那么em就是16px*62%=10px。1em=10px em特点：em值不固定，会继承父元素字体大小 rem是root em。只相对于html根元素 rpx是微信小程序的方案1px=2rpx vh vw: 相对单位,1vw为屏幕宽度的1%background background-color: transparent 透明背景;颜色值;半透明浮层的背景颜色建议使用 rgba() 而不是 opacity 设置透明度。 background-image: url(../images/bg.png);// 属性用于给元素设置一张或多张背景图。 background-repeat 控制背景图片的重复方式。no-repeat不重复;repeat-x水平方向重复;repeat-y 垂直方向重复; background-position 设置背景图的位置。x y;x% y%;[top|center|bottom][left|center|right] background-size 设定背景图片的大小。IE9 以下不支持;cover缩放背景图片以完全覆盖背景区，可能背景图片部分看不见;contain缩放背景图片以完全装入背景区，可能背景区部分空白。 background-clip: 设置元素背景区域覆盖的范围.border-box 覆盖至边框的最外围;padding-box 覆盖至内边距的最外围;content-box 仅覆盖元素内容区域 缩写: 123.avatar &#123; background: #fff url(avatar.svg) no-repeat left center;&#125; 隐藏or透明 opacity: 0;//透明度为0,整体 visibility: hidden;//和opacity: 0;类似 display: none;//消失,不占用位置 background-color: rgba(0,0,0,0.2);//只是背景色透明box-shadowbox-shadow: -16px 0 16px 1px rgba(102,102,102,0.4);第一个值代表阴影左右偏移，正数往右，负数往左第二个值代表上下偏移，正往下，负往上第三个值越大，模糊面积越大越淡第四个值取正值时，阴影扩大，取负值时，阴影收缩line-height line-height: 2;//本身字体高度的2倍 line-height: 200%;//父元素高度的2倍,父元素没写行高就是默认16px*2=32px height=line-height;//垂直居中单行文本盒模型 标准盒模型: border-box,即padding,border不在width,height范围内 IE盒模型: content-box,即width=content尺寸+padding+border css3可以设置box-sizing: content-box;//标准盒模型 positionCSS position属性用于指定一个元素在文档中的定位方式。语法: static | relative | absolute | sticky | fixed static: 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 relative: 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table元素无效. absolute: 不为元素预留空间，通过指定元素相对于最近的非 static 定位父元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 fixed: 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 sticky: 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。相对定位(relative)相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。绝对定位(absolute,fixed)相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）。固定定位(fixed)固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。粘性定位(sticky)粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。#one { position: sticky; top: 10px; }在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。(理解为大于10px时,属于相对定位,可以在页面滚动时随之滚动,当距视口10px时,固定了,就像粘在那里了)浮动float: left;//向左浮动 浮动元素并不是完全意义上的脱离文档流,至少普通元素里的文本可以发现,行内元素也可以发现 设置浮动会让块级元素从左到右或从右到左排列. 块级元素设置浮动呈现inline-block特性,不再撑开父元素,宽度也会收缩 行内元素设置浮动呈现inline-block特性,可以设置宽高.清除浮动问题: 对后续元素位置产生影响 父容器高度计算出现问题通用解决方案12345678910父元素加clearfix.clearfix::after&#123; content:''; display: block; clear: both;&#125;.clearfix&#123; *zoom: 1 //兼容IE6,7&#125; BFC(块级格式化上下文)决定了其子元素将如何定位,以及其他元素的关系和相互作用在正常流中的盒子要么属于块级格式化上下文,要么属于内联格式化上下文 BFC的产生 根元素 float不为none; position: absolute/fixed; display: inline-block/flex/inline-flex/table-cell; overflow不为visible; 特性 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算作用 阻止margin合并 contain float 边距合并合并场景 相邻元素合并,间距为二者中较大值 父子合并 自己合并取消合并 加border,padding BFC CSS布局单栏布局方式: 定宽+水平居中 123456&lt;style&gt;.layout&#123;max-width: 100px;margin: 0 auto;&#125;&lt;/style&gt; 通栏的话再加一层div,单独给div设置背景色即可 双列布局固定margin+浮动元素先设置浮动,再设置普通元素,最后清除浮动 flex布局display:flex一个容器 设置了display:flex属性,就定义了一个flex容器.它的直接子元素会接受这个flex环境. flex-direction1234.container&#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 设置子元素在父容器中的位置1.row默认值,水平从左到右2.row-reverse,从右到左3.column,垂直从上到下4.column-reverse,垂直从下到上 flex-wrap设置换行 1234.container&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125;依次为:不换行,换行,换行切颠倒顺序 flex-flowflex-direction和flex-wrap的缩写,默认值row nowrapflex-flow: &lt;&#39;flex-direction&#39;&gt; || &lt;&#39;flex-wrap&#39;&gt; justify-content设置子元素在水平方向上的对齐方式 1234.container&#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125;分别是水平靠左,水平靠右,水平居中,均匀分布,均匀分布且两端保留子元素间距一半(空间包裹) align-items设置子元素在垂直方向上的对齐方式 1234.container&#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125;分别是垂直靠上,垂直靠下,垂直居中,垂直基线对齐,垂直方向拉伸 align-content设置子元素整体内容的在垂直方向上的对齐方式 1234.container&#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125;分别是整体靠上,整体靠下,整体居中,整体垂直拉伸,整体垂直均匀排列,整体均匀分布且垂直两端保留间距一半空间 用在子元素上的属性order默认情况下flex order会按照书写顺序排列,可以通过order属性改变,数值小的在前面,也可以是负数. 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow.item {flex-grow: 1}按比例瓜分父元素剩余的空间,1即分一份.不写默认是0 flex-basis基准宽度 flex-shrink按比例吸收超出的空间.不写默认是1 flex flex-grow,flex-shrink,flex-basis的缩写 123.item&#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt; || &lt;''flex-basis'&gt;]&#125; aglin-self单独修改自身的属性 Grid布局父元素Grid container的属性display将元素定义为gird container,并为其建立新的网格格式化上下文 1234.container&#123; display: grid | inline-grid | subgrid;&#125;分别是生成一个块级网格;一行网格;如果本身是gird-item,可从父元素获取行列大小 gird-template-columns和gird-template-rows设置网格的列和行 1234.container&#123; gird-template-columns: 40px 50px auto 50px 40px; grid-template-rows: 25% 100px auto;&#125; 简化写法’’ 1234567.container&#123; gird-template-columns: repeat(3, 20px [col-start]) 5%;&#125;等价于.container&#123; gird-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;&#125; “fr”单位允许将轨道大小设置为网格容器自由空间的一部分.如下代码会将每个gird item设置为gird container宽度的三分之一 123.container&#123; .grid-template-columns: 1fr 1fr 1fr;&#125; gird-template-areas — 使用gird-area属性设置的网络区域的名称 . — 点号代表一个空网格单元 none — 没有定义网格单元1234567891011121314151617181920.item-a &#123; grid-area: header;&#125;.item-b &#123; grid-area: main;&#125;.item-c &#123; grid-area: sidebar;&#125;.item-d &#123; grid-area: footer;&#125;.container &#123; grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: "header header header header" "main main . sidebar" "footer footer footer footer";&#125; 这将创建一个四列宽三行高的网格。 整个第一行将由 header 区域组成。 中间一行将由两个 main 区域、一个空单元格和一个 sidebar 区域组成。 最后一行是footer区域组成。 居中水平居中 块级元素水平居中 12margin-left:auto;margin-right:auto; 内联元素水平居中，给它们的父元素加上 1text-align:center; 若不是内联元素想让它居中，可加display:inline-block，加了之后一般还要加下面这句，不然可能会有bug（下面可能会空出一行） 1vertical-align: top; 让导航栏横过来，并在同一行里均匀分布给ul加css1234ul&#123; display:flex; justyfy-content:space-between;&#125; 去掉li的float:left去掉ul的clearfix 垂直居中 若父元素没有写height，则直接在父元素写1padding: 10px 0; 子元素就可以居中，所以尽量避免父亲高度确定 让一个元素在父级元素中绝对居中方法一：给父级元素加:1position:relative; //若父级元素是body可以不用加 再给自己加： 12345678div&#123; position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: auto;&#125; 方法二：（若不兼容IE，工作中只要用这一种方法即可，最简单，Chrome，移动端都可以用）给父元素加： 123display: flex; //让它变成一个弹性盒justify-content: center; //水平居中align-items: center; //垂直居中 table自带居中（兼容IE）1234567891011121314151617181920&lt;html&gt;&lt;style&gt;.parent&#123; border: 1px solid red; height: 600px;&#125;.child&#123; border: 1px solid green;&#125;&lt;/style&gt;&lt;body&gt;&lt;table class="parent"&gt; &lt;tr&gt; &lt;td class="child"&gt; 文字 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 文字会居中 用div假扮table（兼容IE） 123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;style&gt;div.table&#123; display: table; border: 1px solid red; height: 600px;&#125;div.tr&#123; display: table-row; border: 1px solid green;&#125;div.td&#123; display: table-cell; border: 1px solid blue; vertical-align: middle;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="table"&gt; &lt;div class="tr"&gt; &lt;div class="td"&gt; 文字 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用100%高度的before和after 12345678910111213141516171819202122232425.parent&#123; border: 3px solid red; height: 600px; text-align: center;&#125;.child&#123; border: 3px solid black; display: inline-block; width: 300px; vertical-align: middle;&#125;.parent:before&#123; content:''; display: inline-block; height: 100%; vertical-align: middle;&#125;.parent:after&#123; content:''; display: inline-block; height: 100%; vertical-align: middle;&#125; 绝对定位加上margin-top: -自身height的50% 123456789101112131415161718192021222324252627&lt;html&gt;&lt;style&gt;.parent&#123; height: 600px; border: 1px solid red; position: relative;&#125;.child&#123; border: 1px solid green; width: 300px; position: absolute; top: 50%; left: 50%; margin-left: -150px; height: 20px; margin-top: -10px; text-align: center;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="parent"&gt; &lt;div class="child"&gt; 文字 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 媒体查询(响应式)12345678910111213141516&lt;style&gt; /* 屏幕宽度为300px-325px时的css样式 */ @media(min-width: 300px) and (max-width: 325px)&#123; body&#123; background: red; &#125; &#125; /* 屏幕宽度小于450px时的css样式 */ @media(max-width: 450px)&#123; body&#123; background: black; &#125; &#125; /* 这样前面那个就没用了，被覆盖了 */&lt;/style&gt; 一般不用第一个方法，直接引用一个手机版的css即可 &lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width:768px)&quot; href=&quot;mobile.css&quot;&gt;在屏幕宽度小于768px时，就会渲染这个css，要把这个引用写在main.css之后，把main.css覆盖。并加上meta:vp&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; CSS动画transition(过渡)transition的作用在于指定状态变化所需要的时间. 123div&#123; transition: 1s;&#125; 指定属性可以指定transition使用的属性,比如只适用于heighttransition: 1s height; delay(延迟)transition: 1s height,1s 1s width;width在一秒之后在开始变化,也就是延迟一秒.delay可以指定动画发生的顺序,使得不同transition可以连在一起,形成不同效果. transition-timing-function(缓动函数)transition的状态变化速度,默认不是匀速的,而是逐渐放慢的,这叫做ease.transition: 1s ease;除了ease,其他模式还有: linear: 匀速 ease-in: 加速 ease-out: 减速 cubic-bezier: 自定义速度模式(可以在cubic-bezier.com里设置)语法简写:transition: 1s 1s height ease;完整写法:1234transition-property: height;transition-duration: 1s;transition-delay: 1s;transition-timing-function: ease; 注意 transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态，什么none到block之类的是不行的 transition是一次性的，不能重复发生，除非一再触发animation(动画)使用animation首先需要定义动画过程,即关键帧12345@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 写动画帧里的css记得加;号.定义关键帧后可以给DOM元素绑定动画,和事件比较像.加infinite代表无限次,改成数字就是循环多少次. 123div:hover &#123; animation: 1s rainbow infinite;&#125; animation-fill-mode动画结束后,会立即跳到结束状态,如果想让动画保持在结束状态,需要使用animation-fill-mode属性. 123div:hover&#123; animation: 1s rainbow forwards;&#125; animation-fill-mode的属性: none: 默认值,回到动画未开始的状态. forwards: 让动画停留在结束状态 backwards: 让动画回到第一帧的状态 both: animation-direction轮流应用forwards和backwards规则animation-direction动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变顺序默认情况是，animation-direction等于normal.此外，还可以等于取alternate(先从前往后再从后往前)、reverse(从后往前)、alternate-reverse等值.123div:hover &#123; animation: 1s rainbow 3 normal;&#125; animation-play-state有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态，如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。 12345678div &#123; animation: spin 1s linear infinite; animation-play-state: paused;&#125;div:hover &#123; animation-play-state: running;&#125; 语法简写: 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 完整: 123456789div:hover &#123; animation-name: rainbow; animation-duration: 1s; animation-timing-function: linear; animation-delay: 1s; animation-fill-mode:forwards; animation-direction: normal; animation-iteration-count: 3;&#125; 0%可以用from代表，100%可以用to代表，因此上面的代码等同于下面的形式 12345@keyframes rainbow &#123; from &#123; background: #c00 &#125; 50% &#123; background: orange &#125; to &#123; background: yellowgreen &#125;&#125; steps(分步过渡)浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡。 123div:hover &#123; animation: 1s rainbow infinite steps(10);&#125; 歌词效果12345678910111213141516171819202122232425262728293031323334&lt;style&gt;@keyframes moving &#123; from &#123; width: 0; &#125;&#125;.line &#123; position: relative;&#125;p &#123; width: 600px; font-size: 40px; white-space: nowrap; overflow: hidden; position: absolute; top: 0; z-index: 2;&#125;p:nth-child(1) &#123; color: red; animation: moving 20s&#125;p:nth-child(2) &#123; z-index: -1; color: #666;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class="line"&gt; &lt;p&gt;To my days change my ways为生活我试着不断改变&lt;/p&gt; &lt;p&gt;This sudden end to my days这生命的终点突如其来&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 打字机效果12345678910111213141516171819202122&lt;style&gt;@keyframes typing &#123;from &#123; width: 0 &#125; &#125;@keyframes blink-caret &#123; 50% &#123; border-clolr: transparent &#125; &#125;h1 &#123; border-right: 0.1em solid; color: #fff; width: 352px; height: 30px; white-space: nowrap; overflow: hidden; animation: typing 5s steps(11, end),//变11次变成最终状态 blink-caret .5s infinite alternate;&#125;body &#123; background: #000; height: 100vh;&#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;躺在你的学校操场看星空&lt;/h1&gt;&lt;/body&gt; transform(变形)transform属性主要包括rotate(旋转),skew(扭曲),scale(缩放),translate(移动),matrix(矩阵变形)transform ： none | [ ]*transform中使用多个属性时却需要有空格隔开，可用于内联(inline)元素和块级(block)元素 rotate(旋转)可以通过rotate使元素旋转一定的度数transform: rotate(30deg)//顺时针旋转30度 旋转之后元素仍占据原来位置，实际上所有的transform都是这样，缩放、位移等都不会改变元素占据的位置 元素旋转的的基点默认是中心，可以通过transform-origin属性改变transform:rotate(30deg); transform-origin: 0% 0%;transform-origin的取值可以是: top, bottom, left, right, center 百分数translate(位移)transform: translateY(100px)//Y轴位移100px;scale(缩放)scale(x,y): 使元素水平方向和垂直方向同时缩放transform: translate(3)//相同的比例缩放两个方向skew(扭曲)通过skew使元素扭曲一定的度数transform:skew(10deg, 20deg);//x轴扭曲10度,y轴扭曲20度3D元素需要设置需要设置perspective来激活3D效果 transform: perspective( 600px ); perspective: 600px;perspective属性的值决定了3D效果的强烈程度，可以认为是观察者到页面的距离。越大距离越远，视觉上的3D效果就会相应的减弱。3D变形方法rotateX( angle )rotateY( angle )rotateZ( angle )translateZ( tz )scaleZ( sz )translateX()方法使元素延X轴移动，translateZ()使元素延Z轴（在3D空间中方向从前到后）移动。正值使元素离观察者更近，负值使元素变远。]]></content>
      <categories>
        <category>css</category>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F08%2F22%2FjQuery%2F</url>
    <content type="text"><![CDATA[选择器 jQuery基本选择器 解释 $(‘*‘) 匹配所有元素 $(‘#id’) id选择器 $(‘.class’) 类选择器 $(‘element’) 标签选择器 组合选择器 解释 $(‘E,F’) 多元素选择器，同时匹配E和F $(‘E F’) 后代选择器,用空格分隔,匹配E元素所有后代 $(‘E&gt;F’) 子元素选择器,匹配E元素所有直接子元素 $(‘E+F’) 直接相邻元素,匹配E元素之后的相邻的同级元素F $(‘E~F’) 普通相邻元素(弟弟选择器),匹配E元素之后的同级元素F(无论是否直接相邻) $(‘class1.class2’) 匹配类名中既含有class1又含有class2的元素 基本过滤选择器 解释 $(‘E:first’) 所有E中的第一个 $(‘E:last’) 所有E中的最后一个 $(‘E:not(selector)’) 按照selector过滤E $(‘E:even’) 所有E中index是偶数 $(‘E:odd’) 所有E中index是奇数 $(‘E:eq(n)’) 所有E中index为n的元素 $(‘E:gt(n)’) 所有E中index大于n的元素 $(‘E:lt(n)’) 所有E中index小于n的元素 $(‘header’) 选择h1~h6元素 $(‘div:animated’) 选择正在执行动画效果的元素 内容过滤器 解释 $(‘E:contains(value)’) 内容包含value的元素 $(‘E:empty’) 内容为空的元素 $(‘E:has(F)’) 子元素中有F的元素,$(‘div:has(a)’):包含a标签的div $(‘E:parent’) 父元素是E的元素 可视化选择器 解释 $(‘E:hidden’) 所有被隐藏的E $(‘E:visible’) 所有可见的E 属性过滤选择器 解释 $(‘E[attr]’) 含有属性attr的E $(‘E[attr=value]’) 属性attr=value的E $(‘E[attr !=value]’) 属性attr！=value的E $(‘E[attr ^=value]’) 属性attr以value开头的E $(‘E[attr $=value]’) 属性attr以value结尾的E $(‘E[attr *=value]’) 属性attr包含value的E $(‘E[attr][attr*value]’) 可以连用 子元素过滤器 解释 $(‘E:nth-child(n)’) E的第n个子节点 $(‘E:nth-child(3n+1)’) E的第3n+1个子节点 $(‘E:nth-child(even)’) E的index为偶数的子节点 $(‘E:nth-child(odd)’) E的index为奇数的子节点 $(‘E:first-child’) 所有E的第一个子节点 $(‘E:last-child’) 所有E的最后一个子节点 $(‘E:only-child’) 只有唯一子节点的E的子节点 表单元素选择器 解释 $(‘E:type’) 特定类型的input $(‘:checked’) 被选中的checkbox或者radio $(‘option:selected’) 被选中的option 其他查找相关元素的方法.eq(index), .get([index])$(&#39;div&#39;).eq(3) //获取所有div中第4个jQuery对象$(&#39;div&#39;)[2] 或者 $(&#39;div&#39;).get(2) //获取第三个的DOM对象get()不写参数把所有对象转为DOM对象返回 兄弟元素获取 选择器 解释 .next([selector]) 没有写selcetor,返回所有后面的兄弟元素.写了就返回满足条件的 .prev([selector]) 和上面相反,获取前面的兄弟元素 .nextAll([selector]) 获取所有后面的兄弟元素 .prevAll([selector]) 获取所有前面的兄弟元素 .siblings([selector]) 获取所有前后邻居的元素 父子元素获取 选择器 解释 .parent([selector]) 获取父元素,可选筛选器 .parents([selector]) 获取祖先元素,可选筛选器 .children([selector]) 获取子元素,可选筛选器 .find([selector]) 查找符合选择器的后代 筛选当前结果集 选择器 解释 .first() 获取当前结果集第一个对象 .last() 获取当前结果集最后一个对象 .filter(slector), .filter(function(index)) 筛选当前结果集符合条件的对象 .not(selector), .not(function(index)) 从当前结果集中移除指定元素 .is(selector), is(function(index)), is(dom/jqObj) 判断结果集中的元素，是否为一个选择器，DOM元素，或者jQuery对象，如果这些元素至少一个匹配给定的参数，那么返回true .has(seletor), has(dom) 筛选匹配结果集中符合条件的后代元素 jQueryDOM操作创建元素将DOM传入$方法即可返回一个jQuery对象var obj = $(&#39;&lt;div class=&quot;test&quot;&gt;&lt;p&gt;&lt;span&gt;Done&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&#39;) 添加元素 方法 解释 示例 .append(content[,content]) / .append(function(index,html)) 可以添加多个内容,DOM对象,字符串,jQuery对象 $(‘p’).append($newdiv); $(‘p’).append($(‘strong’)); $(‘p’).append(document.createTextNode(‘hello’)) .appendTo(target) 把对象插入到目标target尾部,可以是selector,DOM对象,字符串,元素集合,jQuery对象(最后一个孩子) $(‘h2’).appendTo($(‘.container’)); $(‘&lt;p&gt;Test&lt;/p&gt;’).appendTo(‘.inner’) .prepend(content[,content]) / .prepend(function(index, html)) 向头部追加内容,内容添加到最前面(第一个孩子) $(‘.inner’).prepend(‘&lt;p&gt;Test&lt;/p&gt;’) .prependTo(Target) 把对象插入到目标头部 $(‘&lt;p&gt;Test&lt;/p&gt;’).prependTo(‘.inner’) .before([content][,content]) / .before(function) 在对象前面(不是头部,而是外面,和对象并列同级)插入内容(放到前面做邻居) $(‘.inner’).before(‘&lt;p&gt;Test&lt;/p&gt;’); $(‘.container’).before($(‘h2’)); $( “p” ).before( document.createTextNode( “Hello” ) ) .insertBefore(target) 把对象插入到target之前(不是头部,是同级)(做邻居) $(‘h2’).insertBefore($(‘.container)) .after([content][,content]) / .after(function（index）) 和before相反，在对象后面(不是尾部，而是外面，和对象并列同级)插入内容，参数和append类似 $( “.inner” ).after( “&lt;p&gt;Test&lt;/p&gt;” ); $( “p” ).after( document.createTextNode( “Hello” ) ); .insertAfter(target) 和insertBefore相反，把对象插入到target之后（同样不是尾部，是同级） $( “&lt;p&gt;Test&lt;/p&gt;” ).insertAfter( “.inner” ); $( “p” ).insertAfter( “#foo” ); 删除元素 方法 解释 示例 .remove([selector]) 删除被选元素及其子元素 $(‘.div’).remove() .empty() 清空被选元素内所有子元素 $(‘body’).empty() .detach() .detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。 $(‘.div’).detach() 包裹元素 方法 解释 示例 .wrap(wrapElement) / .wrap(function(index)) 为每个对象包裹一层HTML结构，可以是selector, element, HTML string, jQuery object $( “.inner” ).wrap( “&lt;div class=’new’&gt;&lt;/div&gt;” ) .wrapAll(wrappingElement) 把所有匹配对象包裹在同一个html结构里 $(‘.inner’).wrapAll(‘&lt;div class=”new”&gt;&lt;/div&gt;) .wrapInner(wrapingElement) 为每个匹配的对象包裹一层HTML结构 $(‘.inner’).wrapInner(‘&lt;div class=”new”&gt;&lt;/div&gt;) .unwrap 把DOM元素外的壳去掉 $(‘p’).unwrap() html([string])$(&#39;div&#39;).html()$(&#39;div&#39;).html(&#39;123&#39;)这是一个读写两用的方法,用于获取修改元素的innerHTML 没有传递参数的时候,返回元素的innerHTML 当传递一个string参数时,修改元素的innerHTML为参数值 text()和html方法类似，操作的是DOM的innerText值 jQuery属性操作属性相关.val([value])这是一个读写双用的方法,用来处理input的value值,当方法没有参数时返回input的value值.当传递一个参数时,方法修改input的value值为参数值. 12$('.input').val()$('.input').val('newValue') .attr().attr(attributeName)获取元素特定属性的值var title = $(&#39;em&#39;).attr(&#39;title&#39;) .attr(attributeName,value)/.attr(attributesJson)/.attr(attributeName,funtion(index,attr))为元素属性赋值$( &quot;#greatphoto&quot; ).attr( &quot;alt&quot;, &quot;Beijing&quot; ) .removeAttr()为匹配的元素集合中的每个元素移除一个属性$(&#39;div&#39;).removeAttr(&#39;id&#39;) .prop()/.removeProp()这两个方法是用来操作元素的property的 CSS相关.css().css(propertyName) / .css(propertyNames)获取元素style特定property的值 12345678var color = $( this ).css( "background-color" )var styleProps = $( this ).css([ "width", "height", "color", "background-color"]) .css(propertyName,value)/.css(propertyName,function(index,value))/ .css(propertiesJson)设置元素style特定property的值 123456789101112$( "div.example" ).css( "width", function( index ) &#123; return index * 50;&#125;)$( this ).css( "width", "+=200" )$( this ).css( "background-color", "yellow" )$( this ).css(&#123; "background-color": "yellow", "font-weight": "bolder"&#125;) .addClass(className) / .addClass(function(index,currentClass))为元素添加class，不是覆盖原class，是追加，也不会检查重复 12345$( "p" ).addClass( "myClass yourClass" )$( "ul li" ).addClass(function( index ) &#123; return "item-" + index;&#125;) .removeClass([className])/.removeClass(function(index,class))移除元素单个/多个/所有class 12345$( "p" ).removeClass( "myClass yourClass" );$( "li:last" ).removeClass(function() &#123; return $( this ).prev().attr( "class" );&#125;) .hasClass(className)检查元素是否包含某个class，返回true/false 1$( "#mydiv" ).hasClass( "foo" ) .toggleClass(className)toggle是切换的意思，方法用于切换，switch是个bool类型值 123456789&lt;div class="tumble"&gt;Some text.&lt;/div&gt;//第一次执行 $( "div.tumble" ).toggleClass( "bounce" )&lt;div class="tumble bounce"&gt;Some text.&lt;/div&gt;//第二次执行$( "div.tumble" ).toggleClass( "bounce" )&lt;div class="tumble"&gt;Some text.&lt;/div&gt; jQuery常用方法.each(fnction(index, Element))遍历一个jQuery对象,为每个匹配元素执行一个函数 12345$('li').each(function(index)&#123; console.log(index + ':' + $(this).text())&#125;)//回调函数返回的是DOM对象,所以this需要加$变成jQuery对象才能使用.text()方法//否则使用this.innerText方法 jQuery.each(collection, callback(indexInArray, valueOfElement))一个通用迭代函数,可以迭代对象和数组.数组和类数组对象通过长度属性来迭代数字索引,从0到length-1.其他对象通过其属性名进行迭代.上面jQuery可以用$替代,即$.each(). 1234567var obj = &#123; "fla" : "infla", "duh" : " no duh"&#125;$.each(obj, function(key, value)&#123; console.log(key + ":" + value)&#125; .map(callback(index, domElement))通过一个函数匹配当前集合中的每个元素,返回一个包含新的jQuery对象 123$('.div').map(function(i, ele)&#123; return this.id&#125;) jQuery.extend([deep,]target[,ovject1][,objectN]) 当提供两个或多个对象给$.extend(),对象的所有属性都添加到目标对象(target参数). 如果只有一个参数提供给$.extend(),这意味着目标参数被省略,在这种情况下,jQuery对象本身默认为目标对象.这样我们可以在jQuery的命名空间下添加新功能.var obj = $.extend({}, object1, object2)object1,object2会被添加到{}中 如果第一个对象的属性本身是一个数组或对象,那它将完全用第二个对象相同的key重写一个属性.这些值不会被合并.如果true作为第一个参数,那么会在对象上进行递归的合并. .clone([withDataAndEvents]).clone()方法深度复制所有匹配的元素集合,包括所有匹配元素,匹配元素的下级,文字节点.$(&#39;.hello&#39;).clone().appendTo(&#39;.Goodbye&#39;) .index()/.index(selector)/.index(element)从给定集合中查找特定元素index 没参数返回第一个元素index 如果参数是DOM对象或jQuery对象,则返回参数在集合中的index 如果参数是选择器,返回第一个匹配元素的index,没有找到返回-112var listItem = $('.bar')console.log('Index:' + $('li').index( listItem )) .ready(handler)当DOM加载完毕,执行.下面两种等价 $(document).ready(handler) $(handler) jQuery事件.on(events[,selector][,data],handler(eventObject)) events: 一个或多个空格分隔的事件类型和可选空间 selector: 一个选择器字符串,用于过滤被选中的元素中能触发事件的后代元素.如果选择器是null或者忽略,那么被选中的元素总能触发事件 data: 当一个事件被触发,要传递给事件处理函数的event.data handler(eventObject): 事件被触发时,执行的函数. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class="box"&gt;&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;input id="ipt" type="text"&gt;&lt;button id="btn"&gt;添加&lt;/button&gt;&lt;div id="wrap"&gt;&lt;/div&gt;&lt;script&gt;$('.box li').on('click',function()&#123; console.log(1) var str = $(this).text() $('#wrap').text(str)&#125;)//等同于$('.box&gt;ul&gt;li').click(function()&#123; console.log(2) var str = $(this).text() $('#wrap').text(str)&#125;)//下面新增的元素是没有绑定事件的$('btn').on('click',function()&#123; var value = $('#ipt').val() $('.box&gt;li').append('&lt;li&gt;' + value + '&lt;/li&gt;')&#125;)//可以用事件代理$('.box ul').on('click','li',function()&#123; var str = $(this).text() $('#wrap').text(Str)&#125;)//上面代码换成原生js代码document.querySelector('.box ul').addEventListener('click',function(e)&#123; if(e.target.tagName.toLowerCase() === 'li')&#123; //do something &#125;&#125;)&lt;/script&gt; .one(events[,selector][,data],handler(eventObject))同on，绑定事件，但只执行一次 .off(events[,selector][,handler])移除一个事件处理函数$(&#39;.box li&#39;).off(&#39;click&#39;) .trigger(eventType[,extraParameters])根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为 1234$('#foo').on('click', function() &#123; console.log($(this).text())&#125;);$('#foo').trigger('click') 其他事件blur([[data],fn])change([[data],fn])click([[data],fn])dblclick([[data],fn])error([[data],fn])1.8-focus([[data],fn])focusin([data],fn)focusout([data],fn)keydown([[data],fn])keypress([[data],fn])keyup([[data],fn])mousedown([[data],fn])mouseenter([[data],fn])mouseleave([[data],fn])mousemove([[data],fn])mouseout([[data],fn])mouseover([[data],fn])mouseup([[data],fn])resize([[data],fn])scroll([[data],fn])select([[data],fn])submit([[data],fn]) 事件对象eve.currentTargeteve.dataeve.delegateTarget1.7+eve.isDefaultPrevented()eve.isImmediatePropag…()eve.isPropagationStopped()eve.namespaceeve.pageXeve.pageYeve.preventDefault()eve.relatedTargeteve.resulteve.stopImmediatePro…()eve.stopPropagation()eve.targeteve.timeStampeve.typeeve.which jQuery动画基础.hide([duration][,easting][,fn]) duration: 三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) easing: 用来指定切换效果，默认是”swing”，可用参数”linear” fn: 在动画完成时执行的函数，每个元素执行一次。用于隐藏元素,没有参数等同于直接设置display属性12$('.target').hide()//等同于$('.target').css('display','none') 123$('#book').hide(300, 'linear', function() &#123; console.log('Animation complete.') &#125;) .show([duration][,easing][,fn])显示元素,用法类似hide .toggle([duration][,easing][,fn])事件处理套件也有一个名为.toggle()方法。哪一个被调用取决于传递的参数的设置用来切换元素的隐藏、显示，类似于toggleClass，用法和show、hide类似 渐变.fadeIn( [duration ] [, easing ] [, complete ] )渐入效果 .fadeOut( [duration ] [, easing ] [, complete ] )渐出效果 .fadeTo( duration, opacity [, easing ] [, complete ] )调整匹配元素的透明度，方法通过匹配元素的不透明度做动画效果 123$('#book').fadeTo('slow', 0.5, function() &#123; // Animation complete.&#125;) fadeToggle([speed,[easing],[fn]])通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数。这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。 1234$("p").fadeToggle("fast",function()&#123; alert("Animation Done.") &#125;) //用200毫秒快速将段落淡入，之后弹出一个对话框 slideDown([speed],[easing],[fn]) 下拉动画.这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式显示出来。 slideUp([speed,[easing],[fn]]) 上浮动画,向上隐藏,在隐藏完成后可选地触发一个回调函数。 slideToggle([speed],[easing],[fn]) 上下切换 动画队列 因为动画是异步,所以将动画执行函数放入回调函数中,等动画执行完毕再执行其他的. 但是这样写会形成回调地狱.又因为存在动画队列,可以按代码二方法执行会有同样效果. 12345678910111213141516171819202122 $box.hide(1000, function()&#123; $box.show(1000, function()&#123; $box.fadeOut('slow',function()&#123; $box.fadeIn('slow',function()&#123; $box.slideUp(function()&#123; $box.slideDown(function()&#123; console.log('动画执行完毕') &#125;) &#125;) &#125;) &#125;) &#125;)&#125;)//等价于$box.hide(1000) .show(1000) .fadeOut() .fadeIn() .slideUp() .slideDown(function()&#123; console.log('真的完毕了') &#125;) 自定义动画animate(params,[speed],[easing],[fn])这个函数的关键在于指定动画形式及结果样式属性对象。这个对象中每个属性都表示一个可以变化的样式属性（如“height”、“top”或“opacity”）。注意：所有指定的属性必须用驼峰形式，比如用marginLeft代替margin-left. params:一组包含作为动画属性和终值的样式属性和及其值的集合 speed:三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) easing:要使用的擦除效果的名称(需要插件支持).默认jQuery提供”linear” 和 “swing”. fn:在动画完成时执行的函数，每个元素执行一次。.finish停止当前动画，并清除动画队列中所有未完成的动画,最终展示动画队列最后一帧的最终状态.stop( [clearQueue] [,jumpToEnd])停止当前正在运行的动画 AJAXjQuery.ajax(url,[settings])jQuery底层AJAX实现.$.ajax()返回其创建的XMLHttpRequest对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。最简单的情况下，$.ajax()可以不带任何参数直接使用。注意，所有的选项都可以通过$.ajaxSetup()函数来全局设置。回调函数如果要处理$.ajax()得到的数据，则需要使用回调函数。beforeSend、error、dataFilter、success、complete。 beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。 error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter 在请求成功之后调用。传入返回的数据以及”dataType”参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。 success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。 12345678910111213141516$.ajax(&#123; url: 'test.com', type: 'GET', datatype: json, data: &#123; name: 'tom', age: '12' &#125;, &lt;!-- success: function(result)&#123; console.log(result) &#125; --&gt;&#125;).done(function(result)&#123; console.log(result)&#125;).fail(function(jqXHR, textStatus)&#123; consloe.log(textStatus)&#125;) url: 一个用来包含发送请求的URL字符串。settings: AJAX请求设置。所有选项都是可选的。 seting中的设置 async：默认设置下，所有请求均为异步请求（也就是说这是默认设置为 true ）。如果需要发送同步请求，请将此选项设置为 false beforeSend：请求发送前的回调函数，用来修改请求发送前jqXHR对象，此功能用来设置自定义 HTTP 头信息，等等。该jqXHR和设置对象作为参数传递 cache：如果设置为 false ，浏览器将不缓存此页面。注意: 设置cache为 false将在 HEAD和GET请求中正常工作。它的工作原理是在GET请求参数中附加”_={timestamp}” context：这个对象用于设置Ajax相关回调函数的上下文。 默认情况下，这个上下文是一个ajax请求使用的参数设置对象 data：发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后面，POST请求作为表单数据 headers：一个额外的{键:值}对映射到请求一起发送。此设置会在beforeSend 函数调用之前被设置 ;因此，请求头中的设置值，会被beforeSend 函数内的设置覆盖 type: 请求方式 (“POST” 或 “GET”)，默认为 “GET”。注意:其它HTTP请求方法，如PUT和DELETE也可以使用，但仅部分浏览器支持。 jQuery.get( [settings] ) / jQuery.post( [settings ] )这两个方法专门用来处理get和post请求 123$.get('test.html',function(data)&#123; $('.result').html(data)&#125;) jQuery.getJSON(url[,data][,success(data,textStatus,jqXHR)])使用一个HTTP GET请求从服务器加载JSON编码的数据范例 123456789101112$.getJSON('ajax/test.json', function(data) &#123; var items = []; $.each(data, function(key, val) &#123; items.push('&lt;li id="' + key + '"&gt;' + val + '&lt;/li&gt;'); &#125;); $('&lt;ul/&gt;', &#123; 'class': 'my-new-list', html: items.join('') &#125;).appendTo('body');&#125;); .load(url[,data][,complete(responseText,textStatus,XMLHttpRequest)])从服务器载入数据并且将返回的HTML代码并插入至匹配的元素中$(&#39;#result&#39;).load(&#39;ajax/test.html&#39;) .serialize() / serializeArray()将用作提交的表单元素的值编译成字符串，方法没有参数，使用标准的 URL-encoded 符号上建立一个文本字符串. 它可以对一个代表一组表单元素的 jQuery 对象进行操作，比如&lt;input&gt;, &lt;textarea&gt;, 和 &lt;select&gt;: 123456789101112131415161718192021222324&lt;form id="holder"&gt; &lt;input type="text" name="a" value="1"/&gt; &lt;div&gt; &lt;input type="text" name="b" value="2" id="b" /&gt; &lt;/div&gt; &lt;input type="hidden" name="c" value="3" id="c" /&gt; &lt;div&gt; &lt;input type="checkbox" name="f" value="8" checked="true"/&gt; &lt;input type="checkbox" name="f" value="9" checked="true"/&gt; &lt;/div&gt;&lt;/form&gt;$("#holder").serialize(); //a=1&amp;b=2&amp;c=3&amp;f=8&amp;f=9$("#holder").serializeArray();/* [ &#123;name: 'a', value: '1'&#125;, &#123;name: 'b', value: '2'&#125;, &#123;name: 'c', value: '3'&#125;, &#123;name: 'f', value: '8'&#125;, &#123;name: 'f', value: '9'&#125; ]*/ serialize和serializeArray都是针对JQuery对象(选中的form元素)进行操作，只是返回值格式不同而已。这里特别要注意：这2个API只能操作form，如果将holder改成div，会发现不起作用 jsonp123456789function getBooks()&#123; $.ajax(&#123; type:'get', url:'http://test.com/bookservice.php', dataType:'jsonp', jsonp:'callback', jsonpCallback:'displayBooks' &#125;);&#125; 当然使用jsonp会在一定程度上造成安全性问题，如果请求的站点不是信任站点，那么可能会在返回的方法调用中包含一些恶意代码。所以尽量向信任的站点发送请求。另外xss也经常会利用jsonp向站点注入恶意代码。]]></content>
      <categories>
        <category>JS</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F21%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[cookie存储信息到浏览器，可以用js设置，也可以在服务器端通过set-cookie让浏览器种下cookie，存在于响应头里。每次请求都会带上cookie，最大容量4k用途：记录用户名 设置cookie时的参数： path: cookie影响到的路径，匹配该路径才发送cookie expires和maxAge:告诉浏览器cookie多久过期不设置就会产生session cookie，当关闭浏览器，cookie就被清除 secure: 为true时，在http无效，在https生效 httpOnly: 浏览器不允许通过js修改cookie session用来保存状态。当用户输入用户名密码提交给服务器后，服务器验证通过后创建session用于记录用户信息，session可保存在服务器，也可以保存在数据库 创建session后，会把关联的session_id通过是set-cookie添加到响应头 浏览器加载页面发现有set-cookie，就把这个cookie种到指定域名下 下次刷新页面，发送的请求带上cookie，服务器接受后根据session_id来识别用户 localStorage 本地存储，永不过期，除非手动js删除。5M大小。 不参与网络传输 一般用于性能优化 ajaxajax是一种技术方案，核心依赖浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出http请求与接受响应。 如何与后端交互 form表单提交.缺点会跳转，无后台反馈 ajax websocket 实现方法 XMLHttpRequest对象 fetch 范例123456789101112var xhr = new XMLHttpRequst() xhr.open("get", "/xxx.com") xhr.onreadystate = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; //成功 console.log(xhr.responseText) &#125; else &#123; console.log("服务器异常") &#125; &#125; xhr.send() API123456789101112131. let request = new XMLHttpRequest();2. request.open('GET','/xxx') //初始化request3. request.send() //发送请求4. request.onreadystatechange //监听请求状态的变化5. request.readyState === 1 //request.open()已经完成6. request.readyState === 2 //request.send()已经完成7. request.readyState === 3 //request.responseText正在下载5. request.readyState === 4 //响应完成6. request.status //HTTP状态码7. var string = request.responseText //响应的内容8. var value = JSON.parse(request.responseText) //把符合JSON语法的字符串转换成JS，解析响应返回的内容9. value.node //若value是对象，这就是对象里内容10. value.node.name //对象里的name的值 post形式需要将数据放入到send中 跨域同源策略同协议，域名，端口 实现跨域的方法JSONPJSON with padding 通过script标签加载数据的方式获取数据当做js代码来执行。jsonp需要对应接口的后端配合才可以实现。 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; "ip": "8.8.8.8"&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 必考面试题：JSONP为什么不支持POST请求答：因为JSONP是通过动态创建script的方法进行的，而script只能发送get请求不能发送post请求。 jquery的写法123456789$.ajax(&#123; url:"http://jack.com:8002/pay", dataType: "jsonp", success:function (response) &#123; if(response === 'success')&#123; amount.innerText = amount.innerText-1; &#125; &#125; &#125;) CORS跨域资源共享，是一种ajax跨域请求资源的方式。当使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给请求加一个请求头:Origin。后台进行处理，如果确定接受请求，则在返回结果中加响应头：Access-Control-Allow-Origin。浏览器判断该响应头中是否包含Origin的值，如果有，浏览器会处理响应，就可以拿到响应数据。 postMessage A页面1234567891011121314151617181920componentDidMount() &#123; window.addEventListener('message', this.receiveMessage, false) const iframeImg = this.iframe.contentWindow iframeImg.onload = function() &#123; iframeImg.postMessage('message', 'http://www.blogoog.com:8088') &#125;&#125;receiveMessage = (event) =&gt;&#123; const origin = event.origin || event.originalEvent.origin const thisData = JSON.parse(event.data) const imgUrl = Object.values(thisData) this.setState(&#123; imgUrl &#125;) setTimeout(() =&gt;&#123; this.closeIframe(); message.success('上传成功') &#125;,1000) if (origin !== 'http://www.blogoog.com:80881) &#123; window.location.hash = '#/exception/404' &#125;&#125; 123&lt; iframe className = &#123; styles.iframeWrap &#125;src="http://www.blogoog.com:8088" name="imgIframe" frameBorder="0" scrolling="auto" ref=&#123;dom =&gt; &#123;this.iframe = dom &#125;&#125;&gt;您的浏览器不支持iframe&lt;/iframe&gt; A页面使用的语法 window.postMessage()otherWindow.postMessage(message, targetOrigin, [transfer]) otherWindow：其他窗口的一个引用（在这里我使用了iframe的contentWindow属性） message：将要发送到其他window的数据（可以不受限制的将数据对象安全的传送给目标窗口而无需自己序列化，原因是因为采用了结构化克隆算法） targetOrigin：接收信息的URL（在这里我当然填的B页面的URL） transfer：可选参数 window.addEventListener(‘message’, receiveMessage, false)target.addEventListener(type, listener, options) type：表示监听事件类型的字符串 listener：当所监听的事件类型触发时，会通知的一个对象或者一个函数 potions：可选参数（在此我用false，表示在listener被调用之后不会自动移除） receiveMessage = (event) =&gt; {} event.data：从另一个window传递过来的对象（包含传递过来的所有信息） event.origin||event.originalEvent.origin：window.postMessage()发送消息的目标URL event.source：对发送消息的窗口对象的引用注意点！！！ 在页面内嵌入iframe页面的情况下，需要等到页面内的iframe页面，也就是B页面加载完成之后，才能进行postMessage跨域通信 event.origin中的origin不能保证是该窗口的当前origin或者未来origin，因为postMessage被调用后，可能会被导航到不同的位置，所以需要做个异常情况判断处理origin !== &#39;http://www.blogoog.com:8088&#39; B页面 123456789101112created() &#123; window.addEventListener&#123;"message", this.receiveMessage, false) &#125;,receiveMessage(e) &#123; if (e origin === 'http://www.blogoog.com:8080' || e.origin === 'http://www.blogoog.com:8088') &#123; this.sendBtnShow = true this.originSource = e.origin this.magicBuildData = JSON.parse(e.data) &#125;, sendMsg() &#123; top.postMessage(JSON.stringify(data), 'http://www.blogoog.com:8000') &#125; B页面使用到的语法top.postMessage(&#39;data&#39;, &#39;http://www.blogoog.com:8000&#39;)参考上面A页面的语法为什么用top而不用window下面再讲window.addEventListener(&#39;message&#39;, receiveMessage, false)参考上面A页面的语法receiveMessage = (event) =&gt; {}参考上面A页面的语法 window.postMessage()中的window到底是啥？始终是你需要通信的目标窗口 A页面中：A页面向B页面发送跨域信息，window就是在A页面中嵌入的iframe指向的B页面的window，即：iframe.contentWindow B页面中：B页面想A页面发送跨域信息，window就是A页面的window，在这里因为B页面时嵌入到A页面中的，对于B页面来讲，window就是top或者parent需要特别注意的坑 一定要等A页面嵌入的B页面加载完成之后，再进行postMessage跨域通信 一定要对origin做判断，去掉不是来自我们目标窗口的origin，防止来自其他origin的攻击 着重注意window.postMessage()中window的用法，明确目标窗口的window 标签iframeHTML内联框架元素&lt;iframe&gt; 表示嵌套的browsing context。它能够将另一个HTML页面嵌入到当前页面中。 123&lt;iframe src="https://mdn-samples.mozilla.org/snippets/html/iframe-simple-contents.html" title="iframe example 1" width="400" height="300"&gt; &lt;p&gt;Your browser does not support iframes.&lt;/p&gt;&lt;/iframe&gt; canvas标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API source定义多媒体资源 &lt;video&gt; 和&lt;audio&gt; command定义命令按钮，比如单选按钮、复选框或按钮 figure规定独立的流内容（图像、图表、照片、代码等等） nav导航 section定义文档中的节（section、区段） HTTP报文HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，描述报文的内容及含义，后面跟着可选的数据部分 URI和URLURI：统一资源标识符URL：统一资源定位符 报文组成 对报文进行描述的起始行 —— start line 包含属性的首部块 —— header 可选的包含数据的主体部分 —— body 报文语法 请求报文：向web服务器请求一个动作 1234&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 响应报文把请求结果返回给客户端 1234&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; 状态码服务器和浏览器之间的约定 分类:100-199 用于指定客户端应相应的某些动作。200-299 用于表示请求成功。300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。400-499 用于指出客户端的错误。500-599 用于支持服务器错误。 状态码 状态信息 解释 100 Continue 初始请求已接受,继续发送 101 switching Protocols 服务器遵从客户请求转换到另一种协议 200 OK 请求成功 201 Created 服务器已经创建了文档,Location头给出了他的URL 202 Accepted 已接受请求,但处理尚未完成 203 Non-Authoritative Information 文档已正常返回但一些应答头可能不正确,因为使用的是文档的拷贝 204 No Content 服务器接到请求已经处理完毕,但浏览器页面不会刷新 205 Reset Content 没有新内容,但浏览器应该重置它所显示的内容,用来强制浏览器清除表单输入内容. 206 Partial Content 客户发送了一个带有Range头的GET请求,服务器完成了它 300 Multiple Choices 客户请求的文档可以在多个位置找到,这些位置已经在返回的文档中列出.如果服务器要提出优先选择,则应该在Location应答头指明 301 Moved Permanently 永久重定向,请求的网页已经永久移动到新位置 302 Found 临时重定向,POST方法的重定向在未询问用户的情况下就会变成GET 303 See Other 类似301/302,不同之处在于,原来的请求是POST,现在是GET 304 Not Modified 自从上次请求后,网页未被修改过 305 Use Proxy 使用代理服务器 307 Temporary Redirect 临时重定向，不同之处,把POST转为GET 400 Bad Request 请求出现语法错误 401 Unauthorized 用户未授权,需要用户验证 403 Forbidden 服务器已经理解请求,但是拒绝执行 404 Not Found 服务器找不到请求的网页 405 Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权 408 Request Timeout 请求超时 500 Internal Server Error 服务器遇到错误,无法完成请求 503 Service Unavailable 由于临时的服务器维护或过载,暂时无法处理请求 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。 HTTP请求方法 GET请求服务器发送某个资源 HEAD与GET方法类似,但是在服务器的响应中没有资源的内容,只有资源的一些基本信息,主要用于 在不获取资源的情况下获取信息(类型,大小等) 通过状态码看资源是否存在 通过查看首部,测试资源是否被修改 PUT和GET从服务器获取资源相反,PUT用于向服务器写入资源.PUT的语义就是让服务器用请求的主体部分创建一个请求URL命名的文档.如果存在就替换 POSTPOST用于向服务器发送数据,通常用来支持HTML的表单(input,select,textarea),表单中的数据会被发送到服务器 TRACE客户端发送一个请求,这个请求可能会穿过防火墙,代理,网关,和一些其他应用程序,每个中间节点都可以修改HTTP请求,TRACE方法允许客户端在最终请求发往服务器的时候,看看他变成了什么样子TRACE请求会在目的服务器端发送一个”闭环”诊断,行程最后一站服务器会弹回一条TRACE响应,并在响应主题中携带他收到的原始请求报文 DELETE用于要求服务器删除请求的URL,和PUT一样,服务器可能不支持 OPTIONS用于请求服务器告知其支持的各种功能 浏览器的缓存机制通俗语言版(自我理解)12Cache-Control: max-age=300；ETag:W/"e-cbxLFQW5zapn79tQwb/g6Q" 浏览器第一次请求a.jpg这张图片,服务器发回一张图片,并且附送一个ETag(相当于一个用于验证的文件).浏览器把这张图片和ETag缓存到本地.如果在300秒内,浏览器又请求这张图片,那么直接从缓存中读取这张图.如果超过300秒,浏览器发现已经过了时间了,就重新向服务器发请求,并且附带之前给的ETag.服务器拿着当前文件计算后的ETag和浏览器发回的ETag比较,如果一样,说明图片没换,发回一个响应头(不包含图片,304,表示文件没修改,还能用).如果不一样,就把新的文件和新的ETag发回去.另外还有Last-Modified/If-Modified-Since.和ETag功能类似.因为服务器可能不止一个,文件存储在不同的服务器,那就给请求文件上附带上Last-Modified声明,请求时带上If-Modified-Since,表明服务器上一次修改这个文件的时间,拿来和服务器上记录的最后修改时间对比.如果修改时间比较新,说明被动过,发回一个新文件.如果时间比较旧,说明不用换,发回304,使用缓存即可. 严谨说法浏览器缓存控制分为强缓存和协商缓存，协商缓存必须配合强缓存使用。 首先浏览器第一次跟服务器请求一个资源，服务器在返回这个资源和response header的同时，会根据开发者要求或者浏览器默认，在response的header加上相关字段的http response header。 一、当浏览器对某个资源的请求命中了强缓存时，利用[Expires]或者[Cache-Control]这两个http response header实现。 [Expires]：描述的是一个绝对时间，根据的是客户端时间。用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT 下次浏览器再次请求同一资源时。先从客户端缓存中寻找，找到这个资源后，拿出它的[Expires]跟当前的请求时间比较。如果请求时间在[Expires]指定的失效时间之前，就能命中缓存，这样就不用再次到服务器上去缓存一遍，节省了资源。但是正因为是绝对时间，如果客户端时间被随意更改下，这个机制就失效了。所以我们需要[Cache-Control]。 [Cache-Control]：描述的是一个相对时间，在进行缓存命中时，都是利用浏览器时间判断。 这两个header可以只启用一个，也可以同时启用，当response header中，[Expires]和[Cache-Control]同时存在时，[Cache-Control]优先级高于[Expires]。 二、当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中。如果命中，则还是从客户端缓存中加载。协商缓存利用的是[Last-Modified，If-Modified-Since]和[ETag、If-None-Match]这两对Header来管理的。 [Last-Modified]：原理和上面的[expires]相同，区别是它是根据服务器时间返回的header来判断缓存是否存在。但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况（这种问题也不容易被定位），这时候我们需要[ETag、If-None-Match]。 [ETag、If-None-Match]：原理与上相同，区别是浏览器跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同。 [ETag、If-None-Match]这么厉害我们为什么还需要[Last-Modified、If-Modified-Since]呢？有一个例子就是分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样） [Last-Modified，If-Modified-Since]和[ETag、If-None-Match]一般都是同时启用。 HTTPS原理]]></content>
      <categories>
        <category>JS</category>
        <category>HTML基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础]]></title>
    <url>%2F2019%2F08%2F19%2FJS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据类型number, boolean, string, undefined, null, object, symbol原始类型，number, string, boolean。指保存在栈内存里的简单数据段引用类型，对象。又可分为狭义的对象，数组，函数，正则。指保存在堆内存中的对象 typeof undefined 输出 undefinedtypeof null 输出 object 运算符 &amp;&amp; (And) || (or) ! (not) == 和 ===，前者先转化类型，后进行判断，后者比较类型和值 三元运算符condition ? true case : false case boolean值false: undefined null 0 NaN 空字符串 JS函数函数会声明前置 1234foo() //hellofunction foo()&#123; return "hello"&#125; 函数表达式不会 1234fn()//报错var fn() = fnction()&#123; return "hello" &#125; 深拷贝123456789var obj = &#123; name: 'hunger', age: 3, friends: ['aa', 'bb', 'cc']&#125;var obj2 = JSON.parse(JSON.stringify(obj))obj.age = 4console.log(obj2.age) js对象查看所有属性 12var objects = &#123; p: 1&#125;Object.keys(obj) 删除命令delete object.p 循环判断 12345678910switch(判断语句）&#123; case 条件： 输出; break; case 条件: 输出; break; default: 输出&#125; while循环 12345while(expression)&#123; statement&#125;//如果expression为true，执行，//循环继续执行直到判断不成立。 do-while循环 1234do&#123; statement;&#125;while(expression);//先执行，够判断 for循环 break退出本次循环continue跳过本次循环执行下次循环 函数作用域（scope）作用域（scope）指的是变量存在的范围。在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数。 递归一个函数可以指向并调用自身。调用自身的函数我们称之为递归函数。在某种意义上说，递归近似于循环。两者都重复执行相同的代码，并且两者都需要一个终止条件（避免无限循环或者无限递归）。 作用域链 函数在执行的过程中，先从自己内部找变量 如果找不到，再从创建当前函数所在的作用域去找, 以此往上 注意找的是变量的当前的状态闭包它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。一般情况下使用闭包主要是为了 封装数据 暂存数据123456789101112function car()&#123; var speed = 0 function fn()&#123; speed++ console.log(speed) &#125; return fn&#125;var speedUp = car()speedUp() //1speedUp() //2 如果没有这个闭包，函数执行后，里面speed变量就会被清理掉。但我们声明了fn这个函数，并把它返回出来赋值给新的变量speedup。因为speedup是全局变量，是一直存在的，故这个fn函数就一直存在，speed变量也不会被清理 范例如下代码输出多少？如果想输出3，那如何改造代码？ 1234567var fnArr = [];for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i &#125;;&#125;console.log( fnArr[3]() ) // 10 我的理解: fnArr[i]声明的匿名函数的作用域是全局作用域,先遍历,并未执行,遍历结束开始执行,fnArr结果是10个匿名函数f(),全局作用域下0-9的fnArr[i]已经变成10了 原理解析：for循环每次执行，都把function(){ return i} 这个函数赋值给fnArr[i]，但这个函数不执行。因为fnArr[3] =function(){ return i};故当我们调用fnArr3 时，相当于function(){ return i};这个函数立刻执行，这时for循环已经完成，i已经变成了10。故输出10 如果要输出3，需要如下改造 123456789var fnArr = []for (var i = 0; i &lt; 10; i ++) &#123; (function(i)&#123; fnArr[i] = function()&#123; return i &#125; &#125;)(i)//这样保证遍历i时,函数会立即执行(生成10个闭包,暂存数据)&#125;console.log( fnArr[3]() ) // 3 我的理解: 从0开始遍历,(function(0){ fnArr[0] = function(){return i}})(0),(function(1){ fnArr[1] = function(){return i}})(1)(function(2){ fnArr[2] = function(){return i}})(2),(function(3){ fnArr[3] = function(){return i}})(3),传入3,最内部的function找i的变量,一直找到上一层,返回3. 123456789var fnArr = []for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = (function(j)&#123; return function()&#123; return j &#125; &#125;)(i)//生成10个闭包,暂存数据,j换成i也是一样&#125;console.log( fnArr[3]() ) // 3 如下代码输出什么? 123456for(var i=0; i&lt;5; i++)&#123; setTimeout(function()&#123; console.log('delayer:' + i ) &#125;, 0)&#125;//输出5个5 如何连续输出 0,1,2,3,4 12345678for(var i=0; i&lt;5; i++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log('delayer:' + j ) &#125;, 0) &#125;)(i)&#125;//0,1,2,3,4 字符串12str.charAt(0) //获取第一个字符str.charCodeAt(0) //获取字符对应的ASC码 字符串截取 1234var str= "hello"str.substr(1,3) //第一个开始，第二个长度str.substring(1,3) //第一个开始，第二个结束str.slice(1,3) //同上，允许负参 查找 1234str.search("he") //返回下标strong.indexOf("he") //同上str.replace("he", "you") //替换str.match("he") //匹配 大小写 12str.toUpperCase()str.toLowerCase() //本身不变化 split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。找到分隔符后，将其从字符串中删除，并将子字符串的数组返回。如果没有找到或者省略了分隔符，则该数组包含一个由整个字符串组成的元素。如果分隔符为空字符串，则将str转换为字符数组。如果分隔符出现在字符串的开始或结尾，或两者都分开，分别以空字符串开头，结尾或两者开始和结束。因此，如果字符串仅由一个分隔符实例组成，则该数组由两个空字符串组成。 当字符串为空时，split（）返回一个包含一个空字符串的数组，而不是一个空数组，如果字符串和分隔符都是空字符串，则返回一个空数组。 数组1234567891011121314151617181920212223242526272829303132333435arr.push(newelement) //末尾新增一个arr.pop() //末尾踢出一个字arr.shift() //开头拿出一个arr.unshift() //开头新增一个arr.splice(index,替换几个，替换内容) //原数组变//返回由删除元素组成的新数组arr.slice(start，end) //原数组不变arr.join("-") //将数组变成字符串并用-连接arr.reverse() //数组反转arr.sort(v1-v2) //没有参数按顺序排列，但是会出现10,11,7,8,9排列，//有参数设置比较函数，函数结果v1-v2如果大于0，两两替换位置。否则，不变a.concat(array) //拼接，返回数组a和array的集合。原数组不变Array.isArray(obj) //判断传入的obj是不是数组a.indexof(2) //判断数组a中是否含有2,返回其索引a.forEach(fn(element,index,arr)&#123;&#125;)//forEach里是一个回调函数，有三个参数，分别是当前元素，索引值，整个数组a.map(fn(element)&#123;&#125;)//与forEach类似，返回新数组，原数组不变//而forEach会修改原数组a.every(fn(element,index,arr)&#123;&#125;)//every是所有函数返回true才会返回true，遇到false终止，并返回falsea.some(fn(element,index,arr)&#123;&#125;)//some是存在一个返回true时就终止返回truea.filter(fn(element)&#123;&#125;)//返回新数组，回调函数用于逻辑判断，为true则把当前元素加到返回的数组中//为false则不加a.reduce(fn(v1,v2),value)//将数组元素合成一个值，从索引值最小开始。value表示初始值a.abs(x) //返回x的绝对值 Math四舍五入 12Math.round(0.5)//1Math.round(-1.5)//-1 绝对值 1Math.abs(-1) //1 最大值Math.max() 函数返回一组数中的最大值。参数是value1, value2, ...是一组数值 123Math.max(10, 20,30); Math.max.call(null,10, 20,30); Math.max.apply(null,[10, 20,30]); 1234floor返回小于参数值的最大整数.向下取整Math.floor(-3.2) //-4ceil返回大于参数值的最小参数，向上取整Math.ceil(-3.2) //-3 parseInt(值，进制) 123parseInt(string,radix)//将一个字符串 string 转换为 radix 进制的整数，// radix 为介于2-36之间的数。 parseInt()可以将字符串转为数字，也可以将数字取整。向下取整。radix不写默认是2进制.如果第一个字符是数字会解析直到遇到非数字结束，如果第一个字符不是数字或者符号（如：+、-）就返回NaN。带自动净化功能；带自动截断小数功能，且取整，不四舍五入。 几次方 12Math.pow(x,y) //返回 x 的 y 次幂的值。Math.pow(2,2) //4 平方根 12Math.sqrt(4) // 2Math.sqrt(-4) //NaN random 12Math.random()//返回0-1之间的伪随机数.0≦x&lt;1 Date123Date.now() //获取1970年至今的毫秒数Date.parse() //解析日期字符串，返回距离1970年的毫秒数Date.parse("2011-01-11") //13234436600000 1234567new Date() //使用Date构造函数创建一个Date实例，//不传时间就返回当前时间的字符串var str = "2019-01-11"new Date(str) //Fri Jan 11 2019 08:00:00 GMT+0800 (香港标准时间)//获取的是东八区8点的时间，因为格林尼治时间伦敦是0点 get方法 12345678getDate() //日getDay() //星期几，周日是0，周一是1getFullyear() //返回四位的年份getMouth() //返回月份，一月是0，腊月是11getHours() //小时（0-23）getMinutes() // 返回分钟getSenconds() // 秒getMilliseconds() // 毫秒(0-999) set方法类似于get方法，是设置时间 异步和回调函数节流，在时间内，如果执行，就重新开始原理：当达到了一定的时间间隔就会执行一次；可以理解为是缩减执行频率 12345678910111213function throttle(fn,delay)&#123; const timer = null return function()&#123; clearTimeout(timer) timer = setTimeout(function()&#123; fn(arguments) &#125;,delay) &#125;&#125;function fn()&#123; console.log("hello")&#125;var fn2 = throttle(fn, 1000) 函数防抖原理：将若干函数调用合成为一次，并在给定时间过去之后，或者连续事件完全触发完成之后，调用一次(仅仅只会调用一次) 12345678910111213function debounce(fn,ms)&#123; let timer = null return function()&#123; clearTimeout(timer) timer = setTimerout(()=&gt;&#123; fn() &#125;,ms) &#125;&#125;Function _log()&#123; console.log(1)&#125;Window.onscroll = debounce(_log,500) 区别 他们的区别在于防抖只会在连续的事件周期结束时执行一次，而节流会在事件周期内按间隔时间有规律的执行多次。 DOM元素创建和选取DOM是文档对象模型，是html的编程接口readyState加载状态 1234567891011document.location//location属性返回一个只读对象，提供当前文档的url信息document.location.href //获取urldocument.location.protocol //获取"http:"document.location.hostname // "www.example.com"document.location.port // "4097" document.location.pathname // "/path/a.html"document.location.assign("http://www.Google.com") //跳转到指定网址document.location.reload(true) //优先从服务器重新加载document.location.reload(false) //优先从本地缓存加载 123document.open() //新建文档可以使用write写入document.close() //关闭文档document.write() //写入文档 Element表示html元素 element的属性： nodeName: 元素标签名 nodeType:元素类型 className:类名 id:元素id children:子元素列表 childNodes: 子元素列表（NodeList） firstChild: 第一个子元素 lastChild:最后一个 nextSibling: 下一个兄弟元素 previousSibling: 上一个兄弟元素 parentNode.parentElement: 父元素 查询元素 12345678910111213document.getElementById("target")document.getElementsByClassName("box")//上述为ES3写法//下面是ES5写法document.querySelector(".box")document.querySelector("#tatget")//多个元素只会选择第一个//选择多个document.querySelectorAll("div")//浏览器控制台测试时可以用$替代document.querySelector//用$$替代document.querySelectorAll 创建元素 1234567document.createElement("div")//生成文本节点document.createTextNode("Hello")//生成DocumentFragment对象document.createDocumentFragment()//存在于内存中的DOM片段，不属于当前文档。//对它的任何改动，都不会引发网页的重新渲染 修改元素 1234567891011121314151617在元素末尾添加元素appendChild()newDiv.appendChild(newContent)在元素之前插入元素insertBefore()替换元素replaceChild(newElement,oldElement)删除元素parentNode.removeChild(childNode)clone元素node.cloneNode(true)//方法有一个布尔值，传入true时会深拷贝，//复制元素及其子元素，false只会复制元素本身 DOM元素属性123456789101112获取属性node.getAttribute("id")生成新的属性对象节点attribute = document.createAttribute(name)一般用 setAttribute()设置元素属性var node = document.getElementById("id")node.setAttribute("id", "newVal")删除属性节点node.removeAttribute("id") innerText可写属性，返回元素内包含的文本内容，在多层次的时候按照元素由浅到深的顺序拼接内容123456&lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 外层div的innerText返回内容是 &quot;123456&quot; innerHTML返回元素html结构，在写入的时候也会自动构建DOM 样式修改样式 1document.querySelector("p").style.color = "red" 获取样式getComputedStyle 1234var node = document.querySelector('p') var color = window.getComputedStyle(node).color console.log(color)//获取计算后的样式，只读。全局属性 class操作的增删改查123456var nodeBox = document.querySelector(".box")console.log(nodeBox.classList)nodeBox.classList.add("active") //新增classnodeBox.classList.remove("active") //删除nodeBox.classList.toggle("active") //新增删除切换node.classList.contains("active") //判断是否拥有class 页面宽高 12345clientWidth() //包括paddingoffsetHeight() //包括borderscrollHeight() //滚动内容的总高度scrollTop() //滚动的高度innerHeight() //窗口的高度 事件捕获阶段，目标阶段，冒泡阶段 事件绑定12345678&lt;input id="btnClick" type="button" value="Click here"&gt; &lt;script type="text/javascript"&gt;var btnClick = document.getElementById("btnClick")btnClick.onclick = function showMessage()&#123; alert(this.id)&#125;&lt;/script&gt; 会存在覆盖 DOM2事件处理(升级版) addEventListener //绑定事件 removeEventListener //解绑事件 所有DOM节点都包含这两个方法，且都接受三个函数： 事件类型 事件处理方法 布尔参数，true表示在捕获阶段调用，false表示在事件冒泡阶段处理，默认是冒泡阶段123btnClick.addEventListener("click", function()&#123; alert(this.id)&#125;, false) 不存在覆盖，可以写多个方法 属性方法123preventDefault() //取消默认事件行为stopPropagation() //取消事件进一步捕获或冒泡target() //事件的目标元素 事件代理使用事件代理来实现它，监听的元素应该是这些元素的父元素，当我点击父元素内的元素时，父元素都会得到响应，并分发相应的事件。 e.target就是点击的元素。 1234567$('.container').onclick = function(e)&#123; console.log(this) console.log(e.target) if(e.target.classList.contains('box'))&#123; console.log(e.target.innerText) &#125; &#125; 常见事件及自定义事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950鼠标事件clickdblclick //双击左键mouseover //鼠标放上mouseout //鼠标移出mouseenter //类似over，区别不计算子元素mouseleave //类似out，区别不计算子元素mousedown //鼠标按下mouseup //鼠标松开触摸事件touchstarttouchendtouchmove键盘事件keyup //按键后松开触发keydown //按键即会触发keypress //按下松开页面相关事件onload //加载完成时触发onmove //浏览器窗口被移动scroll //滚动条滚动resize //窗口大小变化表单相关focus //获取焦点blur //失去焦点change //失去焦点且内容发生改变reset //reset属性被激活submit //提交，一般是表格提交input //在input元素内容修改后立即触发onload //页面所有资源加载完成DOMContentLoaded //dom结构解析完成编辑事件beforecopy //复制之前beforecut //剪切之前beforepaste //粘贴之前beforeeditfocus //将要进去编辑状态contextmenu //按右键出现菜单或者键盘触发页面菜单losecapture //失去鼠标移动所形成的选择焦点select //被选择时拖动事件drag //某个对象被拖动dragdrop //外部对象被拖到当前窗口dragend //拖动结束dragenter //被拖动对象进入其容器范围 自定义事件123456789101112131415var EventCenter = &#123; on: function(type, handler)&#123; document.addEventListener(type, handler) &#125;, fire: function(type, data)&#123; return document.dispatchEvent(new CustomEvent(type, &#123; detail: data &#125;)) &#125; &#125; EventCenter.on('hello', function(e)&#123; console.log(e.detail) &#125;) EventCenter.fire('hello', '你好') //一个监听函数，一个处理函数 JS动画requestAnimationFrame可以在一定时间内自动执行 123456789function move()&#123; if(moveOffset &lt; offsetX)&#123; ball.style.left = parseInt(getComputedStyle(ball).left) + step +"px" moveOffset += step requestAnimationFrame(move) &#125;&#125;move() BOMbom指浏览器对象模型，核心是window对象。是浏览器的实例window.innerHeight属性，window.innerWidth属性.这两个属性返回网页的CSS布局占据的浏览器窗口的高度和宽度，单位为像素。很显然，当用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。 注意，这两个属性值包括滚动条的高度和宽度。 scrollX：滚动条横向偏移 scrollY：滚动条纵向偏移 这两个值随着滚动位置变化而变化 window.frames返回一个类似数组的对象，成员为页面内的所有框架，包括frame元素和iframe元素。需要注意的是，window.frames的每个成员对应的是框架内的窗口（即框架的window对象），获取每个框架的DOM树，需要使用window.frames[0].document。 12var iframe = window.getElementsByTagName("iframe")[0];var iframe_title = iframe.contentWindow.title; 上面代码用于获取框架页面的标题。 iframe元素遵守同源政策，只有当父页面与框架页面来自同一个域名，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。在iframe框架内部，使用window.parent指向父页面。 navigator指向一个包含浏览器相关信息的对象. window.getComputedStylegetComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值 1var style = window.getComputedStyle("元素", "伪类") URL的编码/解码方法JavaScript提供四个URL的编码/解码方法。 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 区别 encodeURI方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!@#$&amp;*()=:/,;?+' encodeURIComponent方法不会对下列字符编码 1231. ASCII字母2. 数字3. ~!*()' alert()，prompt()，confirm()alert()、prompt()、confirm()都是浏览器用来与用户互动的方法。它们会弹出不同的对话框，要求用户做出回应。 需要注意的是，alert()、prompt()、confirm()这三个方法弹出的对话框，都是浏览器统一规定的式样，是无法定制的。]]></content>
      <categories>
        <category>JS</category>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
