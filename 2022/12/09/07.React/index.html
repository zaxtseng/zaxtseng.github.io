<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="React 面试专题React.js 是 MVVM 框架吗?React 就是 Facebook 的一个开源 JS 框架，专注的层面为 View 层，不包括数据访问层或者那种 Hash 路由（不过 React 有插件支持），与 Angularjs，Emberjs 等大而全的框架不同，React 专注的中心是 Component，即组件。React 认为一切页面元素都可以抽象成组件，比如一个表单，或者">
<meta property="og:type" content="article">
<meta property="og:title" content="07.React">
<meta property="og:url" content="http://example.com/2022/12/09/07.React/index.html">
<meta property="og:site_name" content="ZAX">
<meta property="og:description" content="React 面试专题React.js 是 MVVM 框架吗?React 就是 Facebook 的一个开源 JS 框架，专注的层面为 View 层，不包括数据访问层或者那种 Hash 路由（不过 React 有插件支持），与 Angularjs，Emberjs 等大而全的框架不同，React 专注的中心是 Component，即组件。React 认为一切页面元素都可以抽象成组件，比如一个表单，或者">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae01e6eb804d849e5bb889f787707d~tplv-k3u1fbpfcp-zoom-1.image#id=oTzwI&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="article:published_time" content="2022-12-09T09:45:21.000Z">
<meta property="article:modified_time" content="2023-07-17T01:56:28.303Z">
<meta property="article:author" content="Zax Tseng">
<meta property="article:tag" content="javascript, React, Vue, HTML5">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae01e6eb804d849e5bb889f787707d~tplv-k3u1fbpfcp-zoom-1.image#id=oTzwI&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">


<link rel="canonical" href="http://example.com/2022/12/09/07.React/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/12/09/07.React/","path":"2022/12/09/07.React/","title":"07.React"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>07.React | ZAX</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZAX</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">React 面试专题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-js-%E6%98%AF-MVVM-%E6%A1%86%E6%9E%B6%E5%90%97"><span class="nav-number">1.1.</span> <span class="nav-text">React.js 是 MVVM 框架吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hooks-%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E8%81%8A%E8%81%8A-react-%E4%B8%AD-class-%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">React 组件通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.1.</span> <span class="nav-text">1）父组件向子组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.2.</span> <span class="nav-text">2）子组件向父组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E8%B7%A8%E7%BA%A7%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.3.</span> <span class="nav-text">3）跨级组件通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E9%9D%9E%E5%B5%8C%E5%A5%97%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.4.</span> <span class="nav-text">4）非嵌套关系的组件通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setState-%E6%97%A2%E5%AD%98%E5%9C%A8%E5%BC%82%E6%AD%A5%E6%83%85%E5%86%B5%E4%B9%9F%E5%AD%98%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%83%85%E5%86%B5"><span class="nav-number">1.4.</span> <span class="nav-text">setState 既存在异步情况也存在同步情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.5.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-react-fiber"><span class="nav-number">1.6.</span> <span class="nav-text">说一下 react-fiber</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E8%83%8C%E6%99%AF"><span class="nav-number">1.6.1.</span> <span class="nav-text">1）背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.2.</span> <span class="nav-text">2）实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Portals"><span class="nav-number">1.7.</span> <span class="nav-text">Portals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9F%E5%A6%82%E5%92%8C%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="nav-number">1.8.</span> <span class="nav-text">何时要使用异步组件？如和使用异步组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.</span> <span class="nav-text">React 事件绑定原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-lazy-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.</span> <span class="nav-text">React.lazy() 实现的原理</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zax Tseng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/09/07.React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zax Tseng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZAX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="07.React | ZAX">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          07.React
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-09 17:45:21" itemprop="dateCreated datePublished" datetime="2022-12-09T17:45:21+08:00">2022-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-07-17 09:56:28" itemprop="dateModified" datetime="2023-07-17T09:56:28+08:00">2023-07-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="React-面试专题"><a href="#React-面试专题" class="headerlink" title="React 面试专题"></a>React 面试专题</h2><h3 id="React-js-是-MVVM-框架吗"><a href="#React-js-是-MVVM-框架吗" class="headerlink" title="React.js 是 MVVM 框架吗?"></a>React.js 是 MVVM 框架吗?</h3><p>React 就是 Facebook 的一个开源 JS 框架，专注的层面为 View 层，不包括数据访问层或者那种 Hash 路由（不过 React 有插件支持），与 Angularjs，Emberjs 等大而全的框架不同，React 专注的中心是 Component，即组件。React 认为一切页面元素都可以抽象成组件，比如一个表单，或者表单中的某一项。</p>
<p>React 可以作为 MVVM 中第二个 V，也就是 View，但是并不是 MVVM 框架。MVVM 一个最显著的特征：双向绑定。React 没有这个，它是单向数据绑定的。React 是一个单向数据流的库，状态驱动视图。react 整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在 react 中，是单向数据流，推崇结合 immutable 来实现数据不可变。</p>
<h3 id="hooks-用过吗？聊聊-react-中-class-组件和函数组件的区别"><a href="#hooks-用过吗？聊聊-react-中-class-组件和函数组件的区别" class="headerlink" title="hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别"></a>hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别</h3><p>类组件是使用 ES6 的 class  来定义的组件。 函数组件是接收一个单一的  <code>props</code>  对象并返回一个 React 元素。</p>
<p>关于 React 的两套 API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p>
<p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p>
<p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p>
<p><strong>类组件的缺点</strong> :</p>
<p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中  <code>this</code>  的工作方式。</p>
<p><strong>区别</strong>：</p>
<p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p>
<p>1.状态的有无<br>hooks 出现之前，函数组件<code>没有实例</code>，<code>没有生命周期</code>，<code>没有state</code>，<code>没有this</code>，所以我们称函数组件为无状态组件。 hooks 出现之前，react 中的函数组件通常只考虑负责 UI 的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数 props 决定，不受其他任何因素影响。</p>
<p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的 react 元素。类组件重新渲染将 new 一个新的组件实例，然后调用 render 类方法返回 react 元素，这也说明为什么类组件中 this 是可变的。</p>
<p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p>
<p><strong>React Hooks（钩子的作用）</strong></p>
<p><em>Hook</em>  是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<p>React Hooks 的几个常用钩子:</p>
<ol>
<li><code>useState()</code> &#x2F;&#x2F;状态钩子</li>
<li><code>useContext()</code> &#x2F;&#x2F;共享状态钩子</li>
<li><code>useReducer()</code> &#x2F;&#x2F;action 钩子</li>
<li><code>useEffect()</code> &#x2F;&#x2F;副作用钩子</li>
</ol>
<p>还有几个不常见的大概的说下，后续会专门写篇文章描述下</p>
<ul>
<li>1.useCallback 记忆函数<br>一般把<strong>函数式组件理解为 class 组件 render 函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Click happened&quot;</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p>
<ul>
<li>2.useMemo 记忆组件<br>useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。<br>唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你</strong>。<br>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</li>
<li>3.useRef 保存引用值</li>
</ul>
<p>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p>
<ul>
<li>4.useImperativeHandle 穿透 Ref</li>
</ul>
<p>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p>
<ul>
<li>5.useLayoutEffect 同步执行副作用</li>
</ul>
<p>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。</p>
<p><strong>useEffect 和 useLayoutEffect 有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect 和原来 componentDidMount&amp;componentDidUpdate 一致，在 react 完成 DOM 更新后马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的代码。<code>官方建议优先使用useEffect</code></p>
<h3 id="React-组件通信方式"><a href="#React-组件通信方式" class="headerlink" title="React 组件通信方式"></a>React 组件通信方式</h3><p>react 组件间通信常见的几种情况:</p>
<ul>
<li><ol>
<li>父组件向子组件通信</li>
</ol>
</li>
<li><ol start="2">
<li>子组件向父组件通信</li>
</ol>
</li>
<li><ol start="3">
<li>跨级组件通信</li>
</ol>
</li>
<li><ol start="4">
<li>非嵌套关系的组件通信</li>
</ol>
</li>
</ul>
<h4 id="1）父组件向子组件通信"><a href="#1）父组件向子组件通信" class="headerlink" title="1）父组件向子组件通信"></a>1）父组件向子组件通信</h4><p>父组件通过 props 向子组件传递需要的信息。父传子是在父组件中直接绑定一个正常的属性，这个属性就是指具体的值，在子组件中，用 props 就可以获取到这个值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&quot;京程一灯&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2）子组件向父组件通信"><a href="#2）子组件向父组件通信" class="headerlink" title="2）子组件向父组件通信"></a>2）子组件向父组件通信</h4><p>props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过 props 调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">cb</span> = (<span class="params">msg</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      props.<span class="title function_">callback</span>(msg);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;cb(</span>&quot;<span class="attr">京程一灯欢迎你</span>!&quot;)&#125;&gt;</span>京程一灯欢迎你<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">callback</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">callback</span>=<span class="string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）跨级组件通信"><a href="#3）跨级组件通信" class="headerlink" title="3）跨级组件通信"></a>3）跨级组件通信</h4><p>即父组件向子组件的子组件通信，向更深层子组件通信。</p>
<ul>
<li>使用 props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是中间组件自己需要的。</li>
<li>使用 context，context 相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用 context 实现。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context方式实现跨级组件通信</span></span><br><span class="line"><span class="comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BatteryContext</span> = <span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件的子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;(color) =&gt; <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">color</span> &#125;&#125;&gt;</span>我是红色的:&#123;color&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">GrandChild</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">BatteryContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">BatteryContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）非嵌套关系的组件通信"><a href="#4）非嵌套关系的组件通信" class="headerlink" title="4）非嵌套关系的组件通信"></a>4）非嵌套关系的组件通信</h4><p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p>
<ul>
<li><ol>
<li>可以使用自定义事件通信（发布订阅模式），使用 pubsub-js</li>
</ol>
</li>
<li><ol start="2">
<li>可以通过 redux 等进行全局状态管理</li>
</ol>
</li>
<li><ol start="3">
<li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li>
</ol>
</li>
<li><ol start="4">
<li>也可以 new 一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE 的 eventBus 就是发布订阅模式，是可以在 React 中使用的;</li>
</ol>
</li>
</ul>
<h3 id="setState-既存在异步情况也存在同步情况"><a href="#setState-既存在异步情况也存在同步情况" class="headerlink" title="setState 既存在异步情况也存在同步情况"></a>setState 既存在异步情况也存在同步情况</h3><p>1.异步情况 在<code>React事件当中是异步操作</code></p>
<p>2.同步情况 如果是在<code>setTimeout事件或者自定义的dom事件</code>中，都是同步的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimeout事件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnAction&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  btnAction = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//不能直接修改state，需要通过setState进行修改</span></span><br><span class="line">    <span class="comment">//同步</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Count</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义dom事件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>绑定点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//自定义dom事件，也是同步修改</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Count</span>;</span><br></pre></td></tr></table></figure>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae01e6eb804d849e5bb889f787707d~tplv-k3u1fbpfcp-zoom-1.image#id=oTzwI&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">当组件的实例被创建并插入到 <span class="variable constant_">DOM</span> 中时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>()</span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">componentDidMount</span>()</span><br><span class="line"></span><br><span class="line">更新中</span><br><span class="line">更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>()</span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>()</span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>()</span><br><span class="line"><span class="title function_">componentDidUpdate</span>()</span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line">当组件从 <span class="variable constant_">DOM</span> 中移除时调用此方法：</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentWillUnmount</span>()</span><br></pre></td></tr></table></figure>

<h3 id="说一下-react-fiber"><a href="#说一下-react-fiber" class="headerlink" title="说一下 react-fiber"></a>说一下 react-fiber</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>react-fiber 产生的根本原因，是<code>大量的同步计算任务阻塞了浏览器的 UI 渲染</code>。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用<code>setState</code>更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p>
<h4 id="2）实现原理"><a href="#2）实现原理" class="headerlink" title="2）实现原理"></a>2）实现原理</h4><ul>
<li>react 内部运转分三层：<ul>
<li>Virtual DOM 层，描述页面长什么样。</li>
<li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li>
<li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li>
</ul>
</li>
</ul>
<p><code>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">    stateNode,    <span class="comment">// 节点实例</span></span><br><span class="line">    child,        <span class="comment">// 子节点</span></span><br><span class="line">    sibling,      <span class="comment">// 兄弟节点</span></span><br><span class="line">    <span class="keyword">return</span>,       <span class="comment">// 父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如 Diff）的执行，从而更快的生效。任务的优先级有六种：<ul>
<li>synchronous，与之前的 Stack Reconciler 操作一样，同步执行</li>
<li>task，在 next tick 之前执行</li>
<li>animation，下一帧之前执行</li>
<li>high，在不久的将来立即执行</li>
<li>low，稍微延迟执行也没关系</li>
<li>offscreen，下一次 render 时或 scroll 时才执行</li>
</ul>
</li>
<li>Fiber Reconciler（react ）执行过程分为 2 个阶段：<ul>
<li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li>
<li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li>
</ul>
</li>
<li>Fiber 树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</li>
</ul>
<p>从 Stack Reconciler 到 Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p>
<p>传送门 ☞<a target="_blank" rel="noopener" href="https://juejin.cn/post/7002250258826657799"># 深入了解 Fiber</a></p>
<h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用 portals 进行创建<br>例如 模态框, 弹出的 loading</p>
<h3 id="何时要使用异步组件？如和使用异步组件"><a href="#何时要使用异步组件？如和使用异步组件" class="headerlink" title="何时要使用异步组件？如和使用异步组件"></a>何时要使用异步组件？如和使用异步组件</h3><ul>
<li>加载大组件的时候</li>
<li>路由异步加载的时候</li>
</ul>
<p>react 中要配合 Suspense 使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步懒加载</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Box</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./components/Box&quot;</span>));</span><br><span class="line"><span class="comment">// 使用组件的时候要用suspense进行包裹</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;&#123;show &amp;&amp; <span class="tag">&lt;<span class="name">Box</span> /&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="React-事件绑定原理"><a href="#React-事件绑定原理" class="headerlink" title="React 事件绑定原理"></a>React 事件绑定原理</h3><p>React 并不是将 click 事件绑在该 div 的真实 DOM 上，而是<code>在document处监听所有支持的事件</code>，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <code>event.preventDefault</code>。</p>
<h3 id="React-lazy-实现的原理"><a href="#React-lazy-实现的原理" class="headerlink" title="React.lazy() 实现的原理"></a>React.lazy() 实现的原理</h3><p>React 的懒加载示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./OtherComponent&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>React.lazy 原理</strong></p>
<p>以下 React 源码基于 16.8.0 版本</p>
<p>React.lazy 的源码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> lazy&lt;T, R&gt;(<span class="attr">ctor</span>: <span class="function">() =&gt;</span> <span class="title class_">Thenable</span>&lt;T, R&gt;): <span class="title class_">LazyComponent</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> lazyType = &#123;</span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_LAZY_TYPE</span>,</span><br><span class="line">    <span class="attr">_ctor</span>: ctor,</span><br><span class="line">    <span class="comment">// React uses these fields to store the result.</span></span><br><span class="line">    <span class="attr">_status</span>: -<span class="number">1</span>,</span><br><span class="line">    <span class="attr">_result</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lazyType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其返回了一个 LazyComponent 对象。</p>
<p>而对于 LazyComponent 对象的解析：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title class_">LazyComponent</span>: &#123;</span><br><span class="line">  <span class="keyword">const</span> elementType = workInProgress.<span class="property">elementType</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountLazyComponent</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    elementType,</span><br><span class="line">    updateExpirationTime,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountLazyComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  _current,</span></span><br><span class="line"><span class="params">  workInProgress,</span></span><br><span class="line"><span class="params">  elementType,</span></span><br><span class="line"><span class="params">  updateExpirationTime,</span></span><br><span class="line"><span class="params">  renderExpirationTime,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Component</span> = <span class="title function_">readLazyComponentType</span>(elementType);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pending = 0, Resolved = 1, Rejected = 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> readLazyComponentType&lt;T&gt;(<span class="attr">lazyComponent</span>: <span class="title class_">LazyComponent</span>&lt;T&gt;): T &#123;</span><br><span class="line">  <span class="keyword">const</span> status = lazyComponent.<span class="property">_status</span>;</span><br><span class="line">  <span class="keyword">const</span> result = lazyComponent.<span class="property">_result</span>;</span><br><span class="line">  <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Resolved</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title class_">Component</span>: T = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Component</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Rejected</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">error</span>: mixed = result;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Pending</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">thenable</span>: <span class="title class_">Thenable</span>&lt;T, mixed&gt; = result;</span><br><span class="line">      <span class="keyword">throw</span> thenable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>: &#123;</span><br><span class="line">      <span class="comment">// lazyComponent 首次被渲染</span></span><br><span class="line">      lazyComponent.<span class="property">_status</span> = <span class="title class_">Pending</span>;</span><br><span class="line">      <span class="keyword">const</span> ctor = lazyComponent.<span class="property">_ctor</span>;</span><br><span class="line">      <span class="keyword">const</span> thenable = <span class="title function_">ctor</span>();</span><br><span class="line">      thenable.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">moduleObject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (lazyComponent.<span class="property">_status</span> === <span class="title class_">Pending</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> defaultExport = moduleObject.<span class="property">default</span>;</span><br><span class="line">            lazyComponent.<span class="property">_status</span> = <span class="title class_">Resolved</span>;</span><br><span class="line">            lazyComponent.<span class="property">_result</span> = defaultExport;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (lazyComponent.<span class="property">_status</span> === <span class="title class_">Pending</span>) &#123;</span><br><span class="line">            lazyComponent.<span class="property">_status</span> = <span class="title class_">Rejected</span>;</span><br><span class="line">            lazyComponent.<span class="property">_result</span> = error;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// Handle synchronous thenables.</span></span><br><span class="line">      <span class="keyword">switch</span> (lazyComponent.<span class="property">_status</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Resolved</span>:</span><br><span class="line">          <span class="keyword">return</span> lazyComponent.<span class="property">_result</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Rejected</span>:</span><br><span class="line">          <span class="keyword">throw</span> lazyComponent.<span class="property">_result</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lazyComponent.<span class="property">_result</span> = thenable;</span><br><span class="line">      <span class="keyword">throw</span> thenable;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：如果 readLazyComponentType 函数多次处理同一个 lazyComponent，则可能进入 Pending、Rejected 等 case 中。</p>
<p>从上述代码中可以看出，对于最初 React.lazy() 所返回的 LazyComponent 对象，其 _status 默认是 -1，所以首次渲染时，会进入 readLazyComponentType 函数中的 default 的逻辑，这里才会真正异步执行 import(url)操作，由于并未等待，随后会检查模块是否 Resolved，如果已经 Resolved 了（已经加载完毕）则直接返回 moduleObject.default（动态加载的模块的默认导出），否则将通过 throw 将 thenable 抛出到上层。</p>
<p>为什么要 throw 它？这就要涉及到 Suspense 的工作原理，我们接着往下分析。</p>
<p><strong>Suspense 原理</strong></p>
<p>由于 React 捕获异常并处理的代码逻辑比较多，这里就不贴源码，感兴趣可以去看 throwException 中的逻辑，其中就包含了如何处理捕获的异常。简单描述一下处理过程，React 捕获到异常之后，会判断异常是不是一个 thenable，如果是则会找到 SuspenseComponent ，如果 thenable 处于 pending 状态，则会将其 children 都渲染成 fallback 的值，一旦 thenable 被 resolve 则 SuspenseComponent 的子组件会重新渲染一次。</p>
<p>为了便于理解，我们也可以用 componentDidCatch 实现一个自己的 Suspense 组件，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Suspense</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">promise</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断 err 是否是 thenable</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      err !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> err === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> err.<span class="property">then</span> === <span class="string">&quot;function&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">promise</span>: err &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        err.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">promise</span>: <span class="literal">null</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; fallback, children &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; promise &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;promise ? fallback : children&#125;<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们分析完了 React 的懒加载原理。简单来说，React 利用 React.lazy 与 import()实现了渲染时的动态加载 ，并利用 Suspense 来处理异步加载资源时页面应该如何显示的问题。</p>
<p>参考传送门 ☞ <a target="_blank" rel="noopener" href="https://thoamsy.github.io/blogs/react-lazy/">React Lazy 的实现原理</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/12/09/05.TypeScript/" rel="prev" title="05.TypeScript">
                  <i class="fa fa-chevron-left"></i> 05.TypeScript
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/12/14/React%20FC/" rel="next" title="React FC">
                  React FC <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zax Tseng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
